\chapter {Класс типов Yesod}\label{ch:yesod-typeclass}

Для любого вашего приложения, использующего Yesod, требуется наличие экземпляра класса типов \lstinline!Yesod!. До этого мы видели только \lstinline!defaultLayout!. В этой главе мы рассмотрим значение других методов \lstinline!Yesod!.

% REVIEW Нужно обсудить, перевод неочевиден.
Класс типов \lstinline!Yesod! является основным местом для определения настроек приложения. Для остальных методов имеются определения по умолчанию, которые обычно являются достаточными. Но чтобы создать сложное, учитывающее требования пользователя приложение, вам, скорее всего, потребуется переопределить, по меньшей мере, некоторые из этих методов.

\section {Рендеринг в строку и разбор URL}

Мы уже отмечали, что в Yesod есть возможность автоматического рендеринга типобезопасных URL в текстовое представление, которое может быть вставлено в HTML-страницу. Допустим, у нас есть определение маршрута, которое выглядит следующим образом:

\begin{lstlisting}
mkYesod "MyApp" [parseRoutes|
/some/path SomePathR GET
]
\end{lstlisting}

Если мы используем \lstinline!SomePath! в hamlet-шаблоне, то во что Yesod его отобразит? Yesod всегда пытается сформировать \emph{абсолютные} URL. Это особенно полезно, если мы создаём XML-карты сайта и Atom-ленты, или при рассылке электронной почты. Но чтобы сформировать абсолютный URL, нам необходимо знать доменное имя приложения.

Возможно, вы считаете, что можно получить эту информацию из запроса пользователя, но нам также надо учитывать номера портов. И даже если бы мы брали номер порта из запроса, то как узнать, используется ли HTTP или HTTPS? Даже если бы \emph{это} нам было известно, то это бы значило, что в зависимости от того, как пользователь делает запрос, получались бы различные URL. К примеру, формировались бы различные URL в зависимости от того, подключается ли пользователь к "example.com" или к "www.example.com". Для поисковой оптимизации нам бы хотелось иметь возможность объединить эти варианты в одном каноническом URL.

И, наконец, Yesod не делает никаких предположений о том, \emph{где} вы будете разворачивать ваше приложение. К примеру, у нас может быть по большей части статический сайт (http://static.example.com/), но нам также хотелось бы резместить вики, построенное на основе Yesod, по пути /wiki/. Нет надёжного способа получить из приложения путь, по которому оно развёрнуто. Таким образом, вместо подобных догадок вам надо указать Yesod путь, который является корнем приложения.

В примере с вики вам нужно записать экземпляр \lstinline!Yesod! следующим образом:

\begin{lstlisting}
instance Yesod MyWiki where
    approot = ApprootStatic "http://static.example.com/wiki"
\end{lstlisting}

Заметьте, что на конце нет косой черты. Далее, когда Yesod будет конструировать URL для \lstinline!SomePathR!, он определит, что относительный путь для \lstinline!SomePathR! выглядит как \lstinline!/some/path!, добавит эту строку к approot и получит в итоге \lstinline!http://static.example.com/wiki/some/path!.

Но, если вы помните, большинство наших примеров не использовало метод \lstinline!approot!. В таких случаях наше приложение получает пустой approot или пустую строку. Это подходит для многих случаев, так как большое число приложений работают с корня домена. В таком случае маршрут, аналогичный \lstinline!SomePathR!, будет рендериться как \lstinline!/some/path!, что является корректной относительной ссылкой в любом месте вашего сайта. Однако для некоторых вариантов использования (ленты Atom/RSS или XML-карты сайтов) требуются абсолютные пути. В таком случае вам следует указать approot явно.

%FIXME foundation value
Кроме конструктора \lstinline!ApprootStatic!, уже показанного выше, можно использовать конструкторы \lstinline!AppMaster! и \lstinline!AppRequest!. Первый позволяет определить approot из значения основы, что позволяет вам, к примеру, загрузить approot из файла конфигурации. Второй же дает возможность кроме этого использовать данные запроса для определения approot, и с помощью этого вы сможете, например, указывать разные доменные имена в зависимости того, как пользователь обращается к сайту.

%FIXME scaffoled, staging, production
Сгенерированный каркас сайта использует по умолчанию \lstinline!ApprootMaster! и получает approot из конфигурационного файла при запуске. Помимо этого, он загружает различные настройки для сборок разработки, тестирования, подготовки к развертыванию и боевой сборки. Таким образом, вы с лёгкостью можете проводить тестирование на одном домене, к примеру, на localhost, а запускать приложение на другом домене.

\section {joinPath}

Чтобы сконвертировать типобезопасный URL в текстовое значение, Yesod использует две вспомогательные функции. Первая --- это метод \lstinline!renderRoute! класса типов \lstinline!RenderRoute!. Каждый типобезопасный URL является экземпляром этого класса типов. \lstinline!renderRoute! преобразовывает значение в список компонентов пути. Так \lstinline!SomePathR! из примера выше будет преобразован в \lstinline!["some", "path"]!.

\begin{remark}
На самом деле \lstinline!renderRoute! создаёт и компоненты пути, и список параметров строки запроса. Определение \lstinline!renderRoute! по умолчанию всегда выдаёт пустой список параметров строки запроса. Но это поведение можно переопределить. Одним из вариантов использования этого является статический подсайт, который добавляет хэш содержимого файла в строку параметров для управления кэшированием
\end{remark}

%FIXME значение основы
Другой функцией является метод \lstinline!joinPath! класса типов Yesod. Эта функция принимает четыре аргумента: значение основы, корень приложения, список сегментов пути и список параметров строки вызова, а возвращает URL в виде текста. Реализация по умолчению <<делает всё правильно>>: отделяет участки пути при помощи косой черты, добавляет корень приложения в начало и дописывает в конец строку запроса.

%rendering
Если вас устраивает рендеринг URL в текст по умолчанию, то вам не надо изменять эту функцию. Но если же вам требуется модифицировать рендеринг так, чтобы, например, добавлять косую черту в конце URL, то этот метод будет подходящим местом для того, чтобы сделать это.

\section {cleanPath}

Противоположной функцией по отношению к \lstinline!joinPath! является \lstinline!cleanPath!. Давайте посмотрим, как она используется в процессе диспетчеризации:

\begin{enumerate}
  \item Путь, запрашиваемый пользователем, разбивается на последовательность компонентов пути.
  \item Мы передаём компоненты пути в функцию \lstinline!cleanPath!.
  \item Если \lstinline!cleanPath! указывает на перенаправление (возвращая \lstinline!Left!), то пользователю возвращается ответ с кодом 301. Такое поведение применяется для принудительного использования канонических URL (к примеру, убирая лишние косые черты).
  \item Иначе мы пытаемся выполнить диспетчеризацию, используя результат \lstinline!cleanPath! (\lstinline!Right! в результате вызова). Если получается, то возвращаем получившийся ответ. В противном случае возвращаем статус 404.
\end{enumerate}

Такая комбинация даёт подсайтам полный контроль над тем, как будут выглядеть их URL, в то же время позволяя основному сайту иметь изменённые URL. В качестве простого примера давайте посмотрим, как мы можем указать Yesod, что нужно всегда добавлять косую черту в конце URL:

\begin{lstlisting}
{-# LANGUAGE TypeFamilies, QuasiQuotes, MultiParamTypeClasses, TemplateHaskell, OverloadedStrings #-}

import Yesod
import Network.HTTP.Types (encodePath)
import Blaze.ByteString.Builder.Char.Utf8 (fromText)
import qualified Data.Text as T
import qualified Data.Text.Encoding as TE
import Control.Arrow ((***))
import Data.Monoid (mappend)

data Slash = Slash

mkYesod "Slash" [parseRoutes|
/ RootR GET
/foo FooR GET
|]

instance Yesod Slash where
    joinPath _ ar pieces' qs' =
        fromText ar `mappend` encodePath pieces qs
      where
        qs = map (TE.encodeUtf8 *** go) qs'
        go "" = Nothing
        go x = Just $ TE.encodeUtf8 x
        pieces = pieces' ++ [""]

    -- Мы хотим сохранять канонические URL. Поэтому, если на конце URL отсутствует
    -- косая черта, делаем перенаправление. Но пустой список остаётся как
    -- есть.
    cleanPath _ [] = Right []
    cleanPath _ s
        | dropWhile (not . T.null) s == [""] = -- единственно возможная пустая строка - последняя
            Right $ init s
        -- Т.к. joinPath добавит недостающую косую черту, мы просто
        -- удаляем пустые участки.
        | otherwise = Left $ filter (not . T.null) s

getRootR = defaultLayout [whamlet|
<p>
    <a href=@{RootR}>RootR
<p>
    <a href=@{FooR}>FooR
|]

getFooR = getRootR

main = warpDebug 3000 Slash
\end{lstlisting}%$

Во-первых, давайте посмотрим на нашу реализацию \lstinline!joinPath!. Она почти полностью скопирована из реализации по умолчанию в Yesod c одним изменением: мы добавляем дополнительную пустую строку в конец. При обработке компонентов пути пустая строка приведёт к добавлению дополнительной косой черты. Таким образом дополнительная пустая строка приведёт к обязательному наличию косой черты на конце.

\lstinline!cleanPath! немного сложнее. Во-первых, мы, как и раньше, проверяем путь на пустоту, и если встречаем его, то оставляем как есть. Мы используем Right, чтобы указать, что нет необходимости в перенаправлении. Следующий клоз в действительности проверяет 2 возможных случая с URL:

\begin{itemize}
  \item В пути имеется две косых черты подряд, которые будут выглядеть как пустая строка в середине списка компонентов пути.
  \item В конце пути нет косой черты, в результате чего последний компонент пути не будет равен пустой строке.
\end{itemize}

Предполагая, что ни одно из этих условий не выполняется, получаем, что только последний компонент является пустой строкой, и нам нужно выполнить диспетчеризацию по списку всех компонентов, за исключением последнего. С другой стороы, если это не так, то нам необходимо перенаправление на канонический URL. В этом случае мы удаляем все пустые компоненты и не будем утруждать себя добавлением косой черты в конце, т. к. \lstinline!joinPath! сделает это за нас.

\section {defaultLayout}

Большинство вебсайтов используют некий общий шаблон для всех своих страниц. \lstinline!defaultLayout! является рекомендуемым способом для этого. В то время, как вы могли бы с лёгкостью определить свою собственную функцию и вызывать её вместо этого метода, если вы переопределяете \lstinline!defaultLayout!, то все страницы, генерируемые Yesod (страницы сообщений об ошибках, страницы аутентификации) автоматически получат заданный стиль.

Переопределение делается довольно просто: мы используем \lstinline!widgetToPageContent! для того, чтобы получить из Widget заголовок, тэги заголовка и тела html, а затем используем \lstinline!hamletToRepHtml! для того, чтобы преобразовать шаблон Hamlet к \lstinline!RepHtml!. В \lstinline!defaultLayout! мы может использовать дополнительные компоненты виджетов, такие как шаблоны Lucius. Пример должен сделать это понятным:

\begin{lstlisting}
    defaultLayout contents = do
        PageContent title headTags bodyTags <- widgetToPageContent $ do
            toWidget [cassius|
#body
    font-family: sans-serif
#wrapper
    width: 760px
    margin: 0 auto
|]
            addWidget contents
        hamletToRepHtml [hamlet|
$doctype 5

<html>
    <head>
        <title>#{title}
        ^{headTags}
    <body>
        <div id="wrapper">
            ^{bodyTags}
|]
getRootR = defaultLayout $ do
    setTitle "Root test"
    toWidget [cassius|body
    color: red
|]
    toWidget [hamlet|<h1>Hello|]
main = warpDebug 4000 Layout
\end{lstlisting}%$

\section {getMessage}

Даже несмотря на то, что мы ещё не рассказывали о сессиях, нам бы хотелось упомянуть \lstinline!getMessage!. Обычным приёмом в веб-программировании является установка сообщения в одном обработчике и отображение его в другом. К примеру, если пользователь отправляет методом \lstinline!POST! форму, вы можете захотеть перенаправить его на другую страницу с сообщением ``Форма отправлена''.

\begin{remark}
Такой сценарий известен как \href{http://en.wikipedia.org/wiki/Post/Redirect/Get}{Post/Redirect/Get}\footnotemark[\value{footnote}].
\end{remark}

\footnotetext{\href{http://en.wikipedia.org/wiki/Post/Redirect/Get}{\texttt{http://en.wikipedia.org/wiki/Post/Redirect/Get}}}

Чтобы облегчить его реализацию в Yesod  есть пара функций: \lstinline!setMessage!, устанавливающая сообщение в пользовательской сессии, и \lstinline!getMessage!, достающая это сообщение (и удаляющая его, чтобы оно не появилось второй раз). Рекомендуется, чтобы вы отобразили результат \lstinline!getMessage! в \lstinline!defaultLayout!. К примеру:

\begin{lstlisting}
    defaultLayout contents = do
        PageContent title headTags bodyTags <- widgetToPageContent contents
        mmsg <- getMessage
        hamletToRepHtml [hamlet|
$doctype 5

<html>
    <head>
        <title>#{title}
        ^{headTags}
    <body>
        $maybe msg <- mmsg
            <div #message>#{msg}
        ^{bodyTags}
|]
getRootR = defaultLayout [whamlet|<a href="@{MsgR}">message|]
getMsgR = setMessage "foo" >> redirect RootR >> return ()
main = warpDebug 4000 Layout
\end{lstlisting}%$

Мы рассмотрим \lstinline!getMessage!/\lstinline!setMessage! более детально, когда мы будем обсуждать сессии.
% FIXME ссылка на \ref{ch:sessions}

\section {Нестандартные страницы сообщений об ошибках}

Одной из отличительных черт профессионального вебсайта являются должным образом спроектированные страницы сообщений об ошибках. Yesod помогает вам в этом используя автоматически \lstinline!defaultLayout! для отображения страниц ошибок. Но иногда вам потребуется пойти чуть дальше. Для этого вы захотите переопределить метод \lstinline!errorHandler!:

\begin{lstlisting}
    errorHandler NotFound = fmap chooseRep $ defaultLayout $ do
        setTitle "Запрашиваемая страница не найдена"
        toWidget [hamlet|
<h1>Страница не найдена
<p>Извиняемся за неудобство, но запрашиваемая страница не может быть найдена.
|]
    errorHandler other = defaultErrorHandler other
getRootR = defaultLayout [whamlet|Hello World|]
main = warpDebug 4000 Layout
\end{lstlisting}

Здесь мы указываем нестандартную страницу для ошибки 404. Также мы можем использовать \lstinline!defaultErrorHandler!, и тогда нам не нужно писать индивидуальный обработчик для каждой страницы сообщений об ошибке. Из-за ограничений типов нам приходится начинать определение методов с \lstinline!fmap chooseRep!, но, с другой стороны, вы можете написать обычную функцию-обработчик.

Фактически вы даже можете возвращать специальные типы ответов, такие как, например, перенаправления:

\begin{lstlisting}
    errorHandler NotFound = redirect RootR
    errorHandler other = defaultErrorHandler other
getRootR = defaultLayout [whamlet|Hello World|]
main = warpDebug 4000 Layout
\end{lstlisting}

\begin{remark}
Но, несмотря на то, что вы можете сделать это, мы не рекомендуем пользоваться таким приёмом. Ошибка 404 должна быть ошибкой 404.
\end{remark}

\section {Внешние CSS и Javascript}

\begin{remark}
Функциональность, описываемая в этом разделе, автоматически включена в сгенерированном шаблоне сайта, таким образом вам самим не нужно беспокоиться о её реализации.
\end{remark}

Одним из наиболее мощных и наиболее пугащих пользователей методов класса типов Yesod является \lstinline!addStaticContent!. Запомните, что Widget состоит из нескольких компонентов, среди которых CSS и Javascript. Каким образом эти CSS/JS попадают в браузер пользователя? По умолчанию они выдаются в тэге \lstinline!<head>! страницы, в тэгах \lstinline!<style>! и \lstinline!<script>!, соотвественно.

Такое решение является простым, но оно далеко от эффективного. Каждая загрузка страницы будет требовать загрузки всех CSS/JS ``с нуля'', даже в том случае, если ничего не изменилось! Что нам на самом деле требуется, дак это сохранение этого содержимого во внешнем файле и ссылка на него из HTML.

И в этом нам поможет \lstinline!addStaticContent!. Этот метод принимает три аргумента: расширение файла для содержимого (\lstinline!css! or \lstinline!js!), MIME-тип содержимого (\lstinline!text/css! или \lstinline!text/javascript!) и само содежримое. А возвращает он один из трёх вариантов результата:

\begin{description}
  \item {Nothing}  \hfill \\
    Никакого сохранения статических файлов не происходит; нужно встроить это содержимое непосредственно в HTML. Это поведение по умолчанию.
  \item {Just (Left Text)} \hfill \\
    Содержимое сохраняется в виде отдельного файла и используется заданная текстовая ссылка для указания на этот файл.
  \item {Just (Right (Route a, Query))} \hfill \\
    Аналогично, но используется типобезопасный URL с указанием параметров строки запроса.
\end{description}

Вариант с \lstinline!Left! полезен, если вы хотите сохранять статические файлы на внешнем сервере, например на CDN или сервером с большим объёмом памяти. Более часто используется вариант \lstinline!Right!, который хорошо связывается со статическим подсайтом\marginpar{речь, судя по всему про yesod-static, возможно, нужно примечание}. Это рекомендованный подход для большинства приложений, и он обеспечивается сгенерированным шаблонным сайтом по умолчанию.

\begin{remark}
Возможно, вы спросите: если это рекомендованный подход, то почему он не является вариантом по умолчанию? Проблема заключается в том, что он делает несколько предположений, которые не всегда соблюдаются: ваше приложение включает в себя статический сайт и местоположение ваших статических файлов.
\end{remark}

Сгенерированный \lstinline!addStaticContent! делает несколько действий в помощь вам:
\begin{itemize}
  \item Он автоматически минифицирует ваш Javascript используя пакет \href{http://hackage.haskell.org/package/hjsmin}{hjsmin}\footnote{\href{http://hackage.haskell.org/package/hjsmin}{\texttt{http://hackage.haskell.org/package/hjsmin}}}
  \item Он именует файлы используя хэш содержимого файлов. Это значит, что вы можете выставлять заголовки кэширования на дату в будущем, не боясь получить устаревшее содержимое.
  \item Также, т.к. имена файлов используют хэши, вам гарантируется, что файл не требуется перезаписывать поверх существующего. Сгенерированный шаблонный код автоматически проверяет существование такого файла и исключает затратные операции ввода-вывода н диск, если операция записи не является необходимой.
\end{itemize}

\section {Более умные статические файлы}

Google рекоммендует использовать одну важную оптимизацию: \href{http://code.google.com/speed/page-speed/docs/request.html\#ServeFromCookielessDomain}{отдавайте статические файлы с отдельного домена}\footnote{\href{http://code.google.com/speed/page-speed/docs/request.html\#ServeFromCookielessDomain}{\texttt{http://code.google.com/speed/page-speed/docs/request.html\#ServeFromCookielessDomain}}}. Преимущество такого подхода состоит в том, что cookie отсылаемые для вашего домена не будут отсылаться при запросе статических файлов, тем самым будет экономиться часть сетевой полосы пропускания.

Чтобы осуществить это, у нас есть метод \lstinline!urlRenderOverride!. Этот метод внедряется в обыный рендеринг URL в строку\marginpar{FIXME rendering} и выставляет специальное значение для определённых маршрутов. К примеру, в сгенерированном шаблонном коде этот метод реализуется как:

\begin{lstlisting}
    urlRenderOverride y (StaticR s) =
        Just $ uncurry (joinPath y (Settings.staticRoot $ settings y)) $ renderRoute s
    urlRenderOverride _ _ = Nothing
\end{lstlisting}%$

Это означает, что статические маршруты обслуживаются со специального ``статического корня'', для которого вы можете указать при конфигурировании значение с другого домена. Такое поведение является прекрасным примером мощности и гибкости типобезопасных URL: при помощи одной строки кода вы можете изменить ренгдеринг статических маршрутов во всех ваших обработчиках.

\section {Аутентификация/авторизация}

Для простых приложений проверка доступа в каждой функции-обработчике может быть простым и удобным решением. Однако, такой подход не очень хорошо масштабируется. Со временем вы захотите использовать более декларативный метод. Многие системы определяют свои списки контроля доступа, специальные файлы конфигуациии и другие ``фокусы''. В Yesod это делается при помощи старого доброго Haskell. Для этого используются следующие три метода:

\begin{description}
  \item {isWriteRequest} \hfill \\
    Определяет, является ли текущий запрос операцией ``чтения'' или ``записи''. По умолчанию Yesod следует RESTful принципам и предполагает, что запросы GET, HEAD, OPTIONS, и TRACE предназначены только для чтения, тогда как остальные могут выполнять запись.

  \item {isAuthorized} \hfill \\

    Этот метод принимает в качетве параметров маршрут (т.е. типобезопасный URL) и булево значение, указывающее на то, является ли запрос запросом записи. А возвращает он \lstinline!AuthResult!, который может быть одним из трёх значений:

    \begin{itemize}
      \item \lstinline!Authorized!
      \item \lstinline!AuthenticationRequired!
      \item \lstinline!Unauthorized!
    \end{itemize}

    По умолчанию он возвращает Authorized для всех запросов.

  \item {authRoute} \hfill \\

    Если \lstinline!isAuthorized! возвращает \lstinline!AuthenticationRequired!, то делается перенаправление по указанному маршруту. Если не указан маршрут (поведение по умолчанию), будет отправлено сообщение 403 "Permission Denied".

\end{description}

Эти методы прекрасно взаимодействют с пакетом \href{http://hackage.haskell.org/package/yesod-auth}{yesod-auth}\footnote{\href{http://hackage.haskell.org/package/yesod-auth}{\texttt{http://hackage.haskell.org/package/yesod-auth}}}, который используется сгенерированным шаблонным сайтом, предоставляя целый набор вариантов аутентификации, таких как OpenID, BrowserID, электронная почта, имя пользвователя и Twitter. Мы покажем более конкретные примеры в главе ~\ref{ch:auth}.

\section {Простые настройки}

Не всё в классе типов Yesod является сложным. Некоторые методы представляют собой простые функции. Давайте пройдёмся по их списку:

\subsection {encryptKey}

Yesod использует сессии на клиенте, которые хранятся в зашифрованных, криптографически захэшированных cookie. Но этото происходит в том случае, если вы указываете ключ шифрования. Если эта функция возвращает \lstinline!Nothing!, то сессии отключаются. Это может быть полезной оптимизацией для сайтов, которым не требуются возможности, предоставляемые сессиями, т.к. это отключает пару операций шифровки/расшифровки для каждого запроса.

\begin{remark}
Комбинация шифрования и хэширования даёт гарантию двух свойств: данные сессии защищены от несанкционированного доступа и непрозрачны. Шифрование без хэширования дадут пользователю возможность произвольно менять данные cookie, и они продолжат приниматься сервером, а хэширование без шифрования позволят просмотреть данные.
\end{remark}

\subsection {clientSessionDuration}

Задаёт время, которое будет длиться сессия. По умолчанию - 2 часа.

\subsection {sessionIpAddress}

По умолчанию сессии привязаны к IP адресу. Если ваши пользователи находятся за прокси-сервером, то это может привести к проблемам, если их IP вдруг изменится. Данная настройка позволяет отключить эту меру безопасности.

\subsection {cookiePath}

Задаёт на какой путь в текущем домене будут выставлены cookie. По умолчанию - ``/'', и это в большинстве случаев будет правильным вариантом. Исключением может быть сценарий, когда приложение работает на подпути в домене (как в примере с вики, приведённом ранее).

\subsection {maximumContentLength}

Для того, чтобы предотвратить DoS-атаку\footnote{Denial of Service - отказ в обслуживании}, Yesod ограничивает максимальный размер тела запроса.  Иногда вам потребуется поднять этот максимум для некоторых маршрутов (к примеру для страниц загрузки файлов). Данный метод позволит вам сделать это.

\subsection {yepnopeJs}

Здесь мы можете указать местополжение Javascript-библиотеки \href{http://yepnopejs.com/}{yepnope}\footnote{\href{http://yepnopejs.com/}{\texttt{http://yepnopejs.com/}}}. Если это местоположение задано, то yepnope будет асинхронно загружать Javascript для ваших страниц.

\section {Выводы}

Класс типов Yesod включает в себя набор переопределяемых методов, которые позволяют сконфигурировать ваше приложение. Они не обязательны и имеют достаточные версии по умолчанию. Используя встроенные в Yesod конструкции, такие как \lstinline!defaultLayout! и \lstinline!getMessage!, вы получите единообразный внешний вид для всего вашего сайта, включая страницы, автоматически сгенерированные Yesod, такие как страницы сообщений об ошибках и страницы аутентификации.

Мы не рассмотрели полностью все методы класса типов Yesod в этой главе. Для просмотра всего списка доступных методов обратитесь к Haddock-документации.
