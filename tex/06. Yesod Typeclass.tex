\chapter {Класс типов Yesod}

Для любого вашего приложения, использующего Yesod, требуется наличие экземпляра класса типов \lstinline'Yesod'. До этого мы видели только \lstinline'defaultLayout'. В этой главе мы рассмотрим значение других методов \lstinline'Yesod'.

Класс типов \lstinline'Yesod' являет собой основное место для определения настроек приложения. Для остальных методов имеются определения по умолчанию, которые обычно являются достаточными. Но, для того чтобы создать достаточно сложное, учитывающее требования пользователя прилжоение, вам, скорее всего, потребуется переопределить по меньшей мере некоторые из этих методов.

\section {Рендеринг в строку и разбор URL}

Мы уже отмечали, что в Yesod есть возможность автоматического рендеринга в строку типобезопасных URL в текстовое представление, которое может быть вставлено в HTML-страницу. Допустим, у нас есть определение маршрута, которое выглядит следующим образом:

\begin{lstlisting}
mkYesod "MyApp" [parseRoutes|
/some/path SomePathR GET
]
\end{lstlisting}

Если мы используем \lstinline'SomePathR' в hamlet-шаблоне, то во что Yesod его отобразит? Yesod всегда пытается сформировать \emph{абсолютные} URL. Это особенно полезно, если мы создаём XML карты сайта и Atom-ленты, или при отсылке электронной почты. Но для того чтобы сформировать абсолютный URL нам необходимо знать доменное имя приложения.

Возможно, вы подумали, что можно получить эту информацию из запроса пользователя, но нам также надо учитывать номера портов. И, даже если бы мы брали номер порта из запроса, то каку узнать используется ли HTTP или HTTPS? Но, даже если нам известно \emph{это}, то это бы значило, что в зависимости от того, как пользователь делает запрос, получались бы различные URL. К примеру, формировались бы различные URL в зависимости от того, подключается ли пользователь к "example.com" или "www.example.com". Для поисковой оптимизации нам бы хотелось иметь возможность объединить эти варианты в одном каноническом URL.

И, наконец, Yesod не делает никаких предположений о том, \emph{где} вы будете разворачивать ваше приложение. К примеру, у нас может быть большей частью статический сайт (http://static.example.com/), но также хотелось бы резместить вики, построенное на Yesod по пути /wiki/. Нет надёжного способа получить из приложения путь, на котором оно развёрнуто. Таким образом, вместо подобных догадок, вам надо указать Yesod путь, который является корнем приложения.

В примере с вики вам нужно записать экземпляр \lstinline'Yesod' следующим образом:

\begin{lstlisting}
instance Yesod MyWiki where
    approot = ApprootStatic "http://static.example.com/wiki"
\end{lstlisting}

Заметьте, что на конце нет косой черты. Далее, когда Yesod будет конструировать URL для \lstinline'SomePathR', он определит, что относительный путь для \lstinline'SomePathR' выглядит как \lstinline'/some/path', добавит эту строку к approot и получит в итоге \lstinline'http://static.example.com/wiki/some/path'.

Но, если вы помните, большинство наших примеров не использовало метод \lstinline'approot. В таких случаях, наше приложение получает пустой approot или пустую строку. Это работает для многих вариантов использования, так как большое число приложений работают с корня домена. В таком случае, маршрут аналогичный \lstinline'SomePathR' будет рендериться как \lstinline'/some/path', что является корректной относительной ссылкой в любом месте вашего сайта. Однако для некоторых вариантов использования (ленты Atom/RSS или XML карты сайтов) требуются абсолютные пути. В таком случае вам следует указать approot явно.

%FIXME foundation value
Кроме конструктора \lstinline'ApprootStatic', уже показанного выше, можно использовать конструкторы \lstinline'AppMaster' и \lstinline'AppRequest'. Первый позволяет определить approot из значения основы, которое позволит вам загрузить approot из файла конфигурации, к примеру. Последний же позволит вам кроме того использовать данные запроса для определения approot, с помощью этого вы сможете, например, указывать разные доменные имена в зависимости того, как пользователь обращается к сайту.

%FIXME scaffoled, staging, production
Каркасный сайт использует ApprootMaster по умолчанию и получает approot из конфигурационного файла при запуске. Помимо этого, он загружает различные настройки для сборок разработки, тестирования, подготовки к ``боевому режиму'' и ``боевой'' сборки, таким образом вы с лёгкостью можете проводить тестирование на одном домене, к примеру на localhost, а запускать приложение на другом домене.

\section {joinPath}

Для того, чтобы сконвертировать типобезопасный URL в текстовое значение, Yesod использует две вспомогательные функции. Первая - это метод renderRoute класса типов RenderRoute. Каждый типобезопасный URL является экземпляром этого класса типов. renderRoute преобразовывает значение в участки пути. К примеру, SomePathR из примера выше будет преобразовано в ["some", "path"].

На самом деле renderRoute создаёт и участки пути и список параметров строки запроса. Определение по умолчанию renderRoute всегда задаёт пустой список параметров строки запроса. Но это поведение можно переопределить. Одним из вариантов использования этого является статический подсайт, который добавляет хэш содержимого файла в строку параметров для управления кэшированием

%FIXME значение основы
Другой функцией является метод joinPath класса типов Yesod. Эта функция принимает четыре аргумента: значение основы, корень приложения, список сегментов пути, список параметров строки вызова, а возвращает URL в виде текста. Реализация по умолчению делает ``правильно'': отделяет участки пути при помощи косой черты, добавляет корень приложения в начало и дописывает в конец строку запроса.

%rendering
Если вас устраивает рендеринг URL в текст по умолчанию, то вам не надо изменять эту функцию. Но, если же вам требуется модифицировать URL для того чтобы, например, добавить косую черту в конце, то этот метод будет подходящим методом для того, чтобы сделать это.

\section {cleanPath}

The flip side to joinPath is cleanPath. Let's look at how it gets used in the dispatch process:

1. The path info requested by the user is split into a series of path pieces.
2. We pass the path pieces to the cleanPath function.
3. If cleanPath indicates a redirect (a Left response), then a 301 response is sent to the client. This is used to force canonical URLs (eg, remove extra slashes).
4. Otherwise, we try to dispatch using the response from cleanPath (a Right). If this works, we return a response. Otherwise, we return a 404.

This combination allows subsites to retain full control of how their URLs appear, yet allows master sites to have modified URLs. As a simple example, let's see how we could modify Yesod to always produce trailing slashes on URLs:

\begin{lstlisting}
{-# LANGUAGE TypeFamilies, QuasiQuotes, MultiParamTypeClasses, TemplateHaskell, OverloadedStrings #-}

import Yesod
import Network.HTTP.Types (encodePath)
import Blaze.ByteString.Builder.Char.Utf8 (fromText)
import qualified Data.Text as T
import qualified Data.Text.Encoding as TE
import Control.Arrow ((***))
import Data.Monoid (mappend)

data Slash = Slash

mkYesod "Slash" [parseRoutes|
/ RootR GET
/foo FooR GET
|]

instance Yesod Slash where
    joinPath _ ar pieces' qs' =
        fromText ar `mappend` encodePath pieces qs
      where
        qs = map (TE.encodeUtf8 *** go) qs'
        go "" = Nothing
        go x = Just $ TE.encodeUtf8 x
        pieces = pieces' ++ [""]

    -- We want to keep canonical URLs. Therefore, if the URL is missing a
    -- trailing slash, redirect. But the empty set of pieces always stays the
    -- same.
    cleanPath _ [] = Right []
    cleanPath _ s
        | dropWhile (not . T.null) s == [""] = -- the only empty string is the last one
            Right $ init s
        -- Since joinPath will append the missing trailing slash, we simply
        -- remove empty pieces.
        | otherwise = Left $ filter (not . T.null) s

getRootR = defaultLayout [whamlet|
<p>
    <a href=@{RootR}>RootR
<p>
    <a href=@{FooR}>FooR
|]

getFooR = getRootR

main = warpDebug 3000 Slash
\end{lstlisting}

First, let's look at our joinPath implementation. This is copied almost verbatim from the default Yesod implementation, with one difference: we append an extra empty string to the end. When dealing with path pieces, an empty string will append another slash. So adding an extra empty string will force a trailing slash.

cleanPath is a little bit trickier. First, we check for the empty path like before, and if so pass it through as-is. We use Right to indicate that a redirect is not necessary. The next clause is actually checking for two different possible URL issues:

* There is a double slash, which would show up as an empty string in the middle of our paths.
* There is a missing trailing slash, which would show up as the last piece not being an empty string.

Assuming neither of those conditions hold, then only the last piece is empty, and we should dispatch based on all but the last piece. However, if this is not the case, we want to redirect to a canonical URL. In this case, we strip out all empty pieces and do not bother appending a trailing slash, since joinPath will do that for us.

defaultLayout

Most websites like to apply some general template to all of their pages. defaultLayout is the recommended approach for this. While you could just as easily define your own function and call that instead, when you override defaultLayout all of the Yesod-generated pages (error pages, authentication pages) automatically get this style.

Overriding is very straight-forward: we use widgetToPageContent to convert a Widget to a title, head tags and body tags, and then use hamletToRepHtml to convert a Hamlet template into a RepHtml. We can even add extra widget components, like a Lucius template. from within defaultLayout. An example should make this all clear:

    defaultLayout contents = do
        PageContent title headTags bodyTags <- widgetToPageContent $ do
            toWidget [cassius|
#body
    font-family: sans-serif
#wrapper
    width: 760px
    margin: 0 auto
|]
            addWidget contents
        hamletToRepHtml [hamlet|
$doctype 5

<html>
    <head>
        <title>#{title}
        ^{headTags}
    <body>
        <div id="wrapper">
            ^{bodyTags}
|]
getRootR = defaultLayout $ do
    setTitle "Root test"
    toWidget [cassius|body
    color: red
|]
    toWidget [hamlet|<h1>Hello|]
main = warpDebug 4000 Layout

getMessage

Even though we haven't covered sessions yet, I'd like to mention getMessage here. A common pattern in web development is setting a message in one handler and displaying it in another. For example, if a user POSTs a form, you may want to redirect him/her to another page along with a "Form submission complete" message.

This is commonly known as Post/Redirect/Get.
To facilitate this, Yesod comes built in with a pair of functions: setMessage sets a message in the user session, and getMessage retrieves the message (and clears it, so it doesn't appear a second time). It's recommended that you put the result of getMessage into your defaultLayout. For example:

    defaultLayout contents = do
        PageContent title headTags bodyTags <- widgetToPageContent contents
        mmsg <- getMessage
        hamletToRepHtml [hamlet|
$doctype 5

<html>
    <head>
        <title>#{title}
        ^{headTags}
    <body>
        $maybe msg <- mmsg
            <div #message>#{msg}
        ^{bodyTags}
|]
getRootR = defaultLayout [whamlet|<a href="@{MsgR}">message|]
getMsgR = setMessage "foo" >> redirect RootR >> return ()
main = warpDebug 4000 Layout

We'll cover getMessage/setMessage in more detail when we discuss sessions.

Custom error pages

One of the marks of a professional web site is a properly designed error page. Yesod gets you a long way there by automatically using your defaultLayout for displaying error pages. But sometimes, you'll want to go even further. For this, you'll want to override the errorHandler method:

    errorHandler NotFound = fmap chooseRep $ defaultLayout $ do
        setTitle "Request page not located"
        toWidget [hamlet|
<h1>Not Found
<p>We apologize for the inconvenience, but the requested page could not be located.
|]
    errorHandler other = defaultErrorHandler other
getRootR = defaultLayout [whamlet|Hello World|]
main = warpDebug 4000 Layout

Here we specify a custom 404 error page. We can also use the defaultErrorHandler when we don't want to write a custom handler for each error type. Due to type constraints, we need to start off our methods with fmap chooseRep, but otherwise you can write a typical handler function.

In fact, you could even use special responses like redirects:

    errorHandler NotFound = redirect RootR
    errorHandler other = defaultErrorHandler other
getRootR = defaultLayout [whamlet|Hello World|]
main = warpDebug 4000 Layout

Even though you can do this, I don't actually recommend such practices. A 404 should be a 404.

External CSS and Javascript

The functionality described here is automatically included in the scaffolded site, so you don't need to worry about implementing this yourself.

One of the most powerful, and most intimidating, methods in the Yesod typeclass is addStaticContent. Remember that a Widget consists of multiple components, including CSS and Javascript. How exactly does that CSS/JS arrive in the user's browser? By default, they are served in the <head> of the page, inside <style> and <script> tags, respectively.

That might be simple, but it's far from efficient. Every page load will now require loading up the CSS/JS from scratch, even if nothing changed! What we really want is to store this content in an external file and then refer to it from the HTML.

This is where addStaticContent comes in. It takes three arguments: the filename extension of the content (css or js), the mime-type of the content (text/css or text/javascript) and the content itself. It will then return one of three possible results:

Nothing

No static file saving occurred; embed this content directly in the HTML. This is the default behavior.

Just (Left Text)

This content was saved in an external file, and use the given textual link to refer to it.

Just (Right (Route a, Query))

Same, but now use a type-safe URL along with some query string parameters.

The Left result is useful if you want to store your static files on an external server, such as a CDN or memory-backed server. The Right result is more commonly used, and ties in very well with the static subsite. This is the recommended approach for most applications, and is provided by the scaffolded site by default.

You might be wondering: if this is the recommended approach, why isn't it the default? The problem is that it makes a number of assumptions that don't universally hold: your application has a static subsite, and the location of your static files.

The scaffolded addStaticContent does a number of intelligent things to help you out:

* It automatically minifies your Javascript using the hjsmin package.
* It names the output files based on a hash of the file contents. This means you can set your cache headers to far in the future without fears of stale content.
* Also, since filenames are based on hashes, you can be guaranteed that a file doesn't need to be written if a file with the same name already exists. The scaffold code automatically checks for the existence of that file, and avoids the costly disk I/O of a write if it's not necessary.

Smarter Static Files

Google recommends an important optimization: serve static files from a separate domain. The advantage to this approach is that cookies set on your main domain are not sent when retrieving static files, thus saving on a bit of bandwidth.

To facilitate this, we have the urlRenderOverride method. This method intercepts the normal URL rendering and sets a special value for some routes. For example, the scaffolding defines this method as:

    urlRenderOverride y (StaticR s) =
        Just $ uncurry (joinPath y (Settings.staticRoot $ settings y)) $ renderRoute s
    urlRenderOverride _ _ = Nothing

This means that static routes are served from a special static root, which you can configure to be a different domain. This is a great example of the power and flexibility of type-safe URLs: with a single line of code you're able to change the rendering of static routes throughout all of your handlers.

Authentication/Authorization

For simple applications, checking permissions inside each handler function can be a simple, convenient approach. However, it doesn't scale well. Eventually, you're going to want to have a more declarative approach. Many systems out there define ACLs, special config files, and a lot of other hocus-pocus. In Yesod, it's just plain old Haskell. There are three methods involved:

isWriteRequest

Determine if the current request is a "read" or "write" operations. By default, Yesod follows RESTful principles, and assumes GET, HEAD, OPTIONS, and TRACE requests are read-only, while all others are can write.

isAuthorized

Takes a route (i.e., type-safe URL) and a boolean indicating whether or not the request is a write request. It returns an AuthResult, which can have one of three values:

* Authorized
* AuthenticationRequired
* Unauthorized

By default, it returns Authorized for all requests.

authRoute

If isAuthorized returns AuthenticationRequired, then redirect to the given route. If no route is provided (the default), return a 403 "Permission Denied" message.

These methods tie in nicely with the yesod-auth package, which is used by the scaffolded site to provide a number of authentication options, such as OpenID, BrowserID, email, username and Twitter. We'll cover more concrete examples in the auth chapter.

Some Simple Settings

Not everything in the Yesod typeclass is complicated. Some methods are simple functions. Let's just go through the list:

encryptKey

Yesod uses client-side sessions, which are stored in encrypted, cryptographically-hashed cookies. Well, as long as you provide an encryption key. If this function returns Nothing, then sessions are disabled. This can be a useful optimization on sites that don't need session facilities, as it avoids an encrypt/decrypt pair on each request.

The combination of encryption and hashing guarantees two properties: the session payload is tamper-proof, and is opaque. Encryption without hashing would allow a user to randomly change the cookie data and still have it accepted by the server, while hashing without encryption would allow inspection of the data.

clientSessionDuration

How long a session should last for. By default, this is two hours.

sessionIpAddress

By default, sessions are tied to an individual IP address. If your users are sitting behind a proxy server, this can cause trouble when their IP suddenly changes. This setting lets you disable this security feature.

cookiePath

What paths within your current domain to set cookies for. The default is "/", and will almost always be correct. One exception might be when you're serving from a subpath within a domain (like our wiki example above).

maximumContentLength

To prevent Denial of Server (DoS) attacks, Yesod will limit the size of request bodies. Some of the time, you'll want to bump that limit for some routes (e.g., a file upload page). This is where you'd do that.

yepnopeJs

You can specify the location of the yepnope Javascript library. If this is given, then yepnope will be used to asynchronously load all of the Javascript on your page.

Summary

The Yesod typeclass has a number of overrideable methods that allow you to configure your application. They are all optional, and provide sensible defaults. By using built-in Yesod constructs like defaultLayout and getMessage, you'll get a consistent look-and-feel throughout your site, including pages automatically generated by Yesod such as error pages and authentication.

We haven't covered all the methods in the Yesod typeclass in this chapter. For a full listing of methods available, you should consult the Haddock documentation.
