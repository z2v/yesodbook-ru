\chapter{Шекспировские шаблоны}\label{chap:shakespeare}

Yesod использует Шекспировское семейство шаблонных языков как стандартный
подход к созданию HTML, CSS и Javascript. Это семейство языков имеет похожий
синтаксис и общие принципы:
\begin{itemize}
    \item Как можно меньшее вмешательство в языки, на базе которых создаются
        Шекспировские шаблоны, но в то же время использование преимуществ этих
        языков.

    \item Гарантии корректности содержимого обеспечиваются компилятором.

    \item Безопасность статической типизации, которая также предотвращает
        XSS (cross-site scripting) атаки.

    \item Автоматическая проверка валидности URL, где это возможно, с
        помощью типобезопасных URL.
\end{itemize}

По сути, ничего не связывает Yesod с этими языками. Или, другими словами, и
языки, и Yesod можно использовать по отдельности. Данная глава будет
рассматривать эти шаблонные языки сами по себе, в то время как оставшаяся часть
книги будет их использовать для разработки приложений для Yesod.

\section{Краткий обзор}

Всего в игре 4 основных языка: Hamlet~--- это шаблонный язык HTML, Julius~---
для Javascript, Cassius и Lucius~--- оба для CSS. Hamlet и Cassius~--- два
языка, чувствительные к форматированию, использующие отступы для обозначения
вложенных блоков. Lucius же, являясь расширением CSS, использует фигурные
скобки для обозначения вложенных блоков.  Julius~--- это простой однопроходный
язык, который служит для генерирования Javascript; единственная добавленная
функциональность~--- это интерполяция переменных.

\begin{remark}
    Cassius~--- это, фактически, альтернативный синтаксис для Lucius. Они
    используют один и тот же механизм трансляции, просто в файлах Cassius
    отступы заменяются на фигурные скобки перед обработкой. Выбор между ними
    осуществляется чисто из синтаксических предпочтений.
\end{remark}

\subsection{Hamlet (HTML)}

\begin{lstlisting}[language=HTML]
$doctype 5
<html>
    <head>
        <title>#{pageTitle} - My Site
        <link rel=stylesheet href=@{Stylesheet}>
    <body>
        <h1 .page-title>#{pageTitle}
        <p>Here is a list of your friends:
        $if null friends
            <p>Sorry, I lied, you don't have any friends.
        $else
            <ul>
                $forall Friend name age <- friends
                    <li>#{name} (#{age} years old)
        <footer>^{copyright}
\end{lstlisting}

\subsection{Cassius (CSS)}

\begin{lstlisting}
#myid
    color: #{red}
    font-size: #{bodyFontSize}
foo bar baz
    background-image: url(@{MyBackgroundR})
\end{lstlisting}

\subsection{Lucius (CSS)}

\begin{lstlisting}
section.blog {
    padding: 1em;
    border: 1px solid #000;
    h1 {
        color: #{headingColor};
    }
}
\end{lstlisting}

\subsection{Julius (Javascript)}

\begin{lstlisting}
$(function(){
    $("section.#{sectionClass}").hide();
    $("#mybutton").click(function(){document.location = "@{SomeRouteR}";});
    ^{addBling}
});
\end{lstlisting}

\section{Types}

Прежде, чем мы перейдём к синтаксису, давайте взглянем на различные
используемые типы данных. Мы уже обсуждали во введении, что типы помогают нам
защищаться от XSS атак. К примеру, скажем, у нас есть HTML шаблон, который
должен отображать чьё-то имя. Он может выглядеть как-то так:

\begin{lstlisting}[language=HTML]
<p>Привет, меня зовут #{name}
\end{lstlisting}

\begin{remark}
    \lstinline'#{...}'~--- это способ интерполяции переменных в Шекспировских
    шаблонах.
\end{remark}

Что должно произойти с именем и какого оно должно быть типа данных?  Наивное
решение~--- это использовать \lstinline'Text' переменную, и вставлять явно её
значение в код.  Но это вызовет проблемы для случая, когда 
\lstinline'name' содержит что-то наподобие:
\begin{lstlisting}[language=HTML]
<script src='http://nefarious.com/evil.js'></script>
\end{lstlisting}
Что хотелось бы получить в данном случае~--- это имя с экранированными
символами, так, чтобы \lstinline'<' стало \lstinline'&lt;'.

Таким же наивным решением было бы просто экранировать \textbf{каждый} блок
вставляемого текста. Что получится, если у вас есть заранее сгенерированный
другим процессом HTML? Например, на сайте Yesod, все Haskell-блоки кода
пропущены через раскрашивающую функцию, которая оборачивает каждое слово в
соответствующий \texttt{span}-тег. Если мы экранируем все символы такого
текста, все блоки раскрашенного кода станут просто нечитабельными!

Вместо этого мы имеем специальный тип данных~--- \lstinline'Html'. Для того,
чтобы сгенерировать \lstinline'Html' значение, у нас есть две возможности в
API: класс типов \lstinline'ToMarkup' предоставляет способ конвертировать
\lstinline'String' и \lstinline'Text' значения в \lstinline'Html', используя
функцию~\lstinline'toHtml', которая автоматически конвертирует все символы.
Этот подход подходит для решения проблемы с \texttt{name}, описанный выше. Для
примеров с блоками кода мы бы использовали функцией~\lstinline'preEscaped'.

Когда вы используете интерполяцию переменной в Hamlet (HTML Шекспировский
язык), он автоматически применяет функцию~\lstinline'toHtml' к значению этой
переменной. Т.е., если вы интерполируете \lstinline'String', все её символы
будут экранированы. Но если вы возьмёте переменную типа~\lstinline'Html', её
значение останется неизменным. В примере с блоками кода, мы могли бы
интерполировать как-нибудь так: \lstinline'#{preEscapedToMarkup myHaskellHtml}'.

\begin{remark}
    Тип данных \lstinline'Html', как и все описанные выше функции, объявлены в
    пакете \texttt{blaze-html}. Это позволяет Hamlet взаимодействовать
    со всеми остальными \texttt{blaze-html} пакетами, а также предоставляет
    более общее решение для создания \texttt{blaze-html} значений.  Ещё одним
    преимуществом пакета \texttt{blaze-html} является его высокая
    производительность.
\end{remark}

Аналогично, у нас есть \lstinline'Css'/\lstinline'ToCss' и
\lstinline'Javascript'/\lstinline'ToJavascript'. Это даёт возможность во время
компиляции проводить некоторую проверку корректности программы, на случай,
чтобы  мы случайно не добавили какой-то HTML код в CSS.

\begin{remark}
    Ещё одно достоинство, уже со стороны CSS,~--- это вспомогательные
    типы данных для цветов и единиц измерений. Например:

    \begin{lstlisting}
    .red { color: #{colorRed} }
    \end{lstlisting}

    За подробностями обращайтесь к документации на Haddock.
\end{remark}

\subsection{Типобезопасные URL}
Наверное, самая уникальная особенность Yesod~--- это типобезопасные URL, и
возможность удобного их использования предоставлена напрямую системой
Шекспировских шаблонов.  Использование типобезопасных URL почти идентично
интерполяции переменных, мы просто используем символ "собаки" (\lstinline'@')
вместо "решётки" (\lstinline'#').  Мы чуть позже остановимся подробнее на
синтаксисе, сперва, давайте создадим общее понимание концепции.

Предположим, у нас есть приложение с двумя маршрутами
\texttt{http://example.com/profile/home}~--- домашняя страница, и
\texttt{http://example.com/display/time} показывает текущее время.  И, скажем,
мы хотим сделать ссылку с домашней страницы на страницу со временем.  Я вижу
три различных способа конструирования URL:
\begin{enumerate}
  \item Как относительную ссылку: \texttt{../display/time}
  \item Как абсолютную ссылку без домена: \texttt{/display/time}
  \item Как абсолютную ссылку с доменом: \texttt{http://example.com/display/time}
\end{enumerate}

Каждый из этих способов имеет недостатки: первый перестанет работать, если
любой из URL изменится. К тому же, он подходит не для всех случаев: RSS и Atom,
к примеру, требуют абсолютный URL. Второй способ более защищён от изменений
URL, чем первый, но всё ещё неприменим для RSS и Atom.  И, хотя, третий способ
хорошо работает для всех случаев, вам придётся каждый раз обновлять все URL,
когда поменяется ваш домен.  Вы думаете, это происходит не так часто? Просто
подождите, пока вы переместитесь с сервера разработки на пробный сервер, а
потом и на "боевой" сервер.

Но что более важно, есть ещё одна очень большая проблема во всех этих подходах:
если вы изменяете ваши маршруты, компилятор не предупредит вас о сломанных
ссылках. Не говоря уже об опечатках, которые также могут причинить большой
ущерб.

Цель введения типобезопасных URL~--- это позволить компилятору проверять за
нами как можно больше вещей. Чтобы сделать это, нашим первым шагом должен быть
уход от обычного текста, который компилятор не умеет понимать, к каким-то
хорошо определённым типам данных. Для нашего простого приложения, давайте
смоделируем наши маршруты следующим типом данных:

\begin{lstlisting}
data MyRoute = Home | Time
\end{lstlisting}

Вместо того, чтобы добавлять в наш шаблон ссылку вида \texttt{/display/time},
мы можем использовать конструктор~\lstinline'Time'. Но в итоговый HTML~--- это
текст, а не типы данных, так что мы должны иметь какой-то способ конвертировать
эти значения в текст.  Мы называем это~--- функцией рендеринга URL в строку,
и вот простой вариант такой функции:

\begin{lstlisting}
renderMyRoute :: MyRoute -> Text
renderMyRoute Home = "http://example.com/profile/home"
renderMyRoute Time = "http://example.com/display/time"
\end{lstlisting}

\begin{remark}
    Функции рендеринга URL обычно чуть более сложные, чем описанный выше
    пример.  Они должны уметь работать с параметрами строки запросов (query
    string parameters), с аргументами конструкторов и более интеллектуально
    управляться с доменными именами.  На практике, вам не придётся беспокоиться
    об этом, т.к. Yesod автоматически создаёт вам функции рендеринга.
    Единственная вещь, которую стоит здесь отметить,~--- это то, что сигнатура
    типа, на самом деле, чуть усложняется для работы с параметрами строки
    запросов.

    \begin{lstlisting}
    type Query = [(Text, Text)]
    type Render url = url -> Query -> Text
    renderMyRoute :: Render MyRoute
    renderMyRoute Home _ = ...
    renderMyRoute Time _ = ...
    \end{lstlisting}
\end{remark}

Что ж, хорошо, у нас теперь есть наша функция рендеринга, и у нас есть
типобезопасные URL, встроенные в шаблоны. Как всё это работает вместе?  Вместо
генерации \lstinline'Html' (или \lstinline'Css' или \lstinline'Javascript')
значений напрямую, Шекспировские шаблоны фактически создают функции, которые,
используя данную функцию рендеринга, создаёт сам HTML. Чтобы лучше понять
данную концепцию, давайте взглянем на то, как Hamlet мог бы обработать
следующий шаблон:

\begin{lstlisting}
<a href=@{Time}>The time
\end{lstlisting}

Эта строчка будет представлена примерно таким Haskell кодом

\begin{lstlisting}
\render -> mconcat ["<a href='", render Time, "'>The time</a>"]
\end{lstlisting}

\section{Синтаксис}

Все Шекспировские языки используют один и тот же интерполяционный синтаксис, и
все они могут использовать типобезопасные URL. Они отличаются синтаксисом,
специфичном для их целевых языков (HTML, CSS, Javascript).

\subsection{Синтаксис языка Hamlet}
Hamlet~--- это самый сложный из языков семейства. Он предоставляет не только
синтаксис для генерации HTML, но также и базовые структуры для контроля:
условия, циклы, обработка значений типа~\lstinline'Maybe'.

\subsubsection{Теги}

Очевидно, теги играют важную роль в любом шаблонном языке HTML. В
Hamlet мы пытаемся оставаться как можно ближе к существующему синтаксису
HTML, чтобы сделать язык более удобным. Однако, вместо использования
закрывающих тегов для обозначения вложенности, мы используем отступы. Например,
следующий код в HTML:
\begin{lstlisting}[language=HTML]
<body>
<p>Какой-то абзац.</p>
<ul>
<li>Пункт 1</li>
<li>Пункт 2</li>
</ul>
</body>
\end{lstlisting}
будет выглядеть следующим образом:
\begin{lstlisting}
<body>
    <p>Какой-то абзац.
    <ul>
        <li>Пункт 1
        <li>Пункт 2
\end{lstlisting}

В целом, мы считаем, что этот способ более прост в использовании, чем
оригинальный HTML, как только вы привыкнете к нему. Единственная
сложная часть~--- это работа с пробелами до и после тегов. К примеру, скажем, вы
хотите создать следующий HTML:

\begin{lstlisting}[language=HTML]
<p>Абзац <i>курсив</i> конец.</p>
\end{lstlisting}

Мы хотим быть уверенными, что пробелы останутся после слова "Абзац" и до слова
"конец". Чтобы добиться этого мы используем два простых escape-символа:

\begin{lstlisting}
<p>
    Абзац #
    <i>курсив
    \ конец.
\end{lstlisting}

Правила для использования escape-пробелов очень простые:
\begin{enumerate}
    \item Если первый непробельный символ в строке~--- это обратная косая черта,
        он игнорируется (На заметку: это также приведёт к тому, что любой тег
        в этой строке будет обработан как простой текст).
    \item Если последний символ в строке~--- это решётка, он игнорируется.
\end{enumerate}

И ещё одна важная особенность. Hamlet \textbf{не} экранирует своё содержимое.
Это сделано намеренно, чтобы позволять копировать уже существующий HTML-код.
Т.е. пример выше также может быть записан как:
\begin{lstlisting}
<p>Абзац <i>курсив</i> конец.
\end{lstlisting}

Обратите внимание, что Hamlet автоматически закроет первый тег, в то время как
внутренний тег <<i>> останется как есть. Вы вольны использовать любой из
предложенных подходов, они равноценны. Убедитесь, однако, что вы в Hamlet
используете закрывающие теги \textbf{только} для внутренних тегов; а нормальные
теги не закрыты.

\subsubsection{Интерполяция}

Всё, что мы видели до текущего момента~---- это приятный, упрощённый
HTML, но он не предоставляет никакой возможности взаимодействовать с
нашим кодом на Haskell.  Как мы будем встраивать в него переменные?
Очень просто: с помощью интерполяции:
\begin{lstlisting}[language=HTML]
<head>
    <title>#{title}
\end{lstlisting}

Символ решётки \lstinline'#', за которым следуют фигурные скобки, обозначает
\textbf{интерполяцию переменной}. В примере выше будет использована переменная
\lstinline'title' из той области видимости, где был использован шаблон. Мне
хочется подчеркнуть ещё раз: Hamlet имеет доступ к переменным той
области видимости, из которой был вызван.  При этом не нужно особым образом
указывать список использованных в шаблоне переменных.

Вы также можете применять функции внутри интерполяции. Вы можете использовать
строковые и численные литералы в интерполяции. Вы можете использовать
квалифицированные имена модулей.  Внутри интерполяции можно использовать как
скобки, так и знак доллара для группировки выражений. И в самом конце, функция
\lstinline'toHtml' применяется к результату вычисления, что значит, что
\emph{любые} экземпляры класса \lstinline'ToHtml' могут быть интерполированы.
Возьмём, к примеру, следующий код.

\includecode{04/var-interpolation.hs}

Что же с нашими хваленными типобезопасными URL? Они почти идентичны
интерполяции переменных, с той лишь разницей, что начинаются с символа
\lstinline'@'. Кроме того, существует также встраивание с помощью знака вставки
\lstinline'^', которое позволяет вам вставить другой шаблон того же типа.  Код
ниже демонстрирует обе описанные концепции.

\includecode{04/url-interpolation.hs}

Кроме того, есть вариант интерполяции URL, который даёт вам возможность
встраивать параметры строки запроса. Это может быть полезно, например, для
создания постраничных ответов. Вместо \lstinline'@{...}' используйте вариант со
знаком вопроса (\lstinline'@?{...}') для обозначения присутствия параметров
строки запроса. Передаваемое значение должно быть двухэлементным кортежем,
первое значение в котором~--- это типобезопасный URL, а второе~--- список пар
параметров строки запроса. Для примера смотрите фрагмент кода ниже.

\includecode{04/url-interpolation-query.hs}

В итоге создаётся вполне ожидаемый HTML:
\begin{lstlisting}[language=HTML]
<p>Вы сейчас на странице 2.
    <a href="/home?page=1">Предыдущая</a>
    <a href="/home?page=3">Следующая</a>
</p>
\end{lstlisting}

\subsubsection{Атрибуты}

В последнем примере, мы добавили \texttt{href} атрибут в тег \texttt{a}.
Давайте уточним синтаксис:

\begin{itemize}
    \item Вы можете использовать интерполяции внутри значения атрибута.

    \item Знак равенства и значения атрибута~--- опциональны, точно так же, как в
        HTML.  Так что \lstinline'<input type=checkbox checked>'~---
        абсолютно корректный код.

    \item Есть два удобных атрибута: для id, вы можете использовать знак
        решётка \lstinline'#', а для класса~--- точку \lstinline'.'. Например,
        \lstinline'<p #paragraphid .class1 .class2>'.

    \item Кавычки вокруг значения атрибута опциональны, но они обязательны,
        если вы хотите использовать пробел в составе этого значения.

    \item Вы можете использовать атрибут опционально с помощью использования
        двоеточия.  Чтобы сделать флажок (checkbox) активированным только, если
        переменная \lstinline'isChecked'  установлена в \lstinline'True', вы
        можете написать \lstinline'<input type=checkbox :isChecked:checked>'.
        Чтобы сделать параграф опционально красным, вы можете использовать
        \lstinline'<p :isRed:style="color:red">'.
\end{itemize}

\subsubsection{Условные выражения}

Однажды вы захотите добавить некоторую логику на вашу страницу. Цель языка
Hamlet~--- это свести эту логику к минимуму насколько возможно, возлагая всю
сложную работу на Haskell. Например, логические выражения~--- очень просты...
Настолько просты, что это базовый набор \lstinline'if', \lstinline'elsif' и
\lstinline'else'.

\begin{lstlisting}
$if isAdmin
    <p>Добро пожаловать в админскую секцию.
$elseif isLoggedIn
    <p>Вы не администратор.
$else
    <p>Я не знаю, кто Вы. Пожалуйста, войдите в систему, чтобы я мог понять, есть ли у вас доступ.
\end{lstlisting}

Все те же самые правила обычной интерполяции применяются и к содержимому
условных выражений.

\subsubsection{Maybe}

Подобным же образом, мы имеем специальную конструкцию, чтобы работать со
значениями \lstinline'Maybe'. Технически, это можно делать с помощью
\lstinline'if', \lstinline'isJust' и \lstinline'fromJust', но наш подход более удобный и
позволяет избегать частично вычислимых функций.

\begin{lstlisting}
$maybe name <- maybeName
    <p>Ваc зовут #{name}
$nothing
    <p>Я не знаю Вашего имени.
\end{lstlisting}

Помимо простых идентификаторов вы можете использовать слева от стрелки
некоторые другие, более сложные значения, например, конструкторы и кортежи.

\begin{lstlisting}
$maybe Person firstName lastName <- maybePerson
    <p>Ваше имя - #{firstName} #{lastName}
\end{lstlisting}

Выражение справа от стрелки подчиняется тем же правилам интерполяции, позволяет
использовать переменные, вызывать функции и т.д.

\subsubsection{Forall}

А что с обходом элементов списка? Мы покрываем и этот шаблон:

\begin{lstlisting}
$if null people
    <p>Нет людей.
$else
    <ul>
        $forall person <- people
            <li>#{person}
\end{lstlisting}


\subsubsection{Case}

Сопоставление шаблонов~--- одна из сильных сторон Haskell. Алгебраические типы
данных позволяют вам удобно моделировать любые типы данных из реального мира, а
case-выражения позволяют вам безопасно их сопоставлять, возлагая на компилятор
обязанность предупреждать, если вы пропустили одно из значений.  Hamlet
предоставляет вам те же самые возможности.

\begin{lstlisting}
$case foo
    $of Left bar
        <p>Это левое значение: #{bar}
    $of Right baz
        <p>Это правое значение: #{baz}
\end{lstlisting}

\subsubsection{With}

Заканчивая обзор выражений языка, рассмотрим \lstinline'with'. Это, по сути,
просто удобный способ объявления синонима для длинного выражения.

\begin{lstlisting}
$with foo <- some very (long ugly) expression that $ should only $ happen once
    <p>Я использую эту переменную #{foo} несколько раз. #{foo}
\end{lstlisting}

\subsubsection{Doctype}
Последняя ложка синтаксического сахара: выражение \lstinline'doctype'. Мы
поддерживаем несколько разных версий \lstinline'doctype', хотя мы рекомендуем
\lstinline'$doctype 5' для современных интернет-приложений, который генерирует
\lstinline'<!DOCTYPE html>'.

\begin{lstlisting}
$doctype 5
<html>
    <head>
        <title>Hamlet просто чудесен
    <body>
        <p>Всё готово.
\end{lstlisting}

\begin{remark}
    Мы всё ещё поддерживаем и старый синтаксис: три восклицательных знака
    \lstinline'!!!'.  Вы всё ещё можете увидеть его в коде. Мы планируем и дальше
    поддерживать этот синтаксис, но в целом, находим \lstinline'$doctype'
    подход более лёгким для чтения.
\end{remark}

\section{Синтаксис языка Lucius}

Lucius~--- это один из двух языков шаблонов для CSS в семействе. Представляет
собой расширение CSS, использующее существующий синтаксис с добавлением
нескольких возможностей.

\begin{itemize}
    \item Как в Hamlet, мы позволяем интерполяцию переменных и URL.
    \item Возможность вложенных CSS блоков.
    \item Вы можете определять переменные в ваших шаблонах.
    \item Набор CSS свойств может быть создан как примесь (mixin) и
        неоднократно использован в нескольких объявлениях.
\end{itemize}

Что касается второго пункта: скажем, вы хотите иметь специфичный стиль для
некоторых тегов внутри тега \lstinline'article'. В обычном CSS вы должны были бы
написать так:

\begin{lstlisting}[language=CSS]
article code { background-color: grey; }
article p { text-indent: 2em; }
article a { text-decoration: none; }
\end{lstlisting}

В этом случае получилось не так уж и много клозов, но необходимость печатать
\lstinline'article' каждый раз слегка надоедает. А представьте, что таких
выражений, скажем, около десятка. Не самое страшное, что но может быть, но всё
же раздражает. Lucius поможет в этом случае:

\begin{lstlisting}
article {
    code { background-color: grey; }
    p { text-indent: 2em; }
    a { text-decoration: none; }
    > h1 { color: green; }
}
\end{lstlisting}

Само наличие переменных в Lucius позволяет вам избегать повторов.
Простым примером будет определить общий используемый цвет как переменную:

\begin{lstlisting}
@textcolor: #ccc; /* просто потому, что мы ненавидим наших пользователей */
body { color: #{textcolor} }
a:link, a:visited { color: #{textcolor} }
\end{lstlisting}

Примеси~--- относительно новая возможность Lucius. Идея в следующем: объявить
примесь, предоставляющую набор свойств, а затем встраивать её в шаблон,
используя интерполяцию со знаком вставки (\lstinline'^'). Следующий пример
показываем, как мы могли бы использовать примесь для работы с префиксами
вендора.

\includecode{04/mixin.hs}

\section{Синтаксис языка Cassius}

Cassius~--- это чувствительная к пробелам альтернатива Lucius. Как упомянуто в
кратком обзоре в начале главы, он использует тот же механизм трансляции, что и
Lucius, но предварительно обрабатывает вход, вставляя фигурные скобки для
оформления блоков и точки с запятой для завершения строк. Это означает, что вы
можете пользоваться всеми возможности Lucius при написании кода на Cassius.
Простой пример:

\begin{lstlisting}
#banner
    border: 1px solid #{bannerColor}
    background-image: url(@{BannerImageR})
\end{lstlisting}

\section{Синтаксис языка Julius}

Julius~--- самый простой среди всех обсуждаемых здесь языков. На самом деле,
многие могут сказать, что это просто Javascript. Julius позволяет использовать
три формы интерполяции, которые мы уже упоминали.  И не применяет никаких
других преобразований к вашему коду.

\begin{remark}
    Если вы используете Julius c каркасом сайта Yesod, вы возможно заметили,
    что ваш Javascript автоматически сжимается. Это не следствие использования
    Julius, а результат использования пакета hjsmin в Yesod для уменьшения
    результирующих файлов Julius.
\end{remark}

\section{Как заставить Шекспировские шаблоны работать}

Конечно, в какой-то момент у вас появится этот вопрос: "Как же мне заставить
это всë работать?". Существует три разных способа вызывать Шекспировские языки
из вашего Haskell кода:

\begin{description}
    \item[Квазицитирование] \hfill
    Квазицитирование (quasiquotes) позволяют вам встроить произвольное
    содержимое в ваш Haskell код, и конвертировать это содержимое в Haskell во
    время компиляции.

    \item[Внешние файлы] \hfill
    В этом случае, код шаблонов находится в отдельных файлов, на который мы
    ссылаемся с помощью шаблонов Haskell.

    \item[Режим перезагрузки] \hfill
    Оба использованных выше подхода требуют полной перекомпиляции для того,
    чтобы увидеть какие-то изменения. В режиме перезагрузки ваши шаблоны
    хранятся в отдельных файлах, и ссылаются из шаблонов Haskell. Но при этом,
    во время выполнения, эти внешние файлы каждый раз пересканируются на лету.

    \begin{remark}
        Режим перезагрузки нельзя использовать для Hamlet, только для Cassius,
        Lucius и Julius.  В Hamlet слишком много сложной логики, которая полагается
        напрямую на компилятор Haskell, что не позволяет использовать этот режим
        для Hamlet.
    \end{remark}
\end{description}

На продуктивных средах следует использовать один из первых двух подходов.  Они
оба встраивают целиком шаблоны в финальный исполняемый файл, упрощая
развёртывание кода и увеличивая производительность.  Достоинство
квазицитирования~--- это простота: всё находится в одном файле.  Для коротких
шаблонов, это может быть очень удобно. Однако, в целом, мы рекомендуем
использовать внешние файлы для шаблонов, поскольку:
\begin{itemize}
    \item Это следует традиции разделения логики и представления данных.

    \item Вы можете легко переключиться между внешними файлами и отладочным
        режимом работы с помощью простых макроопределений CPP, а это означает,
        что вы можете совмещать быструю и удобную разработку и всё ещё получать
        высокую производительность на "боевых" серверах.
\end{itemize}

Так как это специальные функции квазицитирования и шаблонного Haskell,
убедитесь, что вы подключили соответствующие расширения языка, и используйте
корректный синтаксис. Вы можете посмотреть простейшие примеры каждого подхода
на следующих листингах.

\includecode{04/quasiquoter.hs}

% Выносить в отдельный файл не стал, так как пример состоит из двух файлов
\begin{lstlisting}
{-# LANGUAGE OverloadedStrings #-} -- мы используем Text чуть ниже
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE CPP #-} -- чтобы контролировать "боевой" режим против отладочного

import Text.Lucius (CssUrl, luciusFile, luciusFileDebug, renderCss)
import Data.Text (Text)
import qualified Data.Text.Lazy.IO as TLIO

data MyRoute = Home | Time | Stylesheet

render :: MyRoute -> [(Text, Text)] -> Text
render Home _ = "/home"
render Time _ = "/time"
render Stylesheet _ = "/style.css"

template :: CssUrl MyRoute
#if PRODUCTION
template = $(luciusFile "template.lucius")
#else
template = $(luciusFileDebug "template.lucius")
#endif

main :: IO ()
main = TLIO.putStrLn $ renderCss $ template render
-- @template.lucius
foo { bar: baz }
\end{lstlisting}

Способ именования функций достаточно последовательный.

\begin{tabular}{l l l l}
Язык    & Квазицитировние & Внешний файл & Перезагрузка \\
Hamlet  & hamlet           & hamletFile   & Недоступна    \\
Cassius & cassius          & cassiusFile  & cassiusFileReload \\
Lucius  & lucius           & luciusFile   & luciusFileReload \\
Julius  & julius           & juliusFile   & juliusFileReload \\
\end{tabular}

\subsection{Замена типов Hamlet}
До сих пор мы видели, как из Hamlet генерировать значение~\lstinline'HtmlUrl',
представляющее собой блок HTML со встроенными типо-безопасными URL. Кроме
этого, используя Hamlet, мы можем генерировать ещё три значения: простой HTML,
HTML с URL \textbf{и} интернациональными текстами и виджеты. Последние будут
отдельно описаны в главе~\nameref{chap:widgets}.

Чтобы сгенерировать простой HTML без встроенных URL, мы используем
<<упрощённый Hamlet>>. Вот его отличия:
\begin{itemize}
    \item Мы используем другой набор функций с префиксом~<<s>>. Так что
        квазицитирование~--- это \texttt{shamlet} и функция использования
        внешнего файла~--- это \texttt{shamletFile}. Вопрос о том, как следует
        произносить названия этих функций, всё ещё в процессе обсуждения.

    \item Не позволяется использовать интерполяцию URL. Если попытаться это
        сделать, мы получим ошибку во время компиляции.

    \item Встраивание (интерполяция-вставка) более не позволяет использовать
        произвольные значения~\lstinline'HtmlUrl'. Правило здесь такоe: встраиваемое
        значение должно иметь точно такой же тип, что и сам шаблон, в
        данном случае~--- \lstinline'Html'. Это означает, что для
        \texttt{shamlet} встраивание может быть полностью заменено
        интерполяцией переменных (с использованием решётки \texttt{\#}).
\end{itemize}

Работа с интернационализацией (i18n) в Hamlet происходит чуть более
сложно.  Hamlet поддерживает i18n с помощью специального типа данных
для сообщений, концепция и реализация которого очень похожа на тип для типобезопасные
URL. Для примера, скажем, мы хотим написать программу, которая приветствует нас
и говорит, как много яблок мы съели. Мы могли бы представить эти сообщения в
виде типа данных

\begin{lstlisting}
data Msg = Hello | Apples Int
\end{lstlisting}

Далее, мы бы хотели иметь возможность представлять это в каком-то более удобном
для чтения формате, поэтому мы определяем некоторую функцию рендеринга:
\begin{lstlisting}
renderEnglish :: Msg -> Text
renderEnglish Hello = "Hello"
renderEnglish (Apples 0) = "You did not buy any apples."
renderEnglish (Apples 1) = "You bought 1 apple."
renderEnglish (Apples i) = T.concat ["You bought T.pack $ show i, " apples."]
\end{lstlisting}

Теперь мы хотим интерполировать эти значения типа~\lstinline'Msg' напрямую в
шаблоне.  Для этого мы используем интерполяцию с подчёркиванием.

\begin{lstlisting}
$doctype 5
<html>
    <head>
        <title>i18n
    <body>
        <h1>_{Hello}
        <p>_{Apples count}
\end{lstlisting}

Этот шаблон, теперь надо как-то представить в HTML.  Для этого, как и
для типобезопасных URL, мы определяем специальную функцию рендеринга.
Для удобства, определим синоним типа:

\begin{lstlisting}
type Render url = url -> [(Text, Text)] -> Text
type Translate msg = msg -> Html
type HtmlUrlI18n msg url = Translate msg -> Render url -> Html
\end{lstlisting}

В данной точке, вы можете передать \lstinline'renderEnglish',
\lstinline'renderSpanish' или~\lstinline'renderKlingon' в этот шаблон. И он
сгенерирует хорошо переведённый контент (качество которого, конечно, зависит от
ваших переводчиков). Программа целиком будет выглядеть так:
\includecode{04/i18n.hs}

\section{Другие Шекспировские возможности}
В дополнение к языкам-помощникам для HTML, CSS и Javascript, есть также и более
общий пакет утилит. shakespare-text предоставляет простой способ
создания интерполированных строк, который очень нравится тем, кто привык к
скриптовым языкам вроде Ruby или Python. Конечно, утилиты этого пакета можно
использовать не только для Yesod.
\includecode{04/shakespeare-text.hs}

Несколько коротких замечаний по этому простому примеру:
\begin{itemize}
    \item Обратите внимание, что мы используем три разных текстовых типа данных
        в примере (\lstinline'String', строгий и ленивый \lstinline'Text'). Они
        замечательно работают вместе.

    \item Мы используем оператор квазицитирования \lstinline'lt', который
        генерирует ленивую версию текста. Также есть его строгий аналог
        \lstinline'st'.

    \item Есть и более длинные имена для этих операторов (\lstinline'ltext' и
        \lstinline'stext').
\end{itemize}

\section{Общие рекомендации}
Ниже приводятся общие рекомендации сообщества Yesod по использованию
Шекспировского семейства языков.

\begin{itemize}
    \item Для реальных сайтов используйте внешние файлы. Для библиотек вполне
        допустимо использовать квазицитирование, если они невелики.

    \item Патрик Брисбин (Patrick Brisbin) сделал
        \footnotehref{https://github.com/pbrisbin/html-template-syntax}{правила раскраски для Vim},
        которые сильно помогают при разработке.

    \item Вам следует почти всегда начинать теги \texttt{Hamlet} с новой строки
        вместо встраивания открывающих/закрывающих тегов после открытого тега.
        Единственное исключение этому правилу~--- это использование тегов
        \lstinline'<i>' и \lstinline'<b>' в большом блоке текста.
\end{itemize}
