\chapter{Интернационализация}\label{chap:i18n}

Пользователи ожидают от наших программ, что те будут разговаривать с ними на
одном языке. Также, к сожалению, от нас скорее всего потребуется поддержка
более, чем одного языка. В то время, как простая замена строк не представляет
собой большой проблемы, корректное формирование фраз в соответствии со всеми
правилами грамматики может оказаться нетривиальной задачей. В конце концов,
кому из нас приятно видеть в выводе программы <<Список 1 файл(ов)>>?

Для решения проблемы интернационализации\footnote{I18N, от англ.
    internationalization~--- прим. пер.} требуется не только обеспечить
возможность формировать корректный вывод, необходимо сделать этот процесс
простым как для программиста, так и для переводчика, а также достаточно
безошибочным. Решение, реализованное в Yesod, позволяет вам:

\begin{itemize}
  \item Определять язык пользователя, основываясь на информации, переданной в
      HTTP запросе, с возможностью перезаписи.

  \item Простой синтаксис для формирования переводов, не требующий знания
      Haskell. (В конце концов, не всякий переводчик является ещё и
      программистом.)

  \item Возможность при необходимости использовать всю мощь языка Haskell для
      нетривиальных грамматических проблем, вместе с набором вспомогательных
      функций по умолчанию, что покрывает большинство ваших потребностей.

  \item Полное отсутствие проблем с порядком слов в предложении.
\end{itemize}

\section{Краткое содержание}

\includecode[caption={messages/en.msg},language=]{16/messages/en.msg}

\includecode[caption={messages/ru.msg},language=]{16/messages/ru.msg}

\includecode{16/i18n-synopsis.hs}
\section{Обзор}

Большинство существующих решений, таких как gettext или пакеты сообщений Java,
работают на принципе подстановки строк. Для подстановки переменных в строки
обычно используются функции, похожие на printf. Вместо этого в Yesod, как вы
могли догадаться, делается ставка на типы. Это даёт нам все обычные
преимущества, такие как обнаружение ошибок на этапе компиляции.

Теперь рассмотрим конкретный пример. Допустим, мы хотим от нашего приложения
две вещи~--- приветствовать пользователя и показать количество посетителей,
использующих систему в текущий момент. Это можно смоделировать с помощью
следующего типа:

\begin{lstlisting}
data MyMessage = MsgHello | MsgUsersLoggedIn Int
\end{lstlisting}

Мы можем легко написать функцию, преобразующую данный тип в строку на
английском языке:

\begin{lstlisting}
toEnglish :: MyMessage -> String
toEnglish MsgHello = "Hello there!"
toEnglish (MsgUsersLoggedIn 1) = "There is 1 user logged in."
toEnglish (MsgUsersLoggedIn i) = "There are " ++ show i ++ " users logged in."
\end{lstlisting}

Также мы можем написать подобные функции для других языков. Преимущество такого
подхода заключается в возможности использовать всю мощь языка Haskell для
решения нетривиальных грамматических задач, особенно образования формы
множественного числа.

\begin{remark}
    Вам может показаться, что образование множественного числа не такая уж и
    сложная задача~--- всего-то требуется один вариант для одного элемента и
    другой для любого другого количества. Это может быть справедливо для
    английского языка, но для произвольного языка это в общем неверно. В
    русском языке, к примеру, существует отдельная форма множественного числа
    для количества от 2 до 4, а также шесть различных падежей и вам придётся
    использовать отдельный модуль с логикой, определяющей, какую форму следует
    использовать.
\end{remark}

Обратная сторона медали заключается в необходимости писать всё это на Haskell,
что едва ли обрадует переводчика. Чтобы решить эту проблему, в Yesod
используются файлы сообщений. Чуть ниже мы поговорим о них более подробно.

Допустим, у нас уже есть полный набор функций перевода, но как их использовать?
Что нам нужно, так это новая функция, оборачивающая их и вызывающая подходящую
функцию перевода в зависимости от языка, выбранного пользователем. Имея её,
Yesod сможет автоматически выбирать наиболее подходящую функцию и вызывать её
со значениями, которые вы передадите.

Чтобы немного упростить нам жизнь, в Hamlet предусмотрен специальный синтаксис
интерполяции, \lstinline'_{...}', который отвечает за все вызовы функций
перевода. Чтобы связать функцию перевода с вашим приложением, используйте класс
типов~\lstinline'YesodMessage'.

\section{Файлы сообщений}

Самый простой подход к созданию переводов заключается в использовании файлов
сообщений. Идея простая~--- имеется каталог, содержащий все файлы перевода, по
одному файлу на каждый язык. Каждый файл называется в соответствии с кодом
языка, например \texttt{en.msg}. При этом каждая строка файла содержит одну
фразу, которая соответствует одному конструктору вашего типа данных для
сообщений.

\begin{remark}
    Каркас сайта содержит полностью настроенный каталог сообщений.
\end{remark}

Для начала поговорим о кодах для обозначения языков. На самом деле их
существует два вида~--- двухбуквенные коды языков и коды вида <<язык-СТРАНА>>.
Например, когда я загружаю страницу в веб-браузере, он передаёт два кода:
<<en-US>> и <<en>>. Это означает <<я бы предпочёл американский английский, но
если вы его не поддерживаете, сойдёт и английский>>.

Так какой же формат следует использовать в своём приложении? Скорее всего это
двухбуквенные коды, если только вы на самом деле не создаёте отдельные переводы
для разных стран. Это гарантирует, что если кто-то запросит канадский
английский, он всё равно получит английский. Также Yesod добавляет
двухбуквенные коды там, где это уместно. Допустим, пользователь передал
следующий список языков:

\begin{lstlisting}
pt-BR, es, he
\end{lstlisting}

Это означает <<я предпочёл бы бразильский португальский, затем испанский, а
затем иврит>>. Допустим, ваше приложение поддерживает языки <<pt>> (общий
португальский) и английский, при этом английский используется по умолчанию.
Если строго следовать списку, предоставленному пользователем, то будет выбран
английский язык. Однако, Yesod преобразует этот список в такой:

\begin{lstlisting}
pt-BR, es, he, pt
\end{lstlisting}

Другими словами, если только вы не предоставляете отдельные переводы на
диалекте языка, используемом в конкретной стране, используйте двухбуквенные
коды.

А что на счёт файлов сообщений? После работы с Hamlet и Persistent их синтаксис
должен показаться вам очень знакомым. Строка начинается с имени сообщения.
Поскольку это конструктор данных, оно должно начинаться с заглавной буквы.
Затем могут быть параметры. Их следует набирать в нижнем регистре. Они будут
использованы в качестве аргументов конструктора данных.

Список аргументов завершается двоеточием, за которым следует переведённая
строка, в которой можно использовать традиционный синтаксис интерполяции
\lstinline'#{myVar}'. Ссылаясь на параметры, заданные перед двоеточием, и
используя вспомогательные функции, к примеру для образования множественного
числа, вы можете получить любые переводы, какие пожелаете.

\subsection{Определяем типы}

Поскольку мы собираемся создавать тип данных на основе спецификации сообщений,
для каждого параметра конструктора данных должен быть указан тип. Для этого
используется символ \verb'@'. Например, для создания типа данных
\lstinline'data MyMessage = MsgHello | MsgSayAge Int' следует написать:

\begin{lstlisting}
Hello: Привет!
SayAge age@Int: Ваш возраст: #{show age}
\end{lstlisting}

Но тут имеют место две проблемы:

\begin{enumerate}
  \item Определять типы параметров в каждом файле не очень-то соответствует
      принципу DRY (<<don't repeat yourself>>, или <<не повторяйтесь>>).

  \item Переводчикам будет затруднительно определить правильный тип.
\end{enumerate}

По этим причинам определение типов данных требуется только в главном языковом
файле. Он задаётся третьим аргументом функции \lstinline'mkMessage'. Этот файл
так же определяет язык по умолчанию, который используется в случае, если
приложение не поддерживает ни один из языков, указанных в списке пользователя.

\section{Класс типов RenderMessage}

Вызов функции \lstinline'mkMessage' создаёт экземпляр класса типов
\lstinline'RenderMessage', который представляет собой ядро интернационализации
в Yesod. Вот его определение:

\begin{lstlisting}
class RenderMessage master message where
    renderMessage :: master
                  -> [Text] -- ^ языки
                  -> message
                  -> Text
\end{lstlisting}

Обратите внимание, что у класса \lstinline'RenderMessage' есть два параметра
типа~--- тип главного сайта (master) и тип сообщений (message). Теоретически,
мы могли бы опустить тип главного сайта, но это означало бы, что каждый сайт
должен иметь одинаковый набор переводов для каждого типа сообщения. Когда дело
доходит, до совместно используемых библиотек, например для работы с формами,
это решение становится нерабочим.

Функция \lstinline'renderMessage' принимает аргументы для каждого из параметров
типа класса~--- master и message, и дополнительный параметр со списком языков,
понимаемых пользователем, в порядке убывания приоритета. Функция возвращает
\lstinline'Text', который должен быть показан пользователю.

Простейший экземпляр класса \lstinline'RenderMessage' может в действительности
не реализовывать никакого перевода. Вместо этого он может просто отображать
одни и те же значения для любого языка. Например:

\begin{lstlisting}
data MyMessage = Hello | Greet Text
instance RenderMessage MyApp MyMessage where
    renderMessage _ _ Hello = "Привет"
    renderMessage _ _ (Greet name) = "Добро пожаловать, " <> name <> "!"
\end{lstlisting}

Обратите внимание, что мы проигнорировали два первых аргумента
\lstinline'renderMessage'. А теперь изменим этот экземпляр так, чтобы он
поддерживал несколько языков:

\begin{lstlisting}
renderEn Hello = "Hello"
renderEn (Greet name) = "Welcome, " <> name <> "!"
renderRu Hello = "Привет"
renderRu (Greet name) = "Добро пожаловать, " <> name <> "!"
instance RenderMessage MyApp MyMessage where
    renderMessage _ ("en":_) = renderEn
    renderMessage _ ("ru":_) = renderRu
    renderMessage master (_:langs) = renderMessage master langs
    renderMessage _ [] = renderEn
\end{lstlisting}

Идея довольно проста. Сначала мы объявляем вспомогательные функции для
поддержки каждого языка. Затем для каждого языка мы добавляем соответствующее
условие в определение функции \lstinline'renderMessage'. И два последних
варианта означают, что если текущий язык не совпал ни с одним из
поддерживаемых, взять из списка следующий по приоритету язык, а если в списке
больше не осталось языков, то использовать язык по умолчанию (в приведённом
примере~--- английский).

Однако есть вероятность, что вам никогда не придётся писать такое
самостоятельно, поскольку интерфейс файла сообщений сделает всё это за вас. Тем
не менее, всегда полезно знать, что происходит под капотом.

\section{Интерполяция}

Одним из способов использования вашего экземпляра класса
\lstinline'RenderMessage' является вызов функции \lstinline'renderMessage'
напрямую. Это будет работать, хотя и является несколько утомительным, поскольку
вам придётся передавать основное значение и список языков самостоятельно.
Вместо этого Hamlet предоставляет интерполяцию, специализированную для
интернационализации, записываемую, как \lstinline'_{...}'.

\begin{remark}
    Почему подчёркивание? Этот символ стал общепринятым для
    интернационализации, поскольку он используется в библиотеке gettext.
\end{remark}

Hamlet автоматически преобразует это в вызов \lstinline'renderMessage'. Получив
результат типа \lstinline'Text', Hamlet использует функцию \lstinline'toHtml'
для получения значения \lstinline'Html'. Таким образом, специальные символы
(\verb'<', \verb'&', \verb'>') автоматически экранируются.

\section{Фразы, а не слова}

В заключение мне хотелось бы дать вам совет по интернационализации. Допустим, у
вас есть интернет-магазин, продающий черепах. Вы собираетесь использовать слово
<<черепаха>> во многих предложениях, например <<Вы добавили 4 черепахи в вашу
корзину>> и <<Поздравляем, вы заказали 4 черепахи>>. Как программист, вы
наверняка обратили внимание на дублирование кода~--- фраза <<4 черепахи>>
встречается дважды. В связи с этим вы можете составить следующий файл
сообщений:

\begin{lstlisting}
AddStart: Вы добавили
AddEnd: в вашу корзину.
PurchaseStart: Поздравляем, вы заказали
PurchaseEnd: .
Turtles count@Int: #{show count} #{plural count "черепаху" "черепахи" "черепах"}
\end{lstlisting}

Стойте! Это всё, конечно, очень хорошо с точки зрения программирования, но
переводы~--- это \emph{не} программирование. Даже при таком подходе могут
возникнуть сложности:

\begin{itemize}
  \item В некоторых языках <<в вашу корзину>> может идти перед <<Вы добавили>>.

  \item Возможно, <<добавили>> будет преобразовываться в зависимости от того,
      добавили вы одну черепаху или несколько.

  \item Также может возникнуть множество других проблем.
\end{itemize}

Итак, совет такой: старайтесь переводить целые предложения, а не отдельные
слова.
