Блог: i18n, аутентификация, авторизация и база данных

Это приложение простой блог. Оно позволяет администратору добавлять записи в блог с помощью текстового редактора (nicedit), позволяет комментировать зарегистрированным пользователям и имеет полную поддержку i18n. Это также хороший пример использования базы данных Persistent, используя систему авторизации Yesod, и шаблоны.

Хотя в целом мы рекомендуем размещать шаблоны, определения сущностей Persist (Persist entity definitions) и маршрутизацию в отдельных файлах, мы для удобства будем держать всё это в одном файле. Единственным исключением как вы увидите ниже будут сообщения i18n.

Мы начнем с нашего расширений языка. В сгенерированом (scaffolded) коде, расширений языка указываются в файле cabal, так что вам не нужно будет указывать это в ваших Haskell файлах.
 
\begin{lstlisting}
{-# LANGUAGE OverloadedStrings, TypeFamilies, QuasiQuotes,
             TemplateHaskell, GADTs, FlexibleContexts,
             MultiParamTypeClasses #-}
\end{lstlisting}
 
Теперь импорт. 

\begin{lstlisting} 
import Yesod
import Yesod.Auth
import Yesod.Form.Nic (YesodNic, nicHtmlField)
import Yesod.Auth.BrowserId (authBrowserId)
import Data.Text (Text)
import Network.HTTP.Conduit (Manager, newManager, def)
import Database.Persist.Sqlite
    ( ConnectionPool, SqlPersist, runSqlPool, runMigration
    , createSqlitePool
    )
import Data.Time (UTCTime, getCurrentTime)
import Control.Applicative ((<$>), (<*>), pure)
\end{lstlisting}

Сначала мы настроим наши сущности Persistent. Мы собираемся создать наши типы данных (через mkPersist) и функцию миграции, которая будет автоматически создавать и обновлять нашу SQL-схему. Если вы используете сервер MongoDB, миграция не будет необходима.

\begin{lstlisting}
share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persistLowerCase|
\end{lstlisting}
 
Отслеживаем пользователей. В более надежных приложений, мы будем также сберегать дату регистрации, отображаемое имя, и т.д.
 
\begin{lstlisting}
User
   email Text
   UniqueUser email
\end{lstlisting}
 
Отдельные записи в блоге. 
 
\begin{lstlisting}
Entry
   title Text
   posted UTCTime
   content Html
\end{lstlisting}
 
Мы должны добавить этот "deriving" поскольку Html не определяет екземляры для Read, Show или Eq. Если вы получаете сообщение об ошибке "cannot derive" в своём собственном коде, попробуйте добавить deriving.
 
\begin{lstlisting}
   deriving
\end{lstlisting}
 
И комментарий к записи в блоге. 
 
\begin{lstlisting}
Comment
   entry EntryId
   posted UTCTime
   user UserId
   name Text
   text Textarea
|]
\end{lstlisting}
 
Каждый сайт имеет тип основание (foundation datatype). Это значение инициализируется перед запуском приложения, и доступна в течении всего времени работы. В нашем мы будем хранить пул соединений с базой данных и менеджер HTTP-соединения. Смотрите как они будут инициализированы в конце этого файла.
 
\begin{lstlisting}
data Blog = Blog
   { connPool :: ConnectionPool
   , httpManager :: Manager
   }
\end{lstlisting}
 
Для того, чтобы сделать i18n легким и дружественным переводчику, у нас есть специальный формат файлов для перевода сообщений. Существует отдельный файл для каждого языка, и каждый файл называется на основе кода языка (например, en, es, de-DE) и помещаются в эту папку. Мы также указываем основной языковой файл (в данном случае, "en") в качестве языка по умолчанию.
 
\begin{lstlisting}
mkMessage "Blog" "../messages-blog" "en"
\end{lstlisting}
 
Наш файл сообщений en содержит следующее содержание: 

\begin{lstlisting}
    NotAnAdmin: You must be an administrator to access this page.

    WelcomeHomepage: Welcome to the homepage
    SeeArchive: See the archive

    NoEntries: There are no entries in the blog
    LoginToPost: Admins can login to post
    NewEntry: Post to blog
    NewEntryTitle: Title
    NewEntryContent: Content

    PleaseCorrectEntry: Your submitted entry had some errors, please correct and try again.
    EntryCreated title@Text: Your new blog post, #{title}, has been created

    EntryTitle title@Text: Blog post: #{title}
    CommentsHeading: Comments
    NoComments: There are no comments
    AddCommentHeading: Add a Comment
    LoginToComment: You must be logged in to comment
    AddCommentButton: Add comment

    CommentName: Your display name
    CommentText: Comment
    CommentAdded: Your comment has been added
    PleaseCorrectComment: Your submitted comment had some errors, please correct and try again.

    HomepageTitle: Yesod Blog Demo
    BlogArchiveTitle: Blog Archive
\end{lstlisting}

А сейчас мы собираемся создать наши таблицы маршрутизации. У нас есть четыре элемента: домашняя страница, страница список записей (BlogR), отдельную страницу для записи (EntryR) и наш дочерний сайт аутентификации. Обратите внимание, что BlogR и EntryR оба принимают GET и POST методы. Методы POST для добавления новой записи в блог и добавления нового комментария, соответственно.
 
\begin{lstlisting}
mkYesod "Blog" [parseRoutes|
/ RootR GET
/blog BlogR GET POST
/blog/#EntryId EntryR GET POST
/auth AuthR Auth getAuth
|]
\end{lstlisting}
 
Каждый тип основание должен быть экземпляром класса типов Yesod. Здесь мы настраиваем различные параметры.
 
\begin{lstlisting}
instance Yesod Blog where
\end{lstlisting}
 
Основа нашего приложения. Обратите внимание, что для того, чтобы BrowserID работал правильно, это должен быть правильный URL.
 
\begin{lstlisting}
    approot = ApprootStatic "http://localhost:3000"
\end{lstlisting}
 
Наша схема авторизации. Мы хотим чтобы соблюдались следующие правила:

* Только администраторы могут добавлять новую запись. 
* Только зарегистрированные пользователи могут добавлять комментарии. 
* Все остальные страницы могут быть доступны любому.  

We set up our routes in a RESTful way, where the actions that could make changes are always using a POST method. As a result, we can simply check for whether or not a request is a write request, given by the True in the second field.

First, we'll authorize requests to add a new entry.

\begin{lstlisting}
    isAuthorized BlogR True = do
        mauth <- maybeAuth
        case mauth of
            Nothing -> return AuthenticationRequired
            Just (Entity _ user)
                | isAdmin user -> return Authorized
                | otherwise    -> unauthorizedI MsgNotAnAdmin
\end{lstlisting}

Now we'll authorize requests to add a new comment.

\begin{lstlisting}
    isAuthorized (EntryR _) True = do
        mauth <- maybeAuth
        case mauth of
            Nothing -> return AuthenticationRequired
            Just _  -> return Authorized
\end{lstlisting}

And for all other requests, the result is always authorized.

\begin{lstlisting}
    isAuthorized _ _ = return Authorized
\end{lstlisting}

Where a user should be redirected to if they get an AuthenticationRequired.

\begin{lstlisting}
    authRoute _ = Just (AuthR LoginR)
\end{lstlisting}

This is where we define our site look-and-feel. The function is given the content for the individual page, and wraps it up with a standard template.

\begin{lstlisting}
    defaultLayout inside = do
\end{lstlisting}

Yesod encourages the get-following-post pattern, where after a POST, the user is redirected to another page. In order to allow the POST page to give the user some kind of feedback, we have the getMessage and setMessage functions. It's a good idea to always check for pending messages in your defaultLayout function.

\begin{lstlisting}
        mmsg <- getMessage
\end{lstlisting}

We use widgets to compose together HTML, CSS and Javascript. At the end of the day, we need to unwrap all of that into simple HTML. That's what the widgetToPageContent function is for. We're going to give it a widget consisting of the content we received from the individual page (inside), plus a standard CSS for all pages. We'll use the Lucius template language to create the latter.

\begin{lstlisting}
        pc <- widgetToPageContent $ do
            toWidget [lucius|
body {
    width: 760px;
    margin: 1em auto;
    font-family: sans-serif;
}
textarea {
    width: 400px;
    height: 200px;
}
#message {
  color: #900;
}
|]
            inside
\end{lstlisting}

And finally we'll use a new Hamlet template to wrap up the individual components (title, head data and body data) into the final output.

\begin{lstlisting}
        hamletToRepHtml [hamlet|
$doctype 5
<html>
    <head>
        <title>#{pageTitle pc}
        ^{pageHead pc}
    <body>
        $maybe msg <- mmsg
            <div #message>#{msg}
        ^{pageBody pc}
|]
\end{lstlisting}

This is a simple function to check if a user is the admin. In a real application, we would likely store the admin bit in the database itself, or check with some external system. For now, I've just hard-coded my own email address.

\begin{lstlisting}
isAdmin :: User -> Bool
isAdmin user = userEmail user == "michael@snoyman.com"
\end{lstlisting}

In order to access the database, we need to create a YesodPersist instance, which says which backend we're using and how to run an action.

\begin{lstlisting}
instance YesodPersist Blog where
   type YesodPersistBackend Blog = SqlPersist
   runDB f = do 
       master <- getYesod
       let pool = connPool master
       runSqlPool f pool
\end{lstlisting}

This is a convenience synonym. It is defined automatically for you in the scaffolding.

\begin{lstlisting}
type Form x = Html -> MForm Blog Blog (FormResult x, Widget)
\end{lstlisting}

In order to use yesod-form and yesod-auth, we need an instance of RenderMessage for FormMessage. This allows us to control the i18n of individual form messages.

\begin{lstlisting}
instance RenderMessage Blog FormMessage where
    renderMessage _ _ = defaultFormMessage
\end{lstlisting}

In order to use the built-in nic HTML editor, we need this instance. We just take the default values, which use a CDN-hosted version of Nic.

\begin{lstlisting}
instance YesodNic Blog
\end{lstlisting}

In order to use yesod-auth, we need a YesodAuth instance.

\begin{lstlisting}
instance YesodAuth Blog where
    type AuthId Blog = UserId
    loginDest _ = RootR
    logoutDest _ = RootR
    authHttpManager = httpManager
\end{lstlisting}

We'll use [BrowserID](https://browserid.org/), which is a third-party system using email addresses as your identifier. This makes it easy to switch to other systems in the future, locally authenticated email addresses (also included with yesod-auth).

\begin{lstlisting}
    authPlugins _ = [authBrowserId]
\end{lstlisting}

This function takes someone's login credentials (i.e., his/her email address) and gives back a UserId.

\begin{lstlisting}
    getAuthId creds = do
        let email = credsIdent creds
            user = User email
        res <- runDB $ insertBy user
        return $ Just $ either entityKey id res
\end{lstlisting}

Homepage handler. The one important detail here is our usage of \lstinline'`setTitleI`', which allows us to use i18n messages for the title. We also use this message with a \lstinline'`_{Msg...}`' interpolation in Hamlet.

\begin{lstlisting}
getRootR :: Handler RepHtml
getRootR = defaultLayout $ do
    setTitleI MsgHomepageTitle
    [whamlet|
<p>_{MsgWelcomeHomepage}
<p>
   <a href=@{BlogR}>_{MsgSeeArchive}
|]
\end{lstlisting}

Define a form for adding new entries. We want the user to provide the title and content, and then fill in the post date automatically via \lstinline'`getCurrentTime`'.

\begin{lstlisting}
entryForm :: Form Entry
entryForm = renderDivs $ Entry
    <$> areq textField (fieldSettingsLabel MsgNewEntryTitle) Nothing
    <*> aformM (liftIO getCurrentTime)
    <*> areq nicHtmlField (fieldSettingsLabel MsgNewEntryContent) Nothing
\end{lstlisting}

Get the list of all blog entries, and present an admin with a form to create a new entry.

\begin{lstlisting}
getBlogR :: Handler RepHtml
getBlogR = do
    muser <- maybeAuth
    entries <- runDB $ selectList [] [Desc EntryPosted]
    (entryWidget, enctype) <- generateFormPost entryForm
    defaultLayout $ do
        setTitleI MsgBlogArchiveTitle
        [whamlet|
$if null entries
    <p>_{MsgNoEntries}
$else
    <ul>
        $forall Entity entryId entry <- entries
            <li>
                <a href=@{EntryR entryId}>#{entryTitle entry}
\end{lstlisting}

We have three possibilities: the user is logged in as an admin, the user is logged in and is not an admin, and the user is not logged in. In the first case, we should display the entry form. In the second, we'll do nothing. In the third, we'll provide a login link.

\begin{lstlisting}
$maybe Entity _ user <- muser
    $if isAdmin user
        <form method=post enctype=#{enctype}>
            ^{entryWidget}
            <div>
                <input type=submit value=_{MsgNewEntry}>
$nothing
    <p>
        <a href=@{AuthR LoginR}>_{MsgLoginToPost}
|]
\end{lstlisting}

Process an incoming entry addition. We don't do any permissions checking, since isAuthorized handles it for us. If the form submission was valid, we add the entry to the database and redirect to the new entry. Otherwise, we ask the user to try again.

\begin{lstlisting}
postBlogR :: Handler RepHtml
postBlogR = do
    ((res, entryWidget), enctype) <- runFormPost entryForm
    case res of
        FormSuccess entry -> do
            entryId <- runDB $ insert entry
            setMessageI $ MsgEntryCreated $ entryTitle entry
            redirect $ EntryR entryId
        _ -> defaultLayout $ do
            setTitleI MsgPleaseCorrectEntry
            [whamlet|
<form method=post enctype=#{enctype}>
    ^{entryWidget}
    <div>
        <input type=submit value=_{MsgNewEntry}>
|]
\end{lstlisting}

A form for comments, very similar to our entryForm above. It takes the EntryId of the entry the comment is attached to. By using pure, we embed this value in the resulting Comment output, without having it appear in the generated HTML.

\begin{lstlisting}
commentForm :: EntryId -> Form Comment
commentForm entryId = renderDivs $ Comment
    <$> pure entryId
    <*> aformM (liftIO getCurrentTime)
    <*> aformM requireAuthId
    <*> areq textField (fieldSettingsLabel MsgCommentName) Nothing
    <*> areq textareaField (fieldSettingsLabel MsgCommentText) Nothing
\end{lstlisting}

Show an individual entry, comments, and an add comment form if the user is logged in.

\begin{lstlisting}
getEntryR :: EntryId -> Handler RepHtml
getEntryR entryId = do
    (entry, comments) <- runDB $ do
        entry <- get404 entryId
        comments <- selectList [CommentEntry ==. entryId] [Asc CommentPosted]
        return (entry, map entityVal comments)
    muser <- maybeAuth
    (commentWidget, enctype) <-
        generateFormPost (commentForm entryId)
    defaultLayout $ do
        setTitleI $ MsgEntryTitle $ entryTitle entry
        [whamlet|
<h1>#{entryTitle entry}
<article>#{entryContent entry}
    <section .comments>
        <h1>_{MsgCommentsHeading}
        $if null comments
            <p>_{MsgNoComments}
        $else
            $forall Comment _entry posted _user name text <- comments
                <div .comment>
                    <span .by>#{name}
                    <span .at>#{show posted}
                    <div .content>#{text}
        <section>
            <h1>_{MsgAddCommentHeading}
            $maybe _ <- muser
                <form method=post enctype=#{enctype}>
                    ^{commentWidget}
                    <div>
                        <input type=submit value=_{MsgAddCommentButton}>
            $nothing
                <p>
                    <a href=@{AuthR LoginR}>_{MsgLoginToComment}
|]
\end{lstlisting}

Receive an incoming comment submission.

\begin{lstlisting}
postEntryR :: EntryId -> Handler RepHtml
postEntryR entryId = do
    ((res, commentWidget), enctype) <-
        runFormPost (commentForm entryId)
    case res of
        FormSuccess comment -> do
            _ <- runDB $ insert comment
            setMessageI MsgCommentAdded
            redirect $ EntryR entryId
        _ -> defaultLayout $ do
            setTitleI MsgPleaseCorrectComment
            [whamlet|
<form method=post enctype=#{enctype}>
    ^{commentWidget}
    <div>
        <input type=submit value=_{MsgAddCommentButton}>
|]
\end{lstlisting}

Finally our main function.

\begin{lstlisting}
main :: IO ()
main = do
    pool <- createSqlitePool "blog.db3" 10 -- create a new pool
    -- perform any necessary migration
    runSqlPool (runMigration migrateAll) pool
    manager <- newManager def -- create a new HTTP manager
    warpDebug 3000 $ Blog pool manager -- start our server
\end{lstlisting}