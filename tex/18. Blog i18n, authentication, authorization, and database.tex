\chapter{Блог: локализация, аутентификация, авторизация и база данных}
\label

Это приложение --- простой блог. Оно позволяет администратору добавлять записи в блог с помощью текстового редактора (nicedit), зарегистрированным пользователям позволяет оставлять комментарии, а также имеет полную поддержку локализации. Это также хороший пример использования базы данных Persistent, применения системы авторизации Yesod и шаблонов.

Хотя в целом мы рекомендуем размещать шаблоны, определения сущностей Persist (Persist entity definitions) и маршрутизацию в отдельных файлах, здесь, для удобства, мы будем держать всё это в одном файле. Единственным исключением, как вы увидите ниже, будут локализированные сообщения.

Начнем с расширений языка. В коде сгенерированного шаблона сайта расширения языка указаны в файле cabal, так что вам не нужно будет указывать их в ваших файлах Haskell.
 
\begin{lstlisting}
{-# LANGUAGE OverloadedStrings, TypeFamilies, QuasiQuotes,
             TemplateHaskell, GADTs, FlexibleContexts,
             MultiParamTypeClasses #-}
\end{lstlisting}
 
Теперь импорт. 

\begin{lstlisting} 
import Yesod
import Yesod.Auth
import Yesod.Form.Nic (YesodNic, nicHtmlField)
import Yesod.Auth.BrowserId (authBrowserId)
import Data.Text (Text)
import Network.HTTP.Conduit (Manager, newManager, def)
import Database.Persist.Sqlite
    ( ConnectionPool, SqlPersist, runSqlPool, runMigration
    , createSqlitePool
    )
import Data.Time (UTCTime, getCurrentTime)
import Control.Applicative ((<$>), (<*>), pure)
\end{lstlisting}%$

Сначала мы настроим наши сущности Persistent. Мы создадим и наши типы данных (через mkPersist), и функцию миграции, которая будет автоматически создавать и обновлять нашу SQL-схему. Если вы используете сервер MongoDB, миграция будет не нужна.

\begin{lstlisting}
share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persistLowerCase|
\end{lstlisting}
 
Отслеживаем пользователей. В более сложных приложениях мы будем также хранить дату регистрации, отображаемое имя и т. д.
 
\begin{lstlisting}
User
   email Text
   UniqueUser email
\end{lstlisting}
 
Запись в блоге. 
 
\begin{lstlisting}
Entry
   title Text
   posted UTCTime
   content Html
\end{lstlisting}
 
Мы должны добавить \lstinline!deriving!, поскольку Html не определяет экземляры для Read, Show или Eq. Если вы получаете сообщение об ошибке <<cannot derive>> в своём собственном коде, попробуйте добавить \lstinline!deriving!.
 
\begin{lstlisting}
   deriving
\end{lstlisting}
 
И комментарий к записи.
 
\begin{lstlisting}
Comment
   entry EntryId
   posted UTCTime
   user UserId
   name Text
   text Textarea
|]
\end{lstlisting}
 
Каждый сайт имеет тип-основание (foundation datatype). Это значение инициализируется перед запуском приложения и доступно в течении всего времени его работы. В нашем мы будем хранить пул соединений с базой данных и менеджер HTTP-соединения. Как они будут инициализированы, смотрите в конце этого файла.
 
\begin{lstlisting}
data Blog = Blog
   { connPool :: ConnectionPool
   , httpManager :: Manager
   }
\end{lstlisting}
 
Чтобы сделать локализацию легкой и дружественной переводчику, у нас есть специальный формат файлов для перевода сообщений. Для каждого языка существует отдельный файл, который именуется, основываясь на коде языка (например, en, es, de-DE), и размещается каталоге с таким же именем. Также мы указываем основной языковой файл (в данном случае, "en") в качестве языка по умолчанию.
 
\begin{lstlisting}
mkMessage "Blog" "../messages-blog" "en"
\end{lstlisting}
 
Содержимое нашего файла <<en>>: 

\begin{lstlisting}
    NotAnAdmin: You must be an administrator to access this page.

    WelcomeHomepage: Welcome to the homepage
    SeeArchive: See the archive

    NoEntries: There are no entries in the blog
    LoginToPost: Admins can login to post
    NewEntry: Post to blog
    NewEntryTitle: Title
    NewEntryContent: Content

    PleaseCorrectEntry: Your submitted entry had some errors, please correct and try again.
    EntryCreated title@Text: Your new blog post, #{title}, has been created

    EntryTitle title@Text: Blog post: #{title}
    CommentsHeading: Comments
    NoComments: There are no comments
    AddCommentHeading: Add a Comment
    LoginToComment: You must be logged in to comment
    AddCommentButton: Add comment

    CommentName: Your display name
    CommentText: Comment
    CommentAdded: Your comment has been added
    PleaseCorrectComment: Your submitted comment had some errors, please correct and try again.

    HomepageTitle: Yesod Blog Demo
    BlogArchiveTitle: Blog Archive
\end{lstlisting}

Теперь настроим таблицу маршрутизации. У нас будет четыре записи: домашняя страница, страница со списком записей (BlogR), страница индивидуальной записи (EntryR) и подсайт аутентификации. Обратите внимание, что BlogR и EntryR принимают методы GET и POST. POST используются для добавления новой записи в блог и добавления нового комментария, соответственно.
 
\begin{lstlisting}
mkYesod "Blog" [parseRoutes|
/ RootR GET
/blog BlogR GET POST
/blog/#EntryId EntryR GET POST
/auth AuthR Auth getAuth
|]
\end{lstlisting}
 
Каждый тип-основание должен быть экземпляром класса типов Yesod. Именно здесь мы настраиваем различные параметры.
 
\begin{lstlisting}
instance Yesod Blog where
\end{lstlisting}
 
Основа нашего приложения. Обратите внимание: чтобы BrowserID работал правильно, это должен быть правильный URL.
 
\begin{lstlisting}
    approot = ApprootStatic "http://localhost:3000"
\end{lstlisting}
 
Наша схема авторизации. Мы хотим, чтобы соблюдались следующие правила:

\begin{itemize}
\item Только администраторы могут добавлять новую запись. 
\item Только зарегистрированные пользователи могут добавлять комментарии. 
\item Все остальные страницы могут быть доступны любому.
\end{itemize}

Мы сконфигурировали наши маршруты в RESTful-стиле, когда действия, которые могут вносить изменения, всегда используют метод POST. В результате мы можем легко проверить, является ли запрос запросом на запись --- если вторым параметром передано True, значит это так.

Во-первых, мы будем авторизировать запросы на добавление новой записи. 
 
\begin{lstlisting}
    isAuthorized BlogR True = do
        mauth <- maybeAuth
        case mauth of
            Nothing -> return AuthenticationRequired
            Just (Entity _ user)
                | isAdmin user -> return Authorized
                | otherwise    -> unauthorizedI MsgNotAnAdmin
\end{lstlisting}

Также мы будем авторизировать запросы на добавление нового комментария. 
 
\begin{lstlisting}
    isAuthorized (EntryR _) True = do
        mauth <- maybeAuth
        case mauth of
            Nothing -> return AuthenticationRequired
            Just _  -> return Authorized
\end{lstlisting}
 
Все остальные запросы авторизируем всегда.
 
\begin{lstlisting}
    isAuthorized _ _ = return Authorized
\end{lstlisting}
 
Указываем, куда должен быть перенаправлен пользователь, если он получает AuthenticationRequired. 
 
\begin{lstlisting}
    authRoute _ = Just (AuthR LoginR)
\end{lstlisting}
 
Здесь мы определяем оформление нашего сайта. Функция получает содержимое каждой страницы и обёртывает его в стандартный шаблон. 
 
\begin{lstlisting}
    defaultLayout inside = do
\end{lstlisting}
 
Yesod поощряет подход <<get-following-post>>, когда после POST-запроса пользователь перенаправляется на другую страницу. Чтобы позволить POST-странице дать пользователю какой-то отклик, у нас есть функции \lstinline!getMessage! и \lstinline!setMessage!. Хорошей идеей будет всегда проверять на наличие ожидающих сообщений в вашей функции \lstinline!defaultLayout!. 
 
\begin{lstlisting}
        mmsg <- getMessage
\end{lstlisting}
 
Чтобы объеденить вместе HTML, CSS и JavaScript, мы используем виджеты. В конце концов мы должны развернуть их в простой HTML. Для этого есть функция \lstinline!widgetToPageContent!. Мы передадим ей виджет, состоящий из содержимого, которое мы получили от отдельных страниц (inside), и стандартного CSS для всех страниц. Для создания последнего мы используем язык шаблонов Lucius. 
 
\begin{lstlisting}
        pc <- widgetToPageContent $ do
            toWidget [lucius|
body {
    width: 760px;
    margin: 1em auto;
    font-family: sans-serif;
}
textarea {
    width: 400px;
    height: 200px;
}
#message {
  color: #900;
}
|]
            inside
\end{lstlisting}%$
 
В заключение мы используем новый шаблон Hamlet, чтобы обернуть отдельные части (заголовок, содержимое тегов \lstinline!<head>! и \lstinline!<body>!) в конечный результат. 
 
\begin{lstlisting}
        hamletToRepHtml [hamlet|
$doctype 5
<html>
    <head>
        <title>#{pageTitle pc}
        ^{pageHead pc}
    <body>
        $maybe msg <- mmsg
            <div #message>#{msg}
        ^{pageBody pc}
|]
\end{lstlisting}
 
Это простая функция для проверки, является ли пользователь администратором. В реальных приложениях мы, скорее всего, будем хранить признак администратора в базе данных или проверять через какие-нибудь внешние системы. А сейчас я просто жестко задам адрес своей электронной почты. 
 
\begin{lstlisting}
isAdmin :: User -> Bool
isAdmin user = userEmail user == "michael@snoyman.com"
\end{lstlisting}
 
Чтобы получить доступ к базе данных, нам нужно создать экземпляр \lstinline!YesodPersist!, который указывает, какой сервер мы используем и как выполнять действия. 
 
\begin{lstlisting}
instance YesodPersist Blog where
   type YesodPersistBackend Blog = SqlPersist
   runDB f = do 
       master <- getYesod
       let pool = connPool master
       runSqlPool f pool
\end{lstlisting}
 
Это синоним типа для удобства. Он определяется автоматически при генерации шаблона сайта. 
 
\begin{lstlisting}
type Form x = Html -> MForm Blog Blog (FormResult x, Widget)
\end{lstlisting}
 
Для использования \lstinline!yesod-form! и \lstinline!yesod-auth! нам нужен экземпляр \lstinline!RenderMessage! для \lstinline!FormMessage!. Это позволит контролировать локализацию сообщений отдельных форм. 
 
\begin{lstlisting}
instance RenderMessage Blog FormMessage where
    renderMessage _ _ = defaultFormMessage
\end{lstlisting}
 
Этот экземпляр нужен для того, чтобы использовать встроенный редактор HTML Nic. Используем значения по умолчанию для CDN-hosted версии Nic. 
 
\begin{lstlisting}
instance YesodNic Blog
\end{lstlisting}
 
Чтобы использовать \lstinline!yesod-auth!, нам нужен экземпляр \lstinline!YesodAuth!. 
 
\begin{lstlisting}
instance YesodAuth Blog where
    type AuthId Blog = UserId
    loginDest _ = RootR
    logoutDest _ = RootR
    authHttpManager = httpManager
\end{lstlisting}
 
Мы будем использовать [BrowserID](https://browserid.org/), которая является сторонней системой ипользующей адрес электронной почты в качестве вашего идентификатора. Это позволит в будущем легко перейти на другие системы, для локально аутентифицированых адресов электронной почты (также входит в yesod-auth). 
 
\begin{lstlisting}
    authPlugins _ = [authBrowserId]
\end{lstlisting}
 
Эта функция берёт регистрационное имя пользователя (login credentials) (то есть, адрес электронной почты) и возвращает UserId. 
 
\begin{lstlisting}
    getAuthId creds = do
        let email = credsIdent creds
            user = User email
        res <- runDB $ insertBy user
        return $ Just $ either entityKey id res
\end{lstlisting}
 
Обработчик домашней страницы. Одна важная деталь здесь это использование \lstinline'`setTitleI`', что позволяет использовать локализированные сообщения в заголовке. Мы также используем это сообщение с \lstinline'`_{Msg...}`' интерполяцией в Hamlet. 
 
\begin{lstlisting}
getRootR :: Handler RepHtml
getRootR = defaultLayout $ do
    setTitleI MsgHomepageTitle
    [whamlet|
<p>_{MsgWelcomeHomepage}
<p>
   <a href=@{BlogR}>_{MsgSeeArchive}
|]
\end{lstlisting}
 
Определяем форму для добавления новых записей. Мы хотим, чтобы пользователь заполнил заголовок и содержание, а дату записи заполним автоматически с помощью \lstinline'`getCurrentTime`'. 
 
\begin{lstlisting}
entryForm :: Form Entry
entryForm = renderDivs $ Entry
    <$> areq textField (fieldSettingsLabel MsgNewEntryTitle) Nothing
    <*> aformM (liftIO getCurrentTime)
    <*> areq nicHtmlField (fieldSettingsLabel MsgNewEntryContent) Nothing
\end{lstlisting}
 
Получаем список всех записей, и для администратора отобразим форму для создания новой записи. 
 
\begin{lstlisting}
getBlogR :: Handler RepHtml
getBlogR = do
    muser <- maybeAuth
    entries <- runDB $ selectList [] [Desc EntryPosted]
    (entryWidget, enctype) <- generateFormPost entryForm
    defaultLayout $ do
        setTitleI MsgBlogArchiveTitle
        [whamlet|
$if null entries
    <p>_{MsgNoEntries}
$else
    <ul>
        $forall Entity entryId entry <- entries
            <li>
                <a href=@{EntryR entryId}>#{entryTitle entry}
\end{lstlisting}
 
У нас есть три варианта: пользователь вошёл в систему в качестве администратора, пользователь вошёл и не администратор, и пользователь не вошёл в систему. В первом случае, мы должны отобразить форму записи. Во втором, мы ничего не делаем. В третьем, мы предоставим ссылку для входа. 
 
\begin{lstlisting}
$maybe Entity _ user <- muser
    $if isAdmin user
        <form method=post enctype=#{enctype}>
            ^{entryWidget}
            <div>
                <input type=submit value=_{MsgNewEntry}>
$nothing
    <p>
        <a href=@{AuthR LoginR}>_{MsgLoginToPost}
|]
\end{lstlisting}
 
Обработаем добавление новой записи. Мы не делаем никакой проверки авторизации, так как isAuthorized делает это за нас. Если форма была верной (form submission was valid), мы добавляеи запись в базу данных и перенаправляем на эту новую запись. В противном случае, мы просим пользователей попробовать еще раз. 
 
\begin{lstlisting}
postBlogR :: Handler RepHtml
postBlogR = do
    ((res, entryWidget), enctype) <- runFormPost entryForm
    case res of
        FormSuccess entry -> do
            entryId <- runDB $ insert entry
            setMessageI $ MsgEntryCreated $ entryTitle entry
            redirect $ EntryR entryId
        _ -> defaultLayout $ do
            setTitleI MsgPleaseCorrectEntry
            [whamlet|
<form method=post enctype=#{enctype}>
    ^{entryWidget}
    <div>
        <input type=submit value=_{MsgNewEntry}>
|]
\end{lstlisting}
 
Форма для комментариев, очень похожа на entryForm выше. Она принимает EntryID записи к которой относиться комментарий. Используя pure, мы вкладываем это значение в результирующее значение Comment, не позволяя ему появиться в сгенерированном HTML. 
 
\begin{lstlisting}
commentForm :: EntryId -> Form Comment
commentForm entryId = renderDivs $ Comment
    <$> pure entryId
    <*> aformM (liftIO getCurrentTime)
    <*> aformM requireAuthId
    <*> areq textField (fieldSettingsLabel MsgCommentName) Nothing
    <*> areq textareaField (fieldSettingsLabel MsgCommentText) Nothing
\end{lstlisting}
 
Показываем отдельную запись, комментарии, и для зарегистрированых пользователей форму комментариев.
 
\begin{lstlisting}
getEntryR :: EntryId -> Handler RepHtml
getEntryR entryId = do
    (entry, comments) <- runDB $ do
        entry <- get404 entryId
        comments <- selectList [CommentEntry ==. entryId] [Asc CommentPosted]
        return (entry, map entityVal comments)
    muser <- maybeAuth
    (commentWidget, enctype) <-
        generateFormPost (commentForm entryId)
    defaultLayout $ do
        setTitleI $ MsgEntryTitle $ entryTitle entry
        [whamlet|
<h1>#{entryTitle entry}
<article>#{entryContent entry}
    <section .comments>
        <h1>_{MsgCommentsHeading}
        $if null comments
            <p>_{MsgNoComments}
        $else
            $forall Comment _entry posted _user name text <- comments
                <div .comment>
                    <span .by>#{name}
                    <span .at>#{show posted}
                    <div .content>#{text}
        <section>
            <h1>_{MsgAddCommentHeading}
            $maybe _ <- muser
                <form method=post enctype=#{enctype}>
                    ^{commentWidget}
                    <div>
                        <input type=submit value=_{MsgAddCommentButton}>
            $nothing
                <p>
                    <a href=@{AuthR LoginR}>_{MsgLoginToComment}
|]
\end{lstlisting}
 
Получаем комментарий (submission). 
 
\begin{lstlisting}
postEntryR :: EntryId -> Handler RepHtml
postEntryR entryId = do
    ((res, commentWidget), enctype) <-
        runFormPost (commentForm entryId)
    case res of
        FormSuccess comment -> do
            _ <- runDB $ insert comment
            setMessageI MsgCommentAdded
            redirect $ EntryR entryId
        _ -> defaultLayout $ do
            setTitleI MsgPleaseCorrectComment
            [whamlet|
<form method=post enctype=#{enctype}>
    ^{commentWidget}
    <div>
        <input type=submit value=_{MsgAddCommentButton}>
|]
\end{lstlisting}
 
Наконец наша главная функция. 
 
\begin{lstlisting}
main :: IO ()
main = do
    pool <- createSqlitePool "blog.db3" 10 -- создаём новый пул
    -- perform any necessary migration
    runSqlPool (runMigration migrateAll) pool
    manager <- newManager def -- создаём новый менеджер HTTP
    warpDebug 3000 $ Blog pool manager -- стартуем наш сервер
\end{lstlisting}