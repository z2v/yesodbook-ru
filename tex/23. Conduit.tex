\chapter{Кондуиты}

Кондуиты используются для обработки потоков данных. Часто ленивые вычисления
позволяют обрабатывать большие объемы не загружая их в память целиком. Однако, 
использование такого подхода для ввода-вывода влечет требование ленивости ввода-вывода.
А его главный недостаток --- недетерминированность: у нас нет никаких гарантий когда
финализаторы наших ресурсов будут запущены. Для небольшого приложения это допустимо, но
для высоко нагруженного веб-сервера мы можем очень быстро исчерпать допустимые ресурсы,
например, дескрипторы для файлов.

Кондуиты позволяют оперировать большими потоками данных при детерминированном управлении
ресурсами. Они предоставляют унифицированный интерфес для потоков данных вне зависимости
от того откуда они поступают: из файлов, сокетов или памяти. В сочетании с ResourceT мы
можем безопасно работать с ресурсами, зная, что они будут гарантированно освобождены даже
в случае исключений.

В этом приложении рассматривается пакет conduit версии \verb=0.2=.


Кондуиты в двух словах

Хотя понимание низкоуровневой механики кондутов рекомендуется, вы можете далеко
продвинуться и без неё. Давайте начнем с нескольких высокоуровневых примеров. Не
беспокойтесь, если некоторые детали вам будут сейчас непонятны --- мы разберем всё в этом
приложении. Начнем с терминологии и нескольких примеров кода.

\begin{itemize}
 \item \textit{Источник(source)} генерирует данные. Они могут быть в файле, придти из
сокета или лежать списком в памяти. Мы обращаемся к этим данным забирая их из источника.
 \item Sink --- потребляет данные. Основные примеры будут о функции суммирования
(сложения чисел из потока), файловом канале (пишет все пришедшие байты в файл) или
сокете. В конце обработки данных возвращается какое-то значение.
% FIXME: как sink на русский переводить?
 \item \textit{Кондуиты} преобразуют данные. В простейшем примере это будет функция map,
хотя бывает много других. Мы добавляем данные в кондуит также как и в sink. Но вместо
возврата одного значения, кондуит может вернуть несколько результатов каждый раз, когда в
него добавляются данные.
  \item \textit{Комбинирование (fuse)} --- термин Давида Мазьереса. Кондуит можно 
скомбинировать с источником данных (с помощью оператора \verb=$==) и получить
модифицированный источник. Например, мы можем взять источник, читающий байты из файла, и
кондуит, который преобразует байты в текст. Скомбинировав их, мы получим получим
источник, читающий текст из файла. Аналогично, кондуит и sink можно скомбинировать в sink
(оператор \verb#=$#), а два кондуита --- в новый кондуит (оператор \verb#=$=#).
  \item Соединение. Мы можем присоединять источник к sink используя оператор \verb=$$=.
Это приведет к тому, что данные будут передаваться из источника в sink до тех пор, пока
источник или sink не сообщать, что они ``закончили''.
\end{itemize}

Рассмотрим несколько примеров кода.
\begin{verbatim}
{-# LANGUAGE OverloadedStrings #-}
import Data.Conduit -- the core library
import qualified Data.Conduit.List as CL -- some list-like functions
import qualified Data.Conduit.Binary as CB -- bytes
import qualified Data.Conduit.Text as CT

import Data.ByteString (ByteString)
import Data.Text (Text)
import qualified Data.Text as T
import Control.Monad.ST (runST)
\end{verbatim}
Начнем с основ: соединим источник с sink. Мы будем использовать встроенные файловые
функции для эффективности, константной памяти и ресурсо-безопасного копирования файлов.

Обратите внимание: вначале мы используем \verb=$$= для соединения источник с sink, а
затем используем rubResourceT.
\begin{verbatim}
copyFile :: FilePath -< FilePath -< IO ()
copyFile src dest = runResourceT $ CB.sourceFile src $$ CB.sinkFile dest
\end{verbatim}
Модуль Data.Conduit.List предоставляет некоторые число функций для создания sink,
источников и кондуитов. Вот так выглядит свёртка: суммирование чисел.
\begin{verbatim}
sumSink :: Resource m =< Sink Int m Int
sumSink = CL.fold (+) 0
\end{verbatim}
Мы можем реализовать то же самое более низкоуровнево, используя функцию \verb=sinkState=.
Они принимает три параметра: начальное состояние, функцию приема дополнительных данных и
функцию закрытия.
\begin{verbatim}
sumSink2 :: Resource m =< Sink Int m Int
sumSink2 = sinkState
    0 -- начальное значение
    -- обновим состояния согласно полученным данным 
    -- и сообщим что необходимы дополнительные данные
    (\accum i -< return $ StateProcessing (accum + i))
    (\accum -< return accum) -- вернуть текущее значение при закрытии
\end{verbatim}
Другая полезная функция --- \verb=sourceList=. Скомбинировав её с нашей функций
\verb=sumSink=, мы получим встроенную реализацию функции sum.
\begin{verbatim}
sum' :: [Int] -< Int
sum' input = runST $ runResourceT $ CL.sourceList input $$ sumSink
\end{verbatim}
Поскольку это Haskell давайте создадим источник, который генерирует все числа Фибоначчи.
Для этого мы будем использовать sourceState. Состояние будет содеражать следующие два
число в последовательности. Также нам понадобится функция, которая вернет следующее число
и обновит состояние.
\begin{verbatim}fibs :: Resource m => Source m Int
fibs = sourceState
    (0, 1) -- initial state
    (\(x, y) -> return $ StateOpen (y, x + y) x)
\end{verbatim}
Посчитаем сумму первых 10 чисел Фибоначчи. Мы можем использовать изолированный кондуит,
чтобы быть уверенными, что sink суммирования приняла только 10 значений.
\begin{verbatim}sumTenFibs :: Int
sumTenFibs =
       runST -- runs fine in pure code
     $ runResourceT
     $ fibs
    $= CL.isolate 10 -- fuse the source and conduit into a source
    $$ sumSink
\end{verbatim}
Мы также можем скомбинировать кондуит и sink, поменяв местами некоторые операторы.
\begin{verbatim}sumTenFibs2 :: Int
sumTenFibs2 =
       runST
     $ runResourceT
     $ fibs
    $$ CL.isolate 10
    =$ sumSink
\end{verbatim}
Отлично, а теперь сделаем несколько кондуитов. Давайте преобразовывать числа в текст.
Кажется, функция map нам подойдет...
\begin{verbatim}
intToText :: Int -> Text -- дополнительная функция 
intToText = T.pack . show

textify :: Resource m => Conduit Int m Text
textify = CL.map intToText
\end{verbatim}
Аоспользуемся функцией conduitState также как это было сделано выше. Здесь нам не нужно
состояние, поэтому подставим фиктивно значение.
\begin{verbatim}textify2 :: Resource m =< Conduit Int m Text
textify2 = conduitState
    ()
    (\() input -< return $ StateProducing () [intToText input])
    (\() -< return [])
\end{verbatim}
Сделаем кондуит unlines, который будет добавлять перевод строки в конце каждого блока
входных данных. Воспользуемся функцией CL.map. feel free to write it with conduitState as
well for practice.
\begin{verbatim}unlines' :: Resource m => Conduit Text m Text
unlines' = CL.map $ \t -> t `T.append` "\n"
\end{verbatim}
А теперь напишем функцию, которая печатает первые N чисел фибоначчи. Используем
кодировку UTF8.
\begin{verbatim}writeFibs :: Int -< FilePath -< IO ()
writeFibs count dest =
      runResourceT
    $ fibs
   $= CL.isolate count
   $= textify
   $= unlines'
   $= CT.encode CT.utf8
   $$ CB.sinkFile dest
\end{verbatim}
Мы использовали оператор \verb#$=#, чтобы комбинировать кондуиты с источниками, получая
новые источники. Можно делать и обратное: комбинировать кондуиты и sink. Можно даже
скомбинировать два кондуита.
\begin{verbatim}writeFibs2 :: Int -< FilePath -< IO ()
writeFibs2 count dest =
      runResourceT
    $ fibs
   $= CL.isolate count
   $= textify
   $$ unlines'
   =$ CT.encode CT.utf8
   =$ CB.sinkFile dest
\end{verbatim}
Или мы можем скомбинировать все написанные кондуиты в один
\begin{verbatim}someIntLines :: ResourceThrow m -- encoding can throw an exception
             =< Int
             -< Conduit Int m ByteString
someIntLines count =
      CL.isolate count
  =$= textify
  =$= unlines'
  =$= CT.encode CT.utf8
\end{verbatim}
Теперь используем кондуит
\begin{verbatim}
writeFibs3 :: Int -< FilePath -< IO ()
writeFibs3 count dest =
      runResourceT
    $ fibs
   $= someIntLines count
   $$ CB.sinkFile dest

main :: IO ()
main = do
    putStrLn $ "First ten fibs: " ++ show sumTenFibs
    writeFibs 20 "fibs.txt"
    copyFile "fibs.txt" "fibs2.txt"
\end{verbatim}

Структура главы.

Остаток этой главы освещает следующие темы.
\begin{itemize}
 \item ResourceT --- техника, которая позволяет управлять освобождением ресурсов.
 \item Источники --- наши генераторы данных
 \item Sinks --- потребители данных
 \item Кондуиты --- преобразователи данных
 \item Буферизация --- техника борьбы с инверсией управления.
\end{itemize}

Трансформер монады Resource

Трансформер монады Resource (ResourceT) играет существенную роль в управлении ресурсами в
проектах, использующих кондуиты. Он поставляется вместе с библиотекй \verb=conduit=. Мы
будем рассматривать ResourceT самого по себе. Хотя некоторые решения в его дизайне
основаны на кондуитах, ResourceT можно использовато самого по себе.

Назначение

Что не так с этим кодом?
\begin{verbatim}
import System.IO

main = do
    output <- openFile "output.txt" WriteMode
    input  <- openFile "input.txt"  ReadMode
    hGetContents input <<= hPutStr output
    hClose input
    hClose output
\end{verbatim}

Если файл input.txt отсутствует, бросится исключение при попытке его открыть. В
результате hClose output никогда не будет вызвано и мы получим утечку важного ресурса
(дескриптора файлов). В небольшой программе это не критично, но очевидно, что мы не
сможем себе этого позволить в высоко нагруженном процессе сервера с большим аптаймом

К счастью проблема решается довольно просто:
\begin{verbatim}
import System.IO

main =
    withFile "output.txt" WriteMode $ \output ->
    withFile "input.txt" ReadMode $ \input ->
    hGetContents input <<= hPutStr output
\end{verbatim}

Использование withFile гшарантирует, что дескриптор будет закрыт, даже в случае
исключений. Оно также поддерживает асинхронные исключения. Вообще говоря, это прекрасный
подход для случаев, когда вы можете его использовать. Хотя withFile просто использовать,
часто он влечет переписывание всей программы. А это переписывание может быть очень
скучным и сильно неэффективным.

Возьмем, например, енумераторы. Если вы заглянете в документацию, то найдете функцию
enumFile для чте ния содержимого файла, но не найдете функции iterFile для записи
содержимого в файл. Так сделано потому, что поток управления итератов не позволяет
правильно управлять дескрипторами. Взамен, чтобо записать в файл вам надо создавать
дескриптор до запуска итерата, т.е.: 

\begin{verbatim}
import System.IO
import Data.Enumerator
import Data.Enumerator.Binary

main =
    withFile "output.txt" WriteMode $ \output -<
    run_ $ enumFile "input.txt" $$ iterHandle output
\end{verbatim}

Этот код работает хорошо, но представьте, что вместо простой передачи данных в файл, нам
надо провести длительное вычисление перед использование дескриптора. Мы будем иметь
дескриптор задолго до того, как он нам понадобится, блокируя важный ресурс нашего
приложения. Кроме этого, часто мы не можем открыть файл, так как мы поймем какой файл
надо открывать только тогда, когда прочитаем все данные.

Одна из заявленных целей кондуитов --- решить эту пролему с помощью ResourceT. Программа
выше может быть переписана вот так:
\begin{verbatim}
{-# LANGUAGE OverloadedStrings #-}
import Data.Conduit
import Data.Conduit.Binary

main = runResourceT $ sourceFile "input.txt" $$ sinkFile "output.txt"
\end{verbatim}

Как это работает

There are essentially three base functions on ResourceT, and then a bunch of
conveniences thrown on top. The first function is:
\begin{verbatim}
register :: IO () -> ResourceT IO ReleaseKey
\end{verbatim}
Полииморфность этой функции и остальных ниже не используется в полную силу, на самом деле
они могут работать с другими монадами кроме IO. In fact, almost any transformer on top of
IO, as well as any ST stacks, work. Мы разъясним детали познее.
% FIXME: Я провтыкал что такое ST
Эта функция региструет кусок кода, утверждения которого будут выполнены. Она также
возвращает ReleaseKey, которое используется в следующей функции:
\begin{verbatim}release :: ReleaseKey -< ResourceT IO ()
\end{verbatim}
Возоы функции \verb=release= от ReleaseKey немедленно выполняет действии, которое ыло
зарегистрировано ранее. Мы можем вызывать \verb=release= от одной и той же ReleaseKey
стольк раз, сколько пожелаем, при первом вызове регистрация действия отменяется. Это
значит, что вы можете безопасно зарегистрировать действие освобождения памяти, не
заботясь о том, что оно будет выполнено дважды.

Со временем, мы можем захотеть освободить ресурс, ResourceT. Чтобы сделать это,
воспользуемся:
\begin{verbatim}
runResourceT :: ResourceT IO a -> IO a
\end{verbatim}
В этой внешене невинной функции происходит вся магия. 
 It runs through ("пронизывать") all of
the
registered cleanup actions and performs them. Она безопасна с точки зрения исключений, в
том смысле, что освобождения ресурсов будут выполнены в случае и синхронных, и
асинхронныъ исключений. И, как было упомянуто выше, вызов функции release отменит
регистрацию действия. Таким образом нам не стоит беспокоиться о повторном освобождении
ресурсов.

Наконец, для удобства, мы приведем ещё одну функцию для выделения ресурса и регистрации
действия по его освобождению:
\begin{verbatim}
with :: IO a -- ^ allocate
     -> (a -> IO ()) -- ^ free resource
     -> ResourceT IO (ReleaseKey, a)
\end{verbatim}

Теперь перепишем с использованием ResourceT первый некачественный пример:
\begin{verbatim}
import System.IO
import Control.Monad.Trans.Resource
import Control.Monad.Trans.Class (lift)

main = runResourceT $ do
    (releaseO, output) <- with (openFile "output.txt" WriteMode) hClose
    (releaseI, input)  <- with (openFile "input.txt"  ReadMode)  hClose
    lift $ hGetContents input <<= hPutStr output
    release releaseI
    release releaseO
\end{verbatim}

Сейчас мы можем не беспокоиться об исключениях, затрудняющих освобождение ресурсов. Мы
можем опустить вызовы \verb=release= в таких маленьких программах как эта, это ни на что
не повлияет. Но в больших приложениях, где мы продолжим обработку дальше, этот код
гарантирует, что дескрипторы ресурсов освободятся как только это станет возможным, снижая
потребление ресурсов до минимума.
