\chapter{Кондуиты}

Кондуиты используются для обработки потоков данных. Часто ленивые вычисления
позволяют обрабатывать большие объемы не загружая их в память целиком. Однако, 
использование такого подхода для ввода-вывода влечет требование ленивости ввода-вывода.
А его главный недостаток --- недетерминированность: у нас нет никаких гарантий когда
финализаторы наших ресурсов будут запущены. Для небольшого приложения это допустимо, но
для высоко нагруженного веб-сервера мы можем очень быстро исчерпать допустимые ресурсы,
например, дескрипторы для файлов.

Кондуиты позволяют оперировать большими потоками данных при детерминированном управлении
ресурсами. Они предоставляют унифицированный интерфес для потоков данных вне зависимости
от того откуда они поступают: из файлов, сокетов или памяти. В сочетании с ResourceT мы
можем безопасно работать с ресурсами, зная, что они будут гарантированно освобождены даже
в случае исключений.

В этом приложении рассматривается пакет conduit версии \verb=0.2=.


Кондуиты в двух словах

Хотя понимание низкоуровневой механики кондутов рекомендуется, вы можете далеко
продвинуться и без неё. Давайте начнем с нескольких высокоуровневых примеров. Не
беспокойтесь, если некоторые детали вам будут сейчас непонятны --- мы разберем всё в этом
приложении. Начнем с терминологии и нескольких примеров кода.

\begin{itemize}
 \item \textit{Источник(source)} генерирует данные. Они могут быть в файле, придти из
сокета или лежать списком в памяти. Мы обращаемся к этим данным забирая их из источника.
 \item Sink --- потребляет данные. Основные примеры будут о функции суммирования
(сложения чисел из потока), файловом канале (пишет все пришедшие байты в файл) или
сокете. В конце обработки данных возвращается какое-то значение.
% FIXME: как sink на русский переводить?
 \item \textit{Кондуиты} преобразуют данные. В простейшем примере это будет функция map,
хотя бывает много других. Мы добавляем данные в кондуит также как и в sink. Но вместо
возврата одного значения, кондуит может вернуть несколько результатов каждый раз, когда в
него добавляются данные.
  \item \textit{Комбинирование (fuse)} --- термин Давида Мазьереса. Кондуит можно 
скомбинировать с источником данных (с помощью оператора \verb=$==) и получить
модифицированный источник. Например, мы можем взять источник, читающий байты из файла, и
кондуит, который преобразует байты в текст. Скомбинировав их, мы получим получим
источник, читающий текст из файла. Аналогично, кондуит и sink можно скомбинировать в sink
(оператор \verb#=$#), а два кондуита --- в новый кондуит (оператор \verb#=$=#).
  \item Соединение. Мы можем присоединять источник к sink используя оператор \verb=$$=.
Это приведет к тому, что данные будут передаваться из источника в sink до тех пор, пока
источник или sink не сообщать, что они ``закончили''.
\end{itemize}

Рассмотрим несколько примеров кода.
\begin{verbatim}
{-# LANGUAGE OverloadedStrings #-}
import Data.Conduit -- the core library
import qualified Data.Conduit.List as CL -- some list-like functions
import qualified Data.Conduit.Binary as CB -- bytes
import qualified Data.Conduit.Text as CT

import Data.ByteString (ByteString)
import Data.Text (Text)
import qualified Data.Text as T
import Control.Monad.ST (runST)
\end{verbatim}
Начнем с основ: соединим источник с sink. Мы будем использовать встроенные файловые
функции для эффективности, константной памяти и ресурсо-безопасного копирования файлов.

Обратите внимание: вначале мы используем \verb=$$= для соединения источник с sink, а
затем используем rubResourceT.
\begin{verbatim}
copyFile :: FilePath -< FilePath -< IO ()
copyFile src dest = runResourceT $ CB.sourceFile src $$ CB.sinkFile dest
\end{verbatim}
Модуль Data.Conduit.List предоставляет некоторые число функций для создания sink,
источников и кондуитов. Вот так выглядит свёртка: суммирование чисел.
\begin{verbatim}
sumSink :: Resource m =< Sink Int m Int
sumSink = CL.fold (+) 0
\end{verbatim}
Мы можем реализовать то же самое более низкоуровнево, используя функцию \verb=sinkState=.
Они принимает три параметра: начальное состояние, функцию приема дополнительных данных и
функцию закрытия.
\begin{verbatim}
sumSink2 :: Resource m =< Sink Int m Int
sumSink2 = sinkState
    0 -- начальное значение
    -- обновим состояния согласно полученным данным 
    -- и сообщим что необходимы дополнительные данные
    (\accum i -< return $ StateProcessing (accum + i))
    (\accum -< return accum) -- вернуть текущее значение при закрытии
\end{verbatim}
Другая полезная функция --- \verb=sourceList=. Скомбинировав её с нашей функций
\verb=sumSink=, мы получим встроенную реализацию функции sum.
\begin{verbatim}
sum' :: [Int] -< Int
sum' input = runST $ runResourceT $ CL.sourceList input $$ sumSink
\end{verbatim}
Поскольку это Haskell давайте создадим источник, который генерирует все числа Фибоначчи.
Для этого мы будем использовать sourceState. Состояние будет содеражать следующие два
число в последовательности. Также нам понадобится функция, которая вернет следующее число
и обновит состояние.
\begin{verbatim}fibs :: Resource m => Source m Int
fibs = sourceState
    (0, 1) -- initial state
    (\(x, y) -> return $ StateOpen (y, x + y) x)
\end{verbatim}
Посчитаем сумму первых 10 чисел Фибоначчи. Мы можем использовать изолированный кондуит,
чтобы быть уверенными, что sink суммирования приняла только 10 значений.
\begin{verbatim}sumTenFibs :: Int
sumTenFibs =
       runST -- runs fine in pure code
     $ runResourceT
     $ fibs
    $= CL.isolate 10 -- fuse the source and conduit into a source
    $$ sumSink
\end{verbatim}
Мы также можем скомбинировать кондуит и sink, поменяв местами некоторые операторы.
\begin{verbatim}sumTenFibs2 :: Int
sumTenFibs2 =
       runST
     $ runResourceT
     $ fibs
    $$ CL.isolate 10
    =$ sumSink
\end{verbatim}
Отлично, а теперь сделаем несколько кондуитов. Давайте преобразовывать числа в текст.
Кажется, функция map нам подойдет...
\begin{verbatim}
intToText :: Int -> Text -- дополнительная функция 
intToText = T.pack . show

textify :: Resource m => Conduit Int m Text
textify = CL.map intToText
\end{verbatim}
Аоспользуемся функцией conduitState также как это было сделано выше. Здесь нам не нужно
состояние, поэтому подставим фиктивно значение.
\begin{verbatim}textify2 :: Resource m =< Conduit Int m Text
textify2 = conduitState
    ()
    (\() input -< return $ StateProducing () [intToText input])
    (\() -< return [])
\end{verbatim}
Сделаем кондуит unlines, который будет добавлять перевод строки в конце каждого блока
входных данных. Воспользуемся функцией CL.map. feel free to write it with conduitState as
well for practice.
\begin{verbatim}unlines' :: Resource m => Conduit Text m Text
unlines' = CL.map $ \t -> t `T.append` "\n"
\end{verbatim}
А теперь напишем функцию, которая печатает первые N чисел фибоначчи. Используем
кодировку UTF8.
\begin{verbatim}writeFibs :: Int -< FilePath -< IO ()
writeFibs count dest =
      runResourceT
    $ fibs
   $= CL.isolate count
   $= textify
   $= unlines'
   $= CT.encode CT.utf8
   $$ CB.sinkFile dest
\end{verbatim}
Мы использовали оператор \verb#$=#, чтобы комбинировать кондуиты с источниками, получая
новые источники. Можно делать и обратное: комбинировать кондуиты и sink. Можно даже
скомбинировать два кондуита.
\begin{verbatim}writeFibs2 :: Int -< FilePath -< IO ()
writeFibs2 count dest =
      runResourceT
    $ fibs
   $= CL.isolate count
   $= textify
   $$ unlines'
   =$ CT.encode CT.utf8
   =$ CB.sinkFile dest
\end{verbatim}
Или мы можем скомбинировать все написанные кондуиты в один
\begin{verbatim}someIntLines :: ResourceThrow m -- encoding can throw an exception
             =< Int
             -< Conduit Int m ByteString
someIntLines count =
      CL.isolate count
  =$= textify
  =$= unlines'
  =$= CT.encode CT.utf8
\end{verbatim}
Теперь используем кондуит
\begin{verbatim}
writeFibs3 :: Int -< FilePath -< IO ()
writeFibs3 count dest =
      runResourceT
    $ fibs
   $= someIntLines count
   $$ CB.sinkFile dest

main :: IO ()
main = do
    putStrLn $ "First ten fibs: " ++ show sumTenFibs
    writeFibs 20 "fibs.txt"
    copyFile "fibs.txt" "fibs2.txt"
\end{verbatim}

