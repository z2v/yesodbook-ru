\chapter{Кондуиты}\label{chap:conduit}

Кондуиты используются для обработки потоков данных. Часто ленивые вычисления
позволяют обрабатывать большие объемы не загружая их в память целиком. Однако, 
использование такого подхода для ввода-вывода влечет требование ленивости ввода-вывода.
А его главный недостаток --- недетерминированность: у нас нет никаких гарантий когда
финализаторы наших ресурсов будут запущены. Для небольшого приложения это допустимо, но
для высоко нагруженного веб-сервера мы можем очень быстро исчерпать допустимые ресурсы,
например, дескрипторы для файлов.

Кондуиты позволяют оперировать большими потоками данных при детерминированном управлении
ресурсами. Они предоставляют унифицированный интерфес для потоков данных вне зависимости
от того откуда они поступают: из файлов, сокетов или памяти. В сочетании с ResourceT мы
можем безопасно работать с ресурсами, зная, что они будут гарантированно освобождены даже
в случае исключений.

В этом приложении рассматривается пакет 
\footnotehref{http://hackage.haskell.org/package/conduit}{conduit} версии \verb=0.2=.

\section{Кондуиты в двух словах}
Хотя понимание низкоуровневой механики кондуитов рекомендуется, вы можете далеко
продвинуться и без неё. Давайте начнем  с нескольких  высокоуровневых 	 примеров.  Не
беспокойтесь, если некоторые детали      вам   будут       сейчас	  непонятны -- 
  мы разберем всё  в этом   приложении. Начнем с терминологии и нескольких	  
примеров    кода.

\begin{itemize}
 \item \emph{Источник (source)} генерирует данные. Они могут быть в файле, прийти из
сокета или лежать списком в памяти. Мы будем обращаться к этим данным, забирая их из
источника.
 \item \emph{Синки (sinks)} потребляют данные. 
 \marginpar{Я хз как переводить на рускийэтот термин}
 Основные примеры будут о функции суммирования
(сложение чисел из потока), файловом канале (пишет все пришедшие байты в файл) или
сокете. В конце обработки данных возвращается какое-то значение.
 \item \emph{Кондуиты} преобразуют данные. В простейшем примере это будет функция
\lstinline=map=,
хотя бывает много других. Мы добавляем данные в кондуит также как и в sink. Но вместо
возвращения одного значения, кондуит может вернуть несколько результатов каждый раз,
когда в него добавляются данные.
  \item \emph{Комбинирование (fuse)} --- термин Давида Мазьереса. Кондуит можно 
скомбинировать с источником данных (с помощью оператора \lstinline=$==) и получить
новый источник. Например, мы можем взять источник, читающий байты из файла, и
кондуит, преобразующий байты в текст. Скомбинировав их, мы получим 
источник, читающий текст из файла. Аналогично, кондуит и sink можно скомбинировать в sink
(оператор \verb#=$#), а два кондуита --- в новый кондуит (оператор \verb#=$=#).
  \item \emph{Соединение}. Мы можем присоединять источник к sink используя оператор
\verb=$$=.
Это приведет к тому, что данные будут передаваться из источника в sink до тех пор, пока
источник или sink не сообщат, что они <<закончили>>.
\end{itemize}

Рассмотрим несколько примеров кода.
\begin{lstlisting}
{-# LANGUAGE OverloadedStrings #-}
import Data.Conduit -- основная библиотека
import qualified Data.Conduit.List as CL 
  -- несколько функций для работы как бы со списками
import qualified Data.Conduit.Binary as CB -- байты
import qualified Data.Conduit.Text as CT

import Data.ByteString (ByteString)
import Data.Text (Text)
import qualified Data.Text as T
import Control.Monad.ST (runST)
\end{lstlisting}
Для начала соединим источник с синком. Будем использовать встроенные 
функции по работе с файлами для эффективности, константной памяти и ресурсо-безопасного
копирования файлов.

Обратите внимание: вначале мы используем \verb=$$= для соединения источник с sink, а
затем используем \lstinline=runResourceT=.
\begin{lstlisting}
copyFile :: FilePath -> FilePath -> IO ()
copyFile src dest = runResourceT $ CB.sourceFile src $$ CB.sinkFile dest
\end{lstlisting}
Модуль \lstinline=Data.Conduit.List= предоставляет некоторые число функций для создания
синков, источников и кондуитов. Вот так выглядит свёртка: суммирование чисел.
\begin{lstlisting}
sumSink :: Resource m => Sink Int m Int
sumSink = CL.fold (+) 0
\end{lstlisting}
Мы можем реализовать то же самое более низкоуровнево, используя функцию \verb=sinkState=.
Они принимает три параметра: начальное состояние, функцию приема дополнительных данных и
функцию закрытия.
\begin{lstlisting}
sumSink2 :: Resource m => Sink Int m Int
sumSink2 = sinkState
    0 -- начальное значение
    -- обновим состояния согласно полученным данным 
    -- и сообщим что необходимы дополнительные данные
    (\accum i -> return $ StateProcessing (accum + i))
    (\accum -> return accum) -- вернуть текущее значение при закрытии
\end{lstlisting}
Другая полезная функция --- \verb=sourceList=. Скомбинировав её с нашей функций
\verb=sumSink=, мы получим встроенную реализацию функции \lstinline=sum=.
\begin{lstlisting}
sum' :: [Int] -> Int
sum' input = runST $ runResourceT $ CL.sourceList input $$ sumSink
\end{lstlisting}
Поскольку это Haskell давайте создадим источник, который генерирует все числа Фибоначчи.
Для этого мы будем использовать \lstinline=sourceState=. Состояние будет содеражать
следующие два
числа в последовательности. Также нам понадобится функция, которая вернет следующее число
и обновит состояние.
\begin{lstlisting}
fibs :: Resource m => Source m Int
fibs = sourceState
    (0, 1) -- initial state
    (\(x, y) -> return $ StateOpen (y, x + y) x)
\end{lstlisting}
Посчитаем сумму первых 10 чисел Фибоначчи. Мы можем использовать кондуит \lstinline=isolate=,
чтобы быть уверенными, что sink суммирования приняла только 10 значений.
\begin{lstlisting}
   sumTenFibs :: Int
   sumTenFibs =
       runST -- прекрасно работает при чистом коде
     $ runResourceT
     $ fibs
    $= CL.isolate 10 -- комбинирует источник и кондуит в источник
    $$ sumSink
\end{lstlisting}
Мы также можем скомбинировать кондуит и sink, поменяв местами некоторые операторы.
\begin{lstlisting}
sumTenFibs2 :: Int
sumTenFibs2 =
       runST
     $ runResourceT
     $ fibs
    $$ CL.isolate 10
    =$ sumSink
\end{lstlisting}
Отлично, а теперь сделаем несколько кондуитов. Давайте преобразовывать числа в текст.
Кажется, функция \lstinline=map= нам подойдет...
\begin{lstlisting}
intToText :: Int -> Text -- дополнительная функция 
intToText = T.pack . show

textify :: Resource m => Conduit Int m Text
textify = CL.map intToText
\end{lstlisting}
Воспользуемся функцией \lstinline=conduitState= также как это было сделано выше. Здесь
нам не нужно
состояние, поэтому подставим фиктивное значение.
\begin{lstlisting}
textify2 :: Resource m => Conduit Int m Text
textify2 = conduitState
    ()
    (\() input -> return $ StateProducing () [intToText input])
    (\() -> return [])
\end{lstlisting}
Сделаем кондуит \lstinline=unlines=, который будет добавлять перевод строки в конце каждого блока
входных данных. Воспользуемся функцией \lstinline=CL.map=. feel free to write it with
conduitState as
well for practice. \marginpar{Смело реализуйте это через conduitState для тренировки?}
\begin{lstlisting}
unlines' :: Resource m => Conduit Text m Text
unlines' = CL.map $ \t -> t `T.append` "\n"
\end{lstlisting}
А теперь напишем функцию, которая печатает первые N чисел Фибоначчи. Используем
кодировку UTF8.
\begin{lstlisting}
writeFibs :: Int -> FilePath -> IO ()
writeFibs count dest =
      runResourceT
    $ fibs
   $= CL.isolate count
   $= textify
   $= unlines'
   $= CT.encode CT.utf8
   $$ CB.sinkFile dest
\end{lstlisting}
Мы использовали оператор \lstinline'$=', чтобы комбинировать кондуиты с источниками,
получая
новые источники. Можно делать и обратное: комбинировать кондуиты и sink. Можно даже
скомбинировать два кондуита.
\begin{lstlisting}
writeFibs2 :: Int -> FilePath -> IO ()
writeFibs2 count dest =
      runResourceT
    $ fibs
   $= CL.isolate count
   $= textify
   $$ unlines'
   =$ CT.encode CT.utf8
   =$ CB.sinkFile dest
\end{lstlisting}
Или мы можем скомбинировать все написанные кондуиты в один
\begin{lstlisting}
someIntLines :: ResourceThrow m -- изменение кодировки может бросить исключение
             => Int
             -> Conduit Int m ByteString
someIntLines count =
      CL.isolate count
  =$= textify
  =$= unlines'
  =$= CT.encode CT.utf8
\end{lstlisting}
Теперь воспользуемся этим кондуитом:
\begin{lstlisting}
writeFibs3 :: Int -> FilePath -> IO ()
writeFibs3 count dest =
      runResourceT
    $ fibs
   $= someIntLines count
   $$ CB.sinkFile dest

main :: IO ()
main = do
    putStrLn $ "First ten fibs: " ++ show sumTenFibs
    writeFibs 20 "fibs.txt"
    copyFile "fibs.txt" "fibs2.txt"
\end{lstlisting}

\section{Структура главы}

Остаток этой главы освещает следующие темы:
\begin{itemize}
 \item ResourceT --- техника, которая позволяет управлять освобождением ресурсов;
 \item источники --- наши генераторы данных;
 \item синки --- потребители данных;
 \item кондуиты --- преобразователи данных;
 \item буферизация --- техника борьбы с инверсией управления.
\end{itemize}

\section{Трансформер монады Resource}

Трансформер монады \verb*|Resource(ResourceT)| играет существенную роль в управлении
ресурсами в
проектах, использующих кондуиты. Он поставляется вместе с библиотекй \verb=conduit=. 
С ним мы и будем сейчас  разбираться \verb*|ResourceT|. Хотя некоторые решения в его
дизайне
основаны на кондуитах, \verb*|ResourceT| можно использовать самого по себе.

\subsection{Назначение}
Что не так с этим кодом?
\begin{lstlisting}
import System.IO

main = do
    output <- openFile "output.txt" WriteMode
    input  <- openFile "input.txt"  ReadMode
    hGetContents input <<= hPutStr output
    hClose input
    hClose output
\end{lstlisting}
Если файл \verb*|input.txt| отсутствует, бросится исключение при попытке его открыть. В
результате \lstinline'hClose output' никогда не будет вызвано и мы получим утечку важного
ресурса
 --- дескриптора файлов. В небольшой программе это не критично, но очевидно, что мы не
сможем себе этого позволить в высоко нагруженном процессе сервера с большим аптаймом.

К счастью проблема решается довольно просто:
\begin{lstlisting}
import System.IO

main =
    withFile "output.txt" WriteMode $ \output ->
    withFile "input.txt" ReadMode $ \input ->
    hGetContents input <<= hPutStr output
\end{lstlisting}

Использование \lstinline'withFile' гарантирует, что дескриптор будет закрыт, даже в
случае
исключений. Оно также поддерживает асинхронные исключения. Вообще говоря, это прекрасный
подход для случаев, когда его использование допустимо. Часто использование \lstinline'withFile' влечет переписывание всей программы, а оно может быть очень
скучным и сильно неэффективным.

Возьмем, например, енумераторы. Если вы заглянете в документацию, то найдете функцию
\lstinline'enumFile' для чтения содержимого файла, но не найдете функции
\lstinline'iterFile' для записи
содержимого в файл. Так сделано потому, что поток управления итератов не позволяет
правильно управлять дескрипторами. Поэтому, чтобы записать в файл вам надо создавать
дескриптор до запуска итерата, т.е.: 

\begin{lstlisting}
import System.IO
import Data.Enumerator
import Data.Enumerator.Binary

main =
    withFile "output.txt" WriteMode $ \output ->
    run_ $ enumFile "input.txt" $$ iterHandle output
\end{lstlisting}

Этот код работает хорошо, но представьте, что вместо простой передачи данных в файл, нам
надо провести длительное вычисление перед использованием дескриптора. Мы захватим
дескриптор задолго до того, как он нам понадобится, занимая важный ресурс нашего
приложения. Кроме этого, часто мы не можем открыть файл, так как мы поймем какой файл
надо открывать только тогда, когда прочитаем все данные.

Одна из заявленных целей кондуитов --- решить эту пролему с помощью \lstinline'ResourceT'.
Программа выше может быть переписана вот так:
\begin{lstlisting}
{-# LANGUAGE OverloadedStrings #-}
import Data.Conduit
import Data.Conduit.Binary

main = runResourceT $ sourceFile "input.txt" $$ sinkFile "output.txt"
\end{lstlisting}

\subsection{Как это работает}
Всего основных функций по работе с \lstinline'ResourceT' --- три, остальные были
сделаны поверх этих трех исключительно для удобства. Вот первая из этой троицы:
\begin{lstlisting}
register :: IO () -> ResourceT IO ReleaseKey
\end{lstlisting}

\begin{remark}
Полиморфность этой функции и остальных ниже не используется в полную силу. На самом деле
они могут работать с другими монадами кроме IO. По факту, почти любой траснсформер над
IO, также как на любым другим ST стэком, будет работать. Мы разъясним детали познее.
\end{remark}

Эта функция регистрирует кусок кода, который будет выполнен. Она также
возвращает \lstinline'ReleaseKey', которое используется в следующей функции:

\begin{lstlisting}
release :: ReleaseKey -> ResourceT IO ()
\end{lstlisting}
Вызов функции \verb=release= от ReleaseKey немедленно выполняет действие, которое было
зарегистрировано ранее. Мы можем вызывать \verb=release= от одной и той же
\lstinline'ReleaseKey'
столько раз, сколько пожелаем, только при первом вызове регистрация действия снимется. Это
значит, что вы можете безопасно зарегистрировать действие освобождения памяти, не
заботясь о том, что оно будет выполнено дважды.

Со временем, мы можем захотеть освободить ресурс \lstinline'ResourceT'. Чтобы сделать это,
воспользуемся:
\begin{lstlisting}
runResourceT :: ResourceT IO a -> IO a
\end{lstlisting}
В этой внешене невинной функции происходит вся магия. Она выполняется во всех
зарегистрированных функциях освобождения ресурсов и выполняет это освобождение. 
Она безопасна с точки зрения исключений, в
том смысле, что освобождения ресурсов будут выполнены в случае и синхронных, и
асинхронных исключений. И, как было упомянуто выше, вызов функции \lstinline'release'
отменит
регистрацию действия. Таким образом нам не стоит беспокоиться о повторном освобождении
ресурсов.

Наконец, для удобства, мы приведем ещё одну функцию для выделения ресурса и регистрации
действия по его освобождению:
\begin{lstlisting}
with :: IO a -- выделить
     -> (a -> IO ()) -- освободить
     -> ResourceT IO (ReleaseKey, a)
\end{lstlisting}

Теперь перепишем с использованием \lstinline'ResourceT' первый некачественный пример:
\begin{lstlisting}
import System.IO
import Control.Monad.Trans.Resource
import Control.Monad.Trans.Class (lift)

main = runResourceT $ do
    (releaseO, output) <- with (openFile "output.txt" WriteMode) hClose
    (releaseI, input)  <- with (openFile "input.txt"  ReadMode)  hClose
    lift $ hGetContents input <<= hPutStr output
    release releaseI
    release releaseO
\end{lstlisting}

Сейчас мы можем не беспокоиться об исключениях, затрудняющих освобождение ресурсов. Мы
можем опустить вызовы \verb=release= в таких маленьких программах как эта, это ни на что
не повлияет. Но в больших приложениях, где мы продолжим обработку дальше, этот код
гарантирует, что дескрипторы ресурсов освободятся как только это станет возможным, снижая
потребление ресурсов до минимума.

\subsection{Несколько слов о типах}

Как было упомянуто, \lstinline'ResourceT' это нечто большее, чем код, исполняемый над IO.
Но давайте обсудим некоторые вещи, которые нам потребуются от этой монады.
\begin{itemize}
\item Мутабельные ссылки, для хранения зарегистрированных действий по освобождению
ресурсов. Нам может показаться, что мы можем использовать \lstinline'StateT' трансформер,
но тогда наше состояние не сможет корректно обходиться с исключениями.
\item Нам нужно зарегистрировать действия в базовой монаде. Например, если мы имеем 
стэк \lstinline'ResourceT (WriterT [Int] IO)', нам нужно только зарегистрировать
действия в IO. Это позволит легко втягивать (lift) наш стэк (т.е. добавлять новый
трансформер в середину стэка) и избегать проблем about the
threading of other monadic side-effects.
 \marginpar{я не уверен что такое тут threading}
\item Какой-то способ гарантировать, что действие будет выполнено даже в случае
исключений. Отсюда следует небходимать функции а-ля корзина.
\end{itemize}

Для начала определим класс типов для монад, которые имеют мутабельные ссылки.
\begin{lstlisting}
 class Monad m => HasRef m where
    type Ref m :: * -> *
    newRef' :: a -> m (Ref m a)
    readRef' :: Ref m a -> m a
    writeRef' :: Ref m a -> a -> m ()
    modifyRef' :: Ref m a -> (a -> (a, b)) -> m b
    mask :: ((forall a. m a -> m a) -> m b) -> m b
    mask_ :: m a -> m a
    try :: m a -> m (Either SomeException a)
\end{lstlisting}

Здесь у нас ассоциированный тип для указания типа ссылок. (Фанатам функциональных 
зависисмостей я покажу в следующем разделе, что ассоциированный тип необходим.) 
Затем мы определяем несколько основных операций над ссылками.
В конце несколько функций для работы с
исключениями, которые необходимы для безопасной реализации функций, описанных в
последнем разделе. Реализация инстанса для IO довольно прямолинейна:
  
\begin{lstlisting}
instance HasRef IO where
    type Ref IO = I.IORef
    newRef' = I.newIORef
    modifyRef' = I.atomicModifyIORef
    readRef' = I.readIORef
    writeRef' = I.writeIORef
    mask = E.mask
    mask_ = E.mask_
    try = E.try 
\end{lstlisting}
Однако, при реализации инстанса монады ST мы сталкиваемся с проблемой: мы никак не можем
обрабатывать исключения в монаде ST. В результате, функции \lstinline'mask',
\lstinline'mask_' и \lstinline'try' имеют
дефолтную реализацию без проверки исключений. Сейчас мы сформулируем первое
предупреждение:

\textit{Операции в монаде ST не безопасны относительно исключений. Мы не должен выделять
важные ресурсы в монаде ST когда используем \lstinline'ResourceT'. You might be wondering
why bother
with
ResourceT at all then for ST. The answer is that there is a
lot you can do with conduits without allocating scarce resources, and ST is a
great way to do this in a pure way. But more on this later. 
\marginpar{Я ничего не понял}}


Пункт номер 2: нам надо как-то работать с монадой Base. Опять же, мы можем
использовать ассоциированные типы (почему опять --- будет сказано в следующем разделе). 
Наше решение будет выглядеть примерно так:
\begin{lstlisting}
class (HasRef (Base m), Monad m) => Resource m where
    type Base m :: * -> *

    resourceLiftBase :: Base m a -> m a 
\end{lstlisting}
Мы забыли о пункте 3 --- функции а-ля корзина. Нам понадобится ещё один метод в классе
типов:
\begin{lstlisting}
resourceBracket_ :: Base m a -> Base m b -> m c -> m c 
\end{lstlisting}
Причной, по которой первые два аргумента функции \lstinline'resourceBracket_' <<живут>> в
монаде Base, является то, что в \lstinline'ResourceT' все выделения и освобождения
ресурсов, происходят в базовой монаде.

Итак, над нашим инстансом HasRef для IO нам также нужен инстанс
\lstinline'Resource'. Реализация довольно очевидна:
\begin{lstlisting}
 instance Resource IO where
    type Base IO = IO
    resourceLiftBase = id
    resourceBracket_ = E.bracket_
\end{lstlisting}

Итак, у нас есть несколько сходных инстансов \lstinline'ST', в которых функция
\lstinline'resourceBracket_' небезопасна относительно исключений. Решающий шаг заключается
в реализации трансформеров. Нам не нужно
предоставлять инстанс \lstinline'HasRef', а инстанс \lstinline'Resource' --- нужно.
Хитрость нужна в допустимой реализации функции \lstinline'resourceBracket_'. Здесь мы
воспользовалсиь некоторыми функциями для управления монадами 
(\footnotehref{http://hackage.haskell.org/package/monad-control}{monad-control}):

\begin{lstlisting}
instance (MonadTransControl t, Resource m, Monad (t m))
        => Resource (t m) where
    type Base (t m) = Base m

    resourceLiftBase = lift . resourceLiftBase
    resourceBracket_ a b c =
        control' \$ \run -> resourceBracket_ a b (run c)
      where
        control' f = liftWith f >>= restoreT . return 
\end{lstlisting}
Для всякого трансформера, его база является базой внутренней монады. Аналогично, мы можем
добраться до базовой монады, втянув внутреннюю монаду и добравшись до её базы. Хитрость
понадобилась при реализации \verb=resourceBracket_=. Я не буду вдаваться в подробные
объяснения, чтобы, случайно, не выставить себя идиотом. 
\marginpar{Нелитературно. В оригинале:
I will not go into a detailed explanation, as I would simply make a fool of myself.}

\subsection{Определение ResourceT}

Теперь у нас достаточно информации, чтобы осмыслить определение типа
\lstinline'ResourceT':
\begin{lstlisting}
newtype ReleaseKey = ReleaseKey Int

type RefCount = Int
type NextKey = Int

data ReleaseMap base =
  ReleaseMap !NextKey !RefCount !(IntMap (base ()))

newtype ResourceT m a =
  ResourceT (Ref (Base m) (ReleaseMap (Base m)) -> m a)
\end{lstlisting}
Мы видим, что \lstinline'ReleaseKey' это просто \lstinline'Int'. Если вы загляните на
несколько строк вниз, то
это определение обретет смысл, так как мы используем \lstinline'IntMap' для того, чтобы
хранить
зарегистрированые действия. Мы также определяем два синонима: \lstinline'RefCount' и
\lstinline'NextKey'. \lstinline'NextKey'
хранит последнее присвоенное значение ключа и инкрементируется каждый раз, когда
вызывается функция \verb=register=. Мы коснемся этого немного позже.

\lstinline'ReleaseMap' хранит три вида информации: следующий ключ, счетчик ссылок, и затем
\lstinline'map' всех
зарегистрированных действий (actions). Заметьте, что \lstinline'ReleaseMap' принимает
типовую переменную \lstinline'base', которая определяет, действия какой монады по
освобождению ресурсов  будут использоваться.
\marginpar{хрень какая-то. В оригинале which states which monad release actions must live
in.}

В конце концов, \lstinline'ResourceT' является по существу \lstinline'ReaderT', который
хранит мутабельную
ссылку на \lstinline'ReleaseMap'. The reference type is determined by the base
of the monad in question, as is the cleanup monad. This is why we need to use associated
types. \marginpar{Я ничего не понял}

Целью оставшейся части кода в модуле \lstinline'Control.Monad.Trans.Resource'
является создание инстансов типа \lstinline'ResourceT'.

\subsection{Другие классы типов}

Модуль предоставляет ещё три класса типов:
   
\subsubsection{ResourceUnsafeIO}
Любая монада может втянуть (lift) IO действия в себя, но это может быть небезопасно.
Первый пример этого --- ST. Care should be taken to
only lift actions which do not acquire scarce resources and which don't "fire the
missiles." \marginpar{Я ничего не понял} Другими словами, все обычные предпреждения насчет \lstinline'unsafeIOToST'
справедливы.
  
\subsubsection{ResourceThrow}

Для действий, которые могут бросать исключение. Автоматически приминимо ко всем
монадам на базе IO. Для ST-монад вы можете использовать трансформер
\lstinline'ExceptionT', чтобы
предоставить возможность пробрасывания исключений. Это потребуется для некоторых функций
кондуитов, например, для декодирования текста.
   
\subsubsection{ResourceIO}

Включает в себя несколько классов типов, в том числе два
упомянутых выше. Он создан только для удобства, мы можем получить тот же результат без
него, потребуется только внимательнее оперировать типами (you'd just have to do a lot
more typing).
   
\subsection{Forking}

Может показаться, что ответвление от процесса хронически небезопасно при использовании 
\lstinline'ResourceT', так как родительский процесс может вызвать
\lstinline'runResourceT' в то время
как дочерний использует ресурсы. Это, конечно же, так, если вы используете обычную
функцию \lstinline'forkIO'.

\begin{remark}
Вообще, вы не можете использовать стандартный \lstinline'forkIO', так как он
использует монаду
IO, но вы можете использовать функцию \lstinline'fork' из залифченой базовой монады.
По этой причине пакет regions не предоставляет экземпляр \lstinline'MonadBaseControl' для
этого
трансформатора (который очень похож на \lstinline'ResourceT'). Однако, назначение
\lstinline'ResourceT' заключается не в запрещении 
программистам стрелять себе в ногу, а только в облегчении написания
правильного кода. Поэтому, мы всё же предостовляем этот экземпляр, даже если он может быть
использован неправильно. 
\end{remark}

Чтобы решить эту проблему \lstinline'ResourceT' включает в себя
счетчик ссылок. Когда вы образовываете новый поток с помощью \lstinline'resourceForkIO',
значение \lstinline'RefCount' в \lstinline'ReleaseMap' инкрементируется. Всякий раз, когда
\lstinline'runResourceT'
вызывается, это значение декрементируется. Только когда оно достигнeт нуля, происходят
действия по освобождению ресурсов.
 
\subsection{Дополнительные функции для удобства}

В дополнение мы расскажем про несколько функций, созданных для удобства.
   
Функции \verb=newRef=, \verb=writeRef=, и \verb=readRef= оборачивают
функции с \lstinline'HasRef' и позволяют им работать с любым \lstinline'ResourceT'.
Функция \verb=withIO= по сути является функцией \verb=with= с ограниченным типом, но она 
позволяет работать с некоторой вложенностью типов, в то время как при \verb=with=
пришлось бы продираться в глубину \marginpar{Нелитературно. в оригинале: but working around 
some of the nastiness with types you would otherwise run into}. В общем, вам стоит
использовать \lstinline'withIO' для написания IO кода.
Функция \verb=transResourceT= позволит вам модифицировать в какой монаде исполняется ваш
\verb=ResourceT=, в предположении, что база одна и та же.
\begin{lstlisting}
transResourceT :: (Base m ~ Base n)
               => (m a -> n a)
               -> ResourceT m a
               -> ResourceT n a
transResourceT f (ResourceT mx) = ResourceT (\r -> f (mx r))
\end{lstlisting}  

\section{Источники}

Проще всего понять, что это такое посмотрев на их типы:
\begin{lstlisting}
data SourceResult m a = Open (Source m a) a | Closed
data Source m a = Source
    { sourcePull :: ResourceT m (SourceResult m a)
    , sourceClose :: ResourceT m ()
    }
\end{lstlisting}
Источник имеет две операции: вы можете запросить ещё данных и вы можете закрыть его (как,
например, закрыть дескриптор файла). При запросе новых данных вы или получаете немного
данных и новое  значение типа \lstinline=Source= (источник остается открытым), или
\lstinline=Nothing= (источник закрывается). Давайте посмотрим на простейшие примеры.
\begin{lstlisting}
-- START
import Prelude hiding (repeat)
import Data.Conduit

-- | Никогда не выдает данные
eof :: Monad m => Source m a
eof = Source
    { sourcePull = return Closed
    , sourceClose = return ()
    }

-- | Всегда выдает одно и то же
repeat :: Monad m => a -> Source m a
repeat a = Source
    { sourcePull = return $ Open (repeat a) a
    , sourceClose = return ()
    }
-- STOP
main :: IO ()
main = return ()
\end{lstlisting}
Эти источники довольно тривиальны, так как они всегда возвращают одно и то же. К тому
же их функции закрытия ничего не делают. Вам может показаться, что это баг: не должны ли 
мы в функции \lstinline=sourcePull= возвращать  \verb=return Closed= после того, как
источник был
закрыт? Это не является необходимым, так как согласно одному из инвариантов для
источников они никогда не могут быть переиспользованы. Другими словами:
    
\textit{Если источник вернул \lstinline=Open=, то он предоставил вам новый источник, с
которым и
стоит работать, заменив оригинальный. Если источник вернул \lstinline=Closed=, тогда, вы
больше не можете выполнять операции над ним.}
    
Не стоит очень беспокоиться по поводу сохранения этого инварианта. На практике, вам почти
не придется вызывать \lstinline=sourcePull= или \lstinline=sourceClose= самостоятельно.
Также, навряд ли вам придётся их самостоятельно описывать (для этого существуют
\lstinline=sourceState= и \lstinline=sourceIO=).
\marginpar{уточнить это предожение (In fact, you hardly  even write them yourself either (that's what sourceState and sourceIO are for).}
Идея заключается в том, что мы можем сделать некоторые предположения, когда реализовываем
источники.

\subsection{Состояние}
В двух примерах источников выше есть кое-что общее: они всегда возвращают то же самое
значение. Другими словами, у них не состояния. Для более-менее серьёзных источников нам
потребуется реализовывать состояние.

\begin{remark}
Состояние может запросто быть определено вне нашей программы. Например, если мы
реализуем источник, который читает данные из дескриптора, нам не нужно вручную
указывать никакого состояния, потому что дескриптор имеет состояние сам по себе.
\end{remark}

Будем хранить состояние в источнике путём обновления возвращаемого значения типа
\lstinline=Source= в конструкторе \lstinline=Open=. Лучше всего это рассмотреть на
примере.

\begin{lstlisting}
-- START
import Data.Conduit
import Control.Monad.Trans.Resource

-- Выдает данные из списка по одному
sourceList :: Resource m => [a] -> Source m a
sourceList list = Source
    { sourcePull =
        case list of
            [] -> return Closed -- больше нет данных
            -- Здесь будем хранить состояние, возвращая новый 
            -- источник с остатком списка
            x:xs -> return $ Open (sourceList xs) x
        , sourceClose = return ()
        }
-- STOP
main :: IO ()
main = return ()
\end{lstlisting}

Всякий раз, когда мы забираем данные из источника, он проверяет список. Если он пуст,
возвращаем \lstinline=Closed=, что разумно. Если не пуст, возвращаем \lstinline=Open= со
следующим значением
списка и новым значением источника, вызванного от хвоста списка.

\subsection{Функции sourceState и sourceIO}
В добавление к возможности манипулировать источниками, мы также имеем несколько функций,
позволяющих создавать источники более высокоуровнево. Функция \lstinline=sourceState=
позволяет писать
код как будто вы используете монаду \lstinline=State=. Вы предоставляете начальное
состояние,
функцию получения данных от текущего состояния, а она возвращает новое состояние и
новое значение. Перепишем \lstinline=sourceList= с помощью неё:

\begin{lstlisting}
-- START
import Data.Conduit
import Control.Monad.Trans.Resource

-- Выдает данные из списка по одному
sourceList :: Resource m => [a] -> Source m a
sourceList state0 = sourceState
    state0
    pull
  where
    pull [] = return StateClosed
    pull (x:xs) = return $ StateOpen xs x
-- STOP
main :: IO ()
main = return ()
\end{lstlisting}

Замечание по использованию конструкторов \lstinline=StateClosed= и \lstinline=StateOpen=.
Они очень похожи на
\lstinline=Closed= и \lstinline=Open=, за исключением того, что при указании следующего
источника вы указываете и следующее состояние (остаток списка).

Другое распространенное применение --- выделение ресурсов ввода-вывода (например,
открытие файла), регистрация функции освобождения ресурса (закрытие файла) и
предоставление функции получения данных из ресура.
В пакете conduit присутствует встроенная функция \verb=sourceFile=, которая выдает поток
значений типа \lstinline=ByteString=. Давайте напишем совершенно неэффективную
альтернативу, которая будет возвращать поток символов.

\begin{lstlisting}
-- START
import Data.Conduit
import Control.Monad.Trans.Resource
import System.IO
import Control.Monad.IO.Class (liftIO)

sourceFile :: ResourceIO m => FilePath -> Source m Char
sourceFile fp = sourceIO
    (openFile fp ReadMode)
    hClose
    (\h -> liftIO $ do
        eof <- hIsEOF h
        if eof
            then return IOClosed
            else fmap IOOpen $ hGetChar h)
-- STOP
main :: IO ()
main = return ()
\end{lstlisting}

Как и \verb=sourceState=, она использует конструкторы \verb*|Open| и \verb*|Closed|.
Функция \lstinline=sourceIO= выполняет несколько действий для нас:
\begin{itemize}
 \item Регистрирует функцию освобождения ресурса с трансформером \lstinline=ResourceT=,
гарантируя, что она будет вызвана даже в случае исключений.
 \item Инициализирует поле \lstinline=sourceClose= чтобы освободить ресурс немедленно.
 \item Как только вернется \lstinline=IOClosed=, будет вызвано освобождение ресурса.
\end{itemize}
  
\section{Sinks}

Они поглащают потоки данных и генерируют результат. Они должны всегда выдавать результат
и только атомарный результат. Это зафиксированно в их типе.

Экземпляр \lstinline=Monad= для синков упрощает композицию нескольких синков, в больший
синк. Вы также
можете использовать встроенные функции для большинства своих нужд. Как и с источниками,
вам редко понадобится погружаться в тонкости реализации. 

Начнем с примера:
получение строк из потока символов (для простоты, будем предполагать наличие переводов
строк в стиле Unix).

\begin{lstlisting}
import Data.Conduit
import qualified Data.Conduit.List as CL

-- получить одну строку из потока
sinkLine :: Resource m => Sink Char m String
sinkLine = sinkState
    id -- Начальное состояние. В начале строки ничего нет
    push
    close
  where
    -- В конце строки возвращаем содержимое до теущего места
    push front '\n' =
        return $ StateDone Nothing $ front []

    -- Если это другой символ - добавим его в начало и продолжим
    push front char =
        return $ StateProcessing $ front . (char:)

    -- Если встретили конец файла до перевода строки, то выдадим то, что имеем
    close front = return $ front []

-- Выдадим все строчки в файле, до пустой строки или конца файла
sinkLines :: Resource m => Sink Char m [String]
sinkLines = do
    line <- sinkLine
    if null line
        then return []
        else do
            lines <- sinkLines
            return $ line : lines

content :: String
content = unlines
    [ "This is the first line."
    , "Here's the second."
    , ""
    , "After the blank."
    ]

main :: IO ()
main = do
    lines <- runResourceT $ CL.sourceList content $$ sinkLines
    mapM_ putStrLn lines
\end{lstlisting}
Запуская этот пример мы получим следующий результат:
\begin{verbatim}
This is the first line.
Here's the second.
\end{verbatim}

Функция \lstinline=sinkLine= демонстрирует использование \lstinline=sinkState=, которая
очень похожа на только что
виденную функцию \lstinline=sourceState=. Она принимает три параметра: начальное
состояние,
функцию добавления \verb=push= 
(принимает текущее состояние и входные данные и возвращает новое состояние и результат)
и функцию закрытия (принимает текущее состояние и возвращает вывод). Как
противоположность к \lstinline=sourceState=, которая не нуждается в функции закрытия, sink
должна всегда возвращать результат.

В нашей функции \lstinline=push= две клаузы. Когда она получет символ конца строки,
процесс заканчивается в состоянии \lstinline=StateDone.= \lstinline=Nothing= означает,
что
входных данных не
осталось (мы обсудим это позднее). Она также выдает все полученные символы. Вторая
клауза просто добавляет символ к текущему состоянию и сообщает, что мы продолжаем работу
в состоянии \lstinline=StateProcessing=. Функция \lstinline=close= возвращает все символы.

Функция \lstinline=sinkLines= демонстрирует как мы можем использовать монадический
интерфейс, чтобы создавать новые синки. Если вы замените \lstinline=sinkLine= на
\lstinline=getLine=, это будет выглядеть
как обычный код, который забирает строки и стандартного входного потока. Этот
стандартный интефейс должен помочь вам легко освоиться и быстро начать писать код.

\subsection{Типы}

Типы для синков несколько более хитроумны, чем для источников. Давайте взглянем на них:
\begin{lstlisting}
type SinkPush input m output = input -> ResourceT m (SinkResult input m output)
type SinkClose m output = ResourceT m output

data SinkResult input m output =
    Processing (SinkPush input m output) (SinkClose m output)
  | Done (Maybe input) output

data Sink input m output =
    SinkNoData output
  | SinkData
        { sinkPush :: SinkPush input m output
        , sinkClose :: SinkClose m output
        }
  | SinkLift (ResourceT m (Sink input m output))
\end{lstlisting}  
Всякий раз, когда в синк добавляются данные, он может сказать, что ему нужно больше
данных, или, что всё готово. Если обработка ещё идет, то он должен предоставить
обновленные функции push и close. Если всё готово, то он возвращает результат и
необработанные данные. Довольно таки тривиально.
 
Первая настоящая неочевиность ("gotcha") \marginpar{Правильно же?} заключается в наличии трех конструкторов у
типа \lstinline=Sink=. Зачем нам конструктор \lstinline=SinkNoData=: разве синки
созданы не для поглощения данных? Ответ заключается в том, что нам нужно эффективно
реализовать наш экземпляр \lstinline=Monad=. Когда мы вызываем \lstinline=return=, мы
выозвращаем значение, которое не требует данных для вычисления. Мы могли бы сэмулировать
это с помощью конструктора \lstinline=SinkData= как-нибудь так:
\begin{lstlisting}
myReturn a = SinkData (\input -> return (Done (Just input) a)) (return a)
\end{lstlisting}
Но это бы вызывало чтение лишней части информации из входных данных, а она нам сейчас не
нужна и,
вероятно, вообще не понадобится. (Взгляните ещё раз на пример с \lstinline=sinkLines=)
Поэтому мы имеем ещё один конструктор, обозначающий, что никаких входных данных не нужно.
Подобным образом, \lstinline=SinkLift= предоставляется для более эффективной реализации
экземпляра \lstinline=MonadTrans=.

\subsection{Синки: без дополнительных функций}
Попробуем реализовать несколько синков <<в лоб>>.
\begin{lstlisting}
-- START
import Data.Conduit
import System.IO
import Control.Monad.Trans.Resource
import Control.Monad.IO.Class (liftIO)

-- Прочитать данные целиком и выкинуть их
sinkNull :: Resource m => Sink a m ()
sinkNull =
    SinkData push close
  where
    push _ignored = return $ Processing push close
    close = return ()

-- Запишем поток символов в файл. Нам понадобится что-то вроде инициализации.
-- Инициализаируем функцию push, а затем вернём другую функцию push для 
-- вложенного вызова. Используя withIO мы уверены в том, что дескриптор будет 
-- закрыт даже в случае исключений
sinkFile :: ResourceIO m => FilePath -> Sink Char m ()
sinkFile fp =
    SinkData pushInit closeInit
  where
    pushInit char = do
        (releaseKey, handle) <- withIO (openFile fp WriteMode) hClose
        push releaseKey handle char
    closeInit = do
        -- Если файл не открывали, то нечего и закрывать
        return ()

    push releaseKey handle char = do
        liftIO $ hPutChar handle char
        return $ Processing (push releaseKey handle) (close releaseKey handle)

    close releaseKey _ = do
        -- Закрыть дескриптор как можно скорее
        return ()

-- И мы посчитаем сколько значений было в потоке.
count :: Resource m => Sink a m Int
count =
    SinkData (push 0) (close 0)
  where
    push count _ignored =
        return $ Processing (push count') (close count')
      where
        count' = count + 1

    close count = return count
-- STOP
main :: IO ()
main = return ()
\end{lstlisting}
Здесь нет ничего сложного. Только обратим внимание на типичный шаблон использования:
описываем свои функции \lstinline'push' и \lstinline'close' в клаузе \lstinline'where', а
затем используем их дважды --- 
один раз для инициализации \lstinline'SinkData', а другой в конструкторе
\lstinline'Processing'. 
Это может быть несколько утомительно. Вот почему мы воспользуемся дополнительными функциями.

\subsection{Sinks: реализация с дополнительными функциями}
Давайте перепишем \lstinline'sinkFile', используя преимущества дополнительных функций 
\lstinline'sinkIO' и \lstinline'sinkState'.
\begin{lstlisting}
-- START
import Data.Conduit
import System.IO
import Control.Monad.IO.Class (liftIO)

-- Нам не нужно касаться release key напрямую, sinkIO автоматически
-- освобождает ресурс, как только мы возвращаем IODone из функции push,
-- или когда вызывается sinkClose.
sinkFile :: ResourceIO m => FilePath -> Sink Char m ()
sinkFile fp = sinkIO
    (openFile fp WriteMode)
    hClose
    -- push: notice that we are given the handle and the input
    (\handle char -> do
        liftIO $ hPutChar handle char
        return IOProcessing)
    -- close: у нас также есть handle, но мы его не используем
    (\_handle -> return ())

-- А теперь посчитаем сколько значений было в потоке
count :: Resource m => Sink a m Int
count = sinkState
    0
    -- The push function gets both the current state and the next input...
    (\state _ignored ->
        -- и возвращает новое состояние
        return $ StateProcessing $ state + 1)
    -- Функция close выдает финальное состояние и возвращает рузультат
    (\state -> return state)
-- STOP
main :: IO ()
main = return ()
\end{lstlisting}
Здесь нет ничего эпического, только более короткий код. Использование этих двух
дополнительных  функций рекомендуется всем, так как оно гарантирует правильное
управление рeсурсами и обновление состояния.

\subsection{Функции работы со списками}
Можно легко писать собственные синки, если вы пользуетесь встроенными примитивами из
модуля 
\footnotehref{http://hackage.haskell.org/packages/archive/conduit/latest/doc/html/Data.Conduit.List.html}{Data.Conduit.List}. Там есть аналоги для типичных функций работы со
списками, например, свертки. (Там так же есть некоторые кондуиты,
например, 
\footnotehref{http://hackage.haskell.org/packages/archive/conduit/latest/doc/html/Data-Conduit-List.html\#v:map}{conduit:Data.Conduit.List:map}.)

Если вы желаете поупражняться в кондуитах, то реализовать функции из модуля 
\lstinline'List' (с хэлперами и без) будет для начала неплохо.

Давайте посмотрим на простые функции, которые можно подружить со встроенными
синками.
\begin{lstlisting}
-- START
import Data.Conduit
import qualified Data.Conduit.List as CL
import Control.Monad.IO.Class (liftIO)

-- суммирование
sum' :: Resource m => Sink Int m Int
sum' = CL.fold (+) 0

-- напечатать всё в stdout
printer :: (Show a, ResourceIO m) => Sink a m ()
printer = CL.mapM_ (liftIO . print)

-- Просуммировать все числа в потоке кроме первых пяти
sumSkipFive :: Resource m => Sink Int m Int
sumSkipFive = do
    CL.drop 5
    CL.fold (+) 0

-- Суммировать числа и печатать накапливаемую сумму
printSum :: ResourceIO m => Sink Int m Int
printSum = do
    total <- CL.foldM go 0
    liftIO $ putStrLn $ "Sum: " ++ show total
    return total
  where
    go accum int = do
        liftIO $ putStrLn $ "New input: " ++ show int
        return $ accum + int
-- STOP
main :: IO ()
main = return ()
\end{lstlisting}

\subsection{Соединение}
Наконец, мы хотим как-то поиспользовать наши синки. Пока мы умеет только вручную вызвать
\verb*|sinkPush| and \verb*|sinkClose|, но это утомительно. Пример:
\begin{lstlisting}
import Data.Conduit
import Control.Monad.IO.Class (liftIO)

printSum :: Sink Int m Int
printSum = undefined
-- START
main :: IO ()
main = runResourceT $ do
    res <-
        case printSum of
            SinkData push close -> loop [1..10] push close
            SinkNoData res -> return res
    liftIO $ putStrLn $ "Got a result: " ++ show res
  where
    loop [] _push close = close
    loop (x:xs) push close = do
        mres <- push x
        case mres of
            Done _leftover res -> return res
            Processing push' close' -> loop xs push' close'
\end{lstlisting}
Вместо этого, рекомендуется соединять ваш синк с источником. Это проще, 
ошибок будет меньше, да и у вас будет больше простора в том, откуда приходят ваши данные.
Перепишем пример выше:
\begin{lstlisting}
import Data.Conduit
import qualified Data.Conduit.List as CL
import Control.Monad.IO.Class (liftIO)

printSum :: Sink Int m Int
printSum = undefined
-- START
main :: IO ()
main = runResourceT $ do
    res <- CL.sourceList [1..10] $$ printSum
    liftIO $ putStrLn $ "Got a result: " ++ show res
\end{lstlisting}

Соединение требует проверки конструктора синка (\lstinline'SinkData' vs. 
\lstinline'SinkNoData' vs. \lstinline'SinkLift'), запроса данных из источника, их передачи
в синк и его закрытия.

Однако, есть один момент, который я хотел подчеркнуть таким длинным примером. Со второй
по последнюю строчки мы игнорируем значение, возвращаемое с \lstinline'Done'. Это вносит
проблему
потери данных. Это важная тема, которую стоило бы хорошенько обсудить. К сожалению,
сейчас мы не сможем полностью её осветить, так как мы не обсудили главного виновника
драмы: \lstinline'Conduits' (тип, не пакет). 

Но если говорить кратко, то оставшееся значение не всегда игнорируется. Экземпляр Monad,
например, использует его для передачи данных из одной синки в другую по цепочке.
В действительности, настоящий оператор соединения не всегде отбрасывает остатки. Когда мы
обсудим источники, получение данных из которых можно приостанавливать (resumable), мы
увидим, что оставшееся значение складывается обратно в буфер, чтобы позволить последующим
синкам переиспользовать существующие источники для получения данных.

\section{Кондуиты}
В этой части мы рассмотрим главный тип данных в нашем пакете --- кондуиты. В то время как
источники генерируют данные а синки их поглощают, кондуиты преобразуют поток.

\subsection{Типы}
Также как мы и делали ранее, начнем с изучения используемых типов.
\begin{lstlisting}
data ConduitResult input m output =
    Producing (Conduit input m output) [output]
  | Finished (Maybe input) [output]

data Conduit input m output = Conduit
    { conduitPush :: input -> ResourceT m (ConduitResult input m output)
    , conduitClose :: ResourceT m [output]
    }
\end{lstlisting}
Это очень похоже на то, что мы видели с синками. В кондуит можно положить данные и в этом
случае он вернет результат. Этот результат демонстрирует либо, что данные ещё
генерируются, либо, что работа закончена. Если кондуит закрыт, то он возвращает некоторый
результат.

Но взглянем чуть-чуть на отличительные особенности. Как и синки мы можем
в данный момент времени добавить только некоторую часть данных в кондуит, а оставшиеся 
данные могут быть из 0 или 1 части. Однако, присутствуют некоторые изменения:
\begin{itemize}  
\item Когда генерируем данные (а синк их обрабатывает), мы выдаем некоторый
результат. Кондуит может сгенерировать новый поток данных
вместо выдачи атомарного результата в конце обработки.
\item Синк всегда выдает одно значение на выходе, в то время как кондуиты ноль или 
несколько (список). Чтобы понять это, можно смотреть на кондуиты, как на функцию
\lstinline'concatMap' (она генерирует несолько результатов для атомарного входа)
или как функцию \lstinline'filter' (выдает 0 или 1 результат от входных данных).
\item У нас нет конструктора подобного \lstinline'SinkNoData'. Это так, потому что мы
предоставляем
экземпляр \lstinline'Monad' для кондуитов. Мы увидим позже как использовать известный 
монадический подход для создания кондуитов.
\end{itemize}  
В целом, кондуиты должны выглядеть очень сходно с тем, что мы рассматривали.

\subsection{Простые кондуиты}

Начнем с определения простейших кондуитов без состояния.
\begin{lstlisting}
-- START
import Prelude hiding (map, concatMap)
import Data.Conduit

-- Простой кондуит передает данные как есть
passThrough :: Monad m => Conduit input m input
passThrough = Conduit
    { conduitPush = \input -> return $ Producing passThrough [input]
    , conduitClose = return []
    }

-- применяет функцию к значениям из потока
map :: Monad m => (input -> output) -> Conduit input m output
map f = Conduit
    { conduitPush = \input -> return $ Producing (map f) [f input]
    , conduitClose = return []
    }

-- а здесь ещё и конкатенирует
concatMap :: Monad m => (input -> [output]) -> Conduit input m output
concatMap f = Conduit
    { conduitPush = \input -> return $ Producing (concatMap f) $ f input
    , conduitClose = return []
    }
-- STOP
main :: IO ()
main = return ()
\end{lstlisting}

\subsection{Кондуиты с состоянием}
Конечно же, не все кодуиты могут быть объявлены без состояния.  Реализация 
кондуитов с состоянием в лоб (bare metal) не очень сложна.
\begin{lstlisting}
-- START
import Prelude hiding (reverse)
import qualified Data.List
import Data.Conduit
import Control.Monad.Trans.Resource

-- Расставить элементы потока в обратном порядке. Здесь та же самая
-- проблема, что при использовании стандартной функции reverse:
-- надо предварительно прочитать весь поток в память
reverse :: Resource m => Conduit input m input
reverse =
    mkConduit []
  where
    mkConduit state = Conduit (push state) (close state)
    push state input = return $ Producing (mkConduit $ input : state) []
    close state = return state

-- То же самое, но ещё с сортировкой
sort :: (Ord input, Resource m) => Conduit input m input
sort =
    mkConduit []
  where
    mkConduit state = Conduit (push state) (close state)
    push state input = return $ Producing (mkConduit $ input : state) []
    close state = return $ Data.List.sort state
-- STOP
main :: IO ()
main = return ()
\end{lstlisting} 
Но мы можем сделать лучше. Как и в случаях с \lstinline'sourceState' и 
\lstinline'sinkState', мы с помощью \lstinline'conduitState' кое-что упростим.
\begin{lstlisting}
  -- START
import Prelude hiding (reverse)
import qualified Data.List
import Data.Conduit

reverse :: Resource m => Conduit input m input
reverse =
    conduitState [] push close
  where
    push state input = return $ StateProducing (input : state) []
    close state = return state

sort :: (Ord input, Resource m) => Conduit input m input
sort =
    conduitState [] push close
  where
    push state input = return $ StateProducing (input : state) []
    close state = return $ Data.List.sort state
-- STOP
main :: IO ()
main = return ()
\end{lstlisting}

\subsection{Использование кондуитов}
Кондуиты работают с другими сущностями этого пакета с помощью комбинирования (fusing).
Кондуит может быть скомбинирован с источником, создавая новый источник, 
с синком для получения нового синка, или с другим кондуитом, для получения 
нового кондуита. Неплохо бы взглянуть на операторы комбинирования. 
\begin{lstlisting}
-- Комбинирование слева: источник + кондуит = источник
($=) :: (Resource m, IsSource src) => src m a -> Conduit a m b -> Source m b

-- Справа: кондуит + синк = синк
(=$) :: Resource m => Conduit a m b -> Sink b m c -> Sink a m c

-- По середине: кондуит + кондуит = кондуит
(=$=) :: Resource m => Conduit a m b -> Conduit b m c -> Conduit a m c
\end{lstlisting}
Использование этих операторов довольно прямолинейно.
\begin{lstlisting}
useConduits = do
    runResourceT
          $  CL.sourceList [1..10]
          $= reverse
          $= CL.map show
          $$ CL.consume

    -- эквивалентно
    runResourceT
          $  CL.sourceList [1..10]
          $$ reverse
          =$ CL.map show
          =$ CL.consume

    -- и ещё раз эквивалентно
    runResourceT
          $  CL.sourceList [1..10]
          $$ (reverse =$= CL.map show)
          =$ CL.consume
\end{lstlisting}
Существует ещё один способ выразить то же самое. Его поиск оставлен читателю
 в качестве упражнения.

Вам может показаться, что такое количество различных способов комбинирования 
чрезмерно. Хотя вы можете выбирать какой способ вам больше нравится, 
в большинстве случаем вам нужен определенный способ. Например:

\begin{itemize}   
\item Если у вас поток чисел и вы хотите применить кондуит (например, 
\lstinline'map show') только к некоторой части потока, которая будет передана 
в определенную синку, то нужно использовать оператор комбинирования справа.
\item Если вы читаете файл и хотите распарсить его целиком как текстовые данные, 
стоит использовать оператор комбинирования слева, чтобы преоразовать весь поток.
\item Если вам нужны переиспользуемые кондуиты, которые будут объединяться в 
большие кондуиты, используете срединное комбинирование.
\end{itemize}

\subsection{Потери данных} 
Забудем о кондуитах на минутку. Давайте напишем программу, которая использует 
голые списки: она примет список чисел, применит некоторое преобразование к нему,
возьмет первые 5 элементов и сделает с ними что-то, а потом возьмем оставшиеся
непреобразованные денные и сделает с ними что-нибудь ещё. Как-то так, например:
\begin{lstlisting}
main = do
    let list = [1..10]
        transformed = map show list
        (begin, end) = splitAt 5 transformed
        untransformed = map read end
    mapM_ putStrLn begin
    print $ sum untransformed
\end{lstlisting}
Но ясно, что это не очень хорошее решение в целом, потому что нам не нужно 
преобразовывать в одну сторону, а потом обратно все элементы списка. К тому же 
мы не всегда будем иметь функцию обратного преобразования. Другая причина 
--- неэффективность. В данном случае мы можем написать более эффективное решение:
\begin{lstlisting}
  main = do
    let list = [1..10]
        (begin, end) = splitAt 5 list
        transformed = map show begin
    mapM_ putStrLn transformed
    print $ sum end
\end{lstlisting}
Обратите внимание: мы разбиваем список до применения  нашего преобразования. 
Этот подход работает, потому что при использовании \lstinline'map' у нас есть
 взаимооднозначное соответствие между элементами. Поэтому выделение первых пяти 
 элементов до или после преобразования суть одно и то же. Но что будет, если мы 
 заменим \lstinline'map show' чем-то более сложное.
\begin{lstlisting}
deviousTransform =
    concatMap go
  where
    go 1 = [show 1]
    go 2 = [show 2, "two"]
    go 3 = replicate 5 "three"
    go x = [show x]
\end{lstlisting}
Теперь нет взаимооднозначного соответствия. Следовательно, мы не можем 
использовать второй способ. Но на самом деле всё гораздо хуже: мы также не можем 
использовать первый способ, потому что у нас нет обратного преобразования к 
функции \lstinline'deviousTransform'.
 
Я знаю только одно решение проблемы: преобразовывать значения по одному. 
Конечный вариант будет выглядеть примерно так:
\begin{lstlisting}
deviousTransform 1 = [show 1]
deviousTransform 2 = [show 2, "two"]
deviousTransform 3 = replicate 5 "three"
deviousTransform x = [show x]

transform5 :: [Int] -> ([String], [Int])
transform5 list =
    go [] list
  where
    go output (x:xs)
        | newLen <= 5 = (take 5 output', xs)
        | otherwise = go output' xs
      where
        output' = output ++ deviousTransform x
        newLen = length output'

    -- Крайний случай: недостаточно данных для получения 5 результатов
    go output [] = (output, [])

main = do
    let list = [1..10]
        (begin, end) = transform5 list
    mapM_ putStrLn begin
    print $ sum end
\end{lstlisting}    
Результат работы программы будет таким:
\begin{verbatim}
1
2
two
three
three
49
\end{verbatim}
Стоит обратить внимание, что число 3 преобразуется в пять копий слова "three", 
хотя только две из них попадают в результат. Остаток отбрасывается при 
вызове \verb=take 5=.
 
Этот пример наглядно демонстрирует проблему потери данных при использовании 
кондуитов. Заставляя кодуиты принимать только одни данные в текущий момент 
времени мы избегаем проблемы немедленного преобразования слишком большого 
количества данных. Это не значит, что мы не теряем данные: если кондуит, 
генерирует так много данных, что синк не может их все принять, то некоторая их 
часть потеряется.
 
В оправдание скажем, что кондуиты позволяют разбивать данные на куски (chunking), 
чтобы избегать потерь данных.
% To put all this another way: conduits avoid chunking to get away from data loss. 
Эта проблема встречается не только при использовании кондуитов. Если вы 
взглянете на реализацию \lstinline'concatMapM' для 
\footnotehref{http://hackage.haskell.org/package/enumerator}{енумераторов}, вы увидете, что 
там элементы обрабатываются по одному. В кондуитах мы выбираем решать эту 
проблему на уровне типов.
%(In conduits, we opted to force the issue at the type level).
 
\subsection{SequencedSink}
 
Предположим, что нам необходимо скомбинировать существующие кондуиты  и  синки, 
чтобы получить новый, более сложный кондуит. Например, мы хотим написать кондуит, 
который прнимает поток чисел и суммирует их по пять. Другими словами, для входа 
[1..50] он должен вернуть [15,40,65,90,115,140,165,190,215,240]. Мы определенно 
можем это сделать с помощью низкоуровнего интерфейса кондуитов.
\begin{lstlisting}
 import Data.Conduit
 -- START
 sum5Raw :: Resource m => Conduit Int m Int
 sum5Raw =
     conduitState (0, 0) push close
   where
     push (total, count) input
         | newCount == 5 = return $ StateProducing (0, 0) [newTotal]
         | otherwise     = return $ StateProducing (newTotal, newCount) []
       where
         newTotal = total + input
         newCount = count + 1
     close (total, count)
         | count == 0 = return []
         | otherwise  = return [total]
 -- STOP
 main :: IO ()
 main = return ()
\end{lstlisting}
Но это неудобно, так как мы уже имеем всё, что нужно, чтобы реализовать это 
высокоуровнево. У нас есть синк свертки, чтобы складывать числа и изолирующий 
кондуит, который позволит передать в синк только определенное количество данных. 
Может быть мы сможем их скомбинировать?
 
Нам нужен \lstinline'SequencedSink'. Он является обычным синком, за исключением 
того, что он возвращает специальный \lstinline'SequencedSinkResponse'. Это 
значение может вернуть новый результат, остановить обработку данных или передать 
управление в новый кондуит. (Дополнительную информаци вы можете почерпнуть 
в Haddocks.) Потом мы сможем преобразовать это в кондуит с помощью функции 
\lstinline'sequenceSink'. Она также принимает состояние, которое будет 
передано в синк.
 
Теперь мы можем переписать \lstinline'sum5Raw' более высокоуровнево.
\begin{lstlisting}
 import Data.Conduit
 import qualified Data.Conduit.List as CL
 -- START
 sum5 :: Resource m => Conduit Int m Int
 sum5 = sequenceSink () $ \() -> do
     nextSum <- CL.isolate 5 =$ CL.fold (+) 0
     return $ Emit () [nextSum]
 -- STOP
 main = return ()
\end{lstlisting}
Здесь все () --- это  неиспользуемое состояние, которое передается и там 
игнорируется. Другими словами мы сделали ровно то, что хотели. Мы скомбинировали 
изолирование со сверткой, чтобы получить сумму следующих пять элементов потока. 
Затем мы возвращаем значение, чтобы начать всё сначала.
 
Предполжим, что мы хотим это слегка изменить. Мы хотим получить первые 8 сумм и 
затем вернуть эти значения, увеличенные в двое. Будем хранить сколько значений 
мы вернули в состоянии, а затем воспользуемся конструктором 
\lstinline'StartConduit', чтобы передать управление кондуиту, умножающему на 2.
\begin{lstlisting}
 import Data.Conduit
 import qualified Data.Conduit.List as CL
 -- START
 sum5Pass :: Resource m => Conduit Int m Int
 sum5Pass = sequenceSink 0 $ \count -> do
     if count == 8
         then return $ StartConduit $ CL.map (* 2)
         else do
             nextSum <- CL.isolate 5 =$ CL.fold (+) 0
             return $ Emit (count + 1) [nextSum]
 -- STOP
 main = return ()
\end{lstlisting}
Очевидно, что примеры выше несколько искусственны, но я надеюсь, что прояснили 
мощь и простоту этого подхода. 
 
\section{Буферизация}

Буферизация --- это одно из уникальных свойств кондуитов. С её использованием 
вам больше не придется заботиться о потоке управления в вашей программе.
% With buffering, conduits no longer need to control the flow of your application. 
Иногда, она поможет упростить код.

\subsection{Инверсия управления}

Буферизация была одной из главный причин для создания кондуитов. Чтобы понять её 
важность, расмотрим подход, который мы видели не так давно, который приведет к 
инверсии управления.

\begin{remark}
Инверсия управления в разных контекстах может означать разное. Если вы возражаете 
против использования этого термина здесь, то можете называть это 
"тёплой пушистой штуковиной" --- я не буду возражать.
\end{remark}

Предположим, что вы хотите посчитать, как много переводов строки в файле. При 
стандартном императивном подходе вы бы действовали примерно так:
\begin{itemize}  
\item   открываем файл;
\item   читаем данные в буфер;
\item   обходим данные в буфере, икрементируя счетчик, когда встречаем перевод строки;
\item   возвращаемся на шаг два;
\item   закрываем файл.
\end{itemize}
Обратите внимание, что ваш код явно вызывает другой код, и этот другой код 
передает управление обратно в ваш код. Вы полностью контролируете поток 
управления вашей программы. В кондуитах, как мы видели, так сделать 
не получится. Вместо этого мы будем:
\begin{itemize}
\item  писать в синк, который считает переводы строки и инкрементирует  аккумулятор;
\item  соединять синк с источником.
\end{itemize} 
Я не сомневаюсь в том, что этот подход проще. Нам не придется заботиться об 
открытии и закрытии файла и чтения данных из него. Здесь необходимые данные 
просто предоставляются нам. Это преимущество инверсии управления --- мы 
можем сосредоточиться именно на нашей части кода.

Мы используем этот подход всюду в хаскеле: например, вместо \lstinline'readMVar' 
и \lstinline'putMVar', мы используетм \lstinline'withMVar'. Не используем 
\lstinline'openFile' и \lstinline'closeFile', сразу пишем \lstinline'withFile' 
и передаем функцию, которая использует дескриптор. Даже в С используется такое 
же: зачем \lstinline'malloc' и \lstinline'free' когда можно писать сразу же
\lstinline'alloca'?

Вообще-то, мы уже далеко ушли от темы. Конечно же, мы не можем использовать 
\lstinline'alloca' везде. Функция \lstinline'alloca' выделять память только на 
локальном стеке, а не в куче. Никак нельзя вернуть выделенную память наружу из 
данной функции.

На самом деле, некоторые ограничения применяются ко всему семейству таких 
функций: мы никогда не сможем вернуть выделенный ресурс наружу из данного 
<<блока>> кода. Обычно, это и не нужно, просто мы должны осмыслить, что это 
изменение повлияет на структуру наших программ. Однако, в сложных окружениях 
становится непросто управлять этим, а порою просто не возможно. 
\marginpar{
Что-то я тут не совсем понял.
Usually this works
out just fine, but we need to recognize that this is a change in how we structure our
programs. Often times, with simple examples, this is a minor change. However, in larger
settings this can become very difficult to manage, bordering on impossible at times.}

\subsection{Веб-сервер}
Давайте напишем веб-сервер. Нам понадобятся следующие низкоуровневые операции:
\begin{lstlisting}
data Socket
recv    :: Socket -> Int -> IO ByteString -- вернет пустую строку если сокет закрыт
sendAll :: Socket -> ByteString -> IO ()
\end{lstlisting}
Также нам понадобится функция \lstinline'handleConn', которая будет обрабатывать 
соединения по одному. Например такая:
\begin{lstlisting}
data Request  -- заголовки запроса, версия HTTP протокола и т.д.
data Response -- код ответа, заголовки, тело.
type Application = Request -> IO Response
handleConn :: Application -> Socket -> IO ()
\end{lstlisting}
Что наша функция \lstinline'handleConn' должна делать? Если кратко, то:
\begin{itemize}  
\item   разобрать тело запроса;
\item   разобрать заголовки запроса;
\item   создать значение типа \lstinline'Request';
\item   передать его приложению, чтобы получить обратно ответ типа \lstinline'Response';
\item   середать ответ обратно в сокет.
\end{itemize}  
Начнем с реализации пунктов 1 и 2 вручную, без кондуитов. Будем действовать очень 
просто, предполагая, что запрос состоит из трех слов, разделенных пробелами. 
Остановимся на таком варианте:
\begin{lstlisting}
data RequestLine = RequestLine ByteString ByteString ByteString

parseRequestLine :: Socket -> IO RequestLine
parseRequestLine socket = do
    bs <- recv socket 4096
    let (method:path:version:ignored) = S8.words bs
    return $ RequestLine method path version
\end{lstlisting}
Здесь две проблемы: мы не рассматриваем случай, когда в чанке данных меньше 
трех строк и отбрасываем лишние данные. Мы определенно можем решить обе 
проблемы вручную, но это будет утомительно. Гораздо проще переписать это 
в териминах кондуитов.
\begin{lstlisting}
-- START
import Data.ByteString (ByteString)
import qualified Data.ByteString as S
import Data.Conduit
import qualified Data.Conduit.Binary as CB
import qualified Data.Conduit.List as CL

data RequestLine = RequestLine ByteString ByteString ByteString

parseRequestLine :: Sink ByteString IO RequestLine
parseRequestLine = do
    let space = toEnum $ fromEnum ' '
    let getWord = do
            CB.dropWhile (== space)
            bss <- CB.takeWhile (/= space) =$ CL.consume
            return $ S.concat bss

    method <- getWord
    path <- getWord
    version <- getWord
    return $ RequestLine method path version
-- STOP
main = return ()
\end{lstlisting}
Это значит, что нашему коду будут предоставлены данные как только они поступят 
а дополнительные данные будут автоматически забуферизованы в источнике, 
готовые к использованию. Теперь мы можем легко состыковать наши программы 
вместе, пользуясь мощью подхода на кондуитах:
\begin{lstlisting}
-- START
import Data.ByteString (ByteString)
import Data.Conduit
import Data.Conduit.Network (sourceSocket)
import Control.Monad.IO.Class (liftIO)
import Network.Socket (Socket)

data RequestLine = RequestLine ByteString ByteString ByteString
type Headers = [(ByteString, ByteString)]
data Request = Request RequestLine Headers
data Response = Response
type Application = Request -> IO Response

parseRequestHeaders :: Sink ByteString IO Headers
parseRequestHeaders = undefined

parseRequestLine :: Sink ByteString IO RequestLine
parseRequestLine = undefined

sendResponse :: Socket -> Response -> IO ()
sendResponse = undefined

handleConn :: Application -> Socket -> IO ()
handleConn app socket = do
    req <- runResourceT $ sourceSocket socket $$ do
        requestLine <- parseRequestLine
        headers <- parseRequestHeaders
        return $ Request requestLine headers
    res <- liftIO $ app req
    liftIO $ sendResponse socket res
-- STOP
main = return ()
\end{lstlisting}
\subsection{Где же тело запроса?}
У нас всё было бы хорошо, если бы мы могли читать тело запроса. Сейчас
приложению просто передается значение типа \lstinline'Request', которе 
завернутоe в монаду \lstinline'IO'. 
Оно не имеет доступа к входному потоку данных.

Это можно легко исправить, завернув значение типа \lstinline'Application' в монаду Sink. 
Это тот же самый трюк, который мы использовали в enumerator-based WAI 0.4. 
\marginpar{WAi? WTF?}
Однако, есть две проблемы:

\begin{itemize}
\item Люди находят это неудобным. Они ожидают, что значение типа 
\lstinline'Request' будет иметь в себе значение \lstinline'requestBody' типа 
\lstinline'Source'.
\item В некоторых случаях использование такого подхода становится невероятно 
тpудным. Например, написать HTTP-прокси комбинируя WAI и http-энумераторы 
видится почти невозможным.
\end{itemize}
Существует ещё один недостаток инверсии управления. Наш код желает быть 
управляемым. Он желает, чтобы ему дали что-то откуда можно брать данные, что-то 
куда их можно сложить и запуститься от них. Нам нужно какое-то решение этой проблемы.

\begin{remark}
Если вы считаете, что описанная проблема не так критична, то это потому, что вы не до
 конца погрузились в детали. Нам надо также учитывать, что тело запроса это тоже поток,
работа с которым произодит и на клиентской, и на серверной стороне.
\end{remark}

Простым решением было бы создание нового источника, и передача его в приложение.
К сожалению, это влечет проблемы с буферизацией. Вы видите, что когда мы соединяем 
наш источник с кинками \lstinline'parseRequestLine' и \lstinline'parseRequestHeaders',
происходит вызов функции \lstinline'recv'.
Если прочитанных данных будет недостаточно, чтобы разобрать все заголовки, то 
состоится ещё один вызов. Когда будет достаточно данных, процесс остановится. 
Однако, очевидно, что он остановится не строго в конце заголовков. Некотороые 
биты из тела запроса также могут быть прочитаны.

Если мы просто создадим новый источник и передадим туда запрос, запросто мы можем 
потерять часть тела запроса. Нам нужно как-то передать буферизированные данные 
тоже.

\subsection{Буферизованные источники (BufferedSource)}
Наконец, мы может представить последний тип данных в кондуитах: 
\lstinline'BufferedSource'. Это абстрактный тип данных, но всё что он в 
действительности делает, это содержит мутабельную ссылку на буфер и 
соответствующий ему источник. Чтобы создать значение такого типа, вы можете 
воспользоваться функцией \lstinline'bufferSource'.
\begin{verbatim}
bufferSource :: Resource m => Source m a -> ResourceT m (BufferedSource m a)
\end{verbatim}
Это небольшое улучшение позволит нам легко решить нашу дилемму связанную с 
веб-сервером. Вместо соединения источника с синками, осуществляющими разбор, 
мы будем использовать \lstinline'BufferedSource'. При закрытии каждого 
соединения, все оставшиеся данные будут складываться обратно в буфер. 
Для нашего веб-сервера мы создадим \lstinline'BufferedSourceuse' и будем 
использовать его для чтения запросов и их заголовков, а затем передадим этот 
\lstinline'BufferedSource' в приложение, для чтения тел запросов.

\subsection{Классы типов}
Мы хотим уметь соединять буферизованый источник с синком, как будто это обычный источник.
Мы также хотим уметь комбинировать его с кондуитами. Чтоб сделать это удобным, в кондуитах
есть класс типов \lstinline'IsSource'. Его экземляры предоставлены и для
\lstinline'Source', и для \lstinline'BufferedSource'. 
Операторы соединения (\verb#$$#) и комбинирования слева (\verb#$=#) используют этот класс типов.

В экземпляре этого класса типов для \lstinline'BufferedSource' есть одна тонкость.
Предположим, что мы хотим написать функцию копирования файлов, без
буферизации. Это довольно стандартный случай использования кондуитов:
\begin{lstlisting}
sourceFile input $$ sinkFile output
\end{lstlisting}
Когда запускается этот код, то открывается и input-файл, и output-файл, данные 
копируются и затем оба файла закрываются. Изменим слегка код, чтобы 
использовать буферизацию:
\begin{lstlisting}
bsrc <- bufferSource $ sourceFile input
bsrc $$ isolate 50 =$ sinkFile output1
bsrc $$ sinkFile output2
\end{lstlisting}
А здесь, когда открывается и закрывается входной файл? Если соблюдать обычные 
правила для источников, то файл откроется в первой строчке, а закроется во 
второй. Следовательно, мы не сможем его использовать в третьей строчке!

Вместо этого, оператор \verb#$$# не закрывает файл. Следовательно, вы можете 
передавать буферизованый источник для выполнения тех действий, которые вам 
нужны, не заботясь, что дескриптор файла будет закрыт без вашего ведома.

\begin{remark}
Как мы упоминали ранее, инвариант гласит, что из источника невозможно забрать 
данные, если он вернул Closed. Чтобы облегчить работу с буферизоваными 
источниками, это инвариант здесь не выполняется. Ответственность о закрытии 
соответствующего источника, а также о том, что он больше не будет исопльзоваться
лежит на реализации \lstinline'BufferedSource'.
\end{remark}

Будьте осторожны: когда вы закончили работу с буферизованым источником, вам 
следует вручную вызывать \lstinline'bsourceClose'. Однако, это обычно является 
оптимизацией, так как источник будет автоматически закрываться по окончанию 
работы функции \lstinline'runResourceT'.

\subsection{Возвращаясь к веб-серверу}
Так как именно будет выглядеть наш веб-сервер?
\begin{lstlisting}
-- START
import Data.ByteString (ByteString)
import Data.Conduit
import Data.Conduit.Network (sourceSocket)
import Control.Monad.IO.Class (liftIO)
import Network.Socket (Socket)

data RequestLine = RequestLine ByteString ByteString ByteString
type Headers = [(ByteString, ByteString)]
data Request = Request RequestLine Headers (BufferedSource IO ByteString)
data Response = Response
type Application = Request -> ResourceT IO Response

parseRequestHeaders :: Sink ByteString IO Headers
parseRequestHeaders = undefined

parseRequestLine :: Sink ByteString IO RequestLine
parseRequestLine = undefined

sendResponse :: Socket -> Response -> IO ()
sendResponse = undefined

handleConn :: Application -> Socket -> IO ()
handleConn app socket = runResourceT $ do
    bsrc <- bufferSource $ sourceSocket socket
    requestLine <- bsrc $$ parseRequestLine
    headers <- bsrc $$ parseRequestHeaders
    let req = Request requestLine headers bsrc
    res <- app req
    liftIO $ sendResponse socket res
-- STOP
main = return ()
\end{lstlisting}
Мы провели несколько небольших изменений. Во-первых, наше приложение теперь завернуто в 
\lstinline=ResourceT IO= монаду. Это не строгая необходимость, но это очень удобно:
приложение теперь может регистрировать функции освобождения ресурсов, которые выполнятся только тогда, когда ответ будет полностью послан клиенту.

Но главные изменения произошли в функции \lstinline=handleConn=. Сейчас мы начинаем работу
сразу с буферизации источника. Затем он используется дважды в нашей функции и передается в
приложение.

