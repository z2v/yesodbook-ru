\chapter{Кондуиты}\label{chap:conduit}

Кондуиты используются для обработки потоков данных. Обычно ленивые вычисления
позволяют обрабатывать большие объемы данных, не загружая их в память целиком. Однако 
использование такого подхода для ввода-вывода влечёт требование ленивости последнего.
Основной недостаток ленивого ввода-вывода~--- его недетерминированность: у нас нет никаких гарантий того, когда будут выполнены 
финализаторы наших ресурсов. Для небольшого приложения это допустимо, но
для высоко нагруженного веб-сервера мы можем очень быстро исчерпать ограниченные системные ресурсы,
например, дескрипторы файлов.

Кондуиты позволяют оперировать большими потоками данных при детерминированном управлении
ресурсами. Они предоставляют унифицированный интерфейс для потоков данных вне зависимости
от того, откуда они поступают: из файлов, сокетов или памяти. В сочетании с \lstinline{ResourceT} мы
можем безопасно работать с ресурсами, зная, что они будут гарантированно освобождены даже
в случае возникновения исключений.

В этом приложении рассматривается пакет 
\footnotehref{http://hackage.haskell.org/package/conduit}{conduit} версии \verb=0.2=.

\section{Кондуиты в двух словах}
Хотя понимание низкоуровневой механики кондуитов рекомендуется, вы можете далеко
продвинуться и без неё. Давайте начнём  с нескольких  высокоуровневых 	 примеров.  Не
беспокойтесь, если некоторые детали будут вам непонятны сразу, 
  мы разберём всё в этом приложении. Начнём с терминологии, после чего перейдём к 
примерам кода.

\begin{itemize}
 \item \emph{Источник (source)} генерирует данные. Они могут быть прочитаны из файла, прийти из
сокета или находиться в памяти в виде списка. Мы будем обращаться к этим данным, забирая их из
источника.

 \item \emph{Стоки (sinks)} потребляют данные. 
 Простейшими примерами могут служить: функция суммирования (сложение чисел из потока), файловый сток (который записывает все полученные байты в файл) или сокет.
По окончании обработки данных (мы объясним это чуть позже) сток возвращает некоторое значение.

 \item \emph{Кондуиты} преобразуют данные. Простейший пример~--- функция
\lstinline=map=,
хотя существует много других. Мы добавляем данные в кондуит так же как и в сток, однако вместо
возврата одного значения кондуит может вернуть несколько результатов каждый раз
как в него добавляются данные.

  \item \emph{Комбинирование (fuse)} (Спасибо Давиду Мазьересу за термин.) Кондуит можно 
скомбинировать с источником данных (с помощью оператора \lstinline!$=!) и получить
новый источник. Например, мы можем взять источник, читающий байты из файла, и
кондуит, преобразующий байты в текст. Скомбинировав их мы получим 
источник, читающий текст из файла. Аналогично, кондуит и сток можно скомбинировать в новый сток
(оператор \verb#=$#), а два кондуита~--- в новый кондуит (оператор \verb#=$=#).

  \item \emph{Соединение}. Мы можем присоединять источник к стоку, используя оператор
\verb=$$=.
Это приведет к тому, что данные будут передаваться из источника в сток до тех пор, пока
один из них не сообщит, что он <<закончил>>.
\end{itemize}

Рассмотрим несколько примеров кода.
\begin{lstlisting}
{-# LANGUAGE OverloadedStrings #-}
import Data.Conduit -- основная библиотека
import qualified Data.Conduit.List as CL -- несколько функций для работы со списками
import qualified Data.Conduit.Binary as CB -- байты
import qualified Data.Conduit.Text as CT

import Data.ByteString (ByteString)
import Data.Text (Text)
import qualified Data.Text as T
import Control.Monad.ST (runST)
\end{lstlisting}
Для начала соединим источник со стоком. Будем использовать встроенные 
функции по работе с файлами для эффективного, использующего постоянный объём памятии ресурсо-безопасного копирования файлов.

Обратите внимание: вначале мы используем \verb=$$= для соединения источника и стока, а
затем используем \lstinline=runResourceT=.
\begin{lstlisting}
copyFile :: FilePath -> FilePath -> IO ()
copyFile src dest = runResourceT $ CB.sourceFile src $$ CB.sinkFile dest
\end{lstlisting}
Модуль \lstinline=Data.Conduit.List= предоставляет несколько вспомогательных функций для создания
источников, стоков и кондуитов. Вот так выглядит типичная свёртка: суммирование чисел.
\begin{lstlisting}
sumSink :: Resource m => Sink Int m Int
sumSink = CL.fold (+) 0
\end{lstlisting}
Мы можем реализовать то же самое на более низком уровне, используя функцию \verb=sinkState=.
Они принимает три параметра: начальное состояние, функцию приёма дополнительных данных и функцию закрытия.
\begin{lstlisting}
sumSink2 :: Resource m => Sink Int m Int
sumSink2 = sinkState
    0 -- начальное значение
    -- обновим состояния согласно полученным данным 
    -- и сообщим, что необходимы дополнительные данные
    (\accum i -> return $ StateProcessing (accum + i))
    (\accum -> return accum) -- вернуть текущее значение при закрытии
\end{lstlisting}
Другая полезная функция~--- \verb=sourceList=. Скомбинировав её с нашей функций
\verb=sumSink=, мы получим встроенную реализацию функции \lstinline=sum=.
\begin{lstlisting}
sum' :: [Int] -> Int
sum' input = runST $ runResourceT $ CL.sourceList input $$ sumSink
\end{lstlisting}
Поскольку это Haskell, давайте создадим источник, который генерирует все числа Фибоначчи.
Для этого воспользуемся \lstinline=sourceState=. Состояние будет содеражать
следующие два
числа в последовательности. Также нам понадобится функция, которая вернёт следующее число
и обновит состояние.
\begin{lstlisting}
fibs :: Resource m => Source m Int
fibs = sourceState
    (0, 1) -- начальное состояние
    (\(x, y) -> return $ StateOpen (y, x + y) x)
\end{lstlisting}
Посчитаем сумму первых 10 чисел Фибоначчи. Мы можем использовать кондуит \lstinline=isolate=,
чтобы быть уверенными, что сток суммирования обработает только 10 значений.
\begin{lstlisting}
   sumTenFibs :: Int
   sumTenFibs =
       runST -- прекрасно работает в чистом коде
     $ runResourceT
     $ fibs
    $= CL.isolate 10 -- комбинирует источник и кондуит в источник
    $$ sumSink
\end{lstlisting}
Мы также можем скомбинировать кондуит и сток, поменяв местами некоторые операторы.
\begin{lstlisting}
sumTenFibs2 :: Int
sumTenFibs2 =
       runST
     $ runResourceT
     $ fibs
    $$ CL.isolate 10
    =$ sumSink
\end{lstlisting}
Отлично, а теперь сделаем несколько кондуитов. Давайте преобразовывать числа в текст.
Звучит, как задача для функции \lstinline=map=...
\begin{lstlisting}
intToText :: Int -> Text -- вспомогательная функция 
intToText = T.pack . show

textify :: Resource m => Conduit Int m Text
textify = CL.map intToText
\end{lstlisting}
Как и раньше, воспользуемся функцией \lstinline=conduitState=. Здесь
нам не нужно состояние, поэтому подставим фиктивное значение.
\begin{lstlisting}
textify2 :: Resource m => Conduit Int m Text
textify2 = conduitState
    ()
    (\() input -> return $ StateProducing () [intToText input])
    (\() -> return [])
\end{lstlisting}
Сделаем кондуит \lstinline=unlines=, который будет добавлять перевод строки в конце каждого блока
входных данных. Воспользуемся функцией \lstinline=CL.map=. Для тренировки можете попробовать реализовать то же самое при помощи \lstinline{conduitState}.
\begin{lstlisting}
unlines' :: Resource m => Conduit Text m Text
unlines' = CL.map $ \t -> t `T.append` "\n"
\end{lstlisting}
А теперь напишем функцию, которая печатает первые N чисел Фибоначчи. Используем
кодировку UTF8.
\begin{lstlisting}
writeFibs :: Int -> FilePath -> IO ()
writeFibs count dest =
      runResourceT
    $ fibs
   $= CL.isolate count
   $= textify
   $= unlines'
   $= CT.encode CT.utf8
   $$ CB.sinkFile dest
\end{lstlisting}
Мы использовали оператор \lstinline'$=', чтобы комбинировать кондуиты с источниками,
получая
новые источники. Можно делать и обратное: комбинировать кондуиты и стоки. Можно даже
скомбинировать два кондуита.
\begin{lstlisting}
writeFibs2 :: Int -> FilePath -> IO ()
writeFibs2 count dest =
      runResourceT
    $ fibs
   $= CL.isolate count
   $= textify
   $$ unlines'
   =$ CT.encode CT.utf8
   =$ CB.sinkFile dest
\end{lstlisting}
Или мы можем скомбинировать все написанные кондуиты в один...
\begin{lstlisting}
someIntLines :: ResourceThrow m -- изменение кодировки может выбросить исключение
             => Int
             -> Conduit Int m ByteString
someIntLines count =
      CL.isolate count
  =$= textify
  =$= unlines'
  =$= CT.encode CT.utf8
\end{lstlisting}
.. и затем использовать этот кондуит:
\begin{lstlisting}
writeFibs3 :: Int -> FilePath -> IO ()
writeFibs3 count dest =
      runResourceT
    $ fibs
   $= someIntLines count
   $$ CB.sinkFile dest

main :: IO ()
main = do
    putStrLn $ "First ten fibs: " ++ show sumTenFibs
    writeFibs 20 "fibs.txt"
    copyFile "fibs.txt" "fibs2.txt"
\end{lstlisting}

\section{Содержание этой главы}

Далее в этой главе освещаются следующие темы:
\begin{itemize}
 \item ResourceT~--- техника, которая позволяет гарантировать освобождение ресурсов;
 \item Источники~--- наши генераторы данных;
 \item Стоки~--- потребители данных;
 \item Кондуиты~--- преобразователи данных;
 \item Буферизация~--- техника борьбы с инверсией управления (Inversion of Control).
\end{itemize}

\section{Трансформер монады Resource}

Трансформер монады \verb*|Resource| (\verb*|ResourceT|) играет существенную роль в управлении ресурсами в
проектах, использующих кондуиты. Он поставляется вместе с библиотекой \verb=conduit=. 
Мы будем рассматривать \verb*|ResourceT| как отдельную сущность. Несмотря на то, что некоторые решения в его дизайне ориентированы на использование с кондуитами, \verb*|ResourceT| и сам по себе остаётся полезным инструкментом.

\subsection{Назначение}
Что не так с этим кодом?
\begin{lstlisting}
import System.IO

main = do
    output <- openFile "output.txt" WriteMode
    input  <- openFile "input.txt"  ReadMode
    hGetContents input <<= hPutStr output
    hClose input
    hClose output
\end{lstlisting}
Если файл \verb*|input.txt| отсутствует, бросится исключение при попытке его открыть. В
результате \lstinline'hClose output' никогда не будет вызвано и мы получим утечку важного ресурса~--- дескриптора файла. В небольшой программе это не критично, но очевидно, что мы не
можем себе этого позволить в долго работающем, высоко нагруженном серверном процессе.

К счастью, проблема решается довольно просто:
\begin{lstlisting}
import System.IO

main =
    withFile "output.txt" WriteMode $ \output ->
    withFile "input.txt" ReadMode $ \input ->
    hGetContents input <<= hPutStr output
\end{lstlisting}

Использование \lstinline'withFile' гарантирует, что дескриптор будет закрыт даже в
случае
исключений. Оно также поддерживает асинхронные исключения. Вообще говоря, это прекрасный
подход для случаев, когда его использование допустимо. Зачастую использование \lstinline'withFile' довольно просто, но иногда может повлечь переписывание всей программы, а это может быть очень скучно или сильно неэффективно.

Возьмём, например, енумераторы (пакет \texttt{enumerator}). Если вы заглянете в документацию, то найдёте функцию
\lstinline'enumFile' для чтения содержимого файла, но не найдёте функции
\lstinline'iterFile' для записи
содержимого в файл. Так сделано потому, что поток управления итератов не позволяет
правильно управлять дескрипторами. Поэтому, чтобы записать в файл вам надо создавать
дескриптор до запуска \lstinline{Iteratee}, например: 

\begin{lstlisting}
import System.IO
import Data.Enumerator
import Data.Enumerator.Binary

main =
    withFile "output.txt" WriteMode $ \output ->
    run_ $ enumFile "input.txt" $$ iterHandle output
\end{lstlisting}

Этот код работает хорошо, но представьте, что вместо простой передачи данных в файл, нам
надо провести длительное вычисление перед использованием дескриптора. Мы захватим
дескриптор задолго до того, как он нам понадобится, занимая важный ресурс нашего
приложения. Кроме того, часто мы не можем открыть файл заранее, так как мы поймем какой файл
открывать только после прочтения данных из входного файла.

Одна из заявленных целей кондуитов~--- решить эту проблему, и они делают это с помощью \lstinline'ResourceT'.
Программа выше может быть переписана следующим образом:
\begin{lstlisting}
{-# LANGUAGE OverloadedStrings #-}
import Data.Conduit
import Data.Conduit.Binary

main = runResourceT $ sourceFile "input.txt" $$ sinkFile "output.txt"
\end{lstlisting}

\subsection{Как это работает}
Всего основных функций по работе с \lstinline'ResourceT'~--- три, остальные
сделаны поверх этих трёх исключительно для удобства. Вот первая из этой троицы:
\begin{lstlisting}
register :: IO () -> ResourceT IO ReleaseKey
\end{lstlisting}

\begin{remark}
На самом деле, эта и другие функции ниже более полиморфны, чем показано здесь. Они могут работать с другими монадами кроме \verb'IO'. В действительности, почти любой трансформер над
IO, также как над любым ST стэком, будет работать. Мы разъясним детали позднее.
\end{remark}

Эта функция регистрирует кусок кода, который будет выполнен. Она
возвращает значение \lstinline'ReleaseKey', которое используется в следующей функции:

\begin{lstlisting}
release :: ReleaseKey -> ResourceT IO ()
\end{lstlisting}
Вызов функции \verb=release= от \verb'ReleaseKey' немедленно выполняет действие, которое было
зарегистрировано ранее. Мы можем вызывать \verb=release= с одним и тем же значением 
\lstinline'ReleaseKey'
столько раз, сколько пожелаем. При первом вызове производится разрегистрация действия. Это
значит, что вы можете безопасно зарегистрировать действие освобождения памяти, не
заботясь о том, что оно будет выполнено дважды.

В один прекрасный момент, нам захочется покинуть \lstinline'ResourceT'. Чтобы сделать это,
воспользуемся:
\begin{lstlisting}
runResourceT :: ResourceT IO a -> IO a
\end{lstlisting}
В этой внешне невинной функции происходит вся магия. Она проходит по всем зарегистрированным действиям освобождения ресурсов и выполняет их. 
Эта функция безопасна с точки зрения исключений, в
том смысле, что освобождение ресурсов будет выполнено в случае и синхронных и
асинхронных исключений. И, как было упомянуто выше, вызов функции \lstinline'release'
отменит
регистрацию действия. Таким образом нам не стоит беспокоиться о повторном освобождении
ресурсов.

Наконец, для удобства, мы приведем ещё одну функцию для выделения ресурса и регистрации
действия по его освобождению:
\begin{lstlisting}
with :: IO a -- выделить
     -> (a -> IO ()) -- освободить
     -> ResourceT IO (ReleaseKey, a)
\end{lstlisting}

Теперь перепишем первый некачественный пример с использованием \lstinline'ResourceT':
\begin{lstlisting}
import System.IO
import Control.Monad.Trans.Resource
import Control.Monad.Trans.Class (lift)

main = runResourceT $ do
    (releaseO, output) <- with (openFile "output.txt" WriteMode) hClose
    (releaseI, input)  <- with (openFile "input.txt"  ReadMode)  hClose
    lift $ hGetContents input <<= hPutStr output
    release releaseI
    release releaseO
\end{lstlisting}

Теперь мы можем не беспокоиться об исключениях, предотвращающих освобождение ресурсов.
В таких маленьких программах как эта можно опустить вызовы \verb=release=, это ни на что
не повлияет. Однако в больших приложениях, где мы продолжим обработку дальше, этот код
гарантирует, что дескрипторы ресурсов освободятся как только это станет возможным, снижая
потребление ресурсов до минимума.

\subsection{Несколько слов о типах}

Как было упомянуто выше, \lstinline'ResourceT' это нечто большее, чем код, исполняемый в \lstinline{IO}.
Давайте обсудим некоторые требования, предъявляемые к используемой монаде.

\begin{itemize}
\item Изменяемые ссылки для хранения зарегистрированных действий по освобождению
ресурсов. Вам может казаться, что мы могли бы использовать трансформер \lstinline'StateT',
но тогда наше состояние не сможет корректно пережить исключительные ситуации.

\item Мы хотим регистрировать действия только в базовой монаде. Например, если мы имеем 
стэк \lstinline'ResourceT (WriterT [Int] IO)', желательно зарегистрировать
только \verb'IO' действия. Это позволит легко втягивать (\verb'lift') наш стэк (т.е. добавлять новый
трансформер в середину стэка) и избежать сбивающих с толку проблем c ``нанизыванием'' сайд-эффектов других монад.

% вполне вероятно, что в оригинале опечатка и вместо ``threading OF other'' надо читать ``threading OR other''. Хотя, относить threading к разряду монадных сайдэффектов на мой взгляд странно.

\item Какой-то способ гарантировать, что действие будет выполнено даже в случае
исключений. Отсюда следует небходимость функции а-ля \verb'bracket'.
\end{itemize}

Для первого пункта определим класс типов для монад, которые имеют изменяемые ссылки:
\begin{lstlisting}
 class Monad m => HasRef m where
    type Ref m :: * -> *
    newRef' :: a -> m (Ref m a)
    readRef' :: Ref m a -> m a
    writeRef' :: Ref m a -> a -> m ()
    modifyRef' :: Ref m a -> (a -> (a, b)) -> m b
    mask :: ((forall a. m a -> m a) -> m b) -> m b
    mask_ :: m a -> m a
    try :: m a -> m (Either SomeException a)
\end{lstlisting}

Здесь у нас ассоциированный тип для указания типа ссылок. (Фанатам функциональных 
зависисмостей я покажу в следующем разделе, что ассоциированный тип необходим.) 
Затем мы определяем несколько основных операций над ссылками.
В конце несколько функций для работы с
исключениями, которые необходимы для безопасной реализации функций, описанных в
последнем разделе. Реализация экземпляра для \verb'IO' довольно прямолинейна:
  
\begin{lstlisting}
instance HasRef IO where
    type Ref IO = I.IORef
    newRef' = I.newIORef
    modifyRef' = I.atomicModifyIORef
    readRef' = I.readIORef
    writeRef' = I.writeIORef
    mask = E.mask
    mask_ = E.mask_
    try = E.try 
\end{lstlisting}

Однако, при реализации экземпляра для монады ST мы сталкиваемся с проблемой:
обработка исключений в 
монаде \lstinline{ST} невозможна. В результате, функции \lstinline'mask',
\lstinline'mask_' и \lstinline'try' имеют
реализацию по умолчанию без проверки исключений. Из-за этого мы должны сформулировать первое
предупреждение:

\textbf{Операции в монаде \lstinline{ST} не безопасны относительно исключений}. Вы не должны выделять
редкие ресурсы в монаде \lstinline{ST} когда используете \lstinline'ResourceT'.

Вы. возможно, спрашиваете себя, зачем тогда вообще использовать \verb'ResourceT' в комбинации с \verb'ST'. Причина в том, что с кондуитами можно делать много чего и без использования редких ресурсов, и \verb'ST' является прекрасным способом делать это чисто. Однако об этом позднее.

Пункт номер 2: нам надо как-то работать с концепцией базовой монады. Опять же, мы можем
использовать ассоциированные типы (и снова это будет объяснено в следующем разделе). 
Наше решение будет выглядеть примерно так:
\begin{lstlisting}
class (HasRef (Base m), Monad m) => Resource m where
    type Base m :: * -> *

    resourceLiftBase :: Base m a -> m a 
\end{lstlisting}

Мы забыли о пункте 3: \verb'bracket'-подобной функции. Нам понадобится ещё один метод в классе
типов:
\begin{lstlisting}
resourceBracket_ :: Base m a -> Base m b -> m c -> m c 
\end{lstlisting}
Причной, по которой первые два аргумента функции \lstinline'resourceBracket_' <<живут>> в
базовой монаде, является то, что в \lstinline'ResourceT' все выделения и освобождения
ресурсов, происходят в базовой монаде.

Итак, над нашим экземпляром \lstinline'HasRef' для \lstinline'IO' нам также нужен экземпляр
\lstinline'Resource'. Реализация довольно очевидна:
\begin{lstlisting}
 instance Resource IO where
    type Base IO = IO
    resourceLiftBase = id
    resourceBracket_ = E.bracket_
\end{lstlisting}

Теперь у нас есть несколько сходных экземпляров \lstinline'ST', в которых функция
\lstinline'resourceBracket_' небезопасна относительно исключений. Решающий шаг заключается
в поддержке трансформеров. Нам не нужен
экземпляр \lstinline'HasRef', но нужен экземпляр \lstinline'Resource'.
Сложность состоит в корректной реализации функции \lstinline'resourceBracket_', для чего
воспользуемся некоторыми функциями из пакета \texttt{monad-control}
(\footnotehref{http://hackage.haskell.org/package/monad-control}{monad-control}):

\begin{lstlisting}
instance (MonadTransControl t, Resource m, Monad (t m))
        => Resource (t m) where
    type Base (t m) = Base m

    resourceLiftBase = lift . resourceLiftBase
    resourceBracket_ a b c =
        control' \$ \run -> resourceBracket_ a b (run c)
      where
        control' f = liftWith f >>= restoreT . return 
\end{lstlisting}

Для всякого трансформера, его база является базой внутренней монады. Аналогично, мы втягиваем значение в базовую монаду посредством втягивания сначала во внутреннюю монаду, а затем в базовую.
Сложная часть~--- реализация \verb=resourceBracket_=. Я не буду вдаваться в подробные
объяснения, чтобы случайно не поставить себя в глупое положение.

\subsection{Определение ResourceT}

Теперь у нас достаточно информации, чтобы осмыслить определение типа
\lstinline'ResourceT':
\begin{lstlisting}
newtype ReleaseKey = ReleaseKey Int

type RefCount = Int
type NextKey = Int

data ReleaseMap base =
  ReleaseMap !NextKey !RefCount !(IntMap (base ()))

newtype ResourceT m a =
  ResourceT (Ref (Base m) (ReleaseMap (Base m)) -> m a)
\end{lstlisting}

Мы видим, что \lstinline'ReleaseKey' это просто \lstinline'Int'. Если вы заглянете на
несколько строк вниз, то
это определение обретёт смысл, так как мы используем \lstinline'IntMap' для хранения
зарегистрированых действий. Мы также определяем два типа-синонима: \lstinline'RefCount' и
\lstinline'NextKey'. \lstinline'NextKey'
хранит последнее присвоенное значение ключа и увеличивается на единицу каждый раз, когда
вызывается функция \verb=register=. \lstinline{RefCount} мы коснёмся немного позже.

\lstinline'ReleaseMap' хранит три вида информации: следующий ключ, счётчик ссылок и
\lstinline'map' всех
зарегистрированных действий (actions). Заметьте, что \lstinline'ReleaseMap' принимает
типовую переменную \lstinline'base', которая определяет, в какой монаде должны жить действия по освобождению ресурсов.

Наконец, \lstinline'ResourceT' является по сути \lstinline'ReaderT', который
хранит изменяемую
ссылку на \lstinline'ReleaseMap'. Тип ссылки определяется типом базовой монады точно так же как и <<очищающая>> монада. Именно поэтому мы и использовали ассоциированные типы.

Большая часть оставшегося кода в модуле \lstinline'Control.Monad.Trans.Resource'~---
определение экземпляров для типа \lstinline'ResourceT'.

\subsection{Другие классы типов}

Модуль предоставляет ещё три класса типов:
   
\subsubsection{ResourceUnsafeIO}
Любая монада, которая может втянуть (lift) IO действия в себя, но это может быть небезопасно.
Первый пример этого~--- \lstinline'ST'. Осторожность необходима только при втягивании действий, которые не используют ресурсы и которые не <<запускают ракеты>>.
Другими словами, применимы все обычные предупреждения насчёт \lstinline'unsafeIOToST'.
  
\subsubsection{ResourceThrow}

Для действий, которые могут бросать исключения. Автоматически приминимо ко всем
монадам на базе \lstinline{IO}. Для \lstinline{ST}-монад можно воспользоваться трансформером
\lstinline'ExceptionT', чтобы
предоставить возможность пробрасывания исключений. Это потребуется для некоторых функций
кондуитов, например, для декодирования текста.
   
\subsubsection{ResourceIO}

Включает в себя несколько классов типов, в том числе два
упомянутых выше. Он создан исключительно для удобства, мы можем добиться того же результата и без него,
разве что потребуется написать больше кода.
   
\subsection{Ветвления (Forking)}

Может показаться, что ответвление потока по определению небезопасно при использовании 
\lstinline'ResourceT', так как родительский поток может вызвать
\lstinline'runResourceT' в то время
как дочерний использует ресурсы. Это, конечно же, так, если вы используете обычную
функцию \lstinline'forkIO'.

\begin{remark}
Вообще, вы не можете использовать стандартный \lstinline'forkIO', так как он
использует монаду
\lstinline{IO}, однако вполне можно воспользоваться функцией \lstinline'fork' из пакета \lstinline{lifted-base}.
Именно по этой причине пакет \lstinline{regions} не предоставляет экземпляр \lstinline'MonadBaseControl' для своего
трансформера (который очень похож на \lstinline'ResourceT'). Однако, назначение
\lstinline'ResourceT' заключается не в запрещении 
программистам стрелять себе в ногу, а только в облегчении написания
правильного кода. Поэтому, мы всё же предоставляем этот экземпляр, даже несмотря на то, что он может быть
использован неправильно. 
\end{remark}

Чтобы решить эту проблему \lstinline'ResourceT' включает в себя
счётчик ссылок. Когда вы создаёте новый поток с помощью \lstinline'resourceForkIO',
значение \lstinline'RefCount' в \lstinline'ReleaseMap' увеличивается на единицу. Всякий раз, когда вызывается 
\lstinline'runResourceT'
, это значение уменьшается на 1. Только когда оно достигнeт нуля, выполнятся
действия по освобождению ресурсов.
 
\subsection{Вспомогательные функции}

В дополнение к тому, о чём уже было упомянуто, мы расскажем про несколько функций, созданных (в основном) для удобства.
   
Функции \verb=newRef=, \verb=writeRef= и \verb=readRef= оборачивают
функции с \lstinline'HasRef' и позволяют им работать с любым \lstinline'ResourceT'.
Функция \verb=withIO= по сути является ограниченной по типу функцией \verb=with=, избегающей некоторых сложностей с типами, с которыми иначе пришлось бы иметь дело.
В общем случае, вам стоит использовать \lstinline'withIO' для написания \lstinline{IO} кода.

Функция \verb=transResourceT= позволит вам модифицировать в какой монаде исполняется ваш
\verb=ResourceT=, учитывая, что база остаётся прежней.
\begin{lstlisting}
transResourceT :: (Base m ~ Base n)
               => (m a -> n a)
               -> ResourceT m a
               -> ResourceT n a
transResourceT f (ResourceT mx) = ResourceT (\r -> f (mx r))
\end{lstlisting}  

\section{Источники}

Мне кажется, проще всего понять что это такое, посмотрев на типы:
\begin{lstlisting}
data SourceResult m a = Open (Source m a) a | Closed
data Source m a = Source
    { sourcePull :: ResourceT m (SourceResult m a)
    , sourceClose :: ResourceT m ()
    }
\end{lstlisting}
Источник поддерживает две операции: вы можете запросить ещё данных и вы можете закрыть его (как,
например, закрыть дескриптор файла). При запросе новых данных вы или получаете немного
данных и новое значение типа \lstinline=Source= (источник остается открытым), или
ничего (источник закрывается). Давайте посмотрим на простейшие примеры.
\begin{lstlisting}
-- START
import Prelude hiding (repeat)
import Data.Conduit

-- | Никогда не выдает данные
eof :: Monad m => Source m a
eof = Source
    { sourcePull = return Closed
    , sourceClose = return ()
    }

-- | Всегда выдает одно и то же
repeat :: Monad m => a -> Source m a
repeat a = Source
    { sourcePull = return $ Open (repeat a) a
    , sourceClose = return ()
    }
-- STOP
main :: IO ()
main = return ()
\end{lstlisting}
Эти источники довольно тривиальны, так как они всегда возвращают одно и то же. К тому
же их функции закрытия ничего не делают. Вам может показаться, что это ошибка: не должны ли 
мы в функции \lstinline=sourcePull= возвращать \lstinline=Closed= после того, как
источник был
закрыт? В этом нет необходимости, так как согласно одному из правил
источников они никогда не могут быть переиспользованы. Другими словами:
    
\textit{Если источник вернул \lstinline=Open=, то он предоставил вам новый источник, с
которым и
стоит работать вместо оригинального. Если источник вернул \lstinline=Closed=, тогда вы
больше не можете выполнять операции над ним.}
    
Не стоит очень беспокоиться по поводу сохранения этого инварианта. На практике, вам почти
не придётся вызывать \lstinline=sourcePull= или \lstinline=sourceClose= самостоятельно.
Более того, вряд ли вам придётся их самостоятельно реализовывать (для этого существуют
\lstinline=sourceState= и \lstinline=sourceIO=).
Идея заключается в том, что мы можем сделать некоторые предположения, когда реализовываем
источники.

\subsection{Состояние}
В двух примерах источников выше есть кое-что общее: они никогда не меняются и всегда возвращают одно и то же
значение. Другими словами, у них нет состояния. Для более-менее серьёзных источников нам
потребуется какое-то состояние.

\begin{remark}
Состояние может запросто быть определено вне нашей программы. Например, если мы
реализуем источник, который читает данные из дескриптора (\lstinline{Handle}), нам не нужно вручную
указывать никакого состояния, потому что дескриптор имеет состояние сам по себе.
\end{remark}

Будем хранить состояние в источнике путём обновления возвращаемого значения типа
\lstinline=Source= в конструкторе \lstinline=Open=. Лучше всего это видно на
примере.

\begin{lstlisting}
-- START
import Data.Conduit
import Control.Monad.Trans.Resource

-- Выдает данные из списка по одному
sourceList :: Resource m => [a] -> Source m a
sourceList list = Source
    { sourcePull =
        case list of
            [] -> return Closed -- больше нет данных
            -- Здесь будем хранить состояние, возвращая новый 
            -- источник с остатком списка
            x:xs -> return $ Open (sourceList xs) x
        , sourceClose = return ()
        }
-- STOP
main :: IO ()
main = return ()
\end{lstlisting}

Всякий раз, когда мы забираем данные из источника, он проверяет список. Если тот пуст,
возвращаем \lstinline=Closed=, что разумно. Если не пуст, возвращаем \lstinline=Open= со
следующим значением из
списка и новым значением источника, содержащим хвост списка.

\subsection{Функции sourceState и sourceIO}
Кроме возможности создавать источники, у нас также имеется несколько вспомогательных функций,
позволяющих создавать источники на более высоком уровне. Функция \lstinline=sourceState=
позволяет писать
код как будто вы используете монаду \lstinline=State=. Вы предоставляете начальное
состояние и
функцию получения данных от текущего состояния, возвращающую новое состояние и
новое значение. Перепишем \lstinline=sourceList= с eё помощью:

\begin{lstlisting}
-- START
import Data.Conduit
import Control.Monad.Trans.Resource

-- Выдаёт данные из списка по одному
sourceList :: Resource m => [a] -> Source m a
sourceList state0 = sourceState
    state0
    pull
  where
    pull [] = return StateClosed
    pull (x:xs) = return $ StateOpen xs x
-- STOP
main :: IO ()
main = return ()
\end{lstlisting}

Обратите внимание на использование конструкторов \lstinline=StateClosed= и \lstinline=StateOpen=.
Они очень похожи на
\lstinline=Closed= и \lstinline=Open=, за исключением того, что вместо указания следующего
источника вы указываете следующее состояние (в данном случае остаток списка).

Другое распространённое применение~--- выделение ресурсов ввода-вывода (например,
открытие файла), регистрация функции освобождения ресурса (закрытие файла) и
предоставление функции получения данных из ресура.
В пакете \texttt{conduit} присутствует встроенная функция \lstinline!sourceFile!, которая выдаёт поток
значений типа \lstinline=ByteString=. Давайте напишем ужасно неэффективную
альтернативу, которая будет возвращать поток символов.

\begin{lstlisting}
-- START
import Data.Conduit
import Control.Monad.Trans.Resource
import System.IO
import Control.Monad.IO.Class (liftIO)

sourceFile :: ResourceIO m => FilePath -> Source m Char
sourceFile fp = sourceIO
    (openFile fp ReadMode)
    hClose
    (\h -> liftIO $ do
        eof <- hIsEOF h
        if eof
            then return IOClosed
            else fmap IOOpen $ hGetChar h)
-- STOP
main :: IO ()
main = return ()
\end{lstlisting}

Как и \verb=sourceState= она использует конструкторы \verb*|Open| и \verb*|Closed|.
Функция \lstinline=sourceIO= выполняет для нас несколько действий:
\begin{itemize}
 \item Регистрирует функцию освобождения ресурса с трансформером \lstinline=ResourceT=,
гарантируя, что она будет вызвана даже в случае исключений;
 \item Инициализирует поле \lstinline=sourceClose= чтобы освободить ресурс немедленно;
 %TODO: всё-таки не совсем "инициализирует". Скорее, настраивает...
 \item Как только вернётся \lstinline=IOClosed=, ресурс будет освобождён.
\end{itemize}
  
\section{Стоки (Sinks)}

Сток поглащает поток данных и генерирует результат. Он должен всегда выдавать результат
и всегда только один. Это отражено в типах.

Экземпляр \lstinline=Monad= для стоков упрощает композицию нескольких стоков, в больший
сток. Вы также
можете использовать встроенные функции для большинства своих нужд. Как и с источниками,
вам редко понадобится погружаться в тонкости реализации. 

Начнём с примера:
получение строк из потока символов (для простоты, будем предполагать наличие переводов
строк в стиле Unix).

\begin{lstlisting}
import Data.Conduit
import qualified Data.Conduit.List as CL

-- Получить одну строку из потока
sinkLine :: Resource m => Sink Char m String
sinkLine = sinkState
    id -- Начальное состояние. В начале строки ничего нет
    push
    close
  where
    -- В конце строки возвращаем содержимое до текущего места
    push front '\n' =
        return $ StateDone Nothing $ front []

    -- Следующий символ - добавим его в начало и продолжим
    push front char =
        return $ StateProcessing $ front . (char:)

    -- Если встретили конец файла до перевода строки, то выдадим то, что имеем
    close front = return $ front []

-- Получить все строки из потока, до тех пор, пока не встретим пустой строки или конца файла
sinkLines :: Resource m => Sink Char m [String]
sinkLines = do
    line <- sinkLine
    if null line
        then return []
        else do
            lines <- sinkLines
            return $ line : lines

content :: String
content = unlines
    [ "This is the first line."
    , "Here's the second."
    , ""
    , "After the blank."
    ]

main :: IO ()
main = do
    lines <- runResourceT $ CL.sourceList content $$ sinkLines
    mapM_ putStrLn lines
\end{lstlisting}
Запустив этот пример мы получим следующий результат:
\begin{verbatim}
This is the first line.
Here's the second.
\end{verbatim}

Функция \lstinline=sinkLine= демонстрирует использование \lstinline=sinkState=, которая
очень похожа на только что
виденную функцию \lstinline=sourceState=. Она принимает три параметра: начальное
состояние,
функцию добавления \verb=push= 
(принимает текущее состояние и входные данные и возвращает новое состояние и результат)
и функцию закрытия (принимает текущее состояние и возвращает вывод).
В отличие от \lstinline=sourceState=, которая не нуждается в функции закрытия, сток
должен всегда возвращать результат.

В нашей функции \lstinline=push= два клоза. Когда она получает символ перевода строки,
процесс заканчивается, о чём говорит \lstinline=StateDone=. \lstinline=Nothing= означает,
что
входных данных не
осталось (мы обсудим это позднее). Она также возвращает все полученные символы. Второй
клоз просто добавляет символ к текущему состоянию и сообщает с помощью
\lstinline=StateProcessing=, что мы продолжаем работу.
Функция \lstinline=close= возвращает все символы.

Функция \lstinline=sinkLines= демонстрирует как мы можем использовать монадический
интерфейс для создания новых стоков. Если вы замените \lstinline=sinkLine= на
\lstinline=getLine=, это будет выглядеть
как обычный код, который читает строки из стандартного потока ввода. Этот
стандартный интефейс должен помочь вам легко освоиться и быстро начать писать код.

\subsection{Типы}

Типы для стоков несколько более хитроумны, чем для источников. Давайте взглянем на них:
\begin{lstlisting}
type SinkPush input m output = input -> ResourceT m (SinkResult input m output)
type SinkClose m output = ResourceT m output

data SinkResult input m output =
    Processing (SinkPush input m output) (SinkClose m output)
  | Done (Maybe input) output

data Sink input m output =
    SinkNoData output
  | SinkData
        { sinkPush :: SinkPush input m output
        , sinkClose :: SinkClose m output
        }
  | SinkLift (ResourceT m (Sink input m output))
\end{lstlisting}  
Всякий раз, когда в сток добавляются данные, он может сказать, что ему нужно больше
данных (\lstinline{Processing}), или, что всё готово. Если обработка ещё идет, то он должен предоставить
обновлённые функции \lstinline{push} и \lstinline{close}. Если всё готово, то он возвращает результат и
необработанные данные. Довольно тривиально.
 
Первая настоящая неочевидность заключается в наличии трёх конструкторов у
типа \lstinline=Sink=. Зачем нам конструктор \lstinline=SinkNoData=: разве стоки
созданы не для потребления данных? Дело в том, что он нужен для эффективной реализации 
экземпляра класса \lstinline=Monad=. Когда мы вызываем \lstinline=return=, мы
выозвращаем значение, которое не требует данных для вычисления. Мы могли бы эмулировать
подобное поведение с помощью конструктора \lstinline=SinkData= примерно так:
\begin{lstlisting}
myReturn a = SinkData (\input -> return (Done (Just input) a)) (return a)
\end{lstlisting}
Но это бы вызывало чтение лишней порции входных данных, которая нам сейчас не нужна и,
вероятно, вообще не понадобится. (Взгляните ещё раз на пример с \lstinline=sinkLines=)
Именно поэтому мы и имеем дополнительный конструктор, обозначающий, что никаких входных данных не требуется.
Подобным образом, \lstinline=SinkLift= предоставляется для более эффективной реализации
экземпляра \lstinline=MonadTrans=.

\subsection{Стоки: без вспомогательных функций}
Попробуем реализовать несколько стоков <<в лоб>>, без использования вспомогательных функций.
\begin{lstlisting}
-- START
import Data.Conduit
import System.IO
import Control.Monad.Trans.Resource
import Control.Monad.IO.Class (liftIO)

-- Прочитать данные целиком и выкинуть их
sinkNull :: Resource m => Sink a m ()
sinkNull =
    SinkData push close
  where
    push _ignored = return $ Processing push close
    close = return ()

-- Запишем поток символов в файл. Нам понадобится что-то вроде инициализации.
-- Инициализаируем функцию push, а затем вернём другую функцию push для 
-- вложенного вызова. Используя withIO мы уверены в том, что дескриптор будет 
-- закрыт даже в случае исключений
sinkFile :: ResourceIO m => FilePath -> Sink Char m ()
sinkFile fp =
    SinkData pushInit closeInit
  where
    pushInit char = do
        (releaseKey, handle) <- withIO (openFile fp WriteMode) hClose
        push releaseKey handle char
    closeInit = do
        -- Если файл не открывали, то нечего и закрывать
        return ()

    push releaseKey handle char = do
        liftIO $ hPutChar handle char
        return $ Processing (push releaseKey handle) (close releaseKey handle)

    close releaseKey _ = do
        -- Закрыть дескриптор как можно скорее
        return ()

-- Теперь посчитаем сколько значений было в потоке.
count :: Resource m => Sink a m Int
count =
    SinkData (push 0) (close 0)
  where
    push count _ignored =
        return $ Processing (push count') (close count')
      where
        count' = count + 1

    close count = return count
-- STOP
main :: IO ()
main = return ()
\end{lstlisting}
Здесь нет ничего сложного. Разве что, обратите внимание на типичный шаблон использования:
описываем свои функции \lstinline'push' и \lstinline'close' в клозе \lstinline'where', а
затем используем их дважды:
один раз для инициализации \lstinline'SinkData', а другой~--- в конструкторе
\lstinline'Processing'. 
Это может быть несколько утомительно, именно поэтому и существуют вспомогательные функции.

\subsection{Стоки: реализация со вспомогательными функциями}
Давайте перепишем \lstinline'sinkFile', используя преимущества вспомогательных функций 
\lstinline'sinkIO' и \lstinline'sinkState'.
\begin{lstlisting}
-- START
import Data.Conduit
import System.IO
import Control.Monad.IO.Class (liftIO)

-- Нам не нужно менять release key напрямую, sinkIO автоматически
-- освобождает ресурс, как только мы возвращаем IODone из функции push,
-- или когда вызывается sinkClose.
sinkFile :: ResourceIO m => FilePath -> Sink Char m ()
sinkFile fp = sinkIO
    (openFile fp WriteMode)
    hClose
    -- push: заметьте, что сюда передаются и дескриптор и входные данные
    (\handle char -> do
        liftIO $ hPutChar handle char
        return IOProcessing)
    -- close: у нас также есть дескриптор, но мы его не используем
    (\_handle -> return ())

-- А теперь посчитаем сколько значений было в потоке
count :: Resource m => Sink a m Int
count = sinkState
    0
    -- Функция push получает на вход текущее состояние и следующие входные данные...
    (\state _ignored ->
        -- и возвращает новое состояние
        return $ StateProcessing $ state + 1)
    -- Функция close получает финальное состояние и возвращает рузультат.
    (\state -> return state)
-- STOP
main :: IO ()
main = return ()
\end{lstlisting}
Ничего особенного, лишь слегка меньше кода, который к тому же менее подвержен ошибкам. Использование этих двух
вспомогательных  функций крайне рекомендуется, так как оно гарантирует правильное
управление рeсурсами и обновление состояния.

\subsection{Функции работы со списками}
Даже несмотря на то, что реализовывать свои стоки довольно просто, вы скорее всего захотите воспользоваться встроенными стоками, предоставляемыми модулем
\footnotehref{http://hackage.haskell.org/packages/archive/conduit/latest/doc/html/Data.Conduit.List.html}{Data.Conduit.List}. Там есть аналоги для типичных функций работы со
списками, например, свертки. (Этот модуль так же содержит некоторые кондуиты,
например, 
\footnotehref{http://hackage.haskell.org/packages/archive/conduit/latest/doc/html/Data-Conduit-List.html\#v:map}{map}.)

Если вы желаете поупражняться в кондуитах, то реализовать функции из модуля 
\lstinline'List' (с использованием вспомогательных функций и без) будет неплохим началом.

Давайте посмотрим на простые вещи, которые можно получить используюя встроенные стоки.
\begin{lstlisting}
-- START
import Data.Conduit
import qualified Data.Conduit.List as CL
import Control.Monad.IO.Class (liftIO)

-- Суммирование
sum' :: Resource m => Sink Int m Int
sum' = CL.fold (+) 0

-- Вывести все входные значения в стандартный поток вывода
printer :: (Show a, ResourceIO m) => Sink a m ()
printer = CL.mapM_ (liftIO . print)

-- Просуммировать все числа в потоке кроме первых пяти
sumSkipFive :: Resource m => Sink Int m Int
sumSkipFive = do
    CL.drop 5
    CL.fold (+) 0

-- Суммировать числа и печатать накапливаемую сумму
printSum :: ResourceIO m => Sink Int m Int
printSum = do
    total <- CL.foldM go 0
    liftIO $ putStrLn $ "Sum: " ++ show total
    return total
  where
    go accum int = do
        liftIO $ putStrLn $ "New input: " ++ show int
        return $ accum + int
-- STOP
main :: IO ()
main = return ()
\end{lstlisting}

\subsection{Соединение}
Наконец, мы хотим как-то использовать наши стоки. Несмотря на то, что мы умеем вручную вызывать
\verb*|sinkPush| и \verb*|sinkClose|, это утомительно. Например:
\begin{lstlisting}
import Data.Conduit
import Control.Monad.IO.Class (liftIO)

printSum :: Sink Int m Int
printSum = undefined
-- START
main :: IO ()
main = runResourceT $ do
    res <-
        case printSum of
            SinkData push close -> loop [1..10] push close
            SinkNoData res -> return res
    liftIO $ putStrLn $ "Got a result: " ++ show res
  where
    loop [] _push close = close
    loop (x:xs) push close = do
        mres <- push x
        case mres of
            Done _leftover res -> return res
            Processing push' close' -> loop xs push' close'
\end{lstlisting}
Вместо этого, рекомендуется соединять сток с источником. Это не только проще, 
но и менее подвержено ошибкам, кроме того такой подход обеспечивает большую гибкость в том, откуда приходят ваши данные.
Перепишем пример выше:
\begin{lstlisting}
import Data.Conduit
import qualified Data.Conduit.List as CL
import Control.Monad.IO.Class (liftIO)

printSum :: Sink Int m Int
printSum = undefined
-- START
main :: IO ()
main = runResourceT $ do
    res <- CL.sourceList [1..10] $$ printSum
    liftIO $ putStrLn $ "Got a result: " ++ show res
\end{lstlisting}

Подобное соединение заботится о проверке конструктора стока (\lstinline'SinkData' vs. 
\lstinline'SinkNoData' vs. \lstinline'SinkLift'), запросе данных из источника, их передаче
в сток и его закрытии.

Однако, есть один момент, который я хотел бы особенно отметить в длинном примере. В предпоследней строке
мы игнорируем значение, возвращаемое с \lstinline'Done'. Это приводит
к потере данных. Это важная тема, над которой мы долго ломали голову. К сожалению,
пока мы не можем полностью её осветить, так как ещё не обсудили главного виновника
драмы: \lstinline'Conduit' (тип, не пакет). 

Если вкратце, то оставшееся значение входа из конструктора \lstinline{Done} не всегда игнорируется. Экземпляр класса \lstinline{Monad},
например, использует его для передачи данных из одного стока в другой по цепочке.
В действительности, настоящий оператор соединения не всегда отбрасывает остатки. Когда мы
обсудим возобновляемые источники, мы
увидим, что оставшееся значение складывается обратно в буфер, чтобы позволить последующим
стокам переиспользовать существующий источник для получения данных.

\section{Кондуиты}
В этой части мы рассмотрим главный тип данных в нашем пакете~--- кондуиты. В то время как
источники генерируют данные, а стоки их поглощают, кондуиты преобразуют поток данных.

\subsection{Типы}
Так же как и ранее, начнём с изучения используемых типов.
\begin{lstlisting}
data ConduitResult input m output =
    Producing (Conduit input m output) [output]
  | Finished (Maybe input) [output]

data Conduit input m output = Conduit
    { conduitPush :: input -> ResourceT m (ConduitResult input m output)
    , conduitClose :: ResourceT m [output]
    }
\end{lstlisting}
Это очень похоже на то, что мы видели со стоками. В кондуит можно положить данные и в этом
случае он вернет результат. Этот результат демонстрирует либо, что данные ещё
генерируются, либо, что работа закончена. При закрытии кондуит возвращает ещё немного данных.

Обратим внимание на отличительные особенности. Как и в случае со стоками, мы можем
добавлять только один фрагмент данных за раз, соответственно, остаток состоит из 0 или 1 фрагмента.
Однако, есть некоторые отличия:

\begin{itemize}  
\item При генерации (аналог обработки данных в стоке) мы можем возвращать выходыне данные.
Это связано с тем, что кондуит создаёт новый поток выходных данных вместо того, чтобы вернуть единичное значение по окончании обработки.
\item Сток всегда выдает одно значение на выходе, в то время как кондуиты~--- ноль или 
несколько (список). Чтобы понять почему, можно рассматривать кондуиты как функцию
\lstinline'concatMap' (она генерирует несколько результатов для единичного входа)
или как функцию \lstinline'filter' (возвращает 0 или 1 фрагмент выходных данных для каждого фрагмента входных).
\item У нас нет особенных конструкторов подобных \lstinline'SinkNoData'. Это так, потому что мы не
предоставляем
экземпляр \lstinline'Monad' для кондуитов. Позже мы увидим как использовать знакомый 
монадический подход для их создания.
\end{itemize}  
В целом, кондуиты очень похожи на всё то, что мы рассмотрели до сих пор.

\subsection{Простые кондуиты}

Начнём с определения простейших кондуитов без состояния.
\begin{lstlisting}
-- START
import Prelude hiding (map, concatMap)
import Data.Conduit

-- Простой кондуит передает данные как есть
passThrough :: Monad m => Conduit input m input
passThrough = Conduit
    { conduitPush = \input -> return $ Producing passThrough [input]
    , conduitClose = return []
    }

-- применяет функцию к значениям из потока
map :: Monad m => (input -> output) -> Conduit input m output
map f = Conduit
    { conduitPush = \input -> return $ Producing (map f) [f input]
    , conduitClose = return []
    }

-- а здесь ещё и конкатенирует
concatMap :: Monad m => (input -> [output]) -> Conduit input m output
concatMap f = Conduit
    { conduitPush = \input -> return $ Producing (concatMap f) $ f input
    , conduitClose = return []
    }
-- STOP
main :: IO ()
main = return ()
\end{lstlisting}

\subsection{Кондуиты с состоянием}
Конечно же, не все кодуиты могут быть объявлены без состояния.  Реализация 
кондуитов с состоянием в лоб не очень сложна.
\begin{lstlisting}
-- START
import Prelude hiding (reverse)
import qualified Data.List
import Data.Conduit
import Control.Monad.Trans.Resource

-- Расставить элементы потока в обратном порядке. Здесь та же самая
-- проблема, что и при использовании стандартной функции reverse:
-- необходимо предварительно прочитать весь поток в память.
reverse :: Resource m => Conduit input m input
reverse =
    mkConduit []
  where
    mkConduit state = Conduit (push state) (close state)
    push state input = return $ Producing (mkConduit $ input : state) []
    close state = return state

-- То же самое с сортировкой
sort :: (Ord input, Resource m) => Conduit input m input
sort =
    mkConduit []
  where
    mkConduit state = Conduit (push state) (close state)
    push state input = return $ Producing (mkConduit $ input : state) []
    close state = return $ Data.List.sort state
-- STOP
main :: IO ()
main = return ()
\end{lstlisting} 
Но мы можем сделать лучше. Как и в случаях с \lstinline'sourceState' и 
\lstinline'sinkState', мы с помощью \lstinline'conduitState' кое-что упростим.
\begin{lstlisting}
  -- START
import Prelude hiding (reverse)
import qualified Data.List
import Data.Conduit

reverse :: Resource m => Conduit input m input
reverse =
    conduitState [] push close
  where
    push state input = return $ StateProducing (input : state) []
    close state = return state

sort :: (Ord input, Resource m) => Conduit input m input
sort =
    conduitState [] push close
  where
    push state input = return $ StateProducing (input : state) []
    close state = return $ Data.List.sort state
-- STOP
main :: IO ()
main = return ()
\end{lstlisting}

\subsection{Использование кондуитов}
Кондуиты работают с другими сущностями этого пакета с помощью комбинирования (fusing).
Кондуит может быть скомбинирован с источником, создавая новый источник; 
со стоком для получения нового стока; или с другим кондуитом для получения 
нового кондуита. Лучше всего просто взглянуть на операторы комбинирования. 
\begin{lstlisting}
-- Комбинирование слева: источник + кондуит = источник
($=) :: (Resource m, IsSource src) => src m a -> Conduit a m b -> Source m b

-- Комбинирование справа: кондуит + сток = сток
(=$) :: Resource m => Conduit a m b -> Sink b m c -> Sink a m c

-- Комбинирование по середине: кондуит + кондуит = кондуит
(=$=) :: Resource m => Conduit a m b -> Conduit b m c -> Conduit a m c
\end{lstlisting}
Использование этих операторов довольно прямолинейно.
\begin{lstlisting}
useConduits = do
    runResourceT
          $  CL.sourceList [1..10]
          $= reverse
          $= CL.map show
          $$ CL.consume

    -- эквивалентно
    runResourceT
          $  CL.sourceList [1..10]
          $$ reverse
          =$ CL.map show
          =$ CL.consume

    -- и так же эквивалентно
    runResourceT
          $  CL.sourceList [1..10]
          $$ (reverse =$= CL.map show)
          =$ CL.consume
\end{lstlisting}
Существует ещё один способ выразить то же самое. Его поиск оставлен читателю
 в качестве упражнения.

Вам может показаться, что такое количество различных способов комбинирования 
чрезмерно. Хотя в некоторых ситуациях вы можете выбирать какой способ вам больше нравится,
чаще всего подойдёт только один из них. Например:

\begin{itemize}   
\item Если у вас поток чисел и вы хотите применить кондуит (например, 
\lstinline'map show') только к некоторой части потока, которая будет передана 
определенному стоку, то нужно использовать оператор комбинирования справа.
\item Если вы читаете файл и хотите распарсить его целиком как текстовые данные, 
стоит использовать оператор комбинирования слева, чтобы преобразовать весь поток.
\item Если вам нужны переиспользуемые кондуиты, которые будут объединяться в 
большие кондуиты, используйте срединное комбинирование.
\end{itemize}

\subsection{Потери данных} 
Забудем о кондуитах на минутку. Предположим, что мы хотим написать программу (используя 
только списки), которая примет список чисел, применит к ним некоторое преобразование,
возьмёт первые 5 преобразованных элементов и сделает с ними что-то, а затем возьмёт оставшиеся
непреобразованные денные и сделает с ними что-нибудь ещё. Как-то так, например:
\begin{lstlisting}
main = do
    let list = [1..10]
        transformed = map show list
        (begin, end) = splitAt 5 transformed
        untransformed = map read end
    mapM_ putStrLn begin
    print $ sum untransformed
\end{lstlisting}
Ясно, что это не очень хорошее общее решение, ведь мы не хотим
преобразовывать все элементы списка сначала в одну сторону, а потом обратно. К тому же,
мы не всегда будем иметь функцию обратного преобразования. Другая причина~---
неэффективность. В данном случае мы можем написать более эффективное решение:
\begin{lstlisting}
  main = do
    let list = [1..10]
        (begin, end) = splitAt 5 list
        transformed = map show begin
    mapM_ putStrLn transformed
    print $ sum end
\end{lstlisting}
Обратите внимание: мы разбиваем список до применения нашего преобразования. 
Этот подход работает, потому что при использовании \lstinline'map' у нас есть
 взаимно-однозначное соответствие между элементами. Поэтому выделение первых пяти 
 элементов до или после преобразования суть одно и то же. Но что будет, если мы 
 заменим \lstinline'map show' чем-то более сложным?
\begin{lstlisting}
deviousTransform =
    concatMap go
  where
    go 1 = [show 1]
    go 2 = [show 2, "two"]
    go 3 = replicate 5 "three"
    go x = [show x]
\end{lstlisting}
Теперь взаимно-однозначное соответствие отсутствует, а следовательно, мы не можем 
использовать второй способ. На самом деле всё гораздо хуже: мы также не можем 
использовать и первый способ, потому что у нас нет обратного преобразования к 
функции \lstinline'deviousTransform'.
 
Я знаю только одно решение данной проблемы: преобразовывать значения по одному. 
Конечный вариант будет выглядеть примерно так:
\begin{lstlisting}
deviousTransform 1 = [show 1]
deviousTransform 2 = [show 2, "two"]
deviousTransform 3 = replicate 5 "three"
deviousTransform x = [show x]

transform5 :: [Int] -> ([String], [Int])
transform5 list =
    go [] list
  where
    go output (x:xs)
        | newLen <= 5 = (take 5 output', xs)
        | otherwise = go output' xs
      where
        output' = output ++ deviousTransform x
        newLen = length output'

    -- Вырожденный случай: недостаточно данных для получения 5 результатов
    go output [] = (output, [])

main = do
    let list = [1..10]
        (begin, end) = transform5 list
    mapM_ putStrLn begin
    print $ sum end
\end{lstlisting}    
Результат работы программы будет таким:
\begin{verbatim}
1
2
two
three
three
49
\end{verbatim}
Стоит обратить внимание, что число 3 преобразуется в пять копий слова "three", 
однако только две из них попадают в результат, остальные же отбрасываются при 
вызове \verb=take 5=.
 
Этот пример наглядно демонстрирует проблему потери данных при использовании 
кондуитов. Заставляя кодуиты принимать только один фрагмент данных за раз 
мы избегаем ненужного преобразования чрезмерного
количества данных. Однако это не значит, что мы не теряем данные: если кондуит, 
генерирует так много данных, что сток не может их все принять, то некоторая их 
часть потеряется.
 
Другими словами, кондуиты не разбивают данные на куски во избежание потерь.
Эта проблема встречается не только при использовании кондуитов. Если вы 
взглянете на реализацию \lstinline'concatMapM' для 
\footnotehref{http://hackage.haskell.org/package/enumerator}{енумераторов}, вы увидете, что 
там элементы обрабатываются по одному. В кондуитах мы предпочли форсировать эту
проблему на уровне типов.
 
\subsection{SequencedSink}
 
Предположим, что нам необходимо скомбинировать существующие кондуиты  и  стоки, 
чтобы получить новый, более сложный кондуит. Например, мы хотим написать кондуит, 
который принимает поток чисел и суммирует их по пять. Другими словами, для входа 
[1..50] он должен вернуть [15,40,65,90,115,140,165,190,215,240]. Мы определенно 
можем это сделать с помощью низкоуровневого интерфейса кондуитов.
\begin{lstlisting}
 import Data.Conduit
 -- START
 sum5Raw :: Resource m => Conduit Int m Int
 sum5Raw =
     conduitState (0, 0) push close
   where
     push (total, count) input
         | newCount == 5 = return $ StateProducing (0, 0) [newTotal]
         | otherwise     = return $ StateProducing (newTotal, newCount) []
       where
         newTotal = total + input
         newCount = count + 1
     close (total, count)
         | count == 0 = return []
         | otherwise  = return [total]
 -- STOP
 main :: IO ()
 main = return ()
\end{lstlisting}
Но это неудобно, так как мы уже имеем всё, что нужно, чтобы реализовать то же самое 
на более высоком уровне. У нас есть сток свёртки, чтобы складывать числа, и изолирующий 
кондуит, который позволит передать в сток только определённое количество данных. 
Может быть мы сможем их скомбинировать?
 
Нам нужен \lstinline'SequencedSink', который является обычным стоком, за исключением 
того, что он возвращает специальный \lstinline'SequencedSinkResponse'. Это 
значение может вернуть новый результат, остановить обработку данных или передать 
управление в новый кондуит. (Дополнительную информацию вы можете почерпнуть 
в Haddocks.) Потом мы сможем преобразовать его в кондуит с помощью функции 
\lstinline'sequenceSink'. Она также принимает состояние, которое будет 
передано напрямую в сток.
 
Теперь мы можем переписать \lstinline'sum5Raw' на значительно более высоком уровне.
\begin{lstlisting}
 import Data.Conduit
 import qualified Data.Conduit.List as CL
 -- START
 sum5 :: Resource m => Conduit Int m Int
 sum5 = sequenceSink () $ \() -> do
     nextSum <- CL.isolate 5 =$ CL.fold (+) 0
     return $ Emit () [nextSum]
 -- STOP
 main = return ()
\end{lstlisting}
Здесь все ()~--- это  неиспользуемое состояние, которое передаётся между функциями,
его можно игнорировать.
Кроме того, мы делаем ровно то, что хотели. Мы скомбинировали 
\lstinline{isolate} с \lstinline{fold}, чтобы получить сумму следующих пяти
элементов из потока. После чего мы возвращаем это значение и начинаем всё сначала.
 
Предположим, что мы хотим слегка изменить условие. Мы хотим получить первые 8 сумм, а 
затем вернуть оставшиеся значения, увеличенные вдвое. Будем хранить количество значений, которые
мы вернули, в состоянии, а затем воспользуемся конструктором 
\lstinline'StartConduit', чтобы передать управление кондуиту, умножающему на 2.
\begin{lstlisting}
 import Data.Conduit
 import qualified Data.Conduit.List as CL
 -- START
 sum5Pass :: Resource m => Conduit Int m Int
 sum5Pass = sequenceSink 0 $ \count -> do
     if count == 8
         then return $ StartConduit $ CL.map (* 2)
         else do
             nextSum <- CL.isolate 5 =$ CL.fold (+) 0
             return $ Emit (count + 1) [nextSum]
 -- STOP
 main = return ()
\end{lstlisting}
Очевидно, что примеры выше несколько искусственны, но я надеюсь, что они
помогли прояснить мощь и простоту этого подхода. 
 
\section{Буферизация}

Буферизация~--- это одно из уникальных свойств кондуитов. С её использованием 
вам больше не придётся заботиться о потоке управления в вашей программе.
% With buffering, conduits no longer need to control the flow of your application. 
Иногда, она поможет упростить код.

\subsection{Инверсия управления}

Буферизация была одной из главный причин для создания кондуитов. Чтобы понять её 
важность, расмотрим подход, который мы видели не так давно, назовём его
инверсией управления.

\begin{remark}
Инверсия управления в разных контекстах может означать разное. Если вы возражаете 
против использования этого термина здесь, то можете называть это 
``тёплой пушистой штуковиной'', я не буду возражать.
\end{remark}

Предположим, что вы хотите посчитать, как много переводов строки в файле. При 
стандартном императивном подходе вы бы действовали примерно так:
\begin{itemize}  
\item   открываем файл;
\item   читаем данные в буфер;
\item   обходим данные в буфере, инкрементируя счётчик каждый раз, как встречаем перевод строки;
\item   возвращаемся на шаг два;
\item   закрываем файл.
\end{itemize}
Обратите внимание, что ваш код явно вызывает другой код, и этот другой код 
передает управление обратно. Вы полностью контролируете поток 
управления вашей программы. В кондуитах, как мы видели, так сделать 
не получится. Вместо этого мы будем:
\begin{itemize}
\item  писать в сток, который считает переводы строки и прибавляет полученное значение к аккумулятору;
\item  соединять сток с источником.
\end{itemize} 
Я не сомневаюсь в том, что этот подход проще. Нам не придётся заботиться об 
открытии и закрытии файла, ровно как и о чтении данных из него. Вместо этого необходимые данные 
просто предоставляются вам. Это преимущество инверсии управления: вы 
можете сосредоточиться именно на своей части кода.

Мы используем подобный подход всюду в Хаскеле: например, вместо \lstinline'readMVar' 
и \lstinline'putMVar', мы используетм \lstinline'withMVar'. Не используем 
\lstinline'openFile' и \lstinline'closeFile', а сразу пишем \lstinline'withFile' 
и передаем функцию, которая использует дескриптор. Даже в С используется нечто 
подобное: зачем вызывать \lstinline'malloc' и \lstinline'free' вместо
\lstinline'alloca'?

Вообще-то, последний пункт не совсем корректен. Конечно же, мы не можем использовать 
\lstinline'alloca' везде. Функция \lstinline'alloca' выделяет память только локально на 
стеке, а не в куче. Выделенную таким образом память никак нельзя вернуть наружу из 
данной функции.

На самом деле, подобное ограничение применимо ко всему семейству 
\lstinline{with}-функций: мы никогда не сможем вернуть выделенный ресурс наружу из данного 
<<блока>> кода. Обычно это и не нужно, просто мы должны признать, что это 
изменение повлияет на структуру наших программ. Зачастую, в простых случаях, изменение минимально, однако в более крупных задачах с ним становится непросто справиться,
а порой и попросту не возможно. 

\subsection{Веб-сервер}
Предположим, мы собираемся написать веб-сервер. Будем использовать следующие низкоуровневые операции:
\begin{lstlisting}
data Socket
recv    :: Socket -> Int -> IO ByteString -- вернёт пустую строку если сокет закрыт
sendAll :: Socket -> ByteString -> IO ()
\end{lstlisting}
Теперь нам надо реализовать функцию \lstinline'handleConn', которая будет обрабатывать 
одиночное соединение. Она будет выглядеть примерно так:
\begin{lstlisting}
data Request  -- заголовки запроса, версия HTTP протокола и т.д.
data Response -- код ответа, заголовки, тело.
type Application = Request -> IO Response
handleConn :: Application -> Socket -> IO ()
\end{lstlisting}
Что должна делать \lstinline'handleConn'? Если кратко, то:
\begin{itemize}  
\item   разобрать тело запроса;
\item   разобрать заголовки запроса;
\item   создать значение типа \lstinline'Request';
\item   передать его приложению и получить обратно ответ типа \lstinline'Response';
\item   передать ответ обратно в сокет.
\end{itemize}  
Начнём с реализации пунктов 1 и 2 вручную, без использования кондуитов. Упростим задачу, предположив, что 
запрос состоит из трёх строк, разделённых пробелами. 
В конечном итоге у нас выйдет что-то похожее на:
\begin{lstlisting}
data RequestLine = RequestLine ByteString ByteString ByteString

parseRequestLine :: Socket -> IO RequestLine
parseRequestLine socket = do
    bs <- recv socket 4096
    let (method:path:version:ignored) = S8.words bs
    return $ RequestLine method path version
\end{lstlisting}
У этого подхода есть две проблемы: никак не обрабатывается случай, когда данные состоят из менее чем 
трёх строк, кроме того, лишние данные отбрасываются. Мы определённо можем решить обе 
проблемы вручную, но это будет утомительно. Гораздо проще переписать всё 
в териминах кондуитов.
\begin{lstlisting}
-- START
import Data.ByteString (ByteString)
import qualified Data.ByteString as S
import Data.Conduit
import qualified Data.Conduit.Binary as CB
import qualified Data.Conduit.List as CL

data RequestLine = RequestLine ByteString ByteString ByteString

parseRequestLine :: Sink ByteString IO RequestLine
parseRequestLine = do
    let space = toEnum $ fromEnum ' '
    let getWord = do
            CB.dropWhile (== space)
            bss <- CB.takeWhile (/= space) =$ CL.consume
            return $ S.concat bss

    method <- getWord
    path <- getWord
    version <- getWord
    return $ RequestLine method path version
-- STOP
main = return ()
\end{lstlisting}
Это значит, что нашему коду будут предоставлены данные как только они поступят,
а дополнительные данные будут автоматически буферизованы в источнике, 
готовые к последующему использованию. Теперь мы можем легко собрать нашу программу 
из составных частей, пользуясь мощью подхода на кондуитах:
\begin{lstlisting}
-- START
import Data.ByteString (ByteString)
import Data.Conduit
import Data.Conduit.Network (sourceSocket)
import Control.Monad.IO.Class (liftIO)
import Network.Socket (Socket)

data RequestLine = RequestLine ByteString ByteString ByteString
type Headers = [(ByteString, ByteString)]
data Request = Request RequestLine Headers
data Response = Response
type Application = Request -> IO Response

parseRequestHeaders :: Sink ByteString IO Headers
parseRequestHeaders = undefined

parseRequestLine :: Sink ByteString IO RequestLine
parseRequestLine = undefined

sendResponse :: Socket -> Response -> IO ()
sendResponse = undefined

handleConn :: Application -> Socket -> IO ()
handleConn app socket = do
    req <- runResourceT $ sourceSocket socket $$ do
        requestLine <- parseRequestLine
        headers <- parseRequestHeaders
        return $ Request requestLine headers
    res <- liftIO $ app req
    liftIO $ sendResponse socket res
-- STOP
main = return ()
\end{lstlisting}
\subsection{Где же тело запроса?}
Всё выглядит замечательно до тех пор, пока мы не осознаём, что не можем прочитать тело запроса.
%У нас всё было бы хорошо, если бы мы могли читать тело запроса.
Сейчас
\lstinline{Application} просто получает значение типа \lstinline'Request', и живёт
в монаде \lstinline'IO', не имея абсолютно никакого 
доступа ко входному потоку данных.

Это можно легко исправить, завернув \lstinline'Application' в монаду \lstinline{Sink}. 
Это тот же самый трюк, который мы использовали в WAI 0.4, основанном на пакете \texttt{enumerator}. 
Однако, есть две проблемы:

\begin{itemize}
\item Люди находят это сбивающим с толку. Они ожидают, что значение типа 
\lstinline'Request' будет иметь поле \lstinline'requestBody' типа 
\lstinline'Source'.
\item В некоторых случаях использование такого подхода становится невероятно 
тpудным. Например, написать HTTP-прокси комбинируя \texttt{WAI} и \texttt{http-enumerator} 
оказалось почти невозможным.
\end{itemize}
Это обратная сторона инверсии управления. Наш код желает контроливать ситуацию
. Он желает, чтобы ему дали нечто, откуда можно брать данные, нечто
куда их можно сложить, и работать с этим. Нам нужно какое-то решение этой проблемы.

\begin{remark}
Если вы считаете, что описанная проблема с прокси не так ужасна, это только потому, что
я не стал вдаваться в подробности.
Нам надо также учитывать, что тело запроса это тоже поток,
работа с которым происходит и на клиентской и на серверной сторонах.
\end{remark}

Простейшим решением было бы создание нового источника и передача его в \lstinline{Application}.
К сожалению, это влечёт проблемы с буферизацией. Когда мы соединяем 
наш источник со стоками \lstinline'parseRequestLine' и \lstinline'parseRequestHeaders',
происходит вызов функции \lstinline'recv'.
Если прочитанных данных будет недостаточно, чтобы разобрать все заголовки, то 
произойдёт ещё один вызов. Когда данных будет достаточно, процесс остановится. 
Однако, есть вероятность, что он остановится не строго в конце заголовков, и некоторая 
часть тела запроса также будет прочитана.

Если мы просто создадим новый источник и передадим его запросу, там будет
отсутствовать начало тела запроса. Нам нужен какой-то способ передать
буферизированные данные.

\subsection{Буферизованные источники (BufferedSource)}

% здесь буферизованные, в предложении ранее -- буферизированные. Не знаю, является ли это проблемой... Возможно, нет.

Наконец, мы может представить последний тип данных в кондуитах: 
\lstinline'BufferedSource'. Это абстрактный тип данных, и всё что он в 
действительности делает, это содержит изменяемую ссылку на буфер и 
соответствующий ему источник. Чтобы создать значение такого типа, вы можете 
воспользоваться функцией \lstinline'bufferSource'.
\begin{verbatim}
bufferSource :: Resource m => Source m a -> ResourceT m (BufferedSource m a)
\end{verbatim}
Это небольшое изменение позволит нам легко решить нашу дилемму связанную с 
веб-сервером. Вместо соединения источника со стоком, осуществляющими разбор, 
мы будем использовать \lstinline'BufferedSource'. При закрытии каждого 
соединения, все оставшиеся данные будут складываться обратно в буфер. 
Для нашего веб-сервера мы создадим \lstinline'BufferedSource', воспользуемся 
им для чтения строки запроса и заголовков, а затем передадим этот же
\lstinline'BufferedSource' в \lstinline{Application} для чтения тела запроса.

\subsection{Классы типов}
Мы хотим иметь возможность соединять буферизованый источник со стоком,
как будто это обычный источник.
Мы также хотим уметь комбинировать его с кондуитами. Для обеспечения этой функциональности,
в кондуитах есть класс типов \lstinline'IsSource'. Его экземпляры реализованы как для
\lstinline'Source', так и для \lstinline'BufferedSource'. 
Операторы соединения (\verb#$$#) и комбинирования слева (\verb#$=#) используют этот класс типов.

В экземпляре этого класса типов для \lstinline'BufferedSource' есть одна тонкость.
Предположим, что мы хотим написать функцию копирования файлов без
буферизации. Это довольно стандартный случай использования кондуитов:
\begin{lstlisting}
sourceFile input $$ sinkFile output
\end{lstlisting}
Когда этот код исполняется, открываются оба файла: и файл ввода и файл вывода; данные 
копируются, после чего оба файла закрываются. Слегка изменим код, чтобы 
использовать буферизацию:
\begin{lstlisting}
bsrc <- bufferSource $ sourceFile input
bsrc $$ isolate 50 =$ sinkFile output1
bsrc $$ sinkFile output2
\end{lstlisting}
А здесь, когда открывается и закрывается входной файл? Открытие
происходит в первой строке, а закрытие, если следовать обычным 
правилам для источников, после исполнения второй.
Однако, если это так, то мы не сможем использовать файл в третьей строке!

Вместо этого, оператор \verb#$$# не закрывает файл. Следовательно, вы можете 
передавать буферизованный источник для выполнения тех действий, которые вам 
нужны, не беспокоясь, что дескриптор файла будет закрыт без вашего ведома.

\begin{remark}
Как мы упоминали ранее, инвариант гласит, что из источника невозможно забрать 
данные, если он уже вернул \lstinline{Closed}. Чтобы облегчить работу с буферизованными 
источниками, этот инвариант здесь не выполняется. Ответственность за закрытие 
соответствующего источника, а также за то, что он больше не будет использоваться,
лежит на реализации \lstinline'BufferedSource'.
\end{remark}

Будьте осторожны: когда вы закончили работу с буферизованным источником, вам 
следует вручную вызвать \lstinline'bsourceClose'. Однако, это обычно является 
оптимизацией, так как источник будет автоматически закрыт по окончании 
работы функции \lstinline'runResourceT'.

\subsection{Возвращаясь к веб-серверу}
Как же именно будет выглядеть теперь наш веб-сервер?
\begin{lstlisting}
-- START
import Data.ByteString (ByteString)
import Data.Conduit
import Data.Conduit.Network (sourceSocket)
import Control.Monad.IO.Class (liftIO)
import Network.Socket (Socket)

data RequestLine = RequestLine ByteString ByteString ByteString
type Headers = [(ByteString, ByteString)]
data Request = Request RequestLine Headers (BufferedSource IO ByteString)
data Response = Response
type Application = Request -> ResourceT IO Response

parseRequestHeaders :: Sink ByteString IO Headers
parseRequestHeaders = undefined

parseRequestLine :: Sink ByteString IO RequestLine
parseRequestLine = undefined

sendResponse :: Socket -> Response -> IO ()
sendResponse = undefined

handleConn :: Application -> Socket -> IO ()
handleConn app socket = runResourceT $ do
    bsrc <- bufferSource $ sourceSocket socket
    requestLine <- bsrc $$ parseRequestLine
    headers <- bsrc $$ parseRequestHeaders
    let req = Request requestLine headers bsrc
    res <- app req
    liftIO $ sendResponse socket res
-- STOP
main = return ()
\end{lstlisting}

Мы произвели несколько небольших изменений. Во-первых, наше приложение теперь завёрнуто в 
\lstinline=ResourceT IO= монаду. Это не необходимо, но очень удобно:
\lstinline{application} теперь может регистрировать функции освобождения ресурсов,
которые выполнятся только тогда, когда ответ будет полностью послан клиенту.

Главные же изменения произошли в функции \lstinline=handleConn=. Сейчас мы начинаем работу
с буферизации источника, который затем используется дважды в нашей функции и передается в
приложение.

