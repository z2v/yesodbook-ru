\chapter{http-conduit}
Большая часть Yesod относится к предоставлению контента по протоколу
HTTP. Но это только часть истории: кто-то должен получать его. И даже
если вы пишете веб приложение, иногда этим <<кто-то>> можете быть вы
сами. Если вы хотите получать контент от других сервисов или
взаимодействовать с RESTful API(? FIXME), вам потребуется написать
клиентский код. И рекомендуемый подход для этого~---
http--conduit.\marginpar{вставить ссылку}

Эта глава напрямую с Yesod не связана, и будет, вообще говоря, полезной для
всех, кто хочет выполнять HTTP запросы.

\section{Конспект}
\begin{lstlisting}
{-# LANGUAGE OverloadedStrings #-}
import Network.HTTP.Conduit -- the main module

-- The streaming interface uses conduits
import Data.Conduit
import Data.Conduit.Binary (sinkFile)

import qualified Data.ByteString.Lazy as L
import Control.Monad.IO.Class (liftIO)

main :: IO ()
main = do
    -- Простейший запрос: просто загружаем информацию с указанного URL
    -- как ленивую ByteString.
    simpleHttp "http://www.example.com/foo.txt" >>= L.writeFile "foo.txt"

    -- Теперь используем потоковый интерфейс. Нам необходимо запускать
    -- всё внутри ResourceT, чтобы быть уверенными, что все наши
    -- соединения корректно закрываются в случае возникновения исключения
    runResourceT $ do
        -- Нам нужен Manager, который отслеживает открытые соединения.
        -- simpleHttp создаёт нового менеджера соединений при каждом
        -- запуске (т.е. он никогда повторно соединения не использует)
        manager <- liftIO $ newManager def

        -- Более эффективная версия запроса с simpleHttp выше.
        -- Сначала разбираем URL в запрос
        req <- liftIO $ parseUrl "http://www.example.com/foo.txt"

        -- Теперь получаем ответ
        res <- http req manager

        -- И, наконец, сливаем результат в файл
        responseBody res $$ sinkFile "foo.txt"

        -- Сделаем это POST запросом, не следуем за перенаправлениями,
        --  и принимаем любой код статуса ответа
        let req2 = req
                { method = "POST"
                , redirectCount = 0
                , checkStatus = \_ _ -> Nothing
                }
        res2 <- http req2 manager
        responseBody res2 $$ sinkFile "post-foo.txt"
\end{lstlisting} %$

\section{Основные положения}
Самый простой путь выполнения запроса в http--conduit~--- использовать
функцию~\lstinline!simpleHttp!. Эта функция принимает
\lstinline!String!, представлящую URL, и возвращает
\lstinline!ByteString! с содержимым этого URL. Но внутри себя функция
содержит несколько шагов:
\begin{itemize}
\item Создаётся новый менеджер соединения~\lstinline!Manager!.
\item URL преобразуется в \lstinline!Request!. Если URL некорректный,
  то выбрасывается исключение.
\item Выполняется HTTP запрос, следующий по всем перенаправлениям с сервера.
\item Если код статуса ответа находится вне диапазона 200-х значений,
  выбрасывается исключение.
\item Тело запроса считывается в память и возвращается.
\item Вызывается \lstinline!runResourceT!, который освобождает все
  ресурсы (например, открытый сокет к серверу).
\end{itemize}

Если вы хотите больше контроля над тем, что происходит, вы можете
настроить любой из описанных шагов (плюс ещё несколько), явно создавая
значение~\lstinline!Request!, вручную размещая \lstinline!Manager!, и
используя функции \lstinline!http! и \lstinline!httpLbs!.

\section{Request}
Самый лёгкий путь создать \lstinline!Request!~--- с помощью
функции~\lstinline!parseUrl!. Эта функция вернёт значение в любой
монаде, являющейся экземпляром класса~\lstinline!Failure!, например,
\lstinline!Maybe! или \lstinline!IO!. Последняя из указанных
используется чаще всего, и приводит к исключению во время выполнения,
если функции передан некорректный URL. Однако, вы можете использовать
другую монаду, если, например, хотите проверять пользовательский ввод.
\begin{lstlisting}
import Network.HTTP.Conduit
import System.Environment (getArgs)
import qualified Data.ByteString.Lazy as L
import Control.Monad.IO.Class (liftIO)

main :: IO ()
main = do
    args <- getArgs
    case args of
        [urlString] ->
            case parseUrl urlString of
                Nothing -> putStrLn "Извините, некорректный URL"
                Just req -> withManager $ \manager -> do
                    Response _ _ _ lbs <- httpLbs req manager
                    liftIO $ L.putStr lbs
        _ -> putStrLn "Извините, передавайте, пожалуйста, только один URL"
\end{lstlisting}
Тип~\lstinline!Request! абстрактный, так что http--conduit может
добавлять новые настройки в будущем, не нарушая API (см. приложение
Settings Type для более подробной информации)\marginpar{вставить
  ссылку}. Чтобы изменить отдельные записи, используйте record
notation\marginpar{FIXME: record notation}. Например, модификация
нашей программы, которая отправляет HEAD запросы и печатает заголовки
ответа, могла бы быть такой:
\begin{lstlisting}
{-# LANGUAGE OverloadedStrings #-}
import Network.HTTP.Conduit
import System.Environment (getArgs)
import qualified Data.ByteString.Lazy as L
import Control.Monad.IO.Class (liftIO)

main :: IO ()
main = do
    args <- getArgs
    case args of
        [urlString] ->
            case parseUrl urlString of
                Nothing -> putStrLn "Извините, некорректный URL"
                Just req -> withManager $ \manager -> do
                    let reqHead = req { method = "HEAD" }
                    Response status _ headers _ <- http reqHead manager
                    liftIO $ do
                        print status
                        mapM_ print headers
        _ -> putStrLn "Извините, передавайте, пожалуйста, только один URL"
\end{lstlisting} %$

Есть целый ряд различных настроек в API, вот те, на которые стоит
обратить внимание:
\begin{description}
\item[proxy] \hfill \\
  Позволяет отправлять запросы через указанный прокси--сервер.
\item[redirectCount] \hfill \\
  Указывает количество переадресаций, по которым следовать. По
  умолчанию~--- 10.
\item[checkStatus] \hfill \\
  Проверка кода статуса ответа. По умолчанию, выбрасывает исключение
  для любого кода вне диапазона 200-х значений.
\item[requestBody] \hfill \\
  Тело запроса для отправки. Удостоверьтесь, что обновили метод. Для
  общего случая кодирования данных в URL, вы можете использовать
  функцию~\lstinline!urlEncodedBody!.
\end{description}

\section{Manager}

The connection manager allows you to reuse connections. When making
multiple queries to a single server (e.g., accessing Amazon S3), this
can be critical for creating efficient code. A manager will keep track
of multiple connections to a given server (taking into account port
and SSL as well), automatically reaping unused connections as
needed. When you make a request, http-conduit first tries to check out
an existing connection. When you're finished with the connection (if
the server allows keep-alive), the connection is returned to the
manager. If anything goes wrong, the connection is closed.

To keep our code exception-safe, we use the ResourceT monad
transformer. All this means for you is that your code needs to be
wrapped inside a call to runResourceT, either implicitly or
explicitly, and that code inside that block will need to liftIO to
perform normal IO actions.

There are two ways you can get ahold of a manager. newManager will
return a manager that will not be automatically closed (you can use
closeManager to do so manually), while withManager will start a new
ResourceT block, allow you to use the manager, and then automatically
close the ResourceT when you're done. If you want to use a ResourceT
for an entire application, and have no need to close it, you should
probably use newManager.

One other thing to point out: you obviously don't want to create a new
manager for each and every request; that would defeat the whole
purpose. You should create your Manager early and then share it.

\section{Response}

The Response datatype has three pieces of information: the status
code, the response headers, and the response body. The first two are
straight-forward; let's discuss the body.

The Response type has a type variable to allow the response body to be
of multiple types. If you want to use http-conduit's streaming
interface, you want this to be a Source. For the simple interface, it
will be a lazy ByteString. One thing to note is that, even though we
use a lazy ByteString, the entire response is held in memory. In other
words, we perform no lazy I/O in this package.

\fbox{\begin{minipage}[!h]{.9\linewidth}
The conduit package does provide a lazy module which would allow you
to read this value in lazily, but like any lazy I/O, it's a bit
unsafe, and definitely non-deterministic. If you need it though, you
can use it.
\end{minipage}
}

\section{http and httpLbs}

So let's tie it together. The http function gives you access to the
streaming interface (i.e., it returns a Response using a
BufferedSource) while httpLbs returns a lazy ByteString. Both of these
return values in the ResourceT transformer so that they can access the
Manager and have connections handled properly in the case of
exceptions.

\fbox{\begin{minipage}[!h]{.9\linewidth}
If you want to ignore the remainder of a large response body, you can
connect to the sinkNull sink. The underlying connection will
automatically be closed, preventing you from having to read a large
response body over the network.
\end{minipage}
}
