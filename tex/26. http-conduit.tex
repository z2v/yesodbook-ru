\chapter{http-conduit}
Большая часть Yesod относится к предоставлению контента по протоколу
HTTP. Но это лишь часть картины: кто-то должен получать этот контент. И даже
если вы пишете веб приложение, иногда этим <<кто-то>> можете быть вы
сами. Если вы хотите получать контент от других сервисов или
взаимодействовать с RESTful API, вам потребуется писать
% думаю, что RESTful API достаточно устоявшийся термин,
% кроме того, скорее всего он уже был объяснён ранее в тексте
клиентский код, и рекомендуемый подход для этого~---
\footnotehref{http://hackage.haskell.org/package/http-conduit}{http--conduit}.

Эта глава напрямую с Yesod не связана, и будет, вообще говоря, полезной для
всех, кто хочет выполнять HTTP запросы.

\section{Конспект}
\begin{lstlisting}
{-# LANGUAGE OverloadedStrings #-}
import Network.HTTP.Conduit -- the main module

%-- The streaming interface uses conduits
-- Потоковый интерфейс использует кондуиты
import Data.Conduit
import Data.Conduit.Binary (sinkFile)

import qualified Data.ByteString.Lazy as L
import Control.Monad.IO.Class (liftIO)

main :: IO ()
main = do
    -- Простейший запрос: просто загружаем информацию с указанного URL
    -- как ленивую ByteString.
    simpleHttp "http://www.example.com/foo.txt" >>= L.writeFile "foo.txt"

    -- Теперь используем потоковый интерфейс. Нам необходимо запускать
    -- всё внутри ResourceT, чтобы быть уверенными, что все наши
    -- соединения корректно закрываются в случае возникновения исключений
    runResourceT $ do
        -- Нам нужен Manager, который отслеживает открытые соединения.
        -- simpleHttp создаёт нового менеджера соединений при каждом
        -- запуске (т.е. соедиения никогда не используются повторно)
        manager <- liftIO $ newManager def

        -- Более эффективная версия запроса с simpleHttp выше.
        -- Сначала разбираем URL в запрос
        req <- liftIO $ parseUrl "http://www.example.com/foo.txt"

        -- Теперь получаем ответ
        res <- http req manager

        -- И, наконец, записываем результат в файл
        responseBody res $$ sinkFile "foo.txt"

        -- Сделаем это POST запросом, не следуем за перенаправлениями,
        --  и принимаем любой код статуса ответа
        let req2 = req
                { method = "POST"
                , redirectCount = 0
                , checkStatus = \_ _ -> Nothing
                }
        res2 <- http req2 manager
        responseBody res2 $$ sinkFile "post-foo.txt"
\end{lstlisting} %$

\section{Основные положения}
Самый простой способ выполнения запроса в http--conduit~--- использовать
функцию~\lstinline!simpleHttp!. Эта функция принимает строку
(типа \lstinline!String!), представляющую URL, и возвращает
значение типа \lstinline!ByteString! с содержимым этого URL. Её реализация
состоит из нескольких шагов:
\begin{itemize}
\item Создаётся новый менеджер соединения~\lstinline!Manager!;
\item URL преобразуется в \lstinline!Request!. Если URL некорректный,
  то выбрасывается исключение;
\item Выполняется HTTP запрос, следующий по всем перенаправлениям с сервера;
\item Если код статуса ответа находится вне диапазона 200-х значений,
  выбрасывается исключение;
\item Тело запроса считывается в память и возвращается;
\item Вызывается \lstinline!runResourceT!, которая освобождает все
  ресурсы (например, открытый сокет к серверу).
\end{itemize}

Если вы хотите больше контроля над тем, что происходит, вы можете
настроить любой из описанных шагов (плюс ещё несколько), явно создавая
значение~\lstinline!Request!, вручную размещая \lstinline!Manager!, и
используя функции \lstinline!http! и \lstinline!httpLbs!.

\section{Request}
Самый лёгкий путь создания \lstinline!Request!~--- с помощью
функции~\lstinline!parseUrl!. Эта функция вернёт значение в любой
монаде, являющейся экземпляром класса~\lstinline!Failure!, например,
\lstinline!Maybe! или \lstinline!IO!. Последняя из указанных
используется чаще всего и приводит к исключению во время выполнения,
если функции передан некорректный URL. Однако, вы можете использовать
другую монаду, если, например, хотите проверять пользовательский ввод.
\begin{lstlisting}
import Network.HTTP.Conduit
import System.Environment (getArgs)
import qualified Data.ByteString.Lazy as L
import Control.Monad.IO.Class (liftIO)

main :: IO ()
main = do
    args <- getArgs
    case args of
        [urlString] ->
            case parseUrl urlString of
                Nothing -> putStrLn "Извините, некорректный URL"
                Just req -> withManager $ \manager -> do
                    Response _ _ _ lbs <- httpLbs req manager
                    liftIO $ L.putStr lbs
        _ -> putStrLn "Извините, передавайте, пожалуйста, только один URL"
\end{lstlisting}
Тип~\lstinline!Request! абстрактный, так что http--conduit может
добавлять новые настройки в будущем, не нарушая API
(см. приложение~\nameref{chap:settings_types} для более подробной
информации). Чтобы изменить значения отдельных полей, используйте
record-нотацию\footnote!Запись вида req { method = "HEAD" }!. К примеру, модификация
нашей программы, которая отправляет HEAD запросы и печатает заголовки
ответа, могла бы выглядеть так:
\begin{lstlisting}
{-# LANGUAGE OverloadedStrings #-}
import Network.HTTP.Conduit
import System.Environment (getArgs)
import qualified Data.ByteString.Lazy as L
import Control.Monad.IO.Class (liftIO)

main :: IO ()
main = do
    args <- getArgs
    case args of
        [urlString] ->
            case parseUrl urlString of
                Nothing -> putStrLn "Извините, некорректный URL"
                Just req -> withManager $ \manager -> do
                    let reqHead = req { method = "HEAD" }
                    Response status _ headers _ <- http reqHead manager
                    liftIO $ do
                        print status
                        mapM_ print headers
        _ -> putStrLn "Извините, передавайте, пожалуйста, только один URL"
\end{lstlisting} %$

API предоставляет целый ряд различных настроек. Вот те, на которые стоит
обратить внимание:
\begin{description}
\item[proxy] \hfill \\
  Позволяет отправлять запросы через указанный прокси--сервер;
\item[redirectCount] \hfill \\
  Указывает количество переадресаций, по которым следовать. По
  умолчанию~--- 10;
\item[checkStatus] \hfill \\
  Проверка кода статуса ответа. По умолчанию, бросает исключение
  для любого кода вне диапазона 200-х значений;
\item[requestBody] \hfill \\
  Тело запроса для отправки. Удостоверьтесь, что так же обновили значение \lstinline!method!.
  Для общего случая кодирования данных в URL можно использовать
  функцию~\lstinline!urlEncodedBody!.
\end{description}

\section{Manager}
Менеджер соединений позволяет повторно использовать
сетевые соединения. При выполнении многочисленных запросов к единственному
серверу (например, обращаясь к Amazon S3), это может быть критично для
создания эффективного кода. Менеджер будет отслеживать множественные
соединения к указанному серверу (в том числе учитывая номер порта и
SSL), автоматически собирая неиспользуемые
соединения при необходимости. Когда вы делаете запрос, http-conduit
сначала пытается проверить наличие существующего соединения. Когда
работа с соединением завершена (в случае если сервер позволяет поддерживать открытое
соединение (keep-alive)), оно возвращается менеджеру. Если
что-нибудь пошло не так, соединение закрывается.

Чтобы предохранить наш код от исключений, мы
используем преобразователь монад \lstinline!ResourceT!. Для вас это
означает, что ваш код должен быть завёрнут внутрь вызова
\lstinline!runResourceT!, явно или неявно, и код внутри этого блока
должен использовать \lstinline!liftIO! для выполнения обычных действий
ввода/вывода (IO).

Есть два способа получить значение типа \lstinline!Manager!.
\lstinline!newManager! возвращает нового менеджера, который не
будет закрыт автоматически (вы можете использовать
\lstinline!closeManager! для ручного закрытия), тогда как
\lstinline!withManager! откроет новый блок \lstinline!ResourceT!, даст
возможность использовать менеджера и затем автоматически закроет
\lstinline!ResourceT!, когда вы закончите. Если вы хотите использовать
\lstinline!ResourceT! для всего приложения, и нет необходимости
его закрывать, вам, вероятнее всего, следует использовать \lstinline!newManager!.

Обратите внимание: очевидно, что не следует создавать нового
менеджера соединений для каждого запроса; это полностью противоречило бы
его назначению. Вместо этого \lstinline!Manager! следует создавать как можно
раньше и затем переиспользовать.

\section{Response}
Тип данных~\lstinline!Response! состоит из трёх информационных блоков:
кода статуса, заголовка ответа и тела ответа. Первые два понятны;
давайте обсудим тело.

У типа данных~\lstinline!Response! есть т\'иповая переменная, чтобы 
тело запроса могло иметь любой тип. Если вы хотите
использовать потоковый интерфейс http-conduit, вам нужен
тип~\lstinline!Source!. Для простого интерфейса это будет
ленивая~\lstinline!ByteString!. Обращаю внимание, что, хотя мы и
используем ленивую~\lstinline!ByteString!, \emph{весь ответ хранится в
памяти}. Другими словами, мы не используем ленивый ввод/вывод в этом
пакете.

\begin{remark}
Пакет \lstinline{conduit} предоставляет ленивую реализацию модуля, которая
позволит вам прочитать это значение лениво, но, как и любой ленивый
ввод/вывод, это не совсем безопасно и, определённо, недетерминировано.
Однако если надо, вы можете его использовать.
\end{remark}

\section{http и httpLbs}
Давайте соберём всё вместе. Функция~\lstinline!http! даёт вам доступ к
потоковому интерфейсу (т.е., она возвращает \lstinline!Response!,
использующий \lstinline!BufferedSource!), тогда как
\lstinline!httpLbs! возвращает ленивую~\lstinline!ByteString!.
В обоих случаях возвращаемые значения находятся в
преобразователе~\lstinline!ResourceT!, так что они
получают доступ к \lstinline!Manager! и корректную работу с соединениями в
случае возникновения исключений.

\begin{remark}
Если вы хотите проигнорировать остаток большого тела запроса, этого можно добиться
соединившись со стоком~\lstinline!sinkNull!. Используемое сетевое
соединение будет автоматически закрыто, что позволит избежать
чтения большого тела запроса по сети.
\end{remark}
