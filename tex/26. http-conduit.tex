\chapter{http-conduit}
Большая часть Yesod относится к предоставлению контента по протоколу
HTTP. Но это только часть истории: кто-то должен получать его. И даже
если вы пишете веб приложение, иногда этим <<кто-то>> можете быть вы
сами. Если вы хотите получать контент от других сервисов или
взаимодействовать с RESTful API(? FIXME), вам потребуется написать
клиентский код. И рекомендуемый подход для этого~---
\footnotehref{http://hackage.haskell.org/package/http-conduit}{http--conduit}.

Эта глава напрямую с Yesod не связана, и будет, вообще говоря, полезной для
всех, кто хочет выполнять HTTP запросы.

\section{Конспект}
\begin{lstlisting}
{-# LANGUAGE OverloadedStrings #-}
import Network.HTTP.Conduit -- the main module

-- The streaming interface uses conduits
import Data.Conduit
import Data.Conduit.Binary (sinkFile)

import qualified Data.ByteString.Lazy as L
import Control.Monad.IO.Class (liftIO)

main :: IO ()
main = do
    -- Простейший запрос: просто загружаем информацию с указанного URL
    -- как ленивую ByteString.
    simpleHttp "http://www.example.com/foo.txt" >>= L.writeFile "foo.txt"

    -- Теперь используем потоковый интерфейс. Нам необходимо запускать
    -- всё внутри ResourceT, чтобы быть уверенными, что все наши
    -- соединения корректно закрываются в случае возникновения исключения
    runResourceT $ do
        -- Нам нужен Manager, который отслеживает открытые соединения.
        -- simpleHttp создаёт нового менеджера соединений при каждом
        -- запуске (т.е. он никогда повторно соединения не использует)
        manager <- liftIO $ newManager def

        -- Более эффективная версия запроса с simpleHttp выше.
        -- Сначала разбираем URL в запрос
        req <- liftIO $ parseUrl "http://www.example.com/foo.txt"

        -- Теперь получаем ответ
        res <- http req manager

        -- И, наконец, сливаем результат в файл
        responseBody res $$ sinkFile "foo.txt"

        -- Сделаем это POST запросом, не следуем за перенаправлениями,
        --  и принимаем любой код статуса ответа
        let req2 = req
                { method = "POST"
                , redirectCount = 0
                , checkStatus = \_ _ -> Nothing
                }
        res2 <- http req2 manager
        responseBody res2 $$ sinkFile "post-foo.txt"
\end{lstlisting} %$

\section{Основные положения}
Самый простой путь выполнения запроса в http--conduit~--- использовать
функцию~\lstinline!simpleHttp!. Эта функция принимает
\lstinline!String!, представлящую URL, и возвращает
\lstinline!ByteString! с содержимым этого URL. Но внутри себя функция
содержит несколько шагов:
\begin{itemize}
\item Создаётся новый менеджер соединения~\lstinline!Manager!.
\item URL преобразуется в \lstinline!Request!. Если URL некорректный,
  то выбрасывается исключение.
\item Выполняется HTTP запрос, следующий по всем перенаправлениям с сервера.
\item Если код статуса ответа находится вне диапазона 200-х значений,
  выбрасывается исключение.
\item Тело запроса считывается в память и возвращается.
\item Вызывается \lstinline!runResourceT!, который освобождает все
  ресурсы (например, открытый сокет к серверу).
\end{itemize}

Если вы хотите больше контроля над тем, что происходит, вы можете
настроить любой из описанных шагов (плюс ещё несколько), явно создавая
значение~\lstinline!Request!, вручную размещая \lstinline!Manager!, и
используя функции \lstinline!http! и \lstinline!httpLbs!.

\section{Request}
Самый лёгкий путь создать \lstinline!Request!~--- с помощью
функции~\lstinline!parseUrl!. Эта функция вернёт значение в любой
монаде, являющейся экземпляром класса~\lstinline!Failure!, например,
\lstinline!Maybe! или \lstinline!IO!. Последняя из указанных
используется чаще всего, и приводит к исключению во время выполнения,
если функции передан некорректный URL. Однако, вы можете использовать
другую монаду, если, например, хотите проверять пользовательский ввод.
\begin{lstlisting}
import Network.HTTP.Conduit
import System.Environment (getArgs)
import qualified Data.ByteString.Lazy as L
import Control.Monad.IO.Class (liftIO)

main :: IO ()
main = do
    args <- getArgs
    case args of
        [urlString] ->
            case parseUrl urlString of
                Nothing -> putStrLn "Извините, некорректный URL"
                Just req -> withManager $ \manager -> do
                    Response _ _ _ lbs <- httpLbs req manager
                    liftIO $ L.putStr lbs
        _ -> putStrLn "Извините, передавайте, пожалуйста, только один URL"
\end{lstlisting}
Тип~\lstinline!Request! абстрактный, так что http--conduit может
добавлять новые настройки в будущем, не нарушая API (см. приложение
Settings Type для более подробной информации)\marginpar{вставить
  ссылку}. Чтобы изменить отдельные записи, используйте record
notation\marginpar{FIXME: record notation}. Например, модификация
нашей программы, которая отправляет HEAD запросы и печатает заголовки
ответа, могла бы быть такой:
\begin{lstlisting}
{-# LANGUAGE OverloadedStrings #-}
import Network.HTTP.Conduit
import System.Environment (getArgs)
import qualified Data.ByteString.Lazy as L
import Control.Monad.IO.Class (liftIO)

main :: IO ()
main = do
    args <- getArgs
    case args of
        [urlString] ->
            case parseUrl urlString of
                Nothing -> putStrLn "Извините, некорректный URL"
                Just req -> withManager $ \manager -> do
                    let reqHead = req { method = "HEAD" }
                    Response status _ headers _ <- http reqHead manager
                    liftIO $ do
                        print status
                        mapM_ print headers
        _ -> putStrLn "Извините, передавайте, пожалуйста, только один URL"
\end{lstlisting} %$

Есть целый ряд различных настроек в API, вот те, на которые стоит
обратить внимание:
\begin{description}
\item[proxy] \hfill \\
  Позволяет отправлять запросы через указанный прокси--сервер.
\item[redirectCount] \hfill \\
  Указывает количество переадресаций, по которым следовать. По
  умолчанию~--- 10.
\item[checkStatus] \hfill \\
  Проверка кода статуса ответа. По умолчанию, выбрасывает исключение
  для любого кода вне диапазона 200-х значений.
\item[requestBody] \hfill \\
  Тело запроса для отправки. Удостоверьтесь, что обновили метод. Для
  общего случая кодирования данных в URL, вы можете использовать
  функцию~\lstinline!urlEncodedBody!.
\end{description}

\section{Manager}
Менеджер соединений позволяет вам повторно использовать
соединения. При выполнении многочисленных запросов к единственному
серверу (например, обращаясь к Amazon S3), это может быть критично для
создания эффективного кода. Менеджер будет отслеживать множественные
соединения к указанному серверу (в том числе учитывая номер порта и
SSL), автоматически забирая (reaping - FIXME) неиспользуемые
соединения при необходимости. Когда вы делаете запрос, http-conduit
сначала пытается проверить существующее соединение. Когда вы закончили
работу с соединением (если сервер позволяет поддерживать открытое
соединение (keep-alive)), соединение возвращается менеджеру. Если
что-нибудь пошло не так, соединение закрывается.

Чтобы сохранить наш код от исключений (exception-safe FIXME), мы
используем преобразователь монад \lstinline!ResourceT!. Для вас это
означает, что ваш код должен быть завёрнут внутрь вызова
\lstinline!runResourceT!, неявно или явно, и код внутри этого блока
должен использовать \lstinline!liftIO! для выполнения обычных действий
ввода/вывода (IO).

Есть два пути, как вы можете сойтись (get ahold - FIXME) с
менеджером. \lstinline!newManager! вернёт нового менеджера, который не
будет закрыт автоматически (вы можете использовать
\lstinline!closeManager! для ручного закрытия), тогда как
\lstinline!withManager! откроет новый блок \lstinline!ResourceT!, даст
возможность использовать менеджера и затем автоматически закроет
\lstinline!ResourceT!, когда вы закончите. Если вы хотите использовать
\lstinline!ResourceT! для всего приложения, и вам нет необходимости
закрывать его, вам следует, видимо, использовать \lstinline!newManager!.

Обратите внимание: вы очевидным образом не хотите создавать нового
менеджера соединений для каждого запроса; это полностью противоречило бы
его назначению. Вам следует создавать \lstinline!Manager! как можно
раньше и потом совместно использовать его.

\section{Response}
Тип данных~\lstinline!Response! состоит из трёх информационных блоков:
код статуса, заголовок ответа и тело ответа. Первые два понятны;
давайте обсудим тело.

У типа данных~\lstinline!Response! есть переменная типа, чтобы дать
возможность телу запроса иметь различные типы. Если вы хотите
использовать потоковый интерфейс http-conduit, вам нужен
тип~\lstinline!Source!. Для простого интерфейса, тип будет
ленивая~\lstinline!ByteString!. Обращаю внимание, что, хотя мы и
используем ленивую~\lstinline!ByteString!, \emph{весь ответ хранится в
памяти}. Другими словами, мы не используем ленивый ввод/вывод в этом
пакете.

\fbox{\begin{minipage}[!h]{.9\linewidth}
Пакет http-conduit предоставляет ленивую реализацию модуля, которая
позволит вам считать это значение лениво, но как и любой ленивый
ввод/вывод, это не совсем безопасно и определённо недетерминировано. Но если
вам нужно, вы можете его использовать.
\end{minipage}
}

\section{http и httpLbs}
Давайте соберём всё вместе. Функция~\lstinline!http! даёт вам доступ к
потоковому интерфейсу (т.е., она возвращает \lstinline!Response!,
использующий \lstinline!BufferedSource!), тогда как
\lstinline!httpLbs! возвращает ленивую~\lstinline!ByteString!. Для
обоих вариантов возвращаемые значения находятся в
преобразователе~\lstinline!ResourceT!, так что они могут
обратиться к \lstinline!Manager! и получить соединения, корректно
обрабатываемые в случае возникновения исключений.

\fbox{\begin{minipage}[!h]{.9\linewidth}
Если вы хотите проигнорировать остаток большого тела запроса, вы
можете соединиться со стоком (sink)~\lstinline!sinkNull!. Используемое
соединение будет автоматически закрыто, что позволит вам избежать
чтения большого тела запроса по сети.
\end{minipage}
}
