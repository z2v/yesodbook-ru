monad-control

Пакет monad-control используется в нескольких местах внутри Yesod, в первую очередь для обеспечения надлежащей обработки исключений в Persistent. Это универсальный пакет, расширяющий стандартную функциональность трансформаторов монад.

Обзор

Одними из мощных, а иногда и запутанных, возможностях Haskell являются  трансформаторы монад. Они позволяют брать различные функциональности, такие как изменяемые состояния, обработка ошибок, или логинг, и легко объединять их вместе. Хотя я поклялся, что никогда не буду писать учебник по монадам, я воспользюсь слезоточивоой аналогией: монады они как луковицы. (Монады не как пироженные.) Я имею ввиду слои.

У нас есть центральная монада, также известная как внутренняя или основная монады. И вокруг этого центра, мы добавляем слои, каждый из которых добавляет новые возможности, действие которых распространяется наружу/вверх. В качестве мотивирующего примера, давайте рассмотрим монаду Error обёрнутую влкруг монады IO:

\begin{lstlisting}
newtype ErrorT e m a = ErrorT { runErrorT :: m (Either e a) }
type MyStack = ErrorT MyError IO
\end{lstlisting}

Обратите пристальное внимание: ErrorT это простой newtype вокруг Either завернутого в монаду. Если развернкть, избавляясь от newtype, получиться:

\begin{lstlisting}
type ErrorTUnwrapped e m a = m (Either e a)
\end{lstlisting}

В какой-то момент нам будет нужно выполнить некоторые IO внутри нашего MyStack. Если бы мы использовали развернутый подход, это было бы тривиально, так как у нас на пути не стоял бы конструктор ErrorT. Тем не менее, нам нужна newtype обёртка по целому ряду причин, но я не буду вдаваться в подробности почему (в конце концов это ведь не учебник по трансформаторам монад). Таким образом, решением является класс типов MonadTrans:

\begin{lstlisting}
class MonadTrans t where
    lift :: Monad m => m a -> t m a
\end{lstlisting}

Должен признать, что когда я увидел эту сигнатуру типа в первый раз, моей реакцией было замешательство и недоверие, что она хоть что-то значит. Но изучение екземпляра немного помогло:

\begin{lstlisting}
instance (Error e) => MonadTrans (ErrorT e) where
    lift m = ErrorT $ do
        a <- m
        return (Right a)
\end{lstlisting}

Всё, что мы здесь делаем это оборачиваем содержимое IO в значение Right, а затем применяем нашу newtype обёртку. Это позволяет нам взять действие которое живёт в IO, и протянуть его во внешнюю монаду.

А сейчас к делу. Для простых функций это работает очень хорошо. Например:

\begin{lstlisting}
sayHi :: IO ()
sayHi = putStrLn "Hello"

sayHiError :: ErrorT MyError IO ()
sayHiError = lift $ putStrLn "Hello"
\end{lstlisting}

Но давайте возьмём что-то посложнее, к примеру callback:

\begin{lstlisting}
withMyFile :: (Handle -> IO a) -> IO a
withMyFile = withFile "test.txt" WriteMode

sayHi :: Handle -> IO ()
sayHi handle = hPutStrLn handle "Hi there"

useMyFile :: IO ()
useMyFile = withMyFile sayHi
\end{lstlisting}

Пока все хорошо. Теперь предположим, что нам нужна версия sayHi которая имеет доступ к монаде Error:

\begin{lstlisting}
sayHiError :: Handle -> ErrorT MyError IO ()
sayHiError handle = do
    lift $ hPutStrLn handle "Hi there, error!"
    throwError MyError
\end{lstlisting}

Мы бы хотели написать функцию которая объединяет withMyFile и sayHiError. К сожалению, GHC не очень это любит:

\begin{lstlisting}
useMyFileErrorBad :: ErrorT MyError IO ()
useMyFileErrorBad = withMyFile sayHiError

    Couldn't match expected type `ErrorT MyError IO ()'
                with actual type `IO ()'
\end{lstlisting}

Почему это происходит и как мы можем это обойти?

Интуиция

Давайте попробуем интуитивно понять, что здесь происходит. Трансформатор монады ErrorT добавляет дополнительную функциональность к монаде IO. Мы добавляем эту новую функциональность к обычним действиям IO таким образом: используем конструктор Right и оборачиваем всё в ErrorT. Используя Right мы обозначаем, что всё прошло успешно, и не было никаких ошибок.

Это интуитивно имеет смысл: поскольку монада IO не имеет концепции возврата MyError, когда что-то идет не так, она всегда будет успешна в фазе протягивания. (Примечание: Это не имеет ничего общего с исключениями времени исполнения, даже не думайте о них). То что у нас есть, это гарантированное однонаправленное преобразование вверх по стеку монад.

Давайте возьмём другой пример: монаду Reader. Reader имеет доступ к некоторой информации находящейся вокруг. Всё что исполняется во внутренней монаде ничего не знает об этой дополнительной информации. Так как вы будете протягивать? Всего навсего игнорируйте эту информацию. А монада Writer? Ничего не пишите. Монада State? Ничего не меняйте. Я вижу здесь  закономерность. 

А теперь давайте попробуем пойти в обратном направлении: допустим у меня что-то в монаде Reader, и я хотел бы исполнять это в основной монаде (например IO). Ну... это не будет работать, не так ли? Мне нужна эта дополнительная информация, я завишу от неё, а она не доступна. В общем нет способа пройти в обратном направлении не предоставляя этого дополнительного значения.

Или есть? Если вы помните, ранее мы специально обратили внимание на то что ErrorT всего лишь обёртка вокруг внутренней монады. Другими словами, если у меня есть errorValue :: ErrorT MyError IO MyValue, я могу применить runErrorT и получить значение типа IO (Either MyError MyValue). Это вполне выглядит как двунаправленное преобразование, не так ли?

Честно, не вполне. Изначально у нас была монада ErrorT MyError IO, с типом значения MyValue. А сейчас у нас монада IO с типом значения Either MyError MyValue. Таким образом, этот процесс на самом деле изменил значение, в то время как протягивание оставляет его тем же.

Но тем не менее, со небольшим чудным манёвром мы можем развернуть ErrorT, обработать данные,  обернуть его снова.

\begin{lstlisting}
useMyFileError1 :: ErrorT MyError IO ()
useMyFileError1 =
    let unwrapped :: Handle -> IO (Either MyError ())
        unwrapped handle = runErrorT $ sayHiError handle
        applied :: IO (Either MyError ())
        applied = withMyFile unwrapped
        rewrapped :: ErrorT MyError IO ()
        rewrapped = ErrorT applied
     in rewrapped
\end{lstlisting}

Это ключевой момент всей этой статьи, так что смотрите внимательно. Сначала мы разворачиваем нашу монаду. Это означает, что для внешнего мира, это теперь старое доброе значение IO. Внутри мы храним всю информацию про наш трансформатор ErrorT. Теперь когда у нас есть просто IO, мы можем легко передать его withMyFile. withMyFile принимает внутреннее состояние и возвращает его обратно без изменений. В заключение, мы оборачиваем всё обратно в наш оригинальный ErrorT.

Вот весь принцип monad-control: мы вкладываем дополнительные возможности нашего трансформатора монады в значение. Попав в значение, система типов игнорирует его и сосредотачивается на внутренней монаде. Как только мы закончили работать с внутренней монадой, мы можем вытащить наше состояние обратно и восстановить наш исходный стек монад.

Типы

Я нарочно начал с трансформатора ErrorT, так как он один из самых простых для этого механизма инверсии. К сожалению, другие немного сложнее. Возьмём, к примеру ReaderT. Он определяется как newtype ReaderT r m a = ReaderT { runReaderT :: r -> m a }. Если мы к нему применим runReaderT, мы получим функцию которая возвращает монадическое значение. Так что нам понадобятся дополнительные механизмы что бы с этим справиться. И здесь мы попадаем в Волшебную страну.

Есть несколько подходов к решению этих проблем. В прошлом я реализовал решение используя семейство типов в пакете neither. Anders Kaseorg реализовал намного более простое решение в пакете monad-peel. А для эффективности, в monad-control, Bas van Dijk использует стиль передачи продолжения (Continuation Passing Style, сокращённо CPS) и екзистенциальные типы.

Код взятый из monad-control на самом деле относиться к версии 0.2. В версии 0.3 некоторые вещи немного поменялись, состояние сделали явным с ассоциированым типом, а MonadControlIO обобщили до MonadBaseControl, но концепция всё ещё таже.

Первым типом который мы рассмотрим будет:

\begin{lstlisting}
type Run t = forall n o b. (Monad n, Monad o, Monad (t o)) => t n b -> n (t o b)
\end{lstlisting}

Это определение невероятно туманно, давайте его разберём. Единственным "входным" параметром типа является t, трансформатор монады. Run это функция которая будет работать для любой комбинации типов n, o и b (это то что означает forall). Типы n и o оба являються монадами, а b это просто значение которое содержиться в них.

Левая часть функции Run, t n b, это наш трансформатор монады обёрнутый вокруг монады n и содержащий значение b. К примеру, это может быть MyTrans FirstMonad MyValue. А возвращает она значение, в котором трансформатор "проглочен" всередину, с совсем новой центральной монадой. Другими словами, FirstMonad (MyTrans NewMonad MyValue). 

По началу это может выглядеть устрашающе, но на самом деле это не так уж незнакомо как вы могли б подумать: это по сути то что мы делали с ErrorT. Мы начали с ErrorT снаружи, оборачивающем IO, а закончили с самим IO содержащим Either. Знаете что, другой способ представить ErrorT это ErrorT MyError Identity. Так что по существу мы вытянули IO наружу и поместили на её место Identity. Тоже самое мы делаем в Run: вытягиваем первую монаду наружу замещая её новой монадой.

Возможно сейчас хорошее время для глотка пива.

Хорошо, сейчас мы уже куда-то приблизились. Если бы у нас был доступ к одной из этих функций Run, мы могли бы использовать её для снятия ErrorT с результата нашей функции sayHiError, и передачи его в withMyFile. С помощью магии undefined мы можем сыграть в эту игру:

\begin{lstlisting}
errorRun :: Run (ErrorT MyError)
errorRun = undefined

useMyFileError2 :: IO (ErrorT MyError Identity ())
useMyFileError2 =
    let afterRun :: Handle -> IO (ErrorT MyError Identity ())
        afterRun handle = errorRun $ sayHiError handle
        applied :: IO (ErrorT MyError Identity ())
        applied = withMyFile afterRun
     in applied
\end{lstlisting}

Это выглядит очень похоже на предыдущий пример. Фактически, errorRun ведёт себя почти так же как и runErrorT. Однако, у нас всё ещё есть две проблеммы: мы не знаем где взять значение errorRun, и кроме того нам надо восстановить оригинальный ErrorT после того как мы закончим.

MonadTransControl

Очевидно что в данном случае мы могли бы использовать наши знания пр отрасформатор ErrorT, что бы положить систему типов на лопатки и написать функцию Run вручную. Но на самом деле нам необходимо решение общее для многих трансформаторов. В таком случае, ка вы знаете нам нужен класс типов.

Итак, давайте повторим, что нам нужно: доступиться к функции Run, а затем каким-то образом восстановить наш оригинальный трансформатор. Так получился MonadTransControl, с одним методом liftControl:

\begin{lstlisting}
class MonadTrans t => MonadTransControl t where
    liftControl :: Monad m => (Run t -> m a) -> t m a
\end{lstlisting}

Давайте посмотрим на это внимательно. Метод liftControl принимает функцию (которую нам следует написать). Параметром этой функции является функция Run, а результатом значение в некоторой монаде (m). Затем liftControl возьмёт этот результат и восстановит оригинальный трансформатор на вершине всего.

\begin{lstlisting}
useMyFileError3 :: Monad m => ErrorT MyError IO (ErrorT MyError m ())
useMyFileError3 =
    liftControl inside
  where
    inside :: Monad m => Run (ErrorT MyError) -> IO (ErrorT MyError m ())
    inside run = withMyFile $ helper run
    helper :: Monad m
           => Run (ErrorT MyError) -> Handle -> IO (ErrorT MyError m ())
    helper run handle = run (sayHiError handle :: ErrorT MyError IO ())
\end{lstlisting}

Близко, но не совсем то, что я имел в виду. Почему две монады? Ну, давайте начнем с конца: sayHiError handle возвращает значение типа ErrorT MyError IO (). Это мы уже знаем, никаких сюрпизов. Что может быть немного удивительно (по крайней мере для меня) это следующие два шага.

Сначала мы применяем run к этому значению. В результате чего, как мы уже обсуждали ранее, внутренняя монада IO извлекается наружу, что бы быть замененой некоторой произвольной монадой (представленной здесь как m). Таким образом, мы в конечном итоге получаем IO (ErrorT MyError m ()). Хорошо... Итак мы получим тот же результат после применения withMyFile. Не удивительно.

У меня заняло много времени, что бы правильно понять последний шаг. Помните, как мы говорили, про восстановление исходного трансформатор? Ну, так мы и делаем: плюхая его  его прямо на все остальное. Таким образом, наш конечный результат будет предыдущего типа - IO (ErrorT MyError m ()) - с MyError ErrorT приклееным спереди.

Кажется, почти бесполезно, верно? Ну, почти. Но не стоит забывать, что "m" может быть любой монадой, в том числе IO. Если рассматривать это таким образом, то мы получем ErrorT MyError IO (ErrorT MyError IO ()). Это похоже на m (m a), а мы хотим просто старую доброю m. К счастью, сейчас нам улыбнулась удача:

\begin{lstlisting}
useMyFileError4 :: ErrorT MyError IO ()
useMyFileError4 = join useMyFileError3
\end{lstlisting}

И оказывается, что это использование так часто, что Bas сжалился над нами и определил вспомогательную функцию:

\begin{lstlisting}
control :: (Monad m, Monad (t m), MonadTransControl t)
        => (Run t -> m (t m a)) -> t m a
control = join . liftControl
\end{lstlisting}

Так что всё что нам надо написать это:

\begin{lstlisting}
useMyFileError5 :: ErrorT MyError IO ()
useMyFileError5 =
    control inside
  where
    inside :: Monad m => Run (ErrorT MyError) -> IO (ErrorT MyError m ())
    inside run = withMyFile $ helper run
    helper :: Monad m
           => Run (ErrorT MyError) -> Handle -> IO (ErrorT MyError m ())
    helper run handle = run (sayHiError handle :: ErrorT MyError IO ())
\end{lstlisting}

Или же немного короче:

\begin{lstlisting}
useMyFileError6 :: ErrorT MyError IO ()
useMyFileError6 = control $ \run -> withMyFile $ run . sayHiError
\end{lstlisting}

MonadControlIO

Класс MonadTrans предоставляет метод lift, который позволяет протягивать действие на один уровень по стеку монад. Также существует класс MonadIO предоставляющий метод liftIO, который протягивает действие IO так далеко по стеку как хочется. У нас такая же схема организации в monad-control. Но сперва, нам нужно следствие Run:

\begin{lstlisting}
type RunInBase m base = forall b. m b -> base (m b)
\end{lstlisting}

Вместо того что бы иметь дело с трансформатором мы работаем с двумя монадами. Монада base это основная монада, а m это стек построеный на ней. Фнкция RunInBase берёт значение всего стека, вытягивает base, и размещает её снаружи. В отличии от типа Run, мы не замещали её произвольной монадой, а использовали исходную. Используя конкретные типы:

\begin{lstlisting}
RunInBase (ErrorT MyError IO) IO = forall b. ErrorT MyError IO b -> IO (ErrorT MyError IO b)
\end{lstlisting}

Это очень похоже на то, что мы рассматривали до сих пор, с той лишь разницей, что тут мы хотим иметь дело с конкретной внутренней монадой. На самом деле класс MonadControlIOэто просто расширение MonadControlTrans с помощью RunInBase.

\begin{lstlisting}
class MonadIO m => MonadControlIO m where
    liftControlIO :: (RunInBase m IO -> IO a) -> m a
\end{lstlisting}

Проще говоря, liftControlIO берёт функцию, которая получает RunInBase. Эта RunInBase может быть использована для разбора нашей монады до простой IO, а затем liftControlIO снова выстраивает всё назад. Так же, как и MonadControlTrans, она поставляется со вспомогательной функцией

\begin{lstlisting}
controlIO :: MonadControlIO m => (RunInBase m IO -> IO (m a)) -> m a
controlIO = join . liftControlIO
\end{lstlisting}

Используя её мы легко можем переписать наш предыдущий пример:

\begin{lstlisting}
useMyFileError7 :: ErrorT MyError IO ()
useMyFileError7 = controlIO $ \run -> withMyFile $ run . sayHiError
\end{lstlisting}

И, как преимущество, она легко масштабируется на несколько трансформаторов:

\begin{lstlisting}
sayHiCrazy :: Handle -> ReaderT Int (StateT Double (ErrorT MyError IO)) ()
sayHiCrazy handle = liftIO $ hPutStrLn handle "Madness!"

useMyFileCrazy :: ReaderT Int (StateT Double (ErrorT MyError IO)) ()
useMyFileCrazy = controlIO $ \run -> withMyFile $ run . sayHiCrazy
\end{lstlisting}

Примеры из реальной жизни

Давайте используя этот код решим несколько задач из реальной жизни. Наверное, самый мотивирующий вариант использования это обработка исключений в стеке трансформатора. Например, предположим, что мы хотим автоматически исполнять некоторый код освобождения ресурсов, когда брошено исключение. Если бы это был обычный IO код, мы бы использовали:

\begin{lstlisting}
onException :: IO a -> IO b -> IO a
\end{lstlisting}

Но если мы в монаде ErrorT, мы не можем передать либо действие либо очистка. На помощь приходит controlIO:

\begin{lstlisting}
onExceptionError :: ErrorT MyError IO a
                 -> ErrorT MyError IO b
                 -> ErrorT MyError IO a
onExceptionError action after = controlIO $ \run ->
    run action `onException` run after
\end{lstlisting}

Допустим нам надо выделить некоторый объем памяти для хранения Double. В монаде IO, мы могли бы просто использовать функцию alloca. И опять наше решение очень простое:

\begin{lstlisting}
allocaError :: (Ptr Double -> ErrorT MyError IO b)
            -> ErrorT MyError IO b
allocaError f = controlIO $ \run -> alloca $ run . f
\end{lstlisting}

Потерянное состояние

Давайте вернёмся к onExceptionError. Под поверхностью она использует OnException которая имеет сигнатур типа: IO a -> IO b -> IO a. Позвольте мне спросить вас: а что случилось с b в резльтате? Хорошо, оно было совершенно проигнорировано. Но это, кажется, вызывает у нас небольшую проблему. Ведь в конце концов, мы сохраняем информацию о состоянии нашего трансформатора в значении внутренней монады. А если мы игнорируем это, мы по существу также игнорируем монадические побочные эффекты!

А ответ в том, что, да, так это происходит в monad-control. Некоторые функции будут терять некоторые из монадических побочных эффектов. Лучше всего это описал Bas, в комментариях к соответствующей функции:

Обратите внимание, что любые монадические побочные эффекты в m в коде "освобождения ресурсов" будут отброшены, он будет исполнен только ради его побочных эффектов в IO.

На практике, monad-control будет, как правило, делать то что надо для вас, но вы должны быть осведомлены, что некоторые побочные эффекты могут исчезать.

Более сложные случаи

До сих пор, для того, чтобы наши трюки работали, мы должны были иметь функции, которые дают нам полный доступ к своим значениями. Иногда это не тот случай. Возьмем, к примеру:

\begin{lstlisting}
addMVarFinalizer :: MVar a -> IO () -> IO ()
\end{lstlisting}

В этом случае, от нас требуеться не иметь никакого значения в нашей функци завершения. Интуитивно понятно, что первым делом мы должны заметить, что не будет никакого способа, чтобы захватить наши монадические побочные эффекты. Так как же мы сможем что-то вроде такого заставить компилироватья? Хорошо, нам необходимо явно указать отказаться от всей своей информации сохраняющей состояние:

\begin{lstlisting}
addMVarFinalizerError :: MVar a -> ErrorT MyError IO () -> ErrorT MyError IO ()
addMVarFinalizerError mvar f = controlIO $ \run ->
    return $ liftIO $ addMVarFinalizer mvar (run f >> return ())
\end{lstlisting}

Другой случай из той же модуля:

\begin{lstlisting}
modifyMVar :: MVar a -> (a -> IO (a, b)) -> IO b
\end{lstlisting}

Здесь, у нас есть ограничения на тип возвращаемого значения во втором аргументе: это должен быть кортеж со значением, переданным в функцию и окончательным возвратным значением. К сожалению, я не вижу способ написания небольшой обертки вокруг modifyMVar что бы заставить ее работать с ErrorT. Вместо этого, в данном случае я скопировал определение modifyMVar и изменил его:

\begin{lstlisting}
modifyMVar :: MVar a
           -> (a -> ErrorT MyError IO (a, b))
           -> ErrorT MyError IO b
modifyMVar m io =
  Control.Exception.Control.mask $ \restore -> do
    a      <- liftIO $ takeMVar m
    (a',b) <- restore (io a) `onExceptionError` liftIO (putMVar m a)
    liftIO $ putMVar m a'
    return b
\end{lstlisting}
