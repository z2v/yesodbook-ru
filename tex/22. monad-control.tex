monad-control

Пакет monad-control используется в нескольких местах внутри Yesod, в первую очередь для обеспечения надлежащей обработки исключений в Persistent. Это универсальный пакет, расширяющий стандартную функциональность трансформаторов монад.

Обзор

Одними из мощных, а иногда и запутанных, возможностей Haskell являются трансформаторы монад. Они позволяют брать различные части функциональности, такие как изменяемые состояния, обработка ошибок, или логинг, и легко объединять их вместе. Хоть я и поклялся, что никогда не буду писать учебник по монадам, я воспользюсь слезоточивой аналогией: монады они как луковицы. (Монады не как пироженные.) Под этим я имею ввиду слои.

У нас есть центральная монада, также известная как внутренняя или основная монады. И вокруг этого центра, мы добавляем слои, каждый из которых добавляет новые возможности, действие которых распространяется наружу/вверх. В качестве мотивирующего примера, давайте рассмотрим монаду Error обёрнутую вокруг монады IO:

\begin{lstlisting}
newtype ErrorT e m a = ErrorT { runErrorT :: m (Either e a) }
type MyStack = ErrorT MyError IO
\end{lstlisting}

Обратите пристальное внимание: ErrorT это простой newtype вокруг Either завернутого в монаду. Если развернуть это выражение, избавляясь от newtype, у нас получится:

\begin{lstlisting}
type ErrorTUnwrapped e m a = m (Either e a)
\end{lstlisting}

В какой-то момент нам будет нужно выполнить некоторый IO внутри нашего MyStack. Если бы мы использовали развернутый подход, это было бы тривиально, так как у нас на пути не стоял бы конструктор ErrorT. Тем не менее, нам нужна newtype обёртка по целому ряду причин, но я не буду вдаваться в подробности почему (в конце концов это ведь не учебник по трансформаторам монад). Таким образом, решением является класс типов MonadTrans:

\begin{lstlisting}
class MonadTrans t where
    lift :: Monad m => m a -> t m a
\end{lstlisting}

Должен признать, что когда я увидел эту сигнатуру типа в первый раз, моей реакцией было замешательство и недоумение, что она хоть что-то значит. Но изучение екземпляра класса немного помогло:

\begin{lstlisting}
instance (Error e) => MonadTrans (ErrorT e) where
    lift m = ErrorT $ do
        a <- m
        return (Right a)
\end{lstlisting}

Всё, что мы здесь делаем это оборачиваем содержимое IO в значение Right, а затем применяем нашу newtype обёртку. Это позволяет нам взять действие которое живёт в IO, и протянуть его во внешнюю/верхнюю монаду.

А сейчас к делу. Для простых функций это работает очень хорошо. Например:

\begin{lstlisting}
sayHi :: IO ()
sayHi = putStrLn "Hello"

sayHiError :: ErrorT MyError IO ()
sayHiError = lift $ putStrLn "Hello"
\end{lstlisting}

Но давайте возьмём что-то посложнее, к примеру callback:

\begin{lstlisting}
withMyFile :: (Handle -> IO a) -> IO a
withMyFile = withFile "test.txt" WriteMode

sayHi :: Handle -> IO ()
sayHi handle = hPutStrLn handle "Hi there"

useMyFile :: IO ()
useMyFile = withMyFile sayHi
\end{lstlisting}

Пока все хорошо, верно? Теперь предположим, что нам нужна версия sayHi которая имеет доступ к монаде Error:

\begin{lstlisting}
sayHiError :: Handle -> ErrorT MyError IO ()
sayHiError handle = do
    lift $ hPutStrLn handle "Hi there, error!"
    throwError MyError
\end{lstlisting}

И мы бы хотели написать функцию которая объединяет withMyFile и sayHiError. К сожалению, GHC это не очень нравиться:

\begin{lstlisting}
useMyFileErrorBad :: ErrorT MyError IO ()
useMyFileErrorBad = withMyFile sayHiError

    Couldn't match expected type `ErrorT MyError IO ()'
                with actual type `IO ()'
\end{lstlisting}

Почему это происходит и как мы можем это обойти?

Интуиция

Давайте попробуем интуитивно понять, что здесь происходит. Трансформатор монады ErrorT добавляет дополнительную функциональность к монаде IO. Мы добавляем эту новую функциональность к обычним действиям IO таким образом: используем конструктор Right и оборачиваем всё в ErrorT. Используя Right мы обозначаем, что всё прошло успешно, и не было никаких ошибок.

Это интуитивно имеет смысл: поскольку монада IO не имеет концепции возврата MyError, когда что-то идет не так, она всегда будет успешна в вызове lift. (Примечание: Это не имеет ничего общего с исключениями времени исполнения, даже не думайте о них). То что у нас есть, это гарантированное однонаправленное преобразование вверх по стеку монад.

Давайте возьмём другой пример: монаду Reader. Reader имеет доступ к некоторым дополнительным данным. То что исполняется во внутренней монаде ничего не знает об этой дополнительной информации. Так как вы реализуете lift? Всего навсего игнорируйте эту информацию. А монада Writer? Ничего не пишите. Монада State? Ничего не меняйте. Я вижу здесь закономерность. 

А теперь давайте попробуем пойти в обратном направлении: допустим у меня что-то исполняется в монаде Reader, и я хотел бы исполнить это в основной монаде (например IO). Хорошо... это не будет работать, не так ли? Ведь мне нужна эта дополнительная информация, я завишу от неё, а она не доступна. В общем нет способа пройти в обратном направлении не предоставляя этого дополнительного значения.

Или есть? Если вы помните, ранее мы специально обратили внимание на то что ErrorT всего лишь обёртка вокруг внутренней монады. Другими словами, если у меня есть errorValue :: ErrorT MyError IO MyValue, я могу применить runErrorT и получить значение типа IO (Either MyError MyValue). Это вполне похоже на двунаправленное преобразование, не так ли?

Честно, не вполне. Изначально у нас была монада ErrorT MyError IO, со значением типа MyValue. А сейчас у нас монада IO со значением типа Either MyError MyValue. Таким образом, этот процесс на самом деле изменил значение, в то время как вызов lift оставляет его тем же.

Но тем не менее, с небольшим манёвром мы можем развернуть ErrorT, обработать данные, и обернуть его снова.

\begin{lstlisting}
useMyFileError1 :: ErrorT MyError IO ()
useMyFileError1 =
    let unwrapped :: Handle -> IO (Either MyError ())
        unwrapped handle = runErrorT $ sayHiError handle
        applied :: IO (Either MyError ())
        applied = withMyFile unwrapped
        rewrapped :: ErrorT MyError IO ()
        rewrapped = ErrorT applied
     in rewrapped
\end{lstlisting}

Это ключевой момент всей статьи, так что смотрите внимательно. Сначала мы разворачиваем нашу монаду. Это означает, что для внешнего мира, это теперь старое доброе значение IO. Внутри мы сберегли всю информацию про наш трансформатор ErrorT. Теперь когда у нас есть просто IO, мы можем легко передать его withMyFile. withMyFile принимает внутреннее состояние и возвращает его обратно без изменений. В конце мы оборачиваем всё обратно в наш оригинальный ErrorT.

В этом весь принцип monad-control: мы вкладываем дополнительные возможности нашего трансформатора монады в значение. Как только они попадают в значение, система типов игнорирует его и сосредотачивается на внутренней монаде. Как только мы закончили работать с внутренней монадой, мы можем вытащить наше состояние обратно и восстановить наш исходный стек монад.

Типы

Я нарочно начал с трансформатора ErrorT, так как он один из самых простых для этого механизма обращения. К сожалению, другие немного сложнее. Возьмём, к примеру ReaderT. Он определяется как newtype ReaderT r m a = ReaderT { runReaderT :: r -> m a }. Если мы к нему применим runReaderT, мы получим функцию которая возвращает монадическое значение. Так что нам понадобятся дополнительные механизмы что бы с этим справиться. И здесь мы попадаем в Волшебную страну.

Есть несколько подходов к решению этих проблем. В прошлом я реализовал решение используя семейство типов в пакете neither. Anders Kaseorg реализовал намного более простое решение в пакете monad-peel. А для эффективности, в monad-control, Bas van Dijk использует стиль передачи продолжения (Continuation Passing Style, сокращённо CPS) и екзистенциальные типы.

Код взятый из monad-control на самом деле относиться к версии 0.2. В версии 0.3 некоторые вещи немного поменялись, состояние сделали явным с ассоциированым типом, а MonadControlIO обобщили до MonadBaseControl, но концепция всё ещё та же.

Первым типом который мы рассмотрим будет:

\begin{lstlisting}
type Run t = forall n o b. (Monad n, Monad o, Monad (t o)) => t n b -> n (t o b)
\end{lstlisting}

Это определение невероятно туманно, давайте его разберём. Единственным "входным" параметром типа является t, трансформатор монады. Run это функция которая будет работать для любой комбинации типов n, o и b (это то что означает forall). Типы n и o оба являються монадами, а b это просто значение которое содержиться в них.

Левая часть функции Run, t n b, это наш трансформатор монады обёрнутый вокруг монады n и содержащий значение b. К примеру, это может быть MyTrans FirstMonad MyValue. А возвращает она значение, в котором трансформатор "проглочен" всередину, с совсем новой центральной монадой. Другими словами, FirstMonad (MyTrans NewMonad MyValue). 

По началу это может выглядеть устрашающе, но на самом деле это не так уж незнакомо как вы могли б подумать: это по сути то что мы делали с ErrorT. Мы начали с ErrorT снаружи, оборачивающем IO, а закончили с IO, уже самим содержащим Either. Знаете что, другой способ представить Either это ErrorT MyError Identity? Так что по существу мы вытянули IO наружу и поместили на её место Identity. Тоже самое мы делаем в Run: вытягиваем монаду FirstMonad наружу замещая её монадой NewMonad.

Сейчас хорошее время для глотка пива.

Хорошо, сейчас мы уже куда-то приблизились. Если бы у нас был доступ к одной из этих функций Run, мы могли бы использовать её для снятия ErrorT с результата нашей функции sayHiError, и передачи его в withMyFile. С помощью магии undefined мы можем сыграть в эту игру:

\begin{lstlisting}
errorRun :: Run (ErrorT MyError)
errorRun = undefined

useMyFileError2 :: IO (ErrorT MyError Identity ())
useMyFileError2 =
    let afterRun :: Handle -> IO (ErrorT MyError Identity ())
        afterRun handle = errorRun $ sayHiError handle
        applied :: IO (ErrorT MyError Identity ())
        applied = withMyFile afterRun
     in applied
\end{lstlisting}

Это выглядит очень похоже на предыдущий пример. Фактически, errorRun ведёт себя почти так же как и runErrorT. Однако, у нас всё ещё есть две проблеммы: мы не знаем где взять значение errorRun, и кроме того нам надо восстановить оригинальный ErrorT после того как мы закончим.

MonadTransControl

Очевидно что в данном случае мы могли бы использовать наши знания про трасформатор ErrorT, что бы положить систему типов на лопатки и написать функцию Run вручную. Но на самом деле нам необходимо решение общее для многих трансформаторов. В таком случае, как вы знаете нам нужен класс типов.

Итак, давайте повторим, что нам нужно: доступиться к функции Run, а затем каким-то образом восстановить наш оригинальный трансформатор. Таким образом получим MonadTransControl, с одним методом liftControl:

\begin{lstlisting}
class MonadTrans t => MonadTransControl t where
    liftControl :: Monad m => (Run t -> m a) -> t m a
\end{lstlisting}

Давайте посмотрим на это внимательно. Метод liftControl принимает функцию (которую нам следует написать). Параметром этой функции является функция Run, а результатом значение в некоторой монаде (m). Затем liftControl возьмёт этот результат и восстановит оригинальный трансформатор вокруг всего.

\begin{lstlisting}
useMyFileError3 :: Monad m => ErrorT MyError IO (ErrorT MyError m ())
useMyFileError3 =
    liftControl inside
  where
    inside :: Monad m => Run (ErrorT MyError) -> IO (ErrorT MyError m ())
    inside run = withMyFile $ helper run
    helper :: Monad m
           => Run (ErrorT MyError) -> Handle -> IO (ErrorT MyError m ())
    helper run handle = run (sayHiError handle :: ErrorT MyError IO ())
\end{lstlisting}

Близко, но не совсем то, что я имел в виду. Почему двойные монады? Хорошо, давайте начнем с конца: sayHiError handle возвращает значение типа ErrorT MyError IO (). Это мы уже знаем, никаких сюрпизов. Что может быть немного удивительно (по крайней мере для меня) это следующие два шага.

Сначала мы применяем run к этому значению. В результате чего, как мы уже обсуждали ранее, внутренняя монада IO извлекается наружу, что бы быть замененой некоторой произвольной монадой (представленной здесь как m). Таким образом, мы в конечном итоге имеем IO (ErrorT MyError m ()). Затем мы получем тот же результат после применения withMyFile. Не удивительно.

У меня заняло много времени, что бы правильно понять последний шаг. Помните, как мы говорили, про восстановление исходного трансформатора? Ну, так мы это и делаем: плюхаем его прямо на все остальное. Таким образом, наш конечный результат будет предыдущего типа - IO (ErrorT MyError m ()) - с ErrorT MyError приклееным спереди.

Кажется, почти бесполезно, верно? Ну, почти. Но не стоит забывать, что "m" может быть любой монадой, в том числе IO. Если рассматривать это таким образом, то мы получем ErrorT MyError IO (ErrorT MyError IO ()). Это похоже на m (m a), а мы хотим просто m a. К счастью, сейчас нам улыбнулась удача:

\begin{lstlisting}
useMyFileError4 :: ErrorT MyError IO ()
useMyFileError4 = join useMyFileError3
\end{lstlisting}

И оказывается, что такое использование настолько обычное, что Bas сжалился над нами и определил вспомогательную функцию:

\begin{lstlisting}
control :: (Monad m, Monad (t m), MonadTransControl t)
        => (Run t -> m (t m a)) -> t m a
control = join . liftControl
\end{lstlisting}

Так что всё что нам надо написать, это:

\begin{lstlisting}
useMyFileError5 :: ErrorT MyError IO ()
useMyFileError5 =
    control inside
  where
    inside :: Monad m => Run (ErrorT MyError) -> IO (ErrorT MyError m ())
    inside run = withMyFile $ helper run
    helper :: Monad m
           => Run (ErrorT MyError) -> Handle -> IO (ErrorT MyError m ())
    helper run handle = run (sayHiError handle :: ErrorT MyError IO ())
\end{lstlisting}

Или же немного короче:

\begin{lstlisting}
useMyFileError6 :: ErrorT MyError IO ()
useMyFileError6 = control $ \run -> withMyFile $ run . sayHiError
\end{lstlisting}

MonadControlIO

Класс MonadTrans предоставляет метод lift, который позволяет протягивать действие на один уровень по стеку монад. Также существует класс MonadIO предоставляющий метод liftIO, который протягивает действие IO так далеко по стеку как хочется. У нас такое же разделение в monad-control. Но сперва, нам нужно функцию подобную Run:

\begin{lstlisting}
type RunInBase m base = forall b. m b -> base (m b)
\end{lstlisting}

Вместо того что бы иметь дело с трансформатором, мы работаем с двумя монадами. Монада base это основная монада, а m это стек построеный на ней. RunInBase это функция которая берёт значение всего стека, вытягивает base, и размещает её снаружи. В отличии от типа Run, мы не замещали её произвольной монадой, а использовали исходную. Пример с конкретными типами:

\begin{lstlisting}
RunInBase (ErrorT MyError IO) IO = forall b. ErrorT MyError IO b -> IO (ErrorT MyError IO b)
\end{lstlisting}

Это очень похоже на то, что мы рассматривали до сих пор, с той лишь разницей, что тут мы хотим иметь дело с конкретной внутренней монадой. На самом деле класс MonadControlIO это просто расширение MonadControlTrans с помощью RunInBase.

\begin{lstlisting}
class MonadIO m => MonadControlIO m where
    liftControlIO :: (RunInBase m IO -> IO a) -> m a
\end{lstlisting}

Проще говоря, liftControlIO принимает функцию, которая принимает RunInBase. Эта RunInBase может быть использована для разбора нашей монады до простой IO, а затем liftControlIO выстраивает всё назад. Так же, как и MonadControlTrans, он поставляется со вспомогательной функцией

\begin{lstlisting}
controlIO :: MonadControlIO m => (RunInBase m IO -> IO (m a)) -> m a
controlIO = join . liftControlIO
\end{lstlisting}

Используя её мы легко можем переписать наш предыдущий пример:

\begin{lstlisting}
useMyFileError7 :: ErrorT MyError IO ()
useMyFileError7 = controlIO $ \run -> withMyFile $ run . sayHiError
\end{lstlisting}

И, как преимущество, она легко масштабируется на несколько трансформаторов:

\begin{lstlisting}
sayHiCrazy :: Handle -> ReaderT Int (StateT Double (ErrorT MyError IO)) ()
sayHiCrazy handle = liftIO $ hPutStrLn handle "Madness!"

useMyFileCrazy :: ReaderT Int (StateT Double (ErrorT MyError IO)) ()
useMyFileCrazy = controlIO $ \run -> withMyFile $ run . sayHiCrazy
\end{lstlisting}

Примеры из реальной жизни

Давайте используя этот код решим несколько задач из реальной жизни. Наверное, самый мотивирующий вариант использования это обработка исключений в стеке трансформатора. Например, предположим, что мы хотим автоматически исполнять некоторый код очистки, когда брошено исключение. Если бы это был обычный IO код, мы бы использовали:

\begin{lstlisting}
onException :: IO a -> IO b -> IO a
\end{lstlisting}

Но если мы в монаде ErrorT, мы не можем передать ни действие ни очистку. На помощь приходит controlIO:

\begin{lstlisting}
onExceptionError :: ErrorT MyError IO a
                 -> ErrorT MyError IO b
                 -> ErrorT MyError IO a
onExceptionError action after = controlIO $ \run ->
    run action `onException` run after
\end{lstlisting}

Или допустим нам надо выделить некоторый объем памяти для хранения Double. Для этого мы могли бы просто использовать функцию alloca в монаде IO. И опять наше решение очень простое:

\begin{lstlisting}
allocaError :: (Ptr Double -> ErrorT MyError IO b)
            -> ErrorT MyError IO b
allocaError f = controlIO $ \run -> alloca $ run . f
\end{lstlisting}

Потерянное состояние

Давайте вернёмся к onExceptionError. В реализации она использует OnException которая имеет сигнатуру типа: IO a -> IO b -> IO a. Позвольте мне спросить вас: а что случилось с b в резльтате? Оно было совершенно проигнорировано. Но это, кажется, вызывает у нас небольшую проблему. Ведь в конце концов, мы сохраняем информацию о состоянии нашего трансформатора в значении внутренней монады. А если мы игнорируем это, мы по существу также игнорируем монадические побочные эффекты!

А ответ в том, что, да, так это происходит в monad-control. Некоторые функции будут терять какие-то из монадических побочных эффектов. Лучше всего это описал Bas, в комментариях к соответствующей функции:

Обратите внимание, что любые монадические побочные эффекты в m кода "очистки" будут отброшены, он будет исполнен только ради его побочных эффектов в IO.

На практике, monad-control будет, как правило, делать то что надо для вас, но вы должны быть осведомлены, что некоторые побочные эффекты могут исчезать.

Более сложные случаи

До сих пор, для того, чтобы наши трюки работали, нам были нужны функции, которые дают полный доступ к своим значениями. Иногда это не тот вариант. Возьмем, к примеру:

\begin{lstlisting}
addMVarFinalizer :: MVar a -> IO () -> IO ()
\end{lstlisting}

В этом случае, от нас требуеться не иметь никакого значения в нашей функци завершения. Интуитивно понятно, что первым делом мы должны заметить, что нет никакого способа захватить наши монадические побочные эффекты. Так как же мы сможем что-то вроде такого заставить компилироватья? Хорошо, нам необходимо явно указать отказаться от всей информации сохраняющей состояние:

\begin{lstlisting}
addMVarFinalizerError :: MVar a -> ErrorT MyError IO () -> ErrorT MyError IO ()
addMVarFinalizerError mvar f = controlIO $ \run ->
    return $ liftIO $ addMVarFinalizer mvar (run f >> return ())
\end{lstlisting}

Другой случай из того же модуля:

\begin{lstlisting}
modifyMVar :: MVar a -> (a -> IO (a, b)) -> IO b
\end{lstlisting}

Здесь, у нас есть ограничения на тип возвращаемого значения во втором аргументе: это должен быть кортеж со значением, переданным в функцию и окончательным значением результата. К сожалению, я не вижу способа написать небольшую обертку вокруг modifyMVar, что бы заставить её работать с ErrorT. Вместо этого, в данном случае я скопировал определение modifyMVar и изменил его:

\begin{lstlisting}
modifyMVar :: MVar a
           -> (a -> ErrorT MyError IO (a, b))
           -> ErrorT MyError IO b
modifyMVar m io =
  Control.Exception.Control.mask $ \restore -> do
    a      <- liftIO $ takeMVar m
    (a',b) <- restore (io a) `onExceptionError` liftIO (putMVar m a)
    liftIO $ putMVar m a'
    return b
\end{lstlisting}
