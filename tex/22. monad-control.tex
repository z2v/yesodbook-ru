monad-control

Пакет monad-control используется в нескольких местах внутри Yesod, в первую очередь для обеспечения надлежащей обработки исключений в Persistent. Это универсальный пакет, расширяющий стандартную функциональность трансформаторов монад.

Обзор

Одними из мощных, а иногда и запутанных, возможностях Haskell являются  трансформаторы монад. Они позволяют брать различные функциональности, такие как изменяемые состояния, обработка ошибок, или логинг, и легко объединять их вместе. Хотя я поклялся, что никогда не буду писать учебник по монадам, я воспользюсь слезоточивоой аналогией: монады они как луковицы. (Монады не как пироженные.) Я имею ввиду слои.

У нас есть центральная монада, также известная как внутренняя или основная монады. И вокруг этого центра, мы добавляем слои, каждый из которых добавляет новые возможности, действие которых распространяется наружу/вверх. В качестве мотивирующего примера, давайте рассмотрим монаду Error обёрнутую влкруг монады IO:

\begin{lstlisting}
newtype ErrorT e m a = ErrorT { runErrorT :: m (Either e a) }
type MyStack = ErrorT MyError IO
\end{lstlisting}

Обратите пристальное внимание: ErrorT это простой newtype вокруг Either завернутого в монаду. Если развернкть, избавляясь от newtype, получиться:

\begin{lstlisting}
type ErrorTUnwrapped e m a = m (Either e a)
\end{lstlisting}

В какой-то момент нам будет нужно выполнить некоторые IO внутри нашего MyStack. Если бы мы использовали развернутый подход, это было бы тривиально, так как у нас на пути не стоял бы конструктор ErrorT. Тем не менее, нам нужна newtype обёртка по целому ряду причин, но я не буду вдаваться в подробности почему (в конце концов это ведь не учебник по трансформаторам монад). Таким образом, решением является класс типов MonadTrans:

\begin{lstlisting}
class MonadTrans t where
    lift :: Monad m => m a -> t m a
\end{lstlisting}

Должен признать, что когда я увидел эту сигнатуру типа в первый раз, моей реакцией было замешательство и недоверие, что она хоть что-то значит. Но изучение екземпляра немного помогло:

\begin{lstlisting}
instance (Error e) => MonadTrans (ErrorT e) where
    lift m = ErrorT $ do
        a <- m
        return (Right a)
\end{lstlisting}

Всё, что мы здесь делаем это оборачиваем содержимое IO в значение Right, а затем применяем нашу newtype обёртку. Это позволяет нам взять действие которое живёт в IO, и протянуть его во внешнюю монаду.

А сейчас к делу. Для простых функций это работает очень хорошо. Например:

\begin{lstlisting}
sayHi :: IO ()
sayHi = putStrLn "Hello"

sayHiError :: ErrorT MyError IO ()
sayHiError = lift $ putStrLn "Hello"
\end{lstlisting}

Но давайте возьмём что-то посложнее, к примеру callback:

\begin{lstlisting}
withMyFile :: (Handle -> IO a) -> IO a
withMyFile = withFile "test.txt" WriteMode

sayHi :: Handle -> IO ()
sayHi handle = hPutStrLn handle "Hi there"

useMyFile :: IO ()
useMyFile = withMyFile sayHi
\end{lstlisting}

Пока все хорошо. Теперь предположим, что нам нужна версия sayHi которая имеет доступ к монаде Error:

\begin{lstlisting}
sayHiError :: Handle -> ErrorT MyError IO ()
sayHiError handle = do
    lift $ hPutStrLn handle "Hi there, error!"
    throwError MyError
\end{lstlisting}

Мы бы хотели написать функцию которая объединяет withMyFile и sayHiError. К сожалению, GHC не очень это любит:

\begin{lstlisting}
useMyFileErrorBad :: ErrorT MyError IO ()
useMyFileErrorBad = withMyFile sayHiError

    Couldn't match expected type `ErrorT MyError IO ()'
                with actual type `IO ()'
\end{lstlisting}

Почему это происходит и как мы можем это обойти?

Интуиция

Давайте попробуем интуитивно понять, что здесь происходит. Трансформатор монады ErrorT добавляет дополнительную функциональность к монаде IO. Мы добавляем эту новую функциональность к обычним действиям IO таким образом: используем конструктор Right и оборачиваем всё в ErrorT. Используя Right мы обозначаем, что всё прошло успешно, и не было никаких ошибок.

Это интуитивно имеет смысл: поскольку монада IO не имеет концепции возврата MyError, когда что-то идет не так, она всегда будет успешна в фазе протягивания. (Примечание: Это не имеет ничего общего с исключениями времени исполнения, даже не думайте о них). То что у нас есть, это гарантированное однонаправленное преобразование вверх по стеку монад.

Давайте возьмём другой пример: монаду Reader. Reader имеет доступ к некоторой информации находящейся вокруг. Всё что исполняется во внутренней монаде ничего не знает об этой дополнительной информации. Так как вы будете протягивать? Всего навсего игнорируйте эту информацию. А монада Writer? Ничего не пишите. Монада State? Ничего не меняйте. Я вижу здесь  закономерность. 

А теперь давайте попробуем пойти в обратном направлении: допустим у меня что-то в монаде Reader, и я хотел бы исполнять это в основной монаде (например IO). Ну... это не будет работать, не так ли? Мне нужна эта дополнительная информация, я завишу от неё, а она не доступна. В общем нет способа пройти в обратном направлении не предоставляя этого дополнительного значения.

Или есть? Если вы помните, ранее мы специально обратили внимание на то что ErrorT всего лишь обёртка вокруг внутренней монады. Другими словами, если у меня есть errorValue :: ErrorT MyError IO MyValue, я могу применить runErrorT и получить значение типа IO (Either MyError MyValue). Это вполне выглядит как двунаправленное преобразование, не так ли?

Честно, не вполне. Изначально у нас была монада ErrorT MyError IO, с типом значения MyValue. А сейчас у нас монада IO с типом значения Either MyError MyValue. Таким образом, этот процесс на самом деле изменил значение, в то время как протягивание оставляет его тем же.

Но тем не менее, со небольшим чудным манёвром мы можем развернуть ErrorT, обработать данные,  обернуть его снова.

\begin{lstlisting}
useMyFileError1 :: ErrorT MyError IO ()
useMyFileError1 =
    let unwrapped :: Handle -> IO (Either MyError ())
        unwrapped handle = runErrorT $ sayHiError handle
        applied :: IO (Either MyError ())
        applied = withMyFile unwrapped
        rewrapped :: ErrorT MyError IO ()
        rewrapped = ErrorT applied
     in rewrapped
\end{lstlisting}

Это ключевой момент всей этой статьи, так что смотрите внимательно. Сначала мы разворачиваем нашу монаду. Это означает, что для внешнего мира, это теперь старое доброе значение IO. Внутри мы храним всю информацию про наш трансформатор ErrorT. Теперь когда у нас есть просто IO, мы можем легко передать его withMyFile. withMyFile принимает внутреннее состояние и возвращает его обратно без изменений. В заключение, мы оборачиваем всё обратно в наш оригинальный ErrorT.

Вот весь принцип monad-control: мы вкладываем дополнительные возможности нашего трансформатора монады в значение. Попав в значение, система типов игнорирует его и сосредотачивается на внутренней монаде. Как только мы закончили работать с внутренней монадой, мы можем вытащить наше состояние обратно и восстановить наш исходный стек монад.

Типы

Я нарочно начал с трансформатора ErrorT, так как он один из самых простых для этого механизма инверсии. К сожалению, другие немного сложнее. Возьмём, к примеру ReaderT. Он определяется как newtype ReaderT r m a = ReaderT { runReaderT :: r -> m a }. Если мы к нему применим runReaderT, мы получим функцию которая возвращает монадическое значение. Так что нам понадобятся дополнительные механизмы что бы с этим справиться. И здесь мы попадаем в Волшебную страну.

Есть несколько подходов к решению этих проблем. В прошлом я реализовал решение используя семейство типов в пакете neither. Anders Kaseorg реализовал намного более простое решение в пакете monad-peel. А для эффективности, в monad-control, Bas van Dijk использует стиль передачи продолжения (Continuation Passing Style, сокращённо CPS) и екзистенциальные типы.

Код взятый из monad-control на самом деле относиться к версии 0.2. В версии 0.3 некоторые вещи немного поменялись, состояние сделали явным с ассоциированым типом, а MonadControlIO обобщили до MonadBaseControl, но концепция всё ещё таже.

Первым типом который мы рассмотрим будет:

\begin{lstlisting}
type Run t = forall n o b. (Monad n, Monad o, Monad (t o)) => t n b -> n (t o b)
\end{lstlisting}

Это определение невероятно туманно, давайте его разберём. Единственным "входным" параметром типа является t, трансформатор монады. Run это функция которая будет работать для любой комбинации типов n, o и b (это то что означает forall). Типы n и o оба являються монадами, а b это просто значение которое содержиться в них.

Левая часть функции Run, t n b, это наш трансформатор монады обёрнутый вокруг монады n и содержащий значение b. К примеру, это может быть MyTrans FirstMonad MyValue. А возвращает она значение, в котором трансформатор "проглочен" всередину, с совсем новой центральной монадой. Другими словами, FirstMonad (MyTrans NewMonad MyValue). 

По началу это может выглядеть устрашающе, но на самом деле это не так уж незнакомо как вы могли б подумать: это по сути то что мы делали с ErrorT. Мы начали с ErrorT снаружи, оборачивающем IO, а закончили с самим IO содержащим Either. Знаете что, другой способ представить ErrorT это ErrorT MyError Identity. Так что по существу мы вытянули IO наружу и поместили на её место Identity. Тоже самое мы делаем в Run: вытягиваем первую монаду наружу замещая её новой монадой.

Возможно сейчас хорошее время для глотка пива.

Хорошо, сейчас мы уже куда-то приблизились. Если бы у нас был доступ к одной из этих функций Run, мы могли бы использовать её для снятия ErrorT с результата нашей функции sayHiError, и передачи его в withMyFile. С помощью магии undefined мы можем сыграть в эту игру:

\begin{lstlisting}
errorRun :: Run (ErrorT MyError)
errorRun = undefined

useMyFileError2 :: IO (ErrorT MyError Identity ())
useMyFileError2 =
    let afterRun :: Handle -> IO (ErrorT MyError Identity ())
        afterRun handle = errorRun $ sayHiError handle
        applied :: IO (ErrorT MyError Identity ())
        applied = withMyFile afterRun
     in applied
\end{lstlisting}

Это выглядит очень похоже на предыдущий пример. Фактически, errorRun ведёт себя почти так же как и runErrorT. Однако, у нас всё ещё есть две проблеммы: мы не знаем где взять значение errorRun, и кроме того нам надо восстановить оригинальный ErrorT после того как мы закончим.

MonadTransControl

Obviously in the specific case we have before us, we could use our knowledge of the ErrorT transformer to beat the types into submission and create our Run function manually. But what we really want is a general solution for many transformers. At this point, you know we need a typeclass.

So let's review what we need: access to a Run function, and some way to restructure our original transformer after the fact. And thus was born MonadTransControl, with its single method liftControl:

\begin{lstlisting}
class MonadTrans t => MonadTransControl t where
    liftControl :: Monad m => (Run t -> m a) -> t m a
\end{lstlisting}

Let's look at this closely. liftControl takes a function (the one we'll be writing). That function is provided with a Run function, and must return a value in some monad (m). liftControl will then take the result of that function and reinstate the original transformer on top of everything.

\begin{lstlisting}
useMyFileError3 :: Monad m => ErrorT MyError IO (ErrorT MyError m ())
useMyFileError3 =
    liftControl inside
  where
    inside :: Monad m => Run (ErrorT MyError) -> IO (ErrorT MyError m ())
    inside run = withMyFile $ helper run
    helper :: Monad m
           => Run (ErrorT MyError) -> Handle -> IO (ErrorT MyError m ())
    helper run handle = run (sayHiError handle :: ErrorT MyError IO ())
\end{lstlisting}

Close, but not exactly what I had in mind. What's up with the double monads? Well, let's start at the end: sayHiError handle returns a value of type ErrorT MyError IO (). This we knew already, no surprises. What might be a little surprising (it got me, at least) is the next two steps.

First we apply run to that value. Like we'd discussed before, the result is that the IO inner monad is popped to the outside, to be replaced by some arbitrary monad (represented by m here). So we end up with an IO (ErrorT MyError m ()). Ok... We then get the same result after applying withMyFile. Not surprising.

The last step took me a long time to understand correctly. Remember how we said that we reconstruct the original transformer? Well, so we do: by plopping it right on top of everything else we have. So our end result is the previous type- IO (ErrorT MyError m ())- with a ErrorT MyError stuck on the front.

Well, that seems just about utterly worthless, right? Well, almost. But don't forget, that "m" can be any monad, including IO. If we treat it that way, we get ErrorT MyError IO (ErrorT MyError IO ()). That looks a lot like m (m a), and we want just plain old m a. Fortunately, now we're in luck:

\begin{lstlisting}
useMyFileError4 :: ErrorT MyError IO ()
useMyFileError4 = join useMyFileError3
\end{lstlisting}

And it turns out that this usage is so common, that Bas had mercy on us and defined a helper function:

\begin{lstlisting}
control :: (Monad m, Monad (t m), MonadTransControl t)
        => (Run t -> m (t m a)) -> t m a
control = join . liftControl
\end{lstlisting}

So all we need to write is:

\begin{lstlisting}
useMyFileError5 :: ErrorT MyError IO ()
useMyFileError5 =
    control inside
  where
    inside :: Monad m => Run (ErrorT MyError) -> IO (ErrorT MyError m ())
    inside run = withMyFile $ helper run
    helper :: Monad m
           => Run (ErrorT MyError) -> Handle -> IO (ErrorT MyError m ())
    helper run handle = run (sayHiError handle :: ErrorT MyError IO ())
\end{lstlisting}

And just to make it a little shorter:

\begin{lstlisting}
useMyFileError6 :: ErrorT MyError IO ()
useMyFileError6 = control $ \run -> withMyFile $ run . sayHiError
\end{lstlisting}

MonadControlIO

The MonadTrans class provides the lift method, which allows you to lift an action one level in the stack. There is also the MonadIO class that provides liftIO, which lifts an IO action as far in the stack as desired. We have the same breakdown in monad-control. But first, we need a corrolary to Run:

\begin{lstlisting}
type RunInBase m base = forall b. m b -> base (m b)
\end{lstlisting}

Instead of dealing with a transformer, we're dealing with two monads. base is the underlying monad, and m is a stack built on top of it. RunInBase is a function that takes a value of the entire stack, pops out that base, and puts in on the outside. Unlike in the Run type, we don't replace it with an arbitrary monad, but with the original one. To use some more concrete types:

\begin{lstlisting}
RunInBase (ErrorT MyError IO) IO = forall b. ErrorT MyError IO b -> IO (ErrorT MyError IO b)
\end{lstlisting}

This should look fairly similar to what we've been looking at so far, the only difference is that we want to deal with a specific inner monad. Our MonadControlIO class is really just an extension of MonadControlTrans using this RunInBase.

\begin{lstlisting}
class MonadIO m => MonadControlIO m where
    liftControlIO :: (RunInBase m IO -> IO a) -> m a
\end{lstlisting}

Simply put, liftControlIO takes a function which receives a RunInBase. That RunInBase can be used to strip down our monad to just an IO, and then liftControlIO builds everything back up again. And like MonadControlTrans, it comes with a helper function

\begin{lstlisting}
controlIO :: MonadControlIO m => (RunInBase m IO -> IO (m a)) -> m a
controlIO = join . liftControlIO
\end{lstlisting}

We can easily rewrite our previous example with it:

\begin{lstlisting}
useMyFileError7 :: ErrorT MyError IO ()
useMyFileError7 = controlIO $ \run -> withMyFile $ run . sayHiError
\end{lstlisting}

And as an advantage, it easily scales to multiple transformers:

\begin{lstlisting}
sayHiCrazy :: Handle -> ReaderT Int (StateT Double (ErrorT MyError IO)) ()
sayHiCrazy handle = liftIO $ hPutStrLn handle "Madness!"

useMyFileCrazy :: ReaderT Int (StateT Double (ErrorT MyError IO)) ()
useMyFileCrazy = controlIO $ \run -> withMyFile $ run . sayHiCrazy
\end{lstlisting}

Real Life Examples

Let's solve some real-life problems with this code. Probably the biggest motivating use case is exception handling in a transformer stack. For example, let's say that we want to automatically run some cleanup code when an exception is thrown. If this were normal IO code, we'd use:

\begin{lstlisting}
onException :: IO a -> IO b -> IO a
\end{lstlisting}

But if we're in the ErrorT monad, we can't pass in either the action or the cleanup. In comes controlIO to the rescue:

\begin{lstlisting}
onExceptionError :: ErrorT MyError IO a
                 -> ErrorT MyError IO b
                 -> ErrorT MyError IO a
onExceptionError action after = controlIO $ \run ->
    run action `onException` run after
\end{lstlisting}

Let's say we need to allocate some memory to store a Double in. In the IO monad, we could just use the alloca function. Once again, our solution is simple:

\begin{lstlisting}
allocaError :: (Ptr Double -> ErrorT MyError IO b)
            -> ErrorT MyError IO b
allocaError f = controlIO $ \run -> alloca $ run . f
\end{lstlisting}

Lost State

Let's rewind a bit to our onExceptionError. It uses onException under the surface, which has a type signature: IO a -> IO b -> IO a. Let me ask you something: what happened to the b in the output? Well, it was thoroughly ignored. But that seems to cause us a bit of a problem. After all, we store our transformer state information in the value of the inner monad. If we ignore it, we're essentially ignoring the monadic side effects as well!

And the answer is that, yes, this does happen with monad-control. Certain functions will drop some of the monadic side effects. This is put best by Bas, in the comments on the relevant functions:

Note, any monadic side effects in m of the "release" computation will be discarded; it is run only for its side effects in IO.

In practice, monad-control will usually be doing the right thing for you, but you need to be aware that some side effects may disappear.

More Complicated Cases

In order to make our tricks work so far, we've needed to have functions that give us full access to play around with their values. Sometimes, this isn't the case. Take, for instance:

\begin{lstlisting}
addMVarFinalizer :: MVar a -> IO () -> IO ()
\end{lstlisting}

In this case, we are required to have no value inside our finalizer function. Intuitively, the first thing we should notice is that there will be no way to capture our monadic side effects. So how do we get something like this to compile? Well, we need to explicitly tell it to drop all of its state-holding information:

\begin{lstlisting}
addMVarFinalizerError :: MVar a -> ErrorT MyError IO () -> ErrorT MyError IO ()
addMVarFinalizerError mvar f = controlIO $ \run ->
    return $ liftIO $ addMVarFinalizer mvar (run f >> return ())
\end{lstlisting}

Another case from the same module is:

\begin{lstlisting}
modifyMVar :: MVar a -> (a -> IO (a, b)) -> IO b
\end{lstlisting}

Here, we have a restriction on the return type in the second argument: it must be a tuple of the value passed to that function and the final return value. Unfortunately, I can't see a way of writing a little wrapper around modifyMVar to make it work for ErrorT. Instead, in this case, I copied the definition of modifyMVar and modified it:

\begin{lstlisting}
modifyMVar :: MVar a
           -> (a -> ErrorT MyError IO (a, b))
           -> ErrorT MyError IO b
modifyMVar m io =
  Control.Exception.Control.mask $ \restore -> do
    a      <- liftIO $ takeMVar m
    (a',b) <- restore (io a) `onExceptionError` liftIO (putMVar m a)
    liftIO $ putMVar m a'
    return b
\end{lstlisting}
