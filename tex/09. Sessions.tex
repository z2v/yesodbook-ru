Сессии

HTTP является протоколом без состояния. И хотя некоторые рассматривают
это как недостаток, сторонники RESTful веб-разработки восхваляют это
как плюс. Когда состояние удалено из общей картины, тогда легче
масштабировать приложения, кэширование может происходить
автоматически, и доступны многие другие приятные побочные эффекты. Вы
можете провести много параллелей с неизменяемой природой Haskell в
целом.

Насколько это возможно, RESTful приложениям следует избегать сохранять
состояние с информацией о взаимодействии с клиентом. Тем не менее,
иногда это неизбежно. Такая функциональность, как корзина покупок
является классическим примером, но другая более обычная
функциональность, наподобие должной обработки входа в систему, может
быть значительно улучшена путем правильного использования сессий.

В этой главе описывается, как Yesod сохраняет данные сессии, как вы
можете получить доступ к этим данным, а также некоторые специальные
функции, которые помогут вам использовать сессии наилучшим образом.

Clientsession

Одним из первых пакетов которые отделились от Yesod был clientsession.
Этот пакет использует шифрование и подписи для хранения данных в куки
на стороне клиента. Шифрование препятствует пользователю изучать
данные, а подпись гарантирует, что сессия не была ни захвачена, ни
изменена.

Возможно, с точки зрения эффективности хранение данных в куки звучит
как плохая идея: ведь, это означает, что данные должны быть отправлены
на каждый запрос. Однако на практике, clientsession может сильно
улучшить производительность.

* Для обслуживания запроса не требуется обращаться к базе данных на
стороне сервера.
* Мы можем легко масштабировать по горизонтали: каждый запрос содержит
всю информацию, необходимую для ответа.
* Для того чтобы уменьщить нагрузку на канал, сайты могут
предоставлять статический контент с отдельного доменного имени, чтобы
избежать накладных расходов на передачу куки для каждого запроса.

Сохранение мегабайт информации в сессии будет плохой идеей. И поэтому
большинство рекомендаций по реализаций сессий не рекомендуют такую 
практику. Если вам действительно нужно сберегать много данных для
пользователя, то лучше хранить ключ поиска в сессии, а фактические
данные в базе данных.

Все взаимодействия с clientsession обрабатывается внутри Yesod, но
есть несколько мест, где вы можете немного настроить его поведение.

Управление сессиями

В классе типов Yesod существуют три функции, которые управляют работой
сессий. Функция encryptKey возвращает текущий ключ шифрования. По
умолчанию, она берёт его из локального файла, что бы сессии могли
сохраняться между перезагрузками базы данных. Если этот файл не
существует, то он будет автоматически создан и заполнен случайными
данными. А если переопределить эту функцию, так чтобы она возвращала
Nothing, сессии будут отключены.

Зачем отключать сессии? Они вносят накладные расходы на
производительность. При нормальных обстоятельствах, эти накладные
расходы минимальны, особенно по сравнению с доступом к базе данных.
Однако, когда имеешь дело с очень простыми задачами, эти накладные
расходы могут стать заметными. Но будьте осторожны с отключением 
сессий: ведь это также отключит такую функциональность, как защиту 
от CSRF (подделка межсайтовых запросов).

Следующая функция clientSessionDuration. Эта функция возвращает
количество минут, в течении которых сессия должна быть активной.
Значение по умолчанию составляет 120 (2 часа).

Это значение в конечном итоге влияет на куки сессии двумя способами:
во-первых, оно определяет срок действия самого куки. Однако, что более
важно, время окончания сессии закодирована внутри подписи сессии.
Когда Yesod расшифровывает подпись, он проверяет в прошлом ли дата, и
если да, то значения сессии игнорируються.

Каждый раз, когда Yesod посылает ответ клиенту, он отправляет
обновленное куки с новым сроком годности. Таким образом, даже если вы
не изменяете сами значения сессии, срок сессии не истечёт, если
пользователь просто продолжает просматривать ваш сайт.

И это подводит нас к последней функции: sessionIpAddress. По
умолчанию, чтобы предотвратить перехват сессии, Yesod также кодирует в
куки IP-адрес клиента. В общем, это хорошая вещь. Тем не менее, 
некоторые провайдеры держат своих пользователей за прокси серверами,
которые переписывают их IP-адреса, иногда меняя исходный адресс в
середине сессии. Если это произойдет, и sessionIpAddress включен, то
сессия пользователя будет сброшена. Установка же этого параметра в False
позволит сессии продолжать в таких условиях, ценой подвержения
пользователя возможному захвату сессии.

Действия с сессией

Как и большинство фреймворков, сессии в Yesod представляет собой
хранилище ключ-значение. API базовой сессии сводится к четырем
функциям: lookupSession получает значение для ключа (если имеется),
getSession возвращает все пары ключ/значение, setSession задаёт
значение для ключа, а deleteSession очищает значение для ключа.

{-# LANGUAGE TypeFamilies, QuasiQuotes, TemplateHaskell, MultiParamTypeClasses, OverloadedStrings #-}
import Yesod
import Control.Applicative ((<$>), (<*>))
import qualified Web.ClientSession as CS

data SessionExample = SessionExample

mkYesod "SessionExample" [parseRoutes|
/ Root GET POST
|]

getRoot :: Handler RepHtml
getRoot = do
    sess <- getSession
    hamletToRepHtml [hamlet|
<form method=post>
    <input type=text name=key>
    <input type=text name=val>
    <input type=submit>
<h1>#{show sess}
|]

postRoot :: Handler ()
postRoot = do
    (key, mval) <- runInputPost $ (,) <$> ireq textField "key" <*> iopt textField "val"
    case mval of
        Nothing -> deleteSession key
        Just val -> setSession key val
    liftIO $ print (key, mval)
    redirect Root

instance Yesod SessionExample where
    -- Make the session timeout 1 minute so that it's easier to play with
    makeSessionBackend _ = do
        key <- CS.getKey CS.defaultKeyFile
        return $ Just $ clientSessionBackend key 1

instance RenderMessage SessionExample FormMessage where
    renderMessage _ _ = defaultFormMessage

main :: IO ()
main = warpDebug 3000 SessionExample
