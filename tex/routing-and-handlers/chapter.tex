\chapter{Маршрутизация URL и обработчики}\label{chap:routing}

Если рассматривать Yesod как веб-фреймворк, построенный по шаблону
<<Модель--Вид--Контроллер>> (MVC, <<Model--View--Controller>>), то маршрутизация URL и
обработчики запросов занимают в этом шаблоне место <<Контроллера>>. Для сравнения опишем
два других подхода к маршрутизации, используемые в других средах веб-разработки:
\begin{itemize}
\item Используется диспетчеризация обработчиков, основанная на имени файла. Так, например,
  работают PHP и ASP.
\item Используется централизованная функция, которая обрабатывает маршруты, опираясь на
  регулярные выражения. Такому подходу следуют Django и Rails.
\end{itemize}

Yesod в основном следует второму подходу, однако имеются и значительные отличия. Вместо
использования регулярных выражений Yesod сопоставляет компоненты маршрута. Вместо
однонаправленного отображения маршрут--обработчик Yesod использует промежуточный тип
данных (называемый тип данных маршрута, или типобезопасный URL) и создаёт функции для
двустороннего преобразования.

Ручная реализация этой более изощрённой системы утомительна и подвержена ошибкам. Поэтому
Yesod определяет предметно-ориентированный язык (Domain Specific Language, DSL) для
описания маршрутов и предоставляет функции Template Haskell для преобразования кода на
этом языке в код на Haskell. В настоящей главе разъясняется синтаксис объявлений маршрута,
даётся некоторое представление о том, какой код генерируется за вас, и описывается
взаимодействие между маршрутизацией и функциями обработки запросов.

\section{Синтаксис записи маршрута}

Вместо того, чтобы пытаться втиснуть объявления маршрутов в рамки существующего
синтаксиса, Yesod использует упрощённый синтаксис, разработанный специально для
маршрутов. Преимущество такого подхода~--- код получается не только проще в написании, но
и достаточно простым для того, чтобы люди, не имеющие опыта работы с Yesod, могли
его прочитать и понять схему сайта вашего приложения.

Простой пример синтаксиса:
\begin{lstlisting}
/             RootR     GET
/blog         BlogR     GET POST
/blog/#BlogId BlogPostR GET POST

/static       StaticR   Static getStatic
\end{lstlisting}

В следующих нескольких разделах будет подробно описано, что происходит при объявлении
маршрута.

\subsection{Компоненты пути URL}

Одно из первых действий, совершаемых Yesod при получении запроса,~---
разбиение запрошенного пути на компоненты. Компоненты разделяются символами
косой черты (/). Например:
\begin{lstlisting}
toPieces "/" = []
toPieces "/foo/bar/baz/" = ["foo", "bar", "baz", ""]
\end{lstlisting}

Вы можете заметить, что некоторые забавные вещи происходят с
завершающим символом косой черты, с двойным символом косой черты
(<</foo//bar//>>) и ещё с некоторыми другими комбинациями.
Yesod рассчитывает на получение канонических адресов URL; если пользователи
запрашивают URL с завершающим символом косой черты или с двойным символом
косой черты, они автоматически перенаправляются на каноническую версию адреса.
Это гарантирует, что у вас одному URL соответствует один ресурс, и может
помочь с рейтингами в поисковых системах.

Для вас это означает, что нет необходимости беспокоиться о точной
структуре URL: вы можете спокойно думать о компонентах
маршрута, а Yesod автоматически выполнит вставку символов косой черты
и экранирование проблемных символов.

Если, кстати, вы захотите более тонко настраивать, как маршруты
разбиваются на компоненты и собираются обратно, вам стоит взглянуть на
методы \lstinline!cleanPath! и \lstinline!joinPath! в главе~\ref{chap:yesod-typeclass}
о классе типов \lstinline!Yesod!.

\subsubsection{Типы компонентов}

Когда вы объявляете маршруты, у вас в распоряжении имеются три типа компонентов:
\begin{description}
\item[Статический] \hfill \\
  Простая строка, с которой в точности должен совпадать компонент URL.

\item[Динамический одинарный] \hfill \\
  Одиночный компонент (т.е. между двумя символами косой черты), который
  представляет собой заданное пользователем значение. Это основой способ получения
  дополнительных данных от пользователя при запросе страницы. Определение таких
  компонентов начинаются с символа решётки (\#), за которым следует тип данных. Тип данных
  должен быть экземпляром \lstinline!PathPiece!.

\item[Динамический множественный] \hfill \\
  Аналогичен предыдущему, но может соответствовать множеству компонентов URL. Это всегда должен
  быть последний компонент в шаблоне ресурса. Задаётся символом звёздочки (*), за которым
  следует тип данных, который должен быть экземпляром
  \lstinline!PathMultiPiece!. Множественные компоненты не столь распространены, как
  предыдущие два, хотя они очень важны для реализации таких возможностей, как статические
  деревья, описывающие структуру файла или вики с произвольными иерархиями.
\end{description}

Давайте взглянем на некоторые стандартные типы шаблонов ресурса, которые вы могли бы
захотеть написать. Начнём с простого: корень приложения будет просто \lstinline!/!. Также
вы, вероятно, захотите разместить страницу с часто задаваемыми вопросами (FAQ) по адресу
\lstinline!/page/faq!.

Теперь давайте представим, что вы собираетесь сделать сайт для вычисления чисел
Фибоначчи. Ваши URL могут выглядеть как \lstinline!/fib/#Int!. Но тут есть
небольшая проблема: мы не хотим, чтобы в наше приложение можно было передавать
отрицательные числа или ноль. К счастью, система типов может нас защитить:
\begin{lstlisting}
newtype Natural = Natural Int
instance PathPiece Natural where
    toPathPiece (Natural i) = T.pack $ show i
    fromPathPiece s =
        case reads $ T.unpack s of
            (i, ""):_
                | i < 1 -> Nothing
                | otherwise -> Just $ Natural i
            [] -> Nothing
\end{lstlisting}%$

В строке 1 мы определяем для \lstinline!Int! изоморфный тип, который защитит нас от
некорректного ввода. Мы видим, что \lstinline!PathPiece!~--- это класс типов с двумя
методами. \lstinline!toPathPiece! просто конвертирует в \lstinline!Text! и ничего
больше. \lstinline!fromPathPiece!  \emph{пытается} преобразовать \lstinline!Text! в наш
тип данных, возвращая \lstinline!Nothing!, если преобразование невозможно. Используя этот
тип данных, мы можем быть уверены, что нашей функции-обработчику будут передаваться только
натуральные числа, позволяя нам в очередной раз использовать систему типов для преодоления
трудностей, связанных с граничными условиями.

\begin{remark}
  В реальном приложении мы бы ещё предпочли удостовериться, что никогда случайно не
  создадим некорректное значение \lstinline!Natural! внутри нашего приложения. Для этого
  мы могли бы использовать подход наподобие умных конструкторов
  (\href{http://www.haskell.org/haskellwiki/Smart\_constructors}{smart
    constructors}\footnotemark).  Но для нашего примера мы решили оставить код простым.
\end{remark}

\footnotetext{\href{http://www.haskell.org/haskellwiki/Smart\_constructors}{\texttt{http://www.haskell.org/haskellwiki/Smart\_constructors}}}

Определение \lstinline!PathMultiPiece! столь же простое. Допустим, что мы хотим сделать
вики с иерархией не менее, чем два уровня; тогда мы могли бы определить тип данных как:
\begin{lstlisting}
data Page = Page Text Text [Text] -- 2 или больше
instance PathMultiPiece Page where
    toPathMultiPiece (Page x y z) = x : y : z
    fromPathMultiPiece (x:y:z) = Just $ Page x y z
    fromPathMultiPiece _ = Nothing
\end{lstlisting}%$

\subsection{Имя ресурса}
С каждым шаблоном ресурса связано имя. Оно станет именем конструктора типа данных для
типобезопасного URL, связанного с вашим приложением, поэтому оно должно начинаться с
прописной буквы. Также имена ресурсов принято завершать прописной буквой <<R>>. Это не
обязательное требование, просто общепринятая практика.

Конкретное определение нашего конструктора зависит от шаблона ресурса, к которому оно
относится. Все типы данных, которые включены в одинарные и множественные компоненты
шаблона, становятся аргументами типа данных. Это даёт нам однозначное соответствие между
нашим типом для типобезопасных URL и корректными для нашего приложения URL.

\begin{remark}
  Это не обязательно означает, что каждое значение типа соответствует работающей странице,
  лишь означает, что значение типа является потенциально корректным URL. Например,
  значение \lstinline!PersonR "Michael"! может не разрешиться в корректную страницу, если
  в базе данных нет записи для \lstinline!"Michael"!.
\end{remark}

Давайте теперь обратимся к реальным примерам. Если бы у вас были такие
шаблоны ресурсов: \lstinline!/person/#Text! с именем
\lstinline!PersonR!; \lstinline!/year/#Int! с именем
\lstinline!YearR! и \lstinline!/page/faq! с именем \lstinline!FaqR!,
то ваш тип данных для маршрутов выглядел бы приблизительно так:
\begin{lstlisting}
data MyRoute = PersonR Text
             | YearR Int
             | FaqR
\end{lstlisting}

Если пользователь запросит \lstinline!/year/2009!,
Yesod преобразует его в значение \lstinline!YearR 2009!.
\lstinline!/person/Michael! станет \lstinline!PersonR "Michael"!
и \lstinline!/page/faq! станет \lstinline!FaqR!. С другой
стороны, \lstinline!/year/two-thousand-nine!,
\lstinline!/person/michael/snoyman! и \lstinline!/page/FAQ! привели бы
к получению 404 ошибок даже без обращения к вашему коду.

\subsection{Спецификация обработчика}
Последний кусочек головоломки объявления ваших ресурсов~--- описание
того, как они будут обрабатываться. Yesod предлагает три варианта:
\begin{itemize}
\item у заданного маршрута единственный обработчик для всех методов запроса;
\item у заданного маршрута для каждого метода отдельный
  обработчик. Для неуказанных методов будет генерироваться ответ с
  кодом 405 <<Метод не поддерживается>> (405 Method Not Allowed);
\item передача управления на подсайт.
\end{itemize}

В первых двух случаях спецификация обработчика очень проста. Для
единственного обработчика это будет просто строка с шаблоном ресурса и
его именем, например \lstinline!/page/faq FaqR!. В таком
случае, функция-обработчик должна иметь имя \lstinline!handleFaqR!.

В случае отдельного обработчика для каждого метода спецификация аналогична,
только добавляется список доступных методов запросов. Методы запросов
должны быть записаны прописными буквами. Например,
\lstinline!/person/#String PersonR GET POST DELETE!.
В данном случае вам потребуется определить три функции-обработчика:
\lstinline!getPersonR!, \lstinline!postPersonR! и~\lstinline!deletePersonR!.

Подсайты~--- очень полезная, но более сложная тема в Yesod. Мы рассмотрим
создание подсайтов позже, в главе~<<\nameref{chap:subsite}>>,
но использовать их не так уж и сложно. Самый
часто используемый подсайт~--- статический сайт, который
раздаёт статические файлы для вашего приложения. Для того, чтобы
раздавать статические файлы из \lstinline!/static!, вам нужно описать
ресурс вида:
\begin{verbatim}
/static StaticR Static getStatic
\end{verbatim}

В этой строке, \lstinline!/static! просто говорит о том, откуда в вашей
структуре URL отдавать статические файлы. Нет никакой магии в слове
<<static>> (статический), вы легко можете заменить его на
\lstinline!/my/non-dynamic/files!.

Следующее слово, \lstinline!StaticR!, присваивает ресурсу имя. Следующие два слова
указывают, что мы используем подсайт. \lstinline!Static!~--- это имя
типа-основания подсайта, а \lstinline!getStatic!~--- функция, которая получает
значение типа \lstinline!Static! из значения типа-основания вашего основного сайта.

Давайте пока не будем углубляться в подробности, касающиеся подсайтов. Мы рассмотрим
подробнее статический сайт в главе~\ref{chap:scaffolding} о каркасе сайта.

\section{Диспетчеризация}
Как только вы определили свои маршруты, Yesod позаботится за вас обо всех
утомительных деталях диспетчеризации URL. Вам нужно только
удостовериться, что вы предоставили соответствующие функции
обработки. Для маршрутов на подсайты вам не требуется писать
какие-либо функции обработки, но для двух других типов обработчиков
это сделать необходимо. Выше мы уже упомянули правило именования:
(\lstinline!MyHandlerR GET! становится \lstinline!getMyHandlerR!,
\lstinline!MyOtherHandlerR! становится \lstinline!handleMyOtherHandlerR!).
Теперь нам нужно определиться с сигнатурой типа.

Теперь, когда мы знаем, какие функции писать, давайте разберёмся, какая у них
должна быть сигнатура типа.

\subsection{Возвращаемый тип}
Давайте посмотрим на простую функцию обработки:
\begin{lstlisting}
mkYesod "Simple" [parseRoutes|
/ HomeR GET
|]

getHomeR :: Handler Html
getHomeR = defaultLayout [whamlet|<h1>This is simple|]
\end{lstlisting}

Возвращаемый тип состоит из двух компонент: \lstinline'Handler' и~\lstinline'Html'. Давайте
подробнее рассмотрим каждую.

\subsubsection{Монада \lstinline'Handler'}
Также как и тип \lstinline'Widget', тип данных~\lstinline'Handler' в библиотеках не
определяется. Вместо него, библиотеки предоставляют тип данных:
\begin{lstlisting}
data HandlerT site m a
\end{lstlisting}

И также, как у \lstinline'WidgetT', у этого типа три аргумента: базовая монада~\lstinline'm',
монадическое значение~\lstinline'a' и основной тип данных~\lstinline'site'. Каждое приложение
определяет синоним~\lstinline'Handler', который сужает \lstinline'site' до основного типа приложения,
и задаёт \lstinline'm' равным \lstinline'IO'. Т.е., если основной тип вашего приложения~--- \lstinline'MyApp',
то у вас есть синоним:
\begin{lstlisting}
type Handler = HandlerT MyApp IO
\end{lstlisting}

Нам потребуется возможность модифицировать базовую монаду при написании подсайтов, но в
остальных случаях мы будет использовать~\lstinline'IO'.

Монада \lstinline'HandlerT' предоставляет доступ к информации о запросе пользователя
(например, параметры строки запроса), позволяет изменять ответ (например, заголовки
ответа), и т.д. Эта та монада, в которой будет жить большая часть вашего кода Yesod.

Кроме того, есть ещё класс типов~\lstinline'MonadHandler'. И~\lstinline'HandlerT',
и~\lstinline'WidgetT' являются экземплярами этого класса, что позволяет использовать
много общих функций в обеих монадах. Если вы встретите \lstinline'MonadHandler' в любой
документации по API, имейте в виду, что функция может быть использована в
ваших функциях-обработчиках.

\subsubsection{\lstinline'Html'}
Нет ничего необычного в этом типе. Наша функция возвращает какой-то HTML-контент,
представленный типом данных~\lstinline'Html'. Очевидно, что Yesod не был бы полезным,
если бы ограничился только генерацией HTML ответов. Мы хотим отвечать, используя
CSS, Javascript, JSON, изображения и многое другое. Поэтому возникает вопрос: какие
типы данных можно возвращать?

Чтобы подготовить ответ, нам необходимо определиться с двумя вопросами:
типом контента (например, \texttt{text/html}, \texttt{image/png}) и как его
сериализовать в поток байтов. Для этого используется тип данных~\lstinline'TypedContent':
\begin{lstlisting}
data TypedContent = TypedContent !ContentType !Content
\end{lstlisting}

У нас также есть класс типов для всех типов данных, которые могут быть преобразованы
в~\lstinline'TypedContent':
\begin{lstlisting}
class ToTypedContent a where
    toTypedContent :: a -> TypedContent
\end{lstlisting}

Множество стандартных типов данных сделаны экземплярами этого класса типов, включая
\lstinline'Html', \lstinline'Value' (из пакета~aeson, для представления JSON),
\lstinline'Text' и даже \lstinline'()' (для представляется пустого ответа).

\subsubsection{Аргументы}
Давайте вернёмся к нашего простому примеру, описанному выше:
\begin{lstlisting}
mkYesod "Simple" [parseRoutes|
/ HomeR GET
|]

getHomeR :: Handler Html
getHomeR = defaultLayout [whamlet|<h1>This is simple|]
\end{lstlisting}

Не все маршруты столь же просты, как \lstinline!HomeR!.
Возьмём для примера наш маршрут
\lstinline!PersonR! из предыдущих разделов. Имя человека необходимо
передавать в функцию обработки. Переход очень прост и, надеюсь,
интуитивно понятен. Пример:
\sourcecode{routing-and-handlers}{args.hs}

Аргументы имеют типы динамических компонент каждого маршрута, в порядке
указания. Также обратите внимание, как мы можем использовать и
\lstinline!Html!, и \lstinline!Text!.

\section{Функции монады \texttt{Handler}}
Поскольку большая часть вашего кода будет находиться в монаде~\lstinline'Handler',
это очень важно потратить некоторое время, чтобы разобраться с нею.
В оставшейся части главы приведено краткое введение в некоторые
самые распространённые функции, находящиеся в монаде
\lstinline!Handler!. Я специально \emph{не} описываю функции для работы с
сессиями; они будут рассмотрены в отдельной~\hyperref[chap:sessions]{главе}.

\subsection{Информация о приложении}
Есть набор функций, которые возвращают информацию о вашем приложении в
целом и не дают никакой информации об отдельных запросах. Среди них:
\begin{description}
\item[getYesod] \hfill \\
  Возвращает значение основы (foundation value) вашего приложения. Если вы храните
  значения настроек в основе, то вы, вероятно, будете часто использовать эту функцию.

\item[getUrlRender] \hfill \\
  Возвращает функцию рендеринга URL, которая преобразует типобезопасный URL в
  \lstinline!Text!. В большинстве случаев, как и при использовании \lstinline!Hamlet!,
  Yesod сам вызывает эту функцию за вас, но иногда может потребоваться вызвать эту функцию
  напрямую.

\item[getUrlRenderParams]  \hfill \\
  Вариант \lstinline!getUrlRender!, который преобразует и типобезопасный URL, и список
  параметров из строки запроса. Это функция выполняет необходимое кодирование символов в
  URL (percent-encoding).
\end{description}

\subsection{Информация о запросе}
Информация о текущем запросе, которую вы обычно желаете получить,~--- это запрошенный
путь, параметры из строки запроса и данные форм, отправленные на сервер методом\texttt{POST}. С
первым пунктом имеет дело маршрутизация, как описано выше. С оставшимися двумя лучше всего
работать, используя модуль работы с~\hyperref[chap:forms]{формами}.

Тем не менее, вам иногда требуется получить данные в менее обработанном виде. Для этой
цели Yesod предоставляет тип данных~\lstinline!YesodRequest!  вместе с
функцией~\lstinline!getRequest! для его получения. Это даёт вам доступ к полному набору
параметров GET-запроса, куки и списку предпочитаемых языков. Есть несколько удобных
функций для упрощения поиска, такие как \lstinline!lookupGetParam!,
\lstinline!lookupCookie! и \lstinline!languages!. Для прямого доступа к данным
POST-запроса следует использовать \lstinline!runRequestBody!.

Если вам требуются ещё более сырые данные, такие как заголовки
запросов, вы можете использовать \lstinline!waiRequest! для доступа к
значению запроса Интерфейса Веб-приложения (Web Application Interface,
WAI). За деталями обращайтесь к \hyperref[chap:web_application_interface]{приложению о WAI}.

\subsection{Сокращённая обработка запроса}
Описанные ниже функции немедленно прекращают выполнение обработчика и
возвращают результат пользователю.
\begin{description}
\item[redirect] \hfill \\
  Отправляет пользователю ответ, предписывающий выполнить переадресацию (код 303). Если вы
  хотите использовать другой код ответа (например, 301 <<Постоянная переадресация>>), вы
  можете воспользоваться \lstinline!redirectWith!.

\begin{remark}
Yesod использует ответ 303 для клиентов, использующих протокол HTTP/1.1, и ответ
302 для клиентов, использующих HTTP/1.0. Вы можете прочитать об этой
ужасной истории в спецификации протокола HTTP.
\end{remark}

\item[notFound] \hfill \\
Возвращает ответ 404. Это может быть полезно, если пользователь
запросил из базы данных несуществующее значение.

\item[permissionDenied] \hfill \\
Возвращает ответ 403 с указанным сообщением об ошибке.

\item[invalidArgs] \hfill \\
Ответ 400 со списком некорректных аргументов.

\item[sendFile] \hfill \\
Отправляет файл из файловой системы с указанным типом контента. Это
предпочтительный способ отправки статических файлов, так как лежащий
в основе обработчик WAI может оказаться в состоянии оптимизировать
отправку до системного вызова~\texttt{sendfile}. Использование
\lstinline!readFile! для отправки статических файлов не является
обязательным.

\item[sendResponse] \hfill \\
Отправить обычный ответ с кодом 200. На самом
деле, определён для удобства, чтобы вы могли прервать глубоко
вложенный код немедленным ответом. Можно использовать Любой экземпляр
класса~\lstinline'ToTypedContent'.

\item[sendWaiResponse] \hfill \\
Иногда вам нужно спуститься на нижний уровень и отправить сырой ответ
WAI. Это может быть особенно полезным для создания потоковых ответов
или техник наподобие событий, отправляемых сервером.
\end{description}

\subsection{Заголовки ответа}
\begin{description}
\item[setCookie] \hfill \\
Установить куки клиенту. Вместо того, чтобы принимать дату истечения
срока жизни, эта функция принимает продолжительность жизни куки в
минутах. Помните, вы не сможете увидеть это куки, используя
\lstinline!lookupCookie!, до \emph{следующего} запроса.

\item[deleteCookie] \hfill \\
Предписывает клиенту удалить куки. Опять же, \lstinline!lookupCookie! не
увидит изменений до следующего запроса.

\item[setHeader] \hfill \\
Устанавливает указанный заголовок запроса.

\item[setLanguage] \hfill \\
Устанавливает предпочитаемый пользователем язык, который будет
показываться в ответе функции~\lstinline!languages!.

\item[cacheSeconds] \hfill \\
  Устанавливает заголовок Cache-Control равным количеству секунд, на которое
  ответ может быть кеширован. Это может быть в частности полезно, если вы используете
  \footnotehref{http://www.varnish-cache.org/}{varnish} на своём сервере.

\item[neverExpires] \hfill \\
  Устанавливает заголовок Expires равным 2037-ому году. Вы можете использовать
  это для контента, время жизни которого неограничено, например, когда маршрут запроса
  имеет связанное с ним значение хеша.

\item[alreadyExpired] \hfill \\
Устанавливает заголовок Expires равным некоторому моменту в прошлом.

\item[expiresAt] \hfill \\
Устанавливает заголовок Expires равным заданному значению даты/времени.
\end{description}

\section{Ввод/вывод и отладка}
Трансформаторы монад \lstinline'HandlerT' и \lstinline'WidgetT' являются
экземплярами целого набора классов типов. В рамках этого раздела нас интересуют
классы \lstinline'MonadIO' и~\lstinline'MonadLogger'. Первый из них позволяет
вам выполнять произвольные действия ввода/вывода внутри вашего обработчика,
например, чтение из файла. Для этого надо только добавить \lstinline'liftIO'
перед вызовом действия.

\lstinline'MonadLogger' реализует встроенную систему протоколирования. Для
настройки этой системы есть множество путей, включая настройку того, какие
сообщения протоколируются и куда они отправляются. По умолчанию, сообщения
выводятся в стандартный поток вывода, в процессе разработки протоколируются все
сообщения, а в продуктивной среде~--- только предупреждения и ошибки.

Часто при протоколировании мы хотим знать конкретное место в исходном коде,
откуда было отправлено сообщение. Для этого, \lstinline'MonadLogger'
предоставляет ряд удобных функций Template Haskell, которые автоматически
вставляют в протокольные сообщений ссылку на место в исходном коде. Вот эти
функции: \lstinline'logDebug', \lstinline'logInfo', \lstinline'logWarn'
и~\lstinline'logError'. Давайте рассмотрим короткий пример их использования.

\sourcecode{routing-and-handlers}{logging.hs}

\section{Строка запроса и фрагменты с хешем}
Мы рассмотрели ряд функций, работающих с URL-подобными объектами, например,
\lstinline'redirect'. Все эти функции работают с типо-безопасными URL. Вопрос: с чем
ещё они работают? Есть класс типов~\lstinline'RedirectUrl', который содержит
логику для конвертации некоторого типа в текстовый URL. Реализованы экземпляры
этого класса для типо-безопасных URL, текстовых URL, и для двух особых случаев:
\begin{enumerate}
    \item Кортеж, включающий URL и список пар ключ/значение для параметров
        строки запроса.

    \item Тип данных \lstinline'Fragment', используемый для добавления
        хеша в конец URL.
\end{enumerate}

Оба этих экземпляра позволяют <<добавлять>> дополнительную информация к
типо-безопасному URL. Давайте посмотрим на примеры, как это может быть
использовано:

\sourcecode{routing-and-handlers}{urls.hs}

Конечно, внутри шаблона Hamlet это обычно не требуется, так как вы можете
просто включить хеш после URL напрямую, например:
\begin{lstlisting}
<a href=@{Link1R}#somehash>Link to hash
\end{lstlisting}

\section{Выводы}
Маршрутизация и диспетчеризация~--- это, пожалуй, основная часть Yesod: здесь
определяются наши типобезопасные URL, и большая часть нашего кода
пишется внутри монады~\lstinline!Handler!. В этой главе описаны
некоторые самые важные и центральные концепции Yesod, поэтому важно,
чтобы вы как следует усвоили её.

Также в главе намечено несколько более сложных тем Yesod, которые
будут охвачены далее. Но вы уже должны быть в состоянии реализовать
очень сложные веб-приложения, используя только те знания,
которые вы уже получили.
