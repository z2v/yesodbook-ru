\chapter{Развёртывание вашего веб-приложения}\label{chap:deploying}
Не могу говорить за всех, но лично я предпочитаю программирование системному
администрированию. Но, на самом деле, рано или поздно вам придётся как-нибудь
разворачивать ваше приложение, и скорее всего вам придётся быть тем самым
человеком, который будет всё это настраивать.

В Haskell сообществе существуют многообещающие инициативы, нацеленные на то,
чтобы облегчить процесс развёртывания. В будущем, возможно, у нас даже будет
сервис, который позволит развернуть ваше веб-приложение при помощи одной
команды.

Однако пока что это не так, и, даже если бы это было так, подобное решение
никогда бы не подошло абсолютно всем. Данная глава описывает различные
существующие варианты развёртывания и даёт некоторые общие рекомендации
касательно того, какой из них следует выбрать в том или ином случае.

\begin{remark}
    Хотя информация в этой главе не зависит от версии Yesod, есть вероятность,
    что данные рекомендации недостаточно точны для последних разработок, таких
    как сервер приложений FP Complete, или доступности Keter. Глава оставлена в
    неизменном виде (относительно версии для Yesod-1.1.~--- \emph{прим.
    перев.}), но, возможно, будет обновлена в будущем (23.06.2013)
\end{remark}

\section{Компиляция}
Начнём с начала: как вы собираете своё приложение? Если вы используете
сгенерированный сайт-каркас~--- это просто вызов команды \lstinline{cabal build}.
Я бы также рекомендовал очистку рабочих каталогов перед сборкой, чтобы
гарантировать отсутствие закешированной информации. Таким образом, простейшая
последовательность команд для сборки вашего приложения будет выглядеть так:

\begin{lstlisting}
cabal clean && cabal configure && cabal build
\end{lstlisting}

\section{Файлы для развёртывания}
При использовании сгенерированного каркаса сайта необходимыми для
развёртывания являются три набора файлов:
\begin{itemize}
    \item Исполняемый файл вашего приложения.

    \item Папка \texttt{config}.

    \item Папка \texttt{static}.
\end{itemize}

Всё остальное, в частности шекспировские шаблоны, вкомпилировано в исполняемый
файл.

Одно предостережение: файл~\texttt{config/client\_session\_key.aes}. Этот файл
управляет шифрованием на сервере клиентских куки сессии. Yesod автоматически
создаст это файл в случае его отсутствия. На практике, это означает, что если
вы не включили этот файл в сценарий развёртывания, всем вашим пользователям
потребуется перезаходить на сайт после каждого обновления. Если вы последуете
совету выше и включите в сценарий папку~\texttt{config}, проблема будет
частична решена.

Другая часть решения~--- убедиться, что как только вы создали
файл~\texttt{config/client\_session\_key.aes}, вы будете использовать только его
для всех последующих обновлений. Самый простой способ решения~--- хранить файл
в системе контроля версий. Однако, если вы используете открытые исходники, это
может быть опасно: кто-нибудь с доступом к вашему репозиторию будет иметь
возможность сфабриковать данные для входа в приложение!

Описанная проблема, по существу, относится к системному администрированию, а не
к программированию. Yesod не предоставляет встроенных средств для безопасного
хранения ключей клиентских сессий. Если вы используете открытый код или не
доверяете кому-либо из имеющих доступ к репозиторию с кодом, становится
чрезвычайно важным разработать надёжное решение для хранения ключа клиентских
сессий.

\section{Warp}
Как было отмечено ранее, Yesod построен на \emph{Интерфейсе веб-приложения (Web
    Application Interface, WAI)}, что позволяет ему запускаться на любом
WAI-совместимом бэкенд сервере. На момент написания этого текста доступны
следующие варианты:
\begin{itemize}
    \item Warp
    \item FastCGI
    \item SCGI
    \item CGI
    \item Webkit
    \item Сервер разработки (development server)
\end{itemize}

Последние два не предназначены для боевого %production
использования. Из оставшихся четырёх, теоретически, для этих целей может быть использован любой. На практике же CGI будет ужасно неэффективен, так как для каждого соединения будет создаваться новый процесс. SCGI, в свою очередь, не настолько хорошо поддерживается фронтенд веб-серверами как Warp (в режиме обратного прокси) или FastCGI.

Таким образом, из двух оставшихся вариантов Warp является рекомендуемым, потому
что:
\begin{itemize}
  \item Он значительно быстрее;

  \item Как и FastCGI может быть запущен за фронтенд сервером, таким как Nginx
      в режиме обратного прокси;

  \item Кроме того, он является полностью функциональным сервером, и потому
      может быть использован сам по себе, без какого-либо фронтенда.
\end{itemize}

Итого, открытым остался лишь один вопрос: следует ли использовать Warp
самостоятельно или через обратный прокси за другим фронтенд сервером? В
большинстве случаев я рекомендую последнее, потому что:
\begin{itemize}
  \item Несмотря на то, что Warp быстр, он оптимизирован для использования в
      качестве сервера приложений, а не сервера статических файлов;

  \item Используя Nginx, вы можете настроить виртуальный хостинг и раздавать
      статические файлы с отдельного домена. (Это возможно и с Warp, хоть и
      несколько сложнее);

  \item Вы можете использовать Nginx как балансировщик нагрузки или SSL прокси.
      (Хотя, используя warp-tls, вполне можно запускать https сайт на одном
      только Warp).
\end{itemize}

Таким образом, моя итоговая рекомендация следующая: используйте Nginx как
обратный прокси для Warp.

\begin{remark}
    Некоторые участники сообщества Yesod не согласны со мной в этом вопросе и
    полагают, что увеличенная производительность и уменьшенная сложность
    решения с одним только Warp делают его лучшим выбором. Так что, поступайте
    как считаете правильным, оба подхода абсолютно корректны.
\end{remark}

\subsection{Конфигурация}
В общем случае, Nginx будет ожидать соединений на 80 порту, а ваше Yesod/Warp
приложение будет слушать какой-нибудь другой непривилегированный порт (скажем,
4321). В таком случае ваш файл nginx.conf будет выглядеть примерно так:

\begin{lstlisting}
daemon off; # НЕ запускайте nginx в фоновом режиме. Это очень удобно для мониторинга приложений
events {
    worker_connections 4096;
}

http {
    server {
        listen 80; # Порт для входящих соединений Nginx
        server_name www.myserver.com;
        location / {
            proxy_pass http://127.0.0.1:4321; # Порт обратного прокси для вашего Yesod приложения
        }
    }
}
\end{lstlisting}
Вы можете добавлять сколько угодно блоков \lstinline{server}. Общая
практика~--- добавлять блок, который гарантирует, что ваши пользователи всегда
будут получать страницы с префиксом \lstinline{www} в имени домена, соблюдая
таким образом RESTful принцип канонических URLов. (Вы можете с тем же успехом
делать обратное и всегда удалять префикс \lstinline{www}. Главное, не забудьте
отразить это и в файле конфигурации nginx и в approot вашего сайта).

\begin{lstlisting}
server {
    listen 80;
    server_name myserver.com;
    rewrite ^/(.*) http://www.myserver.com/$1 permanent;
}
\end{lstlisting}%$

Крайне рекомендуется в качестве оптимизации раздавать статические файлы с
отдельного домена, избегая таким образом ненужной передачи cookie. Предполагая,
что наши статические файлы хранятся в подкаталоге \lstinline{static} каталога
нашего сайта, который имеет путь /home/michael/sites/mysite, это выглядело бы
следующим образом:

\begin{lstlisting}
server {
    listen 80;
    server_name static.myserver.com;
    root /home/michael/sites/mysite/static;
    # Так как yesod-static добавляет хэш содержимого к строке запроса,
    # мы можем свободно выставлять дату истечения срока действия на далёкое будущее
    # без опасений получить устаревшее содержимое.
    expires max;
}
\end{lstlisting}

Для того, чтобы это заработало, ваш сайт должен корректно изменять статические
URLы так, чтобы они указывали на этот альтернативный домен. Сайт-каркас
настроен таким образом, чтобы упростить эту задачу используя функцию
\lstinline{Settings.staticRoot} и определение \lstinline{urlRenderOverride}.
Однако если вам надо всего лишь использовать преимущества Nginx при раздаче
статических файлов без использования отдельных доменных имён, вы можете просто
модифицировать исходный блок server следующим образом:
\begin{lstlisting}
server {
    listen 80; # Порт для входящих соединений Nginx
    server_name www.myserver.com;
    location / {
        proxy_pass http://127.0.0.1:4321; # Порт обратного прокси для вашего Yesod приложения
    }
    location /static {
        root /home/michael/sites/mysite; # Обратите внимание, что мы *НЕ* включаем /static
        expires max;
    }
}
\end{lstlisting}
%

\subsection{Серверный процесс}
Многие знакомы с конфигурациями типа Apache/mod\_php или Lighttpd/FastCGI, в
которых веб-сервер автоматически запускает веб-приложение. При использовании
nginx, как в режиме обратного прокси, так и в режиме FastCGI, это не так: вы
сами ответственны за запуск вашего процесса. Я настоятельно рекомендую
использовать какой-либо инструмент мониторинга, который будет автоматически
перезапускать ваше приложение в случае падений. Существует множество отличных
вариантов для этого, таких как angel или daemontools.

В качестве конкретного примера ниже приведён файл конфигурации Upstart. Он
должен располагаться в /etc/init/mysite.conf:

\begin{lstlisting}
description "My awesome Yesod application"
start on runlevel [2345];
stop on runlevel [!2345];
respawn
chdir /home/michael/sites/mysite
exec /home/michael/sites/mysite/dist/build/mysite/mysite
\end{lstlisting}

Как только этот файл на месте, запуск вашего приложения потребует всего лишь
одной команды \lstinline{sudo start mysite}.

\section{FastCGI}
Некоторые предпочитают использовать FastCGI для развёртывания своих приложений.
В этом случае вам потребуется ещё один инструмент. FastCGI работает, принимая
новые соединения из файлового дескриптора. Стандартная библиотека C
предполагает, что этот файловый дескриптор будет равен 0 (стандартный поток
ввода), а значит, надо использовать специальную программу spawn-fcgi, которая
свяжет стандартный поток ввода вашего приложения с правильным сокетом.

Может оказаться очень удобным использовать для этих целей именованные сокеты
Unix вместо привязки к порту, особенно если вы собираетесь запускать несколько
приложений на одном физическом сервере. Возможный сценарий для запуска вашего
приложения может выглядеть следующим образом:

\begin{lstlisting}
spawn-fcgi \
    -d /home/michael/sites/mysite \
    -s /tmp/mysite.socket \
    -n \
    -M 511 \
    -u michael \
    -- /home/michael/sites/mysite/dist/build/mysite-fastcgi/mysite-fastcgi
\end{lstlisting}

Вам также потребуется сконфигурировать ваш фронтенд сервер для общения с вашим
приложением через FastCGI. В случае с Nginx это относительно просто:

\begin{lstlisting}
server {
    listen 80;
    server_name www.myserver.com;
    location / {
        fastcgi_pass unix:/tmp/mysite.socket;
    }
}
\end{lstlisting}

Этот пример должен выглядеть знакомым, учитывая описанные ранее варианты.
Последний трюк состоит в том, что с Nginx вам необходимо вручную задать все
переменные FastCGI. Рекомендуется хранить эти переменные в отдельном файле
(скажем, fastcgi.conf), и добавлять \lstinline{include fastcgi.conf;} в конец
блока \lstinline{http}. Содержимое этого файла, настроенного для работы через
WAI, должно быть следующим:

\begin{lstlisting}
fastcgi_param  QUERY_STRING       $query_string;
fastcgi_param  REQUEST_METHOD     $request_method;
fastcgi_param  CONTENT_TYPE       $content_type;
fastcgi_param  CONTENT_LENGTH     $content_length;
fastcgi_param  PATH_INFO          $fastcgi_script_name;
fastcgi_param  SERVER_PROTOCOL    $server_protocol;
fastcgi_param  GATEWAY_INTERFACE  CGI/1.1;
fastcgi_param  SERVER_SOFTWARE    nginx/$nginx_version;
fastcgi_param  REMOTE_ADDR        $remote_addr;
fastcgi_param  SERVER_ADDR        $server_addr;
fastcgi_param  SERVER_PORT        $server_port;
fastcgi_param  SERVER_NAME        $server_name;
\end{lstlisting}%$

\section{Настольное приложение}
Другой замечательный способ запускать ваше приложение~---
\footnotehref{http://hackage.haskell.org/package/wai-handler-webkit}{wai-handler-webkit}.
Он объединяет Warp и QtWebkit для создания исполняемого файла, который может
быть запущен при помощи простого двойного щелчка мышью. Это может быть удобным
способом сделать оффлайн версию вашего приложения.

Одно из удобств Yesod в данном случае состоит в том, что все ваши шаблоны
страниц компилируются в исполняемый файл, избавляя вас от необходимости
распространять их отдельно. В случае со статическими файлами это, однако, не
так.

На самом деле, поддержка включения статических файлов прямо в приложение
существует, обращайтесь к документации к
\footnotehref{http://hackage.haskell.org/package/yesod-static}{yesod-static} за
подробностями.

Аналогичный подход
\footnotehref{http://hackage.haskell.org/package/wai-hanlder-launch}{wai-handler-launch},
который не требует библиотеки QtWebkit, запускает Warp сервер и затем открывает
пользовательский браузер по умолчанию. Следует отметить небольшой трюк: для
того, чтобы понять, что пользователь всё ещё пользуется сайтом,
wai-handler-launch вставляет небольшой отрывок Javascript сценария на каждую
HTML страницу, которую раздаёт. Этот сценарий периодически посылает
``пинг''(запрос, не несущий полезной нагрузки и требующий ответа) на сервер.
Если wai-handler-launch не получает ответа на такой запрос в течение двух
минут, то он останавливается.

\section{CGI и Apache}
CGI и FastCGI работают с Apache почти одинаково, так что подправить
конфигурацию должно быть довольно просто. Вам всего лишь надо добиться
выполнения двух пунктов:
\begin{enumerate}
  \item Заставить веб-сервер раздавать ваши файлы как (Fast)CGI;

  \item Сделать так, чтобы все запросы к вашему сайту шли через (Fast)CGI
      исполняемый файл.
\end{enumerate}

Вот пример файла конфигурации для приложения-блога, исполняемый файл которого
называется ``bloggy.cgi'', расположенного в подкаталоге ``blog''. Этот пример
бы взят из приложения, находящегося в каталоге /f5/snoyman/public/blog.

\begin{lstlisting}
Options +ExecCGI
AddHandler cgi-script .cgi
Options +FollowSymlinks

RewriteEngine On
RewriteRule ^/f5/snoyman/public/blog$ /blog/ [R=301,S=1]
RewriteCond $1 !^bloggy.cgi
RewriteCond $1 !^static/
RewriteRule ^(.*) bloggy.cgi/$1 [L]
\end{lstlisting}

Первая запись RewriteRule отвечает за правильную обработку подкаталогов. В
частности, она перенаправляет запросы к /blog на /blog/. Первая запись
RewriteCond предотвращает запрос самого исполняемого файла, вторая~---
разрешает Apache раздавать статические файлы. Последняя строка, собственно, и
осуществляет перенаправление запросов.

\section{FastCGI и lighttpd}
Для этого примера я опустил некоторые из основных настроек FastCGI, такие как
mime-типы. В реальном приложении у меня используется более сложный файл,
который добавляет префикс ``www.'' в начало URL, если он отсутствует, а также
раздаёт статические файлы с отдельного домена. Однако следующего примера должно
быть достаточно, чтобы понять основы.

Здесь ``/home/michael/fastcgi''~--- это fastcgi приложение. Идея состоит в том,
чтобы перенаправлять все запросы на ``/app'', после чего раздавать всё,
начинающееся с ``/app'' через исполняемый файл FastCGI.

\begin{lstlisting}
server.port = 3000
server.document-root = "/home/michael"
server.modules = ("mod_fastcgi", "mod_rewrite")

url.rewrite-once = (
  "(.*)" => "/app/$1"
)

fastcgi.server = (
    "/app" => ((
        "socket" => "/tmp/test.fastcgi.socket",
        "check-local" => "disable",
        "bin-path" => "/home/michael/fastcgi", # полный путь к исполняемому файлу
        "min-procs" => 1,
        "max-procs" => 30,
        "idle-timeout" => 30
    ))
)
\end{lstlisting}%$

\section{CGI и lighttpd}
Ниже представлен конфигурационный файл, почти идентичный версии для FastCGI,
однако он говорит lighttpd запускать файл, заканчивающийся на ``.cgi'' как CGI
исполняемый файл. В данном случае этот файл располагается в
``/home/michael/myapp.cgi''.
\begin{lstlisting}
server.port = 3000
server.document-root = "/home/michael"
server.modules = ("mod_cgi", "mod_rewrite")

url.rewrite-once = (
    "(.*)" => "/myapp.cgi/$1"
)

cgi.assign = (".cgi" => "")
\end{lstlisting}
