\chapter{Аутентификация и Авторизация}\label{chap:auth}

Аутентификация и авторизация две очень связанные, но в то же время различные концепции. В то время как первая имеет дело с идентификацией пользователя, вторая определяет, что пользователю позволенно делать. К сожалению, поскольку для обоих терминов часто используется абревиатура "auth", эти концепции часто объединяются.

Yesod обеспечивает встроенную поддержку для нескольких сторонних систем аутентификации, таких как OpenID, BrowserID и OAuth. Это внешние системы которым ваше приложение доверяет удостоверение личности пользователя. Также есть поддержка более обычных способов аутентификации, таких как имя пользователя/пароль или адрес почты/пароль. Первый способ гарантирует простоту как для пользователей (нет неоходимости запоминать новые пароли), так и для разработчиков (нет нужды иметь дело со всей архитектурой безопасности), в то время как второй даёт разработчику больший контроль.

Для авторизации, мы можем воспользоваться преймуществами REST и типобезопасными URL, чтобы создать простую и декларативную систему. К тому же, поскольку весь код авторизации написан на Haskell, в вашем распоряжении будет вся гибкость языка.

В этой главе мы рассмотрим, как настроить "auth" в Yesod, и обсудим некоторые компромисы в различных опциях аутентификации.

\section{Обзор}

Пакет \footnotehref{http://hackage.haskell.org/package/yesod-auth}{yesod-auth} обеспечивает унифицированный интерефейс для различных плагинов аутентификации. Единственное, что от них требуется, это чтобы они идентифицировали пользователя по какой-то уникальной строке. В OpenID, к примеру, это может быть фактическое значение OpenID. В BrowserID, это адрес электронной почты. Для HashDB (которая использует базу данных хэшированных паролей), это имя пользователя.

Каждый плагин аутентификации обеспечивает свою собственную систему для входа, будь это передача токенов с внешнего сайта, или же форма входа используя адрес почты/пароль. После успешного входа, плагин устанавливает значение в пользовательской сессии, определяющее его \lstinline'AuthId'. Этот \lstinline'AuthId' это обычно Persistent ID из таблицы используемой для отслеживания пользователей. 

Есть несколько функций, доступные для запроса пользовательского \lstinline'AuthId', наиболее используемые \lstinline'maybeAuthId', \lstinline'requireAuthId', \lstinline'maybeAuth' и \lstinline'requireAuth'. Версии require перенаправляют на страницу входа, если пользователь ещё не вошел, а те функции, что не оканчиваются на Id, возвращают два значения --- ID таблицы и значение сущности.

Поскольку сбережение \lstinline'AuthId' построено на сессиях, то применимы все их правила. В часности, данные сохраняются в зашифрованом, подписаном HMAC куки, который автоматически устаревает после определенного сконфигурированного периода неактивности. А также, поскольку не существует серверной составляющей сессий, то при выходе из системы просто удаляются данные из куки этой сессии, и если пользователь повторно использует старое значение куки, то сессия будет считаться действительной.

\begin{remark}
В будущем мы планируем добавить к сессиям серверную часть, которая будет позволять делать принудительный выход пользователя. Почти точно это будет реализовано до релиза Yesod 1.0.
\end{remark}

С другой стороны, авторизация контролируется несколькими методами внутри класса типов \lstinline'Yesod'. Эти методы запускаются для каждого запроса, что бы определить --- разрешить или запретить доступ, или потребовать от пользователя войти на сайт. По умолчанию, эти метода разрешают доступ для каждого запроса. В качестве альтернативы, вы можете реализовать авторизацию более специальном способом, вызывая \lstinline'requireAuth' и подобные функции в индивидуальных функциях обработчиках, хотя это убирает преймущества декларативной системы авторизации.

\section{Узнай меня}

Давайте сразу рассмотрим пример с аутентификацией.

\begin{lstlisting}
{-# LANGUAGE OverloadedStrings, TemplateHaskell, TypeFamilies,
             MultiParamTypeClasses, QuasiQuotes #-}
import Yesod
import Yesod.Auth
import Yesod.Auth.BrowserId
import Yesod.Auth.GoogleEmail
import Data.Text (Text)
import Network.HTTP.Conduit (Manager, newManager, def)

data MyAuthSite = MyAuthSite
    { httpManager :: Manager
    }

mkYesod "MyAuthSite" [parseRoutes|
/ RootR GET
/auth AuthR Auth getAuth
|]

instance Yesod MyAuthSite where
    -- Внимание! Что бы работал вход с BrowserID, вы должны здесь
    -- корректно установить адрес вашего хоста.
    approot = ApprootStatic "http://localhost:3000"

instance YesodAuth MyAuthSite where
    type AuthId MyAuthSite = Text
    getAuthId = return . Just . credsIdent

    loginDest _ = RootR
    logoutDest _ = RootR

    authPlugins _ =
        [ authBrowserId
        , authGoogleEmail
        ]

    authHttpManager = httpManager

instance RenderMessage MyAuthSite FormMessage where
    renderMessage _ _ = defaultFormMessage

getRootR :: Handler RepHtml
getRootR = do
    maid <- maybeAuthId
    defaultLayout [whamlet|
<p>Your current auth ID: #{show maid}
$maybe _ <- maid
    <p>
        <a href=@{AuthR LogoutR}>Logout
$nothing
    <p>
        <a href=@{AuthR LoginR}>Go to the login page
|]

main :: IO ()
main = do
    man <- newManager def
    warpDebug 3000 $ MyAuthSite man
\end{lstlisting}

Начинаем с объявлений маршрутов. Сперва объявляем наш стандартный маршрут \lstinline'RootR', а затем определили подсайт для аутентификации. Помните, что ему нужны четыре параметра: путь к подсайту, имя маршрута, имя подсайта, и функция для получения значения подсайта. Другими словами, основываясь на строке:

\begin{lstlisting}
/auth AuthR Auth getAuth
\end{lstlisting}

Нам нужно иметь функцию \lstinline'getAuth :: MyAuthSite -> Auth'. Пока мы не напишем эту функцию сами, \lstinline'yesod-auth' предоставляет её автоматически. Для других подсайтов (к примеру со статическими файлами), мы обеспечиваем настройки конфигурации в значении подсайта, и поэтому нам нужно определять функцию get. Для auth подсайта, мы указываем эти настройки в классе типов \lstinline'YesodAuth'.

\begin{remark}
Почему не использовать значение подсайта? Существует достаточно много настроек, которые мы бы хотели передать auth подсайту, и делать это из типа записи (record type) было бы неудобно. Также, поскольку мы хотим иметь ассоциируемый тип \lstinline'AuthId', использование класса типов будет более естественным.

С другой стороны, почему бы не использовать класс типов для всех подсайтов? У такого подхода есть минус: вы сможете иметь только один экземпляр класса на сайт, не позволяя раздавать различные группы статичных файлов с различных маршрутов. Также, если мы хотим загружать данные во время иницииализации приложения значение подсайта подойдёт лучше.
\end{remark}

Так что точно входит в экземпляр класса \lstinline'YesodAuth'? Есть шесть необходимых объявлений:

\begin{itemize}
    \item Ассоциированный тип \lstinline'AuthId'. Это то значение которое \lstinline'yesod-auth' будет давать вам, когда вы будете спрашивать, вошёл ли пользователь (через \lstinline'maybeAuthId' или \lstinline'requireAuthId'). В нашем случае, мы просто используем \lstinline'Text', для сохранения необработанного идентификатора, как вы скоро увидите это будет адрес электронной почты. 

    \item \lstinline'getAuthId' получает текущий \lstinline'AuthId' из типа данных \lstinline'Creds' (credentials --- учетные данные). Этот тип имеет три части информации: используемый способ аутентификации (в нашем случае browserid или googleemail), текущий идентификатор, и ассоциированный список с различной дополнительной информацией.

    \item \lstinline'loginDest' возвращает маршрут куда перенаправить пользователя после успешного входа.

    \item Подобно, \lstinline'logoutDest' возвращает маршрут для перенаправления после выхода. 

    \item \lstinline'authPlugins' это список используемых способов аутентификации. В нашем примере, мы используем BrowserID, который входит через систему Mozilla BrowserID, и Google Email, который аутентифицирует почтовый адрес пользователя, используя его Google аккаунт. Что хорошо в этих двух способах это то, что:
    
    \begin{itemize}
        \item Они не требуют установки, в отличие от Facebook или OAuth, которые требуют задания учетных данных.
        
        \item Они используют в качестве идентификатор адрес электронной почты, который более понятен людям, в отличие от OpenID, который использует URL. 
    \end{itemize}
    
    \item \lstinline'authHttpManager' получает менеджер HTTP соединений из основного типа. Это позволяет системам аутентификации, которые использует HTTP соединения (то есть почти все сторонние системы входа), использовать их повторно, избегая стоимости установки нового TCP соединения для каждого запроса.
\end{itemize}

Наш обработчик \lstinline'RootR', содержит ссылки на страницы входа и выхода, которые показываются в зависимости от того зашёл пользователь или нет. Обратите внимание как мы конструируем эти ссылки на подсайт: первым идёт имя маршрута подсайта (\lstinline'AuthR'), а следом маршрут в подсайте (\lstinline'LoginR' и \lstinline'LogoutR').

Илюстрации ниже показывает процесс входа со стороны пользователя.

\begin{figure}[tbh]
  \centering
  \includegraphics{14-initial-screen.png}
  \caption{Начальная загрузка страницы}
\end{figure}

\begin{figure}[tbh]
  \centering
  \includegraphics{14-login-with-browserid.png}
  \caption{Экран входа с помощью BrowserID}
\end{figure}

\begin{figure}[tbh]
  \centering
  \includegraphics{14-after-login.png}
  \caption{Домащняя страница после входа}
\end{figure}

\section{Электронная почта}

Для большинства случаев будет достаточно аутентификации по адресу электронной почты. Но иногда вам может понадобиться чтобы пользователи использовали пароль для вашего сайта. Сгенерированый сайт не включает этой функциональности, потому что:

\begin{itemize}
    \item Что бы безопасно использовать пароль, надо ипользовать SSL. Многие пользователи не предоставляют доступ к сайту по SSL.

    \item В то время как внешние системы аутентификации по адресу электронной почты должным образом хранят пароли, скомпрометировнная база данных может быть проблемой. Мы не делаем никаких предположений, что пользователи Yesod следуют практике безопасной разработки.

    \item Вам нужна работающая система для отправки электронной почты. Много веб серверов в наши дни не справляются со всеми механизмами защиты от спама используемыми почтовыми серверами.

    \begin{remark}
    Пример ниже использует системную программу для отправки писем --- sendmail\footnote{работает только на Unix --- прим. пер.}. Если вы хотите избежать хлопот работая с серверами электронной почты самостоятельно, вы можете использовать Amazon SES. Есть пакет \footnotehref{http://hackage.haskell.org/package/mime-mail-ses}{mime-mail-ses}, который предоставляет альтернативу использованию sendmail. Этот подход мы используем на сайте Haskellers.com.
    \end{remark}
\end{itemize}

Допустим, что вам понадобилось иметь вход с паролем специфичным для вашего сайта. Для этого Yesod предоставляет встроенную систему аутентификации. Для её использования от вас потребуется немного больше кода, ведь будет необходимо безопасно сохраненять пароли в базе данных, и отправлять пользователю почтовые сообщения (проверка аккаунта, восстановление пароля, и т.д.).

Давайте посмотри на сайт предоставляющий аутентификацию по адресу электронной почты и паролю, хранящий пароли в Persistent базе данных SQLite.

\begin{lstlisting}
{-# LANGUAGE OverloadedStrings, TypeFamilies, QuasiQuotes, GADTs,
             TemplateHaskell, MultiParamTypeClasses, FlexibleContexts #-}
import Yesod
import Yesod.Auth
import Yesod.Auth.Email
import Database.Persist.Sqlite
import Database.Persist.TH
import Data.Text (Text)
import Network.Mail.Mime
import qualified Data.Text.Lazy.Encoding
import Text.Shakespeare.Text (stext)
import Text.Blaze.Html.Renderer.Utf8 (renderHtml)
import Text.Hamlet (shamlet)
import Data.Maybe (isJust)
import Control.Monad (join)

share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persist|
User
    email Text
    password Text Maybe -- Пароль может быть ещё не задан
    verkey Text Maybe -- Используется для сброса пароля
    verified Bool
    UniqueUser email
|]

data MyEmailApp = MyEmailApp Connection

mkYesod "MyEmailApp" [parseRoutes|
/ RootR GET
/auth AuthR Auth getAuth
|]

instance Yesod MyEmailApp where
    -- Электронные письма будут содержать ссылки, так что убедитесь что включили approot, 
    -- что бы ссылки были правильными!
    approot = ApprootStatic "http://localhost:3000"

instance RenderMessage MyEmailApp FormMessage where
    renderMessage _ _ = defaultFormMessage

-- Установка Persistent
instance YesodPersist MyEmailApp where
    type YesodPersistBackend MyEmailApp = SqlPersist
    runDB f = do
        MyEmailApp conn <- getYesod
        runSqlConn f conn

instance YesodAuth MyEmailApp where
    type AuthId MyEmailApp = UserId

    loginDest _ = RootR
    logoutDest _ = RootR
    authPlugins _ = [authEmail]

    -- Необходимо найти UserId по заданному адресу электронной почты.
    getAuthId creds = runDB $ do
        x <- insertBy $ User (credsIdent creds) Nothing Nothing False
        return $ Just $
            case x of
                Left (Entity userid _) -> userid -- свеже добавленый пользователь
                Right userid -> userid -- существующий пользователь

    authHttpManager = error "Email doesn't need an HTTP manager"

-- Здесь весь код работающий с электронной почтой
instance YesodAuthEmail MyEmailApp where
    type AuthEmailId MyEmailApp = UserId

    addUnverified email verkey =
        runDB $ insert $ User email Nothing (Just verkey) False

    sendVerifyEmail email _ verurl =
        liftIO $ renderSendMail (emptyMail $ Address Nothing "noreply")
            { mailTo = [Address Nothing email]
            , mailHeaders =
                [ ("Subject", "Verify your email address")
                ]
            , mailParts = [[textPart, htmlPart]]
            }
      where
        textPart = Part
            { partType = "text/plain; charset=utf-8"
            , partEncoding = None
            , partFilename = Nothing
            , partContent = Data.Text.Lazy.Encoding.encodeUtf8 [stext|
Please confirm your email address by clicking on the link below.

\#{verurl}

Thank you
|]
            , partHeaders = []
            }
        htmlPart = Part
            { partType = "text/html; charset=utf-8"
            , partEncoding = None
            , partFilename = Nothing
            , partContent = renderHtml [shamlet|
<p>Please confirm your email address by clicking on the link below.
<p>
    <a href=#{verurl}>#{verurl}
<p>Thank you
|]
            , partHeaders = []
            }
    getVerifyKey = runDB . fmap (join . fmap userVerkey) . get
    setVerifyKey uid key = runDB $ update uid [UserVerkey =. Just key]
    verifyAccount uid = runDB $ do
        mu <- get uid
        case mu of
            Nothing -> return Nothing
            Just u -> do
                update uid [UserVerified =. True]
                return $ Just uid
    getPassword = runDB . fmap (join . fmap userPassword) . get
    setPassword uid pass = runDB $ update uid [UserPassword =. Just pass]
    getEmailCreds email = runDB $ do
        mu <- getBy $ UniqueUser email
        case mu of
            Nothing -> return Nothing
            Just (Entity uid u) -> return $ Just EmailCreds
                { emailCredsId = uid
                , emailCredsAuthId = Just uid
                , emailCredsStatus = isJust $ userPassword u
                , emailCredsVerkey = userVerkey u
                }
    getEmail = runDB . fmap (fmap userEmail) . get

getRootR :: Handler RepHtml
getRootR = do
    maid <- maybeAuthId
    defaultLayout [whamlet|
<p>Your current auth ID: #{show maid}
$maybe _ <- maid
    <p>
        <a href=@{AuthR LogoutR}>Logout
$nothing
    <p>
        <a href=@{AuthR LoginR}>Go to the login page
|]

main :: IO ()
main = withSqliteConn "email.db3" $ \conn -> do
    runSqlConn (runMigration migrateAll) conn
    warpDebug 3000 $ MyEmailApp conn
\end{lstlisting}

\section{Авторизация}

Как только вы аутентифицировали пользователей, вы можете использовать их учётные данные для \emph{авторизации} дальнейших запросов. Авторизация в Yesod простая и декларативная: в большинстве случаев всего лишь необходимо добавить методы \lstinline'authRoute' и \lstinline'isAuthorized' в ваш экземпляр класса типов Yesod. Давайте рассмотрим пример.

\begin{lstlisting}
{-# LANGUAGE OverloadedStrings, TemplateHaskell, TypeFamilies,
             MultiParamTypeClasses, QuasiQuotes #-}
import Yesod
import Yesod.Auth
import Yesod.Auth.Dummy -- только для тестирования, не используйте в реальной жизни!!!
import Data.Text (Text)
import Network.HTTP.Conduit (Manager, newManager, def)

data MyAuthSite = MyAuthSite
    { httpManager :: Manager
    }

mkYesod "MyAuthSite" [parseRoutes|
/ RootR GET POST
/admin AdminR GET
/auth AuthR Auth getAuth
|]

instance Yesod MyAuthSite where
    authRoute _ = Just $ AuthR LoginR

    -- имя маршрута и булевое значение определяющее является ли это запросом на запись
    isAuthorized RootR True = isAdmin
    isAuthorized AdminR _ = isAdmin

    -- любой может получить доступ к другим страницам
    isAuthorized _ _ = return Authorized

isAdmin = do
    mu <- maybeAuthId
    return $ case mu of
        Nothing -> AuthenticationRequired
        Just "admin" -> Authorized
        Just _ -> Unauthorized "You must be an admin"

instance YesodAuth MyAuthSite where
    type AuthId MyAuthSite = Text
    getAuthId = return . Just . credsIdent

    loginDest _ = RootR
    logoutDest _ = RootR

    authPlugins _ = [authDummy]

    authHttpManager = httpManager

instance RenderMessage MyAuthSite FormMessage where
    renderMessage _ _ = defaultFormMessage

getRootR :: Handler RepHtml
getRootR = do
    maid <- maybeAuthId
    defaultLayout [whamlet|
<p>Note: Log in as "admin" to be an administrator.
<p>Your current auth ID: #{show maid}
$maybe _ <- maid
    <p>
        <a href=@{AuthR LogoutR}>Logout
<p>
    <a href=@{AdminR}>Go to admin page
<form method=post>
    Make a change (admins only)
    \ #
    <input type=submit>
|]

postRootR :: Handler ()
postRootR = do
    setMessage "You made some change to the page"
    redirect RootR

getAdminR :: Handler RepHtml
getAdminR = defaultLayout [whamlet|
<p>I guess you're an admin!
<p>
    <a href=@{RootR}>Return to homepage
|]

main :: IO ()
main = do
    manager <- newManager def
    warpDebug 3000 $ MyAuthSite manager
\end{lstlisting}

\lstinline'authRoute' должен быть вашей страницей входа, почти всегда это \lstinline'AuthR LoginR'. Функция \lstinline'isAuthorized' имеет два параметра: запрашиваемый маршрут, и является ли запрос запросом на запись. На самом деле вы можете переопроеделить, что являеться запросом на запись, используя метод \lstinline'isWriteRequest', но из коробки мы следуем принципам RESTful: все запросы кроме \lstinline'GET', \lstinline'HEAD', \lstinline'OPTIONS' или \lstinline'TRACE' это запросы на запись.

В теле \lstinline'isAuthorized' вы можете исполнять любой \lstinline'Handler' код, который вы захотите, что очень удобно. Ведь это означает, что вы можете:

\begin{itemize}
    \item Доступаться к файловой системе (нормальный IO)

    \item Делать запросы к базе данных

    \item Получать любые параметры сессии или запроса
\end{itemize}

Используя эти техники, вы можете разработать настолько сложную систему авторизации, насколько захотите, или даже привязаться к уже существующей системе используемой в вашей организации.

\section{Выводы}

Эта глава рассматривает основы настройки аутентификации пользователей, и то, как встроенные функции авторизации обеспечивают простой и декларативный подход для пользователей. Так что, хоть это и сложные концепции, со многими подходами, Yesod предоставляет вам все строительные блоки, которые вам понадобятся для создания auth решения соответствующего вашим требованиям.
