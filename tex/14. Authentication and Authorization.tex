\chapter{Аутентификация и Авторизация}\label{chap:auth}

Аутентификация и авторизация две очень связанные, но в то же время различные концепции. В то время как первая имеет дело с идентификацией пользователя, вторая определяет, что пользователю позволенно делать. К сожалению, поскольку для обоих терминов часто используется абревиатура "auth", эти концепции часто объединяются.

Yesod обеспечивает встроенную поддержку для нескольких сторонних систем аутентификации, таки как OpenID, BrowserID и OAuth. Это внешние системы которым ваше приложение доверяет удостоверение личности пользователя. Также есть поддержка для более обычных систем аутентификации, таких как имя пользователя/пароль или адрес почты/пароль. Первый способ гарантирует простоту как для пользователей (нет неоходимости запоминать новые пароли), так и для разработчиков (нет нужды иметь дело со всей архитектурой безопасности), в то время как последний дает разработчику больший контроль.

Для авторизации, мы можем воспользоваться преймуществами REST и типобезопасными URL, чтобы создать простую, декларативную систему. К тому же, поскольку весь код авторизации написан на Haskell в вашем распоряжении будет вся гибкость языка.

В этой главе мы рассмотрим, как установить настроить "auth" решение в Yesod, и обсудим некоторые компромисы в различных опциях аутентификации.

\section{Обзор}

Пакет \footnotehref{http://hackage.haskell.org/package/yesod-auth}{yesod-auth} обеспечивает унифицированный интерефейс для различных плагинов аутентификации. Единственное что от требование для них, это чтобы они идентифицировали пользователя по какой-то уникальной строке. В OpenID, к примеру, это может быть фактическое значение OpenID. В BrowserID, это адрес электронной почты. Для HashDB (которая использует базу данных хэшированных паролей), это имя пользователя.

Каждый плагин аутентификации обеспечивает свою собственную систему для входа, либо через передачу токенов с внешнего сайта, или через форму адрес почты/пароль. После успешного входа, плагин устанавливает значение в пользовательской сессии, указывающее его \lstinline'AuthId'. Этот \lstinline'AuthId' это обычно Persistent ID из таблицы используемой для отслеживания пользователей. 

Есть несколько функций, доступные для запроса пользовательского \lstinline'AuthId', наиболее часто \lstinline'maybeAuthId', \lstinline'requireAuthId', \lstinline'maybeAuth' и \lstinline'requireAuth'. Версии require* перенаправляют на страницу входа, если пользователь ешё не вошел, а те функции, что не оканчиваются на Id, возвращают два значения --- ID таблицы и значение сущности.

Поскольку всё хранилище \lstinline'AuthId' построено на сессиях, то применимы все их правила. В часности, данные сохраняются зашифрованными, подписаное HMAC куки, который автоматически устаревает после определенного сконфигурированного периода неактивности. А также, поскольку не существует компоненты сессий на стороне сервера, при выходе из системы просто удаляются данные из куки сессии; если пользователь использует старое значение куки, сессия будет оставаться действительной.

\begin{remark}
В будущем мы планируем добавить к сессиям серверную часть, которая будет позволять делать принудительный выход пользователя. Почти точно это будет реализовано до релиза Yesod 1.0.
\end{remark}

С другой стороны, авторизация обрабатывается несколькими методами внутри класса типов \lstinline'Yesod'. Эти методы запускаются для каждого запроса, что бы определить, должен ли доступ быть разрешен, запрещен, или необходимо чтобы пользователь был авторизован. По умолчанию, эти метода разрешают доступ для каждого запроса. В качестве альтернативы, вы можете реализовать авторизацию более специальном способом, добавив вызовы \lstinline'requireAuth' и подобных функций в индивидуальных функциях обработчиках, хотя это убирает преймущества декларативной системы авторизации.

\section{Опознай меня}

Давайте сразу рассмотрим пример с аутентификацией.

\begin{lstlisting}
{-# LANGUAGE OverloadedStrings, TemplateHaskell, TypeFamilies,
             MultiParamTypeClasses, QuasiQuotes #-}
import Yesod
import Yesod.Auth
import Yesod.Auth.BrowserId
import Yesod.Auth.GoogleEmail
import Data.Text (Text)
import Network.HTTP.Conduit (Manager, newManager, def)

data MyAuthSite = MyAuthSite
    { httpManager :: Manager
    }

mkYesod "MyAuthSite" [parseRoutes|
/ RootR GET
/auth AuthR Auth getAuth
|]

instance Yesod MyAuthSite where
    -- Внимание! Что бы работал вход с BrowserID, вы должны здесь
    -- корректно установить адрес вашего хоста.
    approot = ApprootStatic "http://localhost:3000"

instance YesodAuth MyAuthSite where
    type AuthId MyAuthSite = Text
    getAuthId = return . Just . credsIdent

    loginDest _ = RootR
    logoutDest _ = RootR

    authPlugins _ =
        [ authBrowserId
        , authGoogleEmail
        ]

    authHttpManager = httpManager

instance RenderMessage MyAuthSite FormMessage where
    renderMessage _ _ = defaultFormMessage

getRootR :: Handler RepHtml
getRootR = do
    maid <- maybeAuthId
    defaultLayout [whamlet|
<p>Your current auth ID: #{show maid}
$maybe _ <- maid
    <p>
        <a href=@{AuthR LogoutR}>Logout
$nothing
    <p>
        <a href=@{AuthR LoginR}>Go to the login page
|]

main :: IO ()
main = do
    man <- newManager def
    warpDebug 3000 $ MyAuthSite man
\end{lstlisting}

Мы начали с объявлений маршрута. Сперва объявили наш стандартный маршрут \lstinline'RootR', а затем определили подсайт для аутентификации. Запомните что ему нужны четыре параметра: путь к подсайту, имя маршрута, имя подсайта, и функция для получения значения подсайта. Другими словами, основываясь на строке:

\begin{lstlisting}
/auth AuthR Auth getAuth
\end{lstlisting}

Нам нужно иметь \lstinline'getAuth :: MyAuthSite -> Auth'. Пока мы ещё не написали эту функцию сами, \footnotehref{http://hackage.haskell.org/package/yesod-auth}{yesod-auth} предоставляет её автоматически. Для других подсайтов (к примеру со статическими файлами), мы обеспечиваем настройки конфигурации в значении подсайта, и вледствии этого нужно указать функцию get. Для подсайта auth, мы указываем эти настройки в отдельном классе типов, \lstinline'YesodAuth'.

\begin{remark}
Почему не использовать значение подсайта? Существует достаточно много настроек, которые мы бы хотели настраивать у auth подсайта, и делать это из типа записи (record type) было бы неудобно. Также, поскольку мы хотим иметь ассоциируемый тип \lstinline'AuthId', класс типов будет более естественным.

С другой стороны, почему не использовать класс типов для всех подсайтов? У этого есть минус: вы сможете иметь только один экземпляр класса на сайт, не позволяя раздавать различные наборы статичных файлов с различных маршрутов. Также, значение подсайта работает лучше если мы хотим загружать данные во время иницииализации приложения.
\end{remark}

Так что точно входит в экземпляр класса \lstinline'YesodAuth'? Есть шесть необходимых объявлений:

\begin{itemize}
    \item \lstinline'AuthId' это ассоциированный тип. Это то значение которое \lstinline'yesod-auth' будет давать вам когда вы будете спрашивать, вошёл ли пользователь (через \lstinline'maybeAuthId' или \lstinline'requireAuthId'). В нашем случае, мы просто используем \lstinline'Text', для сохранения необработанного идентификатора --- в нашем случае адреса электронной почты, как мы скоро увидим. 

    \item \lstinline'getAuthId' получает текущий \lstinline'AuthId' из типа данных \lstinline'Creds' (credentials --- учетные данные). Этот тип имеет три части информации: используемый способ аутентификации (в нашем случае browserid или googleemail), текущий идентификатор, и ассоциированный список с различной дополнительной информацией.

    \item \lstinline'loginDest' возвращает маршрут куда перенаправить пользователя после успешного входа.

    \item Подобно, \lstinline'logoutDest' возвращает маршрут для перенаправления после выхода. 

    \item \lstinline'authPlugins' это список используемых способов аутентификации. В нашем примере, мы используем BrowserID, который входит через систему Mozilla BrowserID, и Google Email, который аутентифицирует пользовательский почтовый адрес используя его Google аккаунт. Что хорошо в этих двух способах это:
    
    \begin{itemize}
        \item Они не требуют предустановки, в отличие от Facebook или OAuth, которые требуют установки учетных данных.
        
        \item Они используют адрес электронной почты как идентификатор, что людям более комфортно, в отличие от OpenID, которые используют URL. 
    \end{itemize}
    
    \item \lstinline'authHttpManager' получает менеджер соединений HTTP из основного типа. Это позволяет системам аутентификации, которые использует HTTP соединения (то есть почти все сторонние системы входа), использовать их повторно, избегая стоимости установки нового TCP соединения для каждого запроса.
\end{itemize}

Наш обработчик \lstinline'RootR', содержит ссылки на страницы входа и выхода, зависящие от того зашёл пользователь или нет. Обратите внимание как мы конструируем эти ссылки на подсайт: первым идёт имя маршрута подсайта (\lstinline'AuthR'), а следом маршрут в подсайте (\lstinline'LoginR' и \lstinline'LogoutR').

Илюстрации ниже показывает процесс входа со стороны пользователя.

\begin{figure}[tbh]
  \centering
  \includegraphics{14-initial-screen.png}
  \caption{Начальная загрузка страницы}
\end{figure}

\begin{figure}[tbh]
  \centering
  \includegraphics{14-login-with-browserid.png}
  \caption{Экран входа с помощью BrowserID}
\end{figure}

\begin{figure}[tbh]
  \centering
  \includegraphics{14-after-login.png}
  \caption{Домащняя страница после входа}
\end{figure}

Элеткронная почта

Для множества случаев, сторонная аутентификация через электронную почту будет достаточна. Иногда, мы хотим чтобы пользователи создавали пароль на наш сайт на самом деле. Каркасный сайт не включает это в установку, потому что:
В порядке для принятия защищенного пароля, вам нужно быть запущенным поверх SSL. Много пользователей не предоставляют их сайты поверх SSL.
В то время как бэкэнд электронной почты должным образом солит и хэширует пароли, скомпрометировнная база данных остается проблематичной. Еще раз, мы не делаем никаких предположений, что пользователи Yesod следуют практикам безопасной разработки.
Вам нужна работающая система для посылки электронной почты. Много веб серверов эти дни не оборудованны чтобы справляться с всеми измерениями спам защиты используемые почтовыми серверами.
Пример нижеуже использует встроенную систему отправки писем. Если вы захотите избежать хлопот работая с серверами электронной почты самостоятельно, вы можете использовать Amazon SES. Есть пакет называемый mime-mail-ses, который предоставляет замену для кода sendmail ниже. Этот подход мы используем на сайте Haskellers.com.
Но предполагая, что вы возможно встретите эти требования, и вы захотите иметь отдельный вход с паролем особенный для ваше сайта, Yesod предлагает встроенный бэкэнд. Он требуетнемножко кода для установки, хотя он нуждается в сохранении паролей безопасно в базе данных и отправке различным адресам электронной почты к пользователю (проверка аккаунта, восстановление пароля, и т.д.).
Давайте посмотри на сайт предоставляющий аутентификацию электронной почтой, хранящий пароли в постоянной SQLite базе данных.
\begin{lstlisting}
{-# LANGUAGE OverloadedStrings, TypeFamilies, QuasiQuotes, GADTs,
             TemplateHaskell, MultiParamTypeClasses, FlexibleContexts #-}
import Yesod
import Yesod.Auth
import Yesod.Auth.Email
import Database.Persist.Sqlite
import Database.Persist.TH
import Data.Text (Text)
import Network.Mail.Mime
import qualified Data.Text.Lazy.Encoding
import Text.Shakespeare.Text (stext)
import Text.Blaze.Html.Renderer.Utf8 (renderHtml)
import Text.Hamlet (shamlet)
import Data.Maybe (isJust)
import Control.Monad (join)

share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persist|
User
    email Text
    password Text Maybe -- Пароль может быть не установлен
    verkey Text Maybe -- Используется для сброса пароля
    verified Bool
    UniqueUser email
|]

data MyEmailApp = MyEmailApp Connection

mkYesod "MyEmailApp" [parseRoutes|
/ RootR GET
/auth AuthR Auth getAuth
|]

instance Yesod MyEmailApp where
    -- Электронные письма будут содержать ссылки, так что убедитесь включить approot, так что
    -- ссылки должны быть правильными!
    approot = ApprootStatic "http://localhost:3000"

instance RenderMessage MyEmailApp FormMessage where
    renderMessage _ _ = defaultFormMessage

-- Установка Persistent
instance YesodPersist MyEmailApp where
    type YesodPersistBackend MyEmailApp = SqlPersist
    runDB f = do
        MyEmailApp conn <- getYesod
        runSqlConn f conn

instance YesodAuth MyEmailApp where
    type AuthId MyEmailApp = UserId

    loginDest _ = RootR
    logoutDest _ = RootR
    authPlugins _ = [authEmail]

    -- Необходимо найти UserId по заданному адресу электронной почты.
    getAuthId creds = runDB $ do
        x <- insertBy $ User (credsIdent creds) Nothing Nothing False
        return $ Just $
            case x of
                Left (Entity userid _) -> userid -- новый добавленный пользователь
                Right userid -> userid -- существующий пользователь

    authHttpManager = error "Email doesn't need an HTTP manager"

-- Здесь весь специфичный код для электронной почты
instance YesodAuthEmail MyEmailApp where
    type AuthEmailId MyEmailApp = UserId

    addUnverified email verkey =
        runDB $ insert $ User email Nothing (Just verkey) False

    sendVerifyEmail email _ verurl =
        liftIO $ renderSendMail (emptyMail $ Address Nothing "noreply")
            { mailTo = [Address Nothing email]
            , mailHeaders =
                [ ("Subject", "Verify your email address")
                ]
            , mailParts = [[textPart, htmlPart]]
            }
      where
        textPart = Part
            { partType = "text/plain; charset=utf-8"
            , partEncoding = None
            , partFilename = Nothing
            , partContent = Data.Text.Lazy.Encoding.encodeUtf8 [stext|
Please confirm your email address by clicking on the link below.

\#{verurl}

Thank you
|]
            , partHeaders = []
            }
        htmlPart = Part
            { partType = "text/html; charset=utf-8"
            , partEncoding = None
            , partFilename = Nothing
            , partContent = renderHtml [shamlet|
<p>Please confirm your email address by clicking on the link below.
<p>
    <a href=#{verurl}>#{verurl}
<p>Thank you
|]
            , partHeaders = []
            }
    getVerifyKey = runDB . fmap (join . fmap userVerkey) . get
    setVerifyKey uid key = runDB $ update uid [UserVerkey =. Just key]
    verifyAccount uid = runDB $ do
        mu <- get uid
        case mu of
            Nothing -> return Nothing
            Just u -> do
                update uid [UserVerified =. True]
                return $ Just uid
    getPassword = runDB . fmap (join . fmap userPassword) . get
    setPassword uid pass = runDB $ update uid [UserPassword =. Just pass]
    getEmailCreds email = runDB $ do
        mu <- getBy $ UniqueUser email
        case mu of
            Nothing -> return Nothing
            Just (Entity uid u) -> return $ Just EmailCreds
                { emailCredsId = uid
                , emailCredsAuthId = Just uid
                , emailCredsStatus = isJust $ userPassword u
                , emailCredsVerkey = userVerkey u
                }
    getEmail = runDB . fmap (fmap userEmail) . get

getRootR :: Handler RepHtml
getRootR = do
    maid <- maybeAuthId
    defaultLayout [whamlet|
<p>Your current auth ID: #{show maid}
$maybe _ <- maid
    <p>
        <a href=@{AuthR LogoutR}>Logout
$nothing
    <p>
        <a href=@{AuthR LoginR}>Go to the login page
|]

main :: IO ()
main = withSqliteConn "email.db3" $ \conn -> do
    runSqlConn (runMigration migrateAll) conn
    warpDebug 3000 $ MyEmailApp conn
\end{lstlisting}
Авторизация

Как только вы можете аутентифицировать пользователей, вы можете использовать их учетные данные для авторизационных запросов. Авторизация в Yesod простая и декларативная: большую часть времени, в только нуждаетесь в добавлении authRoute и isAuthorized методов в ваш Yesod экземпляр класс типов. Давайте посмотрим пример.
\begin{lstlisting}
{-# LANGUAGE OverloadedStrings, TemplateHaskell, TypeFamilies,
             MultiParamTypeClasses, QuasiQuotes #-}
import Yesod
import Yesod.Auth
import Yesod.Auth.Dummy -- только для тестирования, не используйте в реальной жизни!!!
import Data.Text (Text)
import Network.HTTP.Conduit (Manager, newManager, def)

data MyAuthSite = MyAuthSite
    { httpManager :: Manager
    }

mkYesod "MyAuthSite" [parseRoutes|
/ RootR GET POST
/admin AdminR GET
/auth AuthR Auth getAuth
|]

instance Yesod MyAuthSite where
    authRoute _ = Just $ AuthR LoginR

    -- имя маршрута, затем булевое значение показывающее если это запрос на запись
    isAuthorized RootR True = isAdmin
    isAuthorized AdminR _ = isAdmin

    -- любой может получить доступ к другим страницам
    isAuthorized _ _ = return Authorized

isAdmin = do
    mu <- maybeAuthId
    return $ case mu of
        Nothing -> AuthenticationRequired
        Just "admin" -> Authorized
        Just _ -> Unauthorized "You must be an admin"

instance YesodAuth MyAuthSite where
    type AuthId MyAuthSite = Text
    getAuthId = return . Just . credsIdent

    loginDest _ = RootR
    logoutDest _ = RootR

    authPlugins _ = [authDummy]

    authHttpManager = httpManager

instance RenderMessage MyAuthSite FormMessage where
    renderMessage _ _ = defaultFormMessage

getRootR :: Handler RepHtml
getRootR = do
    maid <- maybeAuthId
    defaultLayout [whamlet|
<p>Note: Log in as "admin" to be an administrator.
<p>Your current auth ID: #{show maid}
$maybe _ <- maid
    <p>
        <a href=@{AuthR LogoutR}>Logout
<p>
    <a href=@{AdminR}>Go to admin page
<form method=post>
    Make a change (admins only)
    \ #
    <input type=submit>
|]

postRootR :: Handler ()
postRootR = do
    setMessage "You made some change to the page"
    redirect RootR

getAdminR :: Handler RepHtml
getAdminR = defaultLayout [whamlet|
<p>I guess you're an admin!
<p>
    <a href=@{RootR}>Return to homepage
|]

main :: IO ()
main = do
    manager <- newManager def
    warpDebug 3000 $ MyAuthSite manager
\end{lstlisting}
authRoute должен быть вашей страницей входа, почти всегда AuthR LoginR. isAuthorized это функция, такая что берет два параметра: запрашиваемый маршрут, и либо запрос "запись", либо нет. Вы можете на самом деле поменять значение запроса на запись, используя метод isWriteRequest, но версия из коробки следует принципам RESTful: что-угодно но GET, HEAD, OPTIONS или TRACE запросы это запросы на запись.
То, что удобно тело isAuthorized это то, что вы можете запустить и перехватить код, который вы захотите. Это означает вы можете:
Получить доступ к файловой системе (Нормальный IO)
Просмотреть записи в базе данных
Принять любые сессии или запросы какие захотите
Используя эти техники, вы можете разработать как сложную систему авторизации, какую захотите, или даже связать с существующей системы используя свою организацию.
Выводы

Эта глава покрывает основы установки пользовательской аутентификации, а также, как встроенные авторизационные функции предоставляются просто, декларативный подход для пользователей. В то время эти сложные концепции, с многими подходами, Yesod должен предоставить вам строительные блоки, которые вам нужны для создания вашего собственного решения аутентификации.
