Аутентификая и Авторизация

Аутентификая и Авторизация обе очень связанные, и вдобавок раздельные, концепции. В то время имея дело с идентификацией пользователя, последнее определяет, что позволенно пользователю. К сожалению, также оба термина часто обозначаются как \textquotedblleft auth\textquotedblright, как концепции часто объединенные.
Yesod обеспечивает встроенную поддержку для нескольких сторонних систем аутентификации, таки как OpenID, BrowserID и OAuth. Эти системы, где ваше приложение доверяет некоторой внешней системе для подтверждения данных пользователя. В дополнении, есть поддержка для более часто используемых имяпользователя/пароль и адреспочты/пароль систем. Предыдущий способ гарантирует простоту для пользователей (нет новых паролей для запоминания) и разработчиков (нет нужды иметь дело с полной архитектурой защиты), в то время как последнее дает разработчику больший контроль.
На стороне авторизации, нам позволено воспользоваться REST и типобезопасными URL-и, чтобы создавать простые, декларативные системы. В дополнении, также все авторизационные коды написаны на Haskell, и вы имеете всю гибкость языка в вашем распоряжении.
Эта глава покроет, как установить \textquotedblleft auth\textquotedblright решение в Yesod и рассмотрим некоторые компромисы в различных опциях аутентификации.
Обзор

Пакет yesod-auth обеспечивает унифицированный интерефейс для различных плагинов аутентификации. Только настоящее требование для этих бэкэндов, чтобы они идентифицировали пользователя основываясь на уникальной строке. В OpenID, к примеру, это может быть фактическое значение OpenID. В BrowserID, это адрес электронной почты. Для HashDB (который использует базу данных хэшированных паролей), это имя пользователя.
Каждый плагин аутентификации обеспечивает свою собственную систему для входа, любая из двух — это может быть через прохождение токенов с внешнего сайта или формы адрес электронной почты/пароль. После успешного входа, плагин устанавливает значения в пользовательской сессии, чтобы обозначить его/её AuthId. Этот AuthId обычно Persistent ID из таблицы используемой для отслеживания пользователей. 
Есть несколько функций, доступные для запроса пользовательского AuthId, наиболее часто maybeAuthId, requireAuthId, maybeAuth и requireAuth. require версии перенаправляют на страницу входа, если пользователь не вошел, в то время как второе множество функций (те, что не оканчиваются на Id) дают обе таблицы ID и значение сущности.
Поскольку всё хранилище AuthId построено на сессиях, все правила применяются из них. На приктике, данные сохраняются зашифрованными, HMACed клиент cookie, который автоматически устаревает после определенного конфигурированного периода неактивности. В дополнении, так как там нет компонента сервеной стороны к сессиям, выход просто удаляет данные из сессии cookie; если пользователь переиспользует старое значение cookie, сессия будет оставаться действительной.
Есть планы добавить серверный компонент к сессиям, которые будут позволять делать принудительный выход пользователя. Это будет почти естественно имплементированно до 1.0 релиза Yesod.
С другой стороны, авторизация управляется несколькими методами внутри Yesod класса типов. Для каждого запроса, эти методы запускают определение, если доступ должен быть разрешен, запрещен, или если необходимо чтобы пользователь был авторизован. По умолчанию, эти метода позволяют доступ для каждого запроса. В качестве альтернативы, вы можете имплементировать авторизацию в более специальном способе, добавляя вызовы к requireAuth и как в индивидуальных функциях обработчика, хотя это подрывает много выгоды от декларативной системы авторизации.
Авторизуй меня

Давайте перейдем в пример с аутентификацией.
\begin{lstlisting}
{-# LANGUAGE OverloadedStrings, TemplateHaskell, TypeFamilies,
             MultiParamTypeClasses, QuasiQuotes #-}
import Yesod
import Yesod.Auth
import Yesod.Auth.BrowserId
import Yesod.Auth.GoogleEmail
import Data.Text (Text)
import Network.HTTP.Conduit (Manager, newManager, def)

data MyAuthSite = MyAuthSite
    { httpManager :: Manager
    }

mkYesod "MyAuthSite" [parseRoutes|
/ RootR GET
/auth AuthR Auth getAuth
|]

instance Yesod MyAuthSite where
    -- Заметка: В порядке для входа с BrowserID, вы должны корректно
    -- установить ваш hostname здесь.
    approot = ApprootStatic "http://localhost:3000"

instance YesodAuth MyAuthSite where
    type AuthId MyAuthSite = Text
    getAuthId = return . Just . credsIdent

    loginDest _ = RootR
    logoutDest _ = RootR

    authPlugins _ =
        [ authBrowserId
        , authGoogleEmail
        ]

    authHttpManager = httpManager

instance RenderMessage MyAuthSite FormMessage where
    renderMessage _ _ = defaultFormMessage

getRootR :: Handler RepHtml
getRootR = do
    maid <- maybeAuthId
    defaultLayout [whamlet|
<p>Your current auth ID: #{show maid}
$maybe _ <- maid
    <p>
        <a href=@{AuthR LogoutR}>Logout
$nothing
    <p>
        <a href=@{AuthR LoginR}>Go to the login page
|]

main :: IO ()
main = do
    man <- newManager def
    warpDebug 3000 $ MyAuthSite man
\end{lstlisting}
Мы начали с объявлений маршрута. Первое мы объявили наш стандартный RootR маршрут, и затем мы установили аутентификационный подсайт. Запомните этому подсайту нужны 4 параметра: путь к подсайту, имя маршрута, имя подсайта, и функция для получения значения подсайта. Другими словами, основываясь на строке:
\lstinline'/auth AuthR Auth getAuth'
Нам нужно иметь \lstinline'getAuth :: MyAuthSite -> Auth'. Пока мы еще не написали эту функцию сами, yesod-auth предоставляет её автоматически. С другими подсайтами (как со статическими файлами), мы обеспечиваем конфигурацию настройками в значении подсайта, и вледствии этого нужно указать функцию получения. В auth подсайте, мы указываем эти настройки в отдельном классе типов, YesodAuth.
Почему не используем значение подсайта? Есть несколько настроек, которые мы хотим дать для auth подсайта, и делать это из типа записи будет неудобно. Также, позже мы хотим иметь ассоциируемой тип AuthId, класс типов более естественно.
С другой стороны, почему не использовать класс типов для всех подсайтов? У этого есть минус: вы можете затем иметь только один экземпляр класса на сайт, не позволяя раздавать различные множества статичных файлов из различных маршрутов. Также, значение подсайта работает лучше когда мы хотим загрузить данные во время иницииализации приложения.
Так что точно идет в экземпляр класс YesodAuth? Есть шесть необходимых объявлений: