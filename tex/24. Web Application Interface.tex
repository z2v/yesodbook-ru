\chapter {Интерфейс веб-приложения}\label{chap:web_application_interface}

Практически каждый язык, используемый для веб-разработки, сталкивался с проблемой
низкоуровневого интерфейса между веб-сервером и приожением. Самым ранним примером
её решения является почтенный и потёртый в боях CGI (Common Gateway Interface), 
обеспечивающий языконезависимый интерфейс при помощи стандартного ввода, стандартного
вывода и переменных окружения.

Ещё в те времена, когда Perl становалися языком вебпрограммирования де-факто, оcновной
недостаток CGI стал очевидным: процесс должен запускаться заново для каждого запроса.
При использовании интерпретируемого языка и приложений, требующих соединение с базой
данных, эти издержки стали черезмерны. FastCGI (и позднее SCGI) возник как преемник
CGI, но, кажется, основная часть мира программирования направилась в другом направлении.

Каждый язык начал создавать свой собственный стандарт установления связи с серверами.
mod\_perl. mod\_python. mod\_php. mod\_ruby. В одном и том же языке возникало несколько
интерфейсов. В некоторых случаях получались даже интерфейсы поверх интерфейсов.
И всё это привело к большому дублированию усилий: приложение на Python, созданное
для работы с FastCGI не работало бы с mod\_python; mod\_python существовал только для
определённых вебсверверов; и подобные специфичные для языка расширения вебсверверов
требовалось писать для каждого языка программирования.

У Haskell своя история. У нас вначале был пакет \footnotehref{http://hackage.haskell.org/package/cgi}{cgi},
который предоставлял монадный интерфейс. Пакет \footnotehref{http://hackage.haskell.org/package/fastcgi}{fastcgi}
позднее предоставлял такой же интерфейс. В то же время, казалось, что большинство,
занимающихся вебпрограммированием на Haskell, сфокусировалось на автономном сервере.
Проблема в том, что у каждого сервера свой собственный интерфейс, что означает, что 
вам надо ставить целью конкретный сервер. Это означает, что невозможно разделять
общий функционал наподобие GZIP кодирования, серверов для разработки и фреймворков для тестирования.

WAI пытается решить эту проблему, обеспечивая обобщённый и эффективный интерфейс между
вебсерверами и приложениями. Любой обработчик, поддерживающий интерфейс может обслуживать
любое приложение WAI, в то же время любоее приложение, использующее интерфейс может
запускаться с любым обработчиком.

На момент написания существовало несколько бэкэндов, включая Warp, FastCGI и
сервер разработки. Существуют и более эзотерические бэкэнды, такие как, например,
\footnotehref{http://hackage.haskell.org/package/wai-handler-webkit}{wai-handler-webkit},
используемый для создания настольных приложений. \footnotehref{http://hackage.haskell.org/package/wai-extra}{wai-extra} предоставляет большое число компонент связующего слоя, таких как  GZIP, JSON-P
и виртуальный хостинг. \footnotehref{http://hackage.haskell.org/package/wai-test}{wai-test}
облегчает написание модульных тестов, а \footnotehref{http://hackage.haskell.org/package/wai-handler-devel}{wai-handler-devel} позволяет разрабатывать приложение не беспокоясь об остановке для компиляции.
Yesod нацелен на WAI, Happstack также находится в процессе перехода на него.
Он также используется некоторыми приложениями, которые не используют фреймворки, среди
которых новая версия Hoogle.

\fbox{\begin{minipage}[!h]{.9\linewidth}
Yesod предоставляет альтернативный подход для сервера разработки, известный как
yesod devel. Разница с wai-handler-devel состоит в том, что yesod devel компилирует
ваш код каждый раз, учитывая настройки в вашем cabal-файле.
Это рекомендуемый подход к разработке на Yesod.
\end{minipage}}

\section {Интерфейс}

Интерфейс сам по себе довольно незатейлив: приложение принимает запрос и возвращает
ответ. Ответом является статус HTTP, список заголовков и тело ответа.
Запрос содержит различную информацию: запрашиваемый путь, строка запроса, тело запроса,
версия HTTP и т.д.

\section {Тело ответа}

В Haskell имеется тип данных известный как ленивая строка байтов. Используя ленивость,
вы можете создавать большие значения без переполнения памяти. Используя ленивый ввод/вывод,
вы можете сделать такие трюки, как например, иметь значение, которое представляет всё 
содержимое файла, и которое в то же время имеет небольшие затраты по памяти. В теории
ленивая строка байтов является единственным необходимым представляением тела ответа.

На практике же, в то время как ленивые строки байтов замечательно подходят для формирования
``чистых'' значений, ленивый ввод/вывод, необоходимый для чтения файлов вносит некоторый
недетерминизм в нашу программу. При обработке тысяч небольших файлов в секунду ограничивающим
фактором является не память, а число дескрипторов файлов. При использовании ленивого
ввода/вывода файловые дескрипторы не могут быть освобождены сразу же, что приводит к
исчерпанию ресурсов. Для решения этого WAI использует каналы.

\fbox{\begin{minipage}[!h]{.9\linewidth}
Версии WAI до 1.0 использовали энумераторы вместо каналов. В то время как, и каналы
и энумераторы решают ту же самую базовую задачу, опыт показывал, что энумераторы слишком
ограничивают своим подходом к инверсии управления, что усложняет структурирование более
сложных систем, таких как потоковый прокси-сервер. Каналы были спроектированы
с единственной целью - сделать WAI лучше.
\end{minipage}}

Типом данных, наиболее интересным нам, является тип ``источник''. Источник производит
поток данных, отдавая одну порцию за раз. В случае WAI, тело запроса будет источником,
передаваемым приложению, а тело ответа будет источником, возвращаемым из приложения.

Имеется ещё 2 оптимизации: многие системы предоставляют системный вызов sendfile, который
посылает файл прямо в сокет, минуя множественное копирование памяти, которое присуще
более общим системным вызовам ввода/вывода. Кроме того в Haskell имеется тип данных
под называнием \lstinline!Builder!, который делает возможным более эффективное копирование
байтов в буферы.

У тела ответа WAI таким образом имеется три конструктора: один для ``чистых'' построителей
(\lstinline!ResponseBuilder!), один для источника построителей (\lstinline!ResponseSource!) и
один для файлов (\lstinline!ResponseFile!).

\section {Тело запроса}

In order to avoid the need to load the entire request body into memory, we use
sources here as well. Since the purpose of these values are for reading (not writing),
we use ByteStrings in place of Builders. There is a record inside Request called
requestBody, with type BufferedSource IO ByteString. We can use all of the standard 
conduit functions to interact with this source.

The request body could in theory contain any type of data, but the most common are 
URL encoded and multipart form data. The wai-extra package contains built-in support 
for parsing these in a memory-efficient manner.

\section{Hello World}

To demonstrate the simplicity of WAI, let's look at a hello world example. 
In this example, we're going to use the OverloadedStrings language extension to avoid 
explicitly packing string values into bytestrings.

\begin{lstlisting}
{-# LANGUAGE OverloadedStrings #-}
import Network.Wai
import Network.HTTP.Types (status200)
import Network.Wai.Handler.Warp (run)

application _ = return $
  responseLBS status200 [("Content-Type", "text/plain")] "Hello World"

main = run 3000 application
\end{lstlisting}%$

Lines 2 through 4 perform our imports. Warp is provided by the warp package, and is 
the premiere WAI backend. WAI is also built on top of the http-types package, which 
provides a number of datatypes and convenience values, including status200.

First we define our application. Since we don't care about the specific request 
parameters, we ignore the argument to the function. For any request, we are 
returning a response with status code 200 ("OK"), and text/plain content type 
and a body containing the words "Hello World". Pretty straight-forward.

\section {Middleware}

In addition to allowing our applications to run on multiple backends without 
code changes, the WAI allows us another benefits: middleware. Middleware is essentially 
an application transformer, taking one application and returning another one.

Middleware components can be used to provide lots of services: cleaning up URLs,
authentication, caching, JSON-P requests. But
perhaps the most useful and most intuitive
middleware is gzip compression. The middleware
works very simply: it parses the request headers
to determine if a client supports compression, and
if so compresses the response body and adds the
appropriate response header.

The great thing about middlewares is that they are unobtrusive. Let's see how we would 
apply the gzip middleware to our hello world application.

\begin{lstlisting}
{-# LANGUAGE OverloadedStrings #-}
import Network.Wai
import Network.Wai.Handler.Warp (run)
import Network.Wai.Middleware.Gzip (gzip, def)
import Network.HTTP.Types (status200)

application _ = return $ responseLBS status200 [("Content-Type", "text/plain")]
                       "Hello World"

main = run 3000 $ gzip def application
\end{lstlisting}%$

We added an import line to actually have access to the middleware, and then simply 
applied gzip to our application. You can also chain together multiple middlewares: 
a line such as gzip False \$ jsonp \$ othermiddleware \$ myapplication is perfectly valid. 
One word of warning: the order the middleware is applied can be important. For example, 
jsonp needs to work on uncompressed data, so if you apply it after you apply gzip, 
you'll have trouble.

