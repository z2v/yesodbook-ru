\chapter{Интерфейс веб-приложений}\label{chap:web_application_interface}

Практически всякий язык, используемый для веб-разработки, сталкивался с проблемой
низкоуровневого интерфейса между веб-сервером и приложением. Старейшим примером
решения этой проблемы является почтенный и потёртый в боях CGI (Common Gateway Interface), 
предоставляющий языконезависимый интерфейс на основе стандартных потоков ввода/вывода и переменных среды окружения.

Но уже в те времена, когда Perl только становился языком вебпрограммирования де-факто, стал очевиден оcновной недостаток CGI~--- для каждого запроса должен быть запущен новый процесс. Имея дело с интерпретируемым языком и приложениями, требующими подключения к базе
данных, эти издержки стали черезмерны. FastCGI (и позднее SCGI) возник как преемник
CGI, но, похоже, основная часть мира программирования направилась в другом направлении.

Каждый язык начал создавать свой собственный стандарт для взаимодействия с сервером.
mod\_perl. mod\_python. mod\_php. mod\_ruby. Для одного и того же языка появлялись различные
интерфейсы. В некоторых случаях получались даже интерфейсы поверх интерфейсов.
Всё это привело к ещё большему дублированию усилий: приложение на Python, созданное
для работы с FastCGI не работало с mod\_python, а mod\_python существовал только для
определённых веб-сверверов. И подобные модули расширения веб-сервера должны были быть реализованы для каждого языка.

У Haskell своя история. Сначала у нас был пакет \footnotehref{http://hackage.haskell.org/package/cgi}{cgi}, 
который предоставлял монадный интерфейс. Позднее появился пакет \footnotehref{http://hackage.haskell.org/package/fastcgi}{fastcgi} который
предоставлял такой же интерфейс. В то же время, кажеться, что большинство,
занимающихся веб-программированием на Haskell, сфокусировалось на самих серверах.
Проблема в том, что у каждого сервера свой собственный интерфейс, а это означает, что 
вам надо разрабатывать приложение под конкретный сервер. То есть невозможно выделить
общий функционал наподобие GZIP кодирования, сервера разработки и фреймворка для тестирования.

WAI пробует решить эту проблему, обеспечивая обобщённый и эффективный интерфейс между
веб-серверами и приложениями. Любой \emph{обработчик}, поддерживающий этот интерфейс может обслуживать
любое приложение WAI, в то же время любое приложение, использующее этот интерфейс может быть запущено любым обработчиком.

На момент написания этой книги существовует несколько веб-серверов реализующих WAI, такие как Warp, FastCGI и
сервер разработки. Существуют и более эзотерические реализации, например,
\footnotehref{http://hackage.haskell.org/package/wai-handler-webkit}{wai-handler-webkit},
используемый для создания настольных приложений. Пакет \footnotehref{http://hackage.haskell.org/package/wai-extra}{wai-extra} предоставляет много обычных компонент промежуточного уровня, к примеру, реализуюших поддержку GZIP, JSON-P
и виртуального хостинга. Библиотека \footnotehref{http://hackage.haskell.org/package/wai-test}{wai-test}
облегчает написание тестов, а \footnotehref{http://hackage.haskell.org/package/wai-handler-devel}{wai-handler-devel} позволяет разрабатывать приложения не отвлекаясь на остановку сервера для компиляции.
Yesod уже ориентирован на использование WAI, Happstack также находится в процессе перехода на него.
Этот интерфейс также используется некоторыми приложениями, которые вообще не используют фреймворки, среди
них - новая версия Hoogle.

\begin{remark}
Yesod предоставляет альтернативный подход для сервера разработки, известный как
yesod devel. Отличие от wai-handler-devel состоит в том, что yesod devel компилирует
ваш код каждый раз, учитывая настройки в вашем cabal-файле.
Этот подход рекомендуеться в разработке на Yesod.
\end{remark}

\section {Интерфейс}

Интерфейс сам по себе довольно незатейлив: приложение принимает запрос и возвращает
ответ. Ответом является статус HTTP, список заголовков и тело ответа.
Запрос содержит различную информацию: запрашиваемый путь, строку запроса, тело запроса, версию HTTP и т.д.

\section {Тело ответа}

В Haskell есть тип данных известный как ленивая строка байтов. Используя ленивость,
вы можете создавать большие значения без переполнения памяти. Используя ленивый ввод/вывод,
вы можете выполнять такой трюк, как, например, иметь значение, которое представляет всё 
содержимое файла, и которое в то же время имеет небольшие затраты по памяти. В теории
ленивая строка байтов является единственным необходимым представляением тела ответа.

На практике же, в то время как ленивые строки байтов замечательно подходят для ``чистых'' значений, 
ленивый ввод/вывод, необходимый для чтения файлов вносит некоторый
недетерминизм в нашу программу. При обработке тысяч небольших файлов в секунду ограничивающим
фактором является не память, а число дескрипторов файлов. При использовании ленивого
ввода/вывода файловые дескрипторы не могут быть освобождены мгновенно, что приводит к
исчерпанию ресурсов. Для решения этой проблеммы WAI использует  \footnotehref{http://hackage.haskell.org/package/conduit}{кондуиты}.

\begin{remark}
Версии WAI до 1.0 использовали  \footnotehref{http://hackage.haskell.org/package/enumerator}{энумераторы} вместо кондуитов. В то время как, и кондуиты
и энумераторы решают одну и ту же самую базовую задачу, опыт показал, что энумераторы слишком
ограничивают возможности своим подходом ~--- инверсией управления, что усложняет структурирование
сложных систем, таких как потоковый прокси-сервер (streaming proxy server). Кондуиты были спроектированы
с единственной целью ~--- сделать WAI лучше.
\end{remark}

При работе с кондуитами наиболее интересным для нас типом данных является тип \lstinline!Source! ~--- источник. Источник производит
поток данных, отдавая одну порцию за раз. В случае WAI, тело запроса будет источником,
передаваемым приложению, а тело ответа будет источником, возвращаемым из приложения.

Имеется также две дополнительные оптимизации: многие системы предоставляют системный вызов \lstinline!sendfile!, который
посылает файл прямо в сокет, минуя неизбежные копирования в памяти, которые присущи
более общим системным вызовам ввода/вывода. Кроме того в Haskell есть тип данных
\lstinline!Builder! ~--- строитель, который делает возможным более эффективное копирование
байтов в буферы.

У тела ответа WAI таким образом имеется три конструктора: один для чистых строителей
(\lstinline!ResponseBuilder!), один для источника производящего строителей (\lstinline!ResponseSource!) и
один для файлов (\lstinline!ResponseFile!).

\section {Тело запроса}

Для того, чтобы избежать загрузки всего тела запроса в оперативную память, мы также используем
источники. Так как это значение предназначено для чтения (а не для записи), вместо \lstinline!Builder! мы используем
\lstinline!ByteString!. У типа \lstinline!Request! есть
поле с именем \lstinline!requestBody! и типом \lstinline!BufferedSource IO ByteString!.
Мы можем использовать все стандартные функции кондуитов для работы с этим источником.

Теоретически тело запроса может содержать любой тип данных, но наиболее частыми являеются данные
закодированные URL-кодировкой или в формате multipart/form-data. Пакет
\footnotehref{http://hackage.haskell.org/package/wai-extra}{wai-extra} содержит встроенную
поддержку для разбора данных форматов, которая эффективна с точки зрения использования памяти.

\section{Hello world}

Для того, чтобы продемонстрировать простоту WAI, давайте взглянем на пример hello world.
В этом примере мы используем расширение языка OverloadedStrings для того, чтобы избежать
явной упаковки строковых значений в строки байт.

\begin{lstlisting}
{-# LANGUAGE OverloadedStrings #-}
import Network.Wai
import Network.HTTP.Types (status200)
import Network.Wai.Handler.Warp (run)

application _ = return $
  responseLBS status200 [("Content-Type", "text/plain")] "Hello World"

main = run 3000 application
\end{lstlisting}%$

Строки со 2-й по 4-ю служат для импорта. Warp предоставляется пакетом
\footnotehref{http://hackage.haskell.org/package/warp}{warp} и является первым веб-сервером реализующим WAI. Также WAI использует пакет
\footnotehref{http://hackage.haskell.org/package/http-types}{http-types}, который
предоставляет некоторые типы данных и вспомогательные значения,
среди которых \lstinline!status200!.

Сперва мы определяем наше приложение. Так как нам безразличны конкретные параметры
запроса, то мы игнорируем аргумент нашей функции. Для любого запроса мы возвращаем
ответ с кодом статуса 200 ("OK"), типом содержимого text/plain и телом, содержащим
слова "Hello World". Довольно просто.

\section {Middleware ~--- компоненты промежуточного уровня}

В добавление к возможности запуска наших приложений без изменения
кода на различных серверах реализующих WAI, WAI имеет ещё и другое преимущество ~--- возможность создавать и использовать компоненты промежуточного уровня. Они являются по сути
преобразователями приложения, получая на вход одно приложение и возвращая другое.

Компоненты промежуточного уровня могут использоваться для различных нужд: для исправление URL,
аутентификации, кэширования, обработки запросов JSON-P. Но возможно наиболее полезным
и наиболее интуитивно понятным является компонент реализующий gzip-сжатие. Этот компонент работает
довольно просто: он разбирает заголовки запроса для определения, поддерживает ли клиент
сжатие, и, если клиент поддерживает, то выполняет сжатие тела ответа, добавляя соотвествующий
заголовок ответа.

Самое замечательное в компонентах промежуточного уровня заключается в том, что они нетребовательны. Давайте посмотрим
как применить gzip к нашему приложению hello world.

\begin{lstlisting}
{-# LANGUAGE OverloadedStrings #-}
import Network.Wai
import Network.Wai.Handler.Warp (run)
import Network.Wai.Middleware.Gzip (gzip, def)
import Network.HTTP.Types (status200)

application _ = return $ responseLBS status200 [("Content-Type", "text/plain")]
                       "Hello World"

main = run 3000 $ gzip def application
\end{lstlisting}%$

Мы добавили строку импорта чтобы получить доступ к компоненте и затем просто применили \lstinline!gzip!
к нашему приложению. Вы также можете \emph{выстроить в цепочку} несколько компонент:
к примеру, строка \lstinline{gzip False $ jsonp $ othermiddleware $ myapplication}
вполне корректна. Но следует заметить, что важен порядок применения компонент. К примеру
для \lstinline!jsonp! нужны несжатые данные, то есть, если вы его примените после применения \lstinline!gzip!,
то получите проблемы.

