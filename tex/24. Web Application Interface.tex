\chapter{Интерфейс веб-приложений}\label{chap:web_application_interface}

Практически всякий язык, используемый для веб-разработки, сталкивался с проблемой
низкоуровневого интерфейса между веб-сервером и приожением. Старейшим примером
решения этой проблемы является почтенный и потёртый в боях CGI (Common Gateway Interface), 
предоставляющий языконезависимый интерфейс на основе стандартных потоков ввода/вывода и переменных среды окружения.

Но уже в те времена, когда Perl становился языком вебпрограммирования де-факто, стал очевиден оcновной недостаток CGI~--- для каждого запроса должен запускаться новый процесс.
При использовании интерпретируемого языка и приложений, требующих подключения к базе
данных, эти издержки стали черезмерны. FastCGI (и позднее SCGI) возник как преемник
CGI, но, похоже, основная часть мира программирования направилась в другом направлении.

Каждый язык начал создавать свой собственный стандарт для взаимодействия с сервером.
mod\_perl. mod\_python. mod\_php. mod\_ruby. В одном и том же языке появлялись различные
интерфейсы. В некоторых случаях получались даже интерфейсы поверх интерфейсов.
Всё это привело к ещё большему дублированию усилий: приложение на Python, созданное
для работы с FastCGI не работало с mod\_python, а mod\_python существовал только для
определённых веб-сверверов. И такие расширения веб-сверверов специфичные для языка программирования должны были быть написаны для каждого языка.

У Haskell своя история. Сначала у нас был пакет \footnotehref{http://hackage.haskell.org/package/cgi}{cgi}, 
который предоставлял монадный интерфейс. Позднее пакет \footnotehref{http://hackage.haskell.org/package/fastcgi}{fastcgi}
предоставлял такой же интерфейс. В то же время, кажеться, что большинство,
занимающихся веб-программированием на Haskell, сфокусировалось на самих серверах.
Проблема в том, что у каждого сервера свой собственный интерфейс, а это означает, что 
вам надо разрабатывать приложение под конкретный сервер. То есть невозможно выделить
общий функционал наподобие GZIP кодирования, сервера разработки и фреймворка для тестирования.

WAI пробует решить эту проблему, обеспечивая обобщённый и эффективный интерфейс между
веб-серверами и приложениями. Любой \emph{обработчик}, поддерживающий этот интерфейс может обслуживать
любое приложение WAI, в то же время любоее приложение, использующее этот интерфейс может быть запущено любым обработчиком.

На момент написания этой книги существовует несколько реализаций, таких как Warp, FastCGI и
сервер разработки. Существуют и более эзотерические реализации, например,
\footnotehref{http://hackage.haskell.org/package/wai-handler-webkit}{wai-handler-webkit},
используемый для создания настольных приложений. Пакет \footnotehref{http://hackage.haskell.org/package/wai-extra}{wai-extra} предоставляет большое число вспомогательных компонент, таких как  GZIP, JSON-P
и виртуальный хостинг. Библиотека \footnotehref{http://hackage.haskell.org/package/wai-test}{wai-test}
облегчает написание тестов, а \footnotehref{http://hackage.haskell.org/package/wai-handler-devel}{wai-handler-devel} позволяет разрабатывать приложения не отвлекаясь на остановку сервера для компиляции.
Yesod уже ориентирован на использование WAI, Happstack также находится в процессе перехода на него.
Этот интерфейс также используется некоторыми приложениями, которые вообще не используют фреймворки, среди
них - новая версия Hoogle.

\begin{remark}
Yesod предоставляет альтернативный подход для сервера разработки, известный как
yesod devel. Разница с wai-handler-devel состоит в том, что yesod devel компилирует
ваш код каждый раз, учитывая настройки в вашем cabal-файле.
Этот подход рекомендуеться в разработке на Yesod.
\end{remark}

\section {Интерфейс}

Интерфейс сам по себе довольно незатейлив: приложение принимает запрос и возвращает
ответ. Ответом является статус HTTP, список заголовков и тело ответа.
Запрос содержит различную информацию: запрашиваемый путь, строка запроса, тело запроса,
версия HTTP и т.д.

\section {Тело ответа}

В Haskell имеется тип данных известный как ленивая строка байтов. Используя ленивость,
вы можете создавать большие значения без переполнения памяти. Используя ленивый ввод/вывод,
вы можете выполнять такие трюки, как например, иметь значение, которое представляет всё 
содержимое файла, и которое в то же время имеет небольшие затраты по памяти. В теории
ленивая строка байтов является единственным необходимым представляением тела ответа.

На практике же, в то время как ленивые строки байтов замечательно подходят для формирования
``чистых'' значений, ленивый ввод/вывод, необоходимый для чтения файлов вносит некоторый
недетерминизм в нашу программу. При обработке тысяч небольших файлов в секунду ограничивающим
фактором является не память, а число дескрипторов файлов. При использовании ленивого
ввода/вывода файловые дескрипторы не могут быть освобождены мгновенно, что приводит к
исчерпанию ресурсов. Для решения этого WAI использует каналы.

\begin{remark}
Версии WAI до 1.0 использовали энумераторы вместо каналов. В то время как, и каналы
и энумераторы решают ту же самую базовую задачу, опыт показал, что энумераторы слишком
ограничивают возможности своим подходом к инверсии управления, что усложняет структурирование
сложных систем, таких как потоковый прокси-сервер. Каналы были спроектированы
с единственной целью - сделать WAI лучше.
\end{remark}

Типом данных, наиболее интересным нам, является тип ``источник''. Источник производит
поток данных, отдавая одну порцию за раз. В случае WAI, тело запроса будет источником,
передаваемым приложению, а тело ответа будет источником, возвращаемым из приложения.

Имеется также 2 дополнительные оптимизации: многие системы предоставляют системный вызов sendfile, который
посылает файл прямо в сокет, минуя множественное копирование в памяти, которое присуще
более общим системным вызовам ввода/вывода. Кроме того в Haskell имеется тип данных
под называнием \lstinline!Builder!, который делает возможным более эффективное копирование
байтов в буферы.

У тела ответа WAI таким образом имеется три конструктора: один для ``чистых'' построителей
(\lstinline!ResponseBuilder!), один для источника построителей (\lstinline!ResponseSource!) и
один для файлов (\lstinline!ResponseFile!).

\section {Тело запроса}

Для того, чтобы избежать загрузки всего тела запроса в оперативную память, мы также используем
источники. Так как это значение предназначено для чтения (а не для записи), мы используем
\lstinline!ByteString! вместо \lstinline!Builder!. В типе \lstinline!Request! имеется
запись с именем \lstinline!requestBody! и типом \lstinline!BufferedSource IO ByteString!.
Мы можетм использовать любые стандартные функции каналов для работы с этим источником.

Тело запроса в теорри может содержать любой тип данных, но наиболее частыми являеются данные
закодированные URL-кодировкой или в формате Multipart form-data. Пакет
\footnotehref{http://hackage.haskell.org/package/wai-extra}{wai-extra} содержит встроенную
поддержку для разбора данных форматов, которая эффективна с точки зрения использования памяти.

\section{Hello world}

Для того, чтобы продемонстрировать простоту WAI, давайте взглянем на пример hello world.
В этом примере мы используем расширение языка OverloadedStrings для того, чтобы избежать
явной запаковки строковых значений в строки байт.

\begin{lstlisting}
{-# LANGUAGE OverloadedStrings #-}
import Network.Wai
import Network.HTTP.Types (status200)
import Network.Wai.Handler.Warp (run)

application _ = return $
  responseLBS status200 [("Content-Type", "text/plain")] "Hello World"

main = run 3000 application
\end{lstlisting}%$

Строки со 2-й по 4-ю служат для импорта. Warp предоставляется пакетом
\footnotehref{http://hackage.haskell.org/package/warp}{warp} и является первейшим бэкэндом
для WAI. Также интерфейс WAI построен на базе пакета
\footnotehref{http://hackage.haskell.org/package/http-types}{http-types}, который
предоставляет некоторое число типов данных и вспомогательных значений,
среди которых \lstinline!status200!.

Сперва мы определяем наше приложение. Так как нам безразличны конкретные параметры
запроса, то мы игнорируем аргумент нашей функции. Для любого запроса мы возвращаем
ответ кодом статуса 200 ("OK"), тип содержимого text/plain и тело, содержащее
слова "Hello World". Довольно просто.

\section {Middleware}

В добавление к возможности запуска нашего приложения на различных бэкэндах без изменения
кода WAI имеет ещё и другое преимущество: middleware. Middleware является по сути
преобразователем приложения, получая на вход приложение и возвращая другое приложение.

Компоненты middleware могут использоваться для различных нужд: для исправление URL,
аутентификации, кэширования, обработки запросов JSON-P. Но возможно наиболее полезным
и наиболее интуитивным является middleware для gzip-сжатия. Этот компонент работает
довольно просто: он разбирает заголовки запроса для определения, поддерживает ли клиент
сжатие, и, если клиент поддерживает, то выполняет сжатие тела ответа, добавляя соотвествующий
заголовок ответа

Замечательлная вещь в middleware заключается в том, что они ненавязчивы. Давайте посмотрим
как применить gzip к нашему приложению hello world.

\begin{lstlisting}
{-# LANGUAGE OverloadedStrings #-}
import Network.Wai
import Network.Wai.Handler.Warp (run)
import Network.Wai.Middleware.Gzip (gzip, def)
import Network.HTTP.Types (status200)

application _ = return $ responseLBS status200 [("Content-Type", "text/plain")]
                       "Hello World"

main = run 3000 $ gzip def application
\end{lstlisting}%$

Мы добавили строку импорта чтобы получить доступ к middleware и затем просто применили gzip
к нашему приложению. Вы также можете \emph{выстроить в цепочку} несколько middleware:
к примеру, строка \lstinline{gzip False $ jsonp $ othermiddleware $ myapplication}
вполне корректна. Но следует заметить, что важен порядок применения middleware. К примеру
для jsonp нужны несжатые данные, то есть, если вы его примените после применения gzip,
то получите проблемы.

