\chapter{Интерфейс веб-приложений}\label{chap:web_application_interface}

Практически всякий язык, используемый для веб-разработки, сталкивается с проблемой
низкоуровневого интерфейса между веб-сервером и приложением. Самым ранним примером
решения этой проблемы является почтенный и потёртый в боях CGI (Common Gateway Interface),
который предоставляет не зависящий от языка интерфейс на основе стандартных потоков ввода/вывода и переменных среды окружения.

Но уже в те времена, когда Perl только становился языком веб-программирования де-факто, стал очевиден основной недостаток CGI~--- для каждого запроса должен быть запущен новый процесс. При работе с интерпретируемым языком и приложениями, требующими подключения к базе
данных, эти издержки стали чрезмерны. FastCGI (и позднее SCGI) возник как преемник
CGI, но, похоже, основная часть мира программирования направилась в другом направлении.

Каждый язык начал создавать свой собственный стандарт для взаимодействия с сервером.
mod\_perl. mod\_python. mod\_php. mod\_ruby. Для одного и того же языка появлялись различные
интерфейсы. В некоторых случаях получались даже интерфейсы поверх интерфейсов.
Всё это привело к ещё большему дублированию усилий: приложение на Python, созданное
для работы с FastCGI, не работало с mod\_python, а mod\_python существовал только для
определённых веб-серверов. И подобные модули расширения веб-сервера должны были быть реализованы для каждого языка.

У Haskell своя история. Сначала у нас был пакет \footnotehref{http://hackage.haskell.org/package/cgi}{cgi},
который предоставлял монадный интерфейс. Позднее появился пакет \footnotehref{http://hackage.haskell.org/package/fastcgi}{fastcgi} с таким же интерфейсом.
Тем временем, казалось, большая часть
веб-разработки на Haskell сфокусировалась на написании отдельных серверов.
Проблема в том, что у каждого сервера свой собственный интерфейс, а это означает, что
вы вынуждены при разработке ориентироваться на конкретный сервер. Что, в свою очередь,
означает невозможность использовать общий функционал наподобие
GZIP кодирования, сервера разработки или фреймворка для тестирования.

WAI пробует решить эту проблему, обеспечивая обобщённый и эффективный интерфейс между
веб-серверами и приложениями. Любой \emph{обработчик}, поддерживающий этот интерфейс может обслуживать
любое приложение WAI, в то же время любое приложение, использующее этот интерфейс, может быть запущено любым обработчиком.

На момент написания этой книги существует несколько веб-серверов, реализующих WAI, такие как Warp, FastCGI и
сервер разработки. Существуют и другие реализации, известные лишь посвящённым, например,
\footnotehref{http://hackage.haskell.org/package/wai-handler-webkit}{wai-handler-webkit},
используемый для создания настольных приложений. Пакет \footnotehref{http://hackage.haskell.org/package/wai-extra}{wai-extra} предоставляет много обычных компонент промежуточного уровня, к примеру, реализующих поддержку GZIP, JSON-P
и виртуального хостинга. Библиотека \footnotehref{http://hackage.haskell.org/package/wai-test}{wai-test}
облегчает написание модульных тестов, а \footnotehref{http://hackage.haskell.org/package/wai-handler-devel}{wai-handler-devel} позволяет разрабатывать приложения, не отвлекаясь на остановку сервера для компиляции.
Yesod уже ориентирован на использование WAI, Happstack также находится в процессе перехода на него.
Этот интерфейс также используется некоторыми приложениями, которые вообще не
используют фреймворки, включая новую версию Hoogle.

\begin{remark}
Yesod предоставляет альтернативный подход для сервера разработки, известный как
\texttt{yesod devel}. Отличие от \texttt{wai-handler-devel} состоит в том, что \texttt{yesod devel} компилирует
ваш код каждый раз, учитывая все настройки в вашем cabal-файле.
Этот подход рекомендуется при разработке на Yesod.
\end{remark}

\section {Интерфейс}
Интерфейс сам по себе довольно незатейлив: приложение принимает запрос и возвращает
ответ. Ответом является статус HTTP, список заголовков и тело ответа.
Запрос содержит различную информацию: запрашиваемый путь, строку запроса, тело запроса, версию HTTP и т.д.

\subsection {Тело ответа}
В Haskell есть тип данных известный как ленивая строка байтов. Используя ленивость,
вы можете создавать большие значения, не переполняя память. Например, используя ленивый ввод/вывод,
вы можете иметь значение, которое представляет всё
содержимое файла и в то же время занимает небольшой участок памяти. В теории,
ленивая строка байтов является единственным необходимым представлением тела ответа.

На практике же, в то время как ленивые строки байтов замечательно подходят для <<чистых>> значений,
ленивый ввод/вывод, необходимый для чтения файлов, вносит некоторый
недетерминизм в нашу программу. При обработке тысяч небольших файлов в секунду, ограничивающим
фактором является не память, а число дескрипторов файлов. При использовании ленивого
ввода/вывода файловые дескрипторы не могут быть освобождены мгновенно, что приводит к
исчерпанию ресурсов. Для решения этой проблемы WAI использует  \footnotehref{http://hackage.haskell.org/package/conduit}{кондуиты}.

\begin{remark}
Версии WAI до 1.0 использовали  \footnotehref{http://hackage.haskell.org/package/enumerator}{eнумераторы} вместо кондуитов. В то время как, и кондуиты,
и eнумераторы решают одну и ту же самую базовую задачу, опыт показал, что eнумераторы слишком
ограничивают возможности своим подходом~--- инверсией управления, что усложняет структурирование
сложных систем, таких как потоковый прокси-сервер (streaming proxy server). Кондуиты были спроектированы
с единственной целью~--- сделать WAI лучше.
\end{remark}

Уместным для нас типом данных при работе с кондуитами является тип~\lstinline!Source!~--- источник. Источник производит
поток данных, отдавая одну порцию за раз. В случае WAI, тело запроса будет источником,
передаваемым приложению, а тело ответа будет источником, возвращаемым из приложения.

Есть ещё две оптимизации: многие системы предоставляют системный вызов~\texttt{sendfile}, который
отправляет файл напрямую в сокет, минуя неизбежные копирования в памяти, которые присущи
более общим системным вызовам ввода/вывода. Кроме того, в Haskell есть тип данных
\lstinline!Builder!~--- строитель, который позволяет более эффективно копировать
байты в буферы.

Как следствие, для тела ответа WAI есть три конструктора: один для чистых строителей~(\lstinline!ResponseBuilder!),
один для источника, производящего строителей,~(\lstinline!ResponseSource!) и
один для файлов~(\lstinline!ResponseFile!).

\subsection {Тело запроса}
Чтобы избежать загрузки всего тела запроса в оперативную память, здесь мы также используем
источники. Так как это значение предназначено для чтения (а не для записи), вместо \lstinline!Builder! мы используем~\lstinline!ByteString!. Тип данных~\lstinline!Request! содержит
поле с именем~\lstinline!requestBody!, имеющее тип~\lstinline!BufferedSource IO ByteString!.
Мы можем использовать все стандартные функции кондуитов для работы с этим источником.

Теоретически тело запроса может содержать любой тип данных, но наиболее частыми являются данные,
закодированные URL-кодировкой, и составные данные форм. Пакет~\footnotehref{http://hackage.haskell.org/package/wai-extra}{wai-extra} включает встроенную
поддержку для разбора данных форматов эффективно использующим память способом.

\section{Hello world}
Чтобы продемонстрировать простоту WAI, давайте взглянем на простейший пример.
В этом примере мы используем расширение языка OverloadedStrings, чтобы избежать
явной упаковки строковых значений в строки байт.

\includecode{24/hello-world.hs}

В строках со 2-й по 4-ю выполняется импорт необходимых модулей. Warp предоставляется
пакетом~\footnotehref{http://hackage.haskell.org/package/warp}{warp} и является
исторически первым веб-сервером, реализующим WAI. Также WAI использует
пакет~\footnotehref{http://hackage.haskell.org/package/http-types}{http-types},
который предоставляет некоторые типы данных и вспомогательные значения,
включая~\lstinline!status200!.

Сперва мы определяем наше приложение. Так как нам безразличны конкретные параметры
запроса, то мы игнорируем аргумент нашей функции. Для любого запроса мы возвращаем
ответ с кодом статуса 200 (<<OK>>), типом содержимого text/plain и телом, содержащим
слова <<Hello World>>. Довольно просто.

\section {Middleware~--- компоненты промежуточного уровня}
В добавление к возможности запуска наших приложений без изменения
кода на различных серверах реализующих WAI, WAI имеет ещё и другое преимущество~--- возможность создавать и использовать компоненты промежуточного уровня. Они являются по сути
преобразователями приложения, получая на вход одно приложение и возвращая другое.

Компоненты промежуточного уровня могут использоваться для различных нужд: исправления URL,
аутентификации, кэширования, обработки запросов JSON-P. Но, возможно, наиболее полезным
и наиболее интуитивно понятным является компонент реализующий gzip-сжатие. Этот компонент работает
довольно просто: он разбирает заголовки запроса для определения, поддерживает ли клиент
сжатие, и, если клиент поддерживает, то выполняет сжатие тела ответа, добавляя соответствующий
заголовок ответа.

Самое замечательное в компонентах промежуточного уровня заключается в том, что они ненавязчивы. Давайте посмотрим,
как применить gzip к нашему примеру.

\includecode{24/hello-world-gzip.hs}

Мы добавили строку импорта, чтобы получить доступ к компоненте, и затем просто применили \lstinline!gzip!
к нашему приложению. Вы также можете \emph{выстраивать в цепочку} несколько компонент:
к примеру, строка \lstinline{gzip False $ jsonp $ othermiddleware $ myapplication}
 вполне корректна. Но следует заметить, что порядок применения компонент может быть важен. К примеру,
для \lstinline!jsonp! нужны несжатые данные. Если вы его примените после применения \lstinline!gzip!,
то получите проблемы.

