\chapter {Интерфейс веб-приложения}\label{chap:web_application_interface}

Практически каждый язык, используемый для веб-разработки, сталкивался с проблемой
низкоуровневого интерфейса между веб-сервером и приожением. Самым ранним примером
решения этой проблемы является почтенный и потёртый в боях CGI (Common Gateway Interface), 
предоставляющий языконезависимый интерфейс на основе стандартного ввода, стандартного
вывода и переменных окружения.

Уже в те времена, когда Perl становился языком вебпрограммирования де-факто, оcновной
недостаток CGI стал очевидным: процесс должен запускаться заново для каждого запроса.
При использовании интерпретируемого языка и приложений, требующих подключения к базе
данных, эти издержки стали черезмерны. FastCGI (и позднее SCGI) возник как преемник
CGI, но, кажется, основная часть мира программирования направилась в другом направлении.

Каждый язык начал создавать свой собственный стандарт установления связи с серверами.
mod\_perl. mod\_python. mod\_php. mod\_ruby. В одном и том же языке возникало несколько
интерфейсов. В некоторых случаях получались даже интерфейсы поверх интерфейсов.
И всё это привело к большому дублированию усилий: приложение на Python, созданное
для работы с FastCGI не работало бы с mod\_python; mod\_python существовал только для
определённых вебсверверов; и подобные специфичные для языка расширения вебсверверов
требовалось писать для каждого языка программирования.

У Haskell своя история. У нас вначале был пакет \footnotehref{http://hackage.haskell.org/package/cgi}{cgi},
который предоставлял монадный интерфейс. Пакет \footnotehref{http://hackage.haskell.org/package/fastcgi}{fastcgi}
позднее предоставлял такой же интерфейс. В то же время, казалось, что большинство,
занимающихся вебпрограммированием на Haskell, сфокусировалось на автономном сервере.
Проблема в том, что у каждого сервера свой собственный интерфейс, а это означает, что 
вам надо иметь целью разработки конкретный сервер. То есть невозможно выделить
общий функционал наподобие GZIP кодирования, серверов для разработки и фреймворков для тестирования.

WAI пытается решить эту проблему, обеспечивая обобщённый и эффективный интерфейс между
вебсерверами и приложениями. Любой обработчик, поддерживающий интерфейс может обслуживать
любое приложение WAI, в то же время любоее приложение, использующее интерфейс может
запускаться с любым обработчиком.

На момент написания существовало несколько бэкэндов, включая Warp, FastCGI и
сервер разработки. Существуют и более эзотерические бэкэнды, такие как, например,
\footnotehref{http://hackage.haskell.org/package/wai-handler-webkit}{wai-handler-webkit},
используемый для создания настольных приложений. \footnotehref{http://hackage.haskell.org/package/wai-extra}{wai-extra} предоставляет большое число компонент middleware, таких как  GZIP, JSON-P
и виртуальный хостинг. \footnotehref{http://hackage.haskell.org/package/wai-test}{wai-test}
облегчает написание модульных тестов, а \footnotehref{http://hackage.haskell.org/package/wai-handler-devel}{wai-handler-devel} позволяет разрабатывать приложение не беспокоясь об остановке для компиляции.
Yesod нацелен на WAI, Happstack также находится в процессе перехода на него.
Этот интерфейс также используется некоторыми приложениями, которые не используют фреймворки, среди
них - новая версия Hoogle.

\fbox{\begin{minipage}[!h]{.9\linewidth}
Yesod предоставляет альтернативный подход для сервера разработки, известный как
yesod devel. Разница с wai-handler-devel состоит в том, что yesod devel компилирует
ваш код каждый раз, учитывая настройки в вашем cabal-файле.
Это рекомендуемый подход к разработке на Yesod.
\end{minipage}}

\section {Интерфейс}

Интерфейс сам по себе довольно незатейлив: приложение принимает запрос и возвращает
ответ. Ответом является статус HTTP, список заголовков и тело ответа.
Запрос содержит различную информацию: запрашиваемый путь, строка запроса, тело запроса,
версия HTTP и т.д.

\section {Тело ответа}

В Haskell имеется тип данных известный как ленивая строка байтов. Используя ленивость,
вы можете создавать большие значения без переполнения памяти. Используя ленивый ввод/вывод,
вы можете выполнять такие трюки, как например, иметь значение, которое представляет всё 
содержимое файла, и которое в то же время имеет небольшие затраты по памяти. В теории
ленивая строка байтов является единственным необходимым представляением тела ответа.

На практике же, в то время как ленивые строки байтов замечательно подходят для формирования
``чистых'' значений, ленивый ввод/вывод, необоходимый для чтения файлов вносит некоторый
недетерминизм в нашу программу. При обработке тысяч небольших файлов в секунду ограничивающим
фактором является не память, а число дескрипторов файлов. При использовании ленивого
ввода/вывода файловые дескрипторы не могут быть освобождены мгновенно, что приводит к
исчерпанию ресурсов. Для решения этого WAI использует каналы.

\fbox{\begin{minipage}[!h]{.9\linewidth}
Версии WAI до 1.0 использовали энумераторы вместо каналов. В то время как, и каналы
и энумераторы решают ту же самую базовую задачу, опыт показал, что энумераторы слишком
ограничивают возможности своим подходом к инверсии управления, что усложняет структурирование
сложных систем, таких как потоковый прокси-сервер. Каналы были спроектированы
с единственной целью - сделать WAI лучше.
\end{minipage}}

Типом данных, наиболее интересным нам, является тип ``источник''. Источник производит
поток данных, отдавая одну порцию за раз. В случае WAI, тело запроса будет источником,
передаваемым приложению, а тело ответа будет источником, возвращаемым из приложения.

Имеется также 2 дополнительные оптимизации: многие системы предоставляют системный вызов sendfile, который
посылает файл прямо в сокет, минуя множественное копирование в памяти, которое присуще
более общим системным вызовам ввода/вывода. Кроме того в Haskell имеется тип данных
под называнием \lstinline!Builder!, который делает возможным более эффективное копирование
байтов в буферы.

У тела ответа WAI таким образом имеется три конструктора: один для ``чистых'' построителей
(\lstinline!ResponseBuilder!), один для источника построителей (\lstinline!ResponseSource!) и
один для файлов (\lstinline!ResponseFile!).

\section {Тело запроса}

Для того, чтобы избежать загрузки всего тела запроса в оперативную память, мы также используем
источники. Так как это значение предназначено для чтения (а не для записи), мы используем
\lstinline!ByteString! вместо \lstinline!Builder!. В типе \lstinline!Request! имеется
запись с именем \lstinline!requestBody! и типом \lstinline!BufferedSource IO ByteString!.
Мы можетм использовать любые стандартные функции каналов для работы с этим источником.

Тело запроса в теорри может содержать любой тип данных, но наиболее частыми являеются данные
закодированные URL-кодировкой или в формате Multipart form-data. Пакет
\footnotehref{http://hackage.haskell.org/package/wai-extra}{wai-extra} содержит встроенную
поддержку для разбора данных форматов, которая эффективна с точки зрения использования памяти.

\section{Hello world}

Для того, чтобы продемонстрировать простоту WAI, давайте взглянем на пример hello world.
В этом примере мы используем расширение языка OverloadedStrings для того, чтобы избежать
явной запаковки строковых значений в строки байт.

\begin{lstlisting}
{-# LANGUAGE OverloadedStrings #-}
import Network.Wai
import Network.HTTP.Types (status200)
import Network.Wai.Handler.Warp (run)

application _ = return $
  responseLBS status200 [("Content-Type", "text/plain")] "Hello World"

main = run 3000 application
\end{lstlisting}%$

Строки со 2-й по 4-ю служат для импорта. Warp предоставляется пакетом
\footnotehref{http://hackage.haskell.org/package/warp}{warp} и является первейшим бэкэндом
для WAI. Также интерфейс WAI построен на базе пакета
\footnotehref{http://hackage.haskell.org/package/http-types}{http-types}, который
предоставляет некоторое число типов данных и вспомогательных значений,
среди которых \lstinline!status200!.

Сперва мы определяем наше приложение. Так как нам безразличны конкретные параметры
запроса, то мы игнорируем аргумент нашей функции. Для любого запроса мы возвращаем
ответ кодом статуса 200 ("OK"), тип содержимого text/plain и тело, содержащее
слова "Hello World". Довольно просто.

\section {Middleware}

В добавление к возможности запуска нашего приложения на различных бэкэндах без изменения
кода WAI имеет ещё и другое преимущество: middleware. Middleware является по сути
преобразователем приложения, получая на вход приложение и возвращая другое приложение.

Компоненты middleware могут использоваться для различных нужд: для исправление URL,
аутентификации, кэширования, обработки запросов JSON-P. Но возможно наиболее полезным
и наиболее интуитивным является middleware для gzip-сжатия. Этот компонент работает
довольно просто: он разбирает заголовки запроса для определения, поддерживает ли клиент
сжатие, и, если клиент поддерживает, то выполняет сжатие тела ответа, добавляя соотвествующий
заголовок ответа

Замечательлная вещь в middleware заключается в том, что они ненавязчивы. Давайте посмотрим
как применить gzip к нашему приложению hello world.

\begin{lstlisting}
{-# LANGUAGE OverloadedStrings #-}
import Network.Wai
import Network.Wai.Handler.Warp (run)
import Network.Wai.Middleware.Gzip (gzip, def)
import Network.HTTP.Types (status200)

application _ = return $ responseLBS status200 [("Content-Type", "text/plain")]
                       "Hello World"

main = run 3000 $ gzip def application
\end{lstlisting}%$

Мы добавили строку импорта чтобы получить доступ к middleware и затем просто применили gzip
к нашему приложению. Вы также можете \emph{выстроить в цепочку} несколько middleware:
к примеру, строка \lstinline{gzip False \$ jsonp \$ othermiddleware \$ myapplication}
вполне корректна. Но следует заметить, что важен порядок применения middleware. К примеру
для jsonp нужны несжатые данные, то есть, если вы его примените после применения gzip,
то получите проблемы.

