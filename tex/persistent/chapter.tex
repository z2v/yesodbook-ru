\chapter{Persistent}\label{chap:persistent}

\begin{remark}
    В главе описывается версия 1.3 пакета persistent. Будет обновлена до версии
    2.0 в следующей итерации книги (описывающей Yesod 1.4).
\end{remark}

Формы представляют собой границу между пользователем и приложением. Другая
граница, с которой нам приходится иметь дело, находится между приложением и
хранилищем. Является ли это хранилище SQL базой данных, YAML- или бинарным
файлом, скорее всего, уровень хранения исходно не понимает типы данных вашего
приложения, и вам придётся выполнять их преобразование. Persistent представляет
собой ответ Yesod на проблему хранения данных. Это универсальный типобезопасный
интерфейс к хранилищу данных для Haskell.

Haskell предлагает множество различных привязок к базам данных. Однако
большинство из них имеют слабое представление о схеме базы данных и потому не
обеспечивают полезных статических проверок. Кроме того, они вынуждают
программиста использовать API и типы данных, зависящие от конкретной базы
данных.

Чтобы избавиться от этих проблем, программистами на Haskell была предпринята
попытка пойти более революционным путём и создать хранилище данных, специфичное
для Haskell, тем самым получив возможность с лёгкостью хранить любой тип данных
Haskell. Эта возможность действительно прекрасна в некоторых случаях, но она
делает программиста зависимым от техники хранения данных в используемой
библиотеки и плохо взаимодействует с другими языками.

В отличии от Persistent, который предоставляет выбор среди множества
существующих баз данных, каждая из которых оптимизирована для различных
случаев, позволяет взаимодействовать с другими языками, а также использовать
безопасный и производительный интерфейс запросов, сохраняя при этом
безопасность типов, предоставляемую типами данных Haskell.

Persistent следует принципам безопасности типов и краткого, декларативного
синтаксиса. Среди других возможностей следует отметить:
\begin{itemize}
  \item Независимость от базы данных. Имеется первоклассная поддержка
      PostgreSQL, SQLite, MySQL и MongoDB, а также экспериментальная поддержка
      Redis.

  \item Удобное моделирование данных. Persistent позволяет вам моделировать
      отношения и использовать их типо-безопасными способами. Исходный API не
      поддерживает объединения, расширяя поддержку используемых уровней
      хранения. Объединения и другая специфичная для SQL функциональность
      доступна при использовании SQL уровня напрямую (с минимумом
      типо-безопасности). Дополнительная библиотека
      \footnotehref{http://hackage.haskell.org/package/esqueleto}{Esqueleto},
      построенная на базе модели данных Persistent, добавляет типо-безопасные
      объединения и другую функциональность SQL.

  \item Автоматическое выполнение миграций схемы базы данных.
\end{itemize}

Persistent хорошо соединяется с Yesod, но вполне может использоваться сам по
себе, как отдельная библиотека. Большая часть главы посвящена непосредственно
Persistent.

\section{Краткое содержание}

\sourcecode{persistent}{persistent-synopsis.hs}

\section{Решение пограничной проблемы}

Допустим, вы храните информацию о людях в SQL базе данных. Соответствующая
таблица может выглядеть как-то так:
\begin{lstlisting}
CREATE TABLE Person(id SERIAL PRIMARY KEY, name VARCHAR NOT NULL, age INTEGER)
\end{lstlisting}

И если вы используете такую СУБД, как PostgreSQL, вы можете быть уверены, что
СУБД никогда не сохранит некий произвольный текст в поле age. (Нельзя сказать
то же самое в отношении SQLite, но давайте пока забудем об этом.) Для
отображения этой таблицы вы, возможно, создадите примерно такой тип данных:
\begin{lstlisting}
data Person = Person
    { personName :: Text
    , personAge :: Int
    }
\end{lstlisting}

Всё выглядит вполне типобезопасно~--- схема базы данных соответствует типу
данных в Haskell, СУБД гарантирует, что некорректные данные никогда не будут
сохранены в таблице, и всё в целом выглядит прекрасно. До поры, до времени:
\begin{itemize}
  \item Вы хотите получить данные из СУБД, а она предоставляет их в
      нетипизированном виде.

  \item Вы хотите найти всех людей старше 32-х лет, но по ошибке пишете
      <<тридцать два>> в SQL-запросе. И знаете что? Всё прекрасно
      скомпилируется, и вы не узнаете о проблеме, пока не запустите программу.

  \item Вы решили найти первых десятерых человек в алфавитном порядке. Нет
      проблем... если вы не сделаете опечатку в SQL-запросе. И снова вы не
      узнаете об этом, пока не запустите программу.
\end{itemize}

В языках с динамической типизацией ответом на эти проблемы является модульное
тестирование. Проверьте, что для всего, что \emph{может} пойти не так, вы не
забыли написать тест. Но, как я полагаю, вы уже знаете, что это не очень
согласуется с подходом, принятом в Yesod. Мы предпочитаем использовать
преимущества статической типизации языка Haskell для нашей собственной защиты
насколько это возможно, и хранение данных не является исключением.

Итак, вопрос остаётся открытым: как мы можем использовать систему типов языка
Haskell, чтобы исправить положение?

\subsection{Типы}
Как и в случае с маршрутами, нет ничего невероятно сложного в типо-безопасном
доступе к данным. Он всего лишь требует написания монотонного, подверженного
ошибкам избыточного шаблонного кода. Как обычно, это означает, что мы можем
использовать систему типов для того, чтобы избежать лишних ошибок. А чтобы не
заниматься нудной работой, мы вооружимся Template Haskell.

\begin{remark}
    В ранних версиях Persistent очень активно использовался Template Haskell.
    Начиная с версии 0.6 используется новая архитектура, заимствованная из
    пакета groundhog. Благодаря новому подходу существенная часть нагрузки была
    переложена на фантомные типы.
\end{remark}

\lstinline'PersistValue' является основным строительным блоком в Persistent.
Этот тип представляет данные, посылаемые базе данных или получаемые от неё. Вот
его определение:

\begin{lstlisting}
data PersistValue = PersistText Text
                  | PersistByteString ByteString
                  | PersistInt64 Int64
                  | PersistDouble Double
                  | PersistRational Rational
                  | PersistBool Bool
                  | PersistDay Day
                  | PersistTimeOfDay TimeOfDay
                  | PersistUTCTime UTCTime
                  | PersistZonedTime ZT
                  | PersistNull
                  | PersistList [PersistValue]
                  | PersistMap [(Text, PersistValue)]
                  | PersistObjectId ByteString -- ^ предназначен специально для MongoDB
\end{lstlisting}

Каждый из бэкэндов Persistent должен знать, как переводить соответствующие
значения во что-то, понятное СУБД. Однако было бы неудобно выражать все данные
через эти базовые типы. Следующим слоем является класс
типов~\lstinline'PersistField', определяющий, как произвольный тип может быть
преобразован в тип~\lstinline'PersistValue' или обратно.
\lstinline'PersistField' соответствует столбцам в SQL базах данных. В
приведённом ранее примере с людьми name и age будут
нашими~\lstinline'PersistField'.

Чтобы связать пользовательский код, нам понадобится последний класс типов~---
\lstinline'PersistEntity'. Экземпляр класса типов~\lstinline'PersistEntity'
соответствует таблице в SQL базе данных. Этот класс типов определяет несколько
функций и связанные с ними типы. Таким образом, имеет место следующее
соответствие между Persistent и SQL:

\begin{center}
\begin{tabular}{ | l | l |}
\hline
SQL	& Persistent \\ \hline
Тип (VARCHAR, INTEGER и тд)	& PersistValue \\ \hline
Столбец & PersistField \\ \hline
Таблица	& PersistEntity \\ \hline
\end{tabular}
\end{center}

\subsection{Генерация кода}

Дабы убедиться, что экземпляры класса \lstinline'PersistEntity' корректно
соответствуют нашим типам данных, Persistent берёт на себя ответственность и за
тех, и за других. Это хорошо и с точки зрения принципа DRY (Не повторяйтесь,
Don't Repeat Yourself): от вас требуется объявить сущности только один раз.
Рассмотрим следующий пример:

\begin{lstlisting}
{-# LANGUAGE QuasiQuotes, TypeFamilies, GeneralizedNewtypeDeriving, TemplateHaskell, OverloadedStrings, GADTs #-}
import Database.Persist
import Database.Persist.TH
import Database.Persist.Sqlite
import Control.Monad.IO.Class (liftIO)

mkPersist sqlSettings [persistLowerCase|
Person
    name String
    age Int
    deriving Show
|]
\end{lstlisting}

Здесь мы используем комбинацию из Template Haskell и квазицитирования (как при
определении маршрутов): \lstinline'persistLowerCase' является обработчиком
квазицитирования, который преобразует чувствительный к пробелам синтаксис в
список определений сущностей. <<Нижний регистр>> (lower case) относится в
формату создаваемых имён таблиц. При такой схеме сущность \lstinline'SomeTable'
стала бы SQL таблицей с именем~\texttt{some\_table}. Также вы можете вынести
определение сущностей в отдельный файл и
воспользоваться~\lstinline'persistFileWith'. \lstinline'mkPersist' принимает
список этих сущностей и определяет:

\begin{itemize}
  \item По одному типу данных языка Haskell на сущность.

  \item Экземпляр класса \lstinline'PersistEntity' для каждого определённого
      типа данных.
\end{itemize}

Приведённый выше пример генерирует код, который выглядит примерно следующим
образом:

\begin{lstlisting}
{-# LANGUAGE TypeFamilies, GeneralizedNewtypeDeriving, OverloadedStrings, GADTs #-}
import Database.Persist
import Database.Persist.Sqlite
import Control.Monad.IO.Class (liftIO)
import Control.Applicative

data Person = Person
    { personName :: !String
    , personAge :: !Int
    }
  deriving (Show, Read, Eq)

type PersonId = Key Person

instance PersistEntity Person where
    -- Обобщённый алгебраический тип данных (Generalized Algebraic Datatype (GADT))
    -- Это даёт нам типобезопасный подход к сопоставлению
    -- полей с их типами данных
    data EntityField Person typ where
        PersonId   :: EntityField Person PersonId
        PersonName :: EntityField Person String
        PersonAge  :: EntityField Person Int

    data Unique Person
    type PersistEntityBackend Person = SqlBackend

    toPersistFields (Person name age) =
        [ SomePersistField name
        , SomePersistField age
        ]

    fromPersistValues [nameValue, ageValue] = Person
        <$> fromPersistValue nameValue
        <*> fromPersistValue ageValue
    fromPersistValues _ = Left "Invalid fromPersistValues input"

    -- Информация о каждом поле для внутреннего использования при генерации SQL выражений
    persistFieldDef PersonId = FieldDef
        (HaskellName "Id")
        (DBName "id")
        (FTTypeCon Nothing "PersonId")
        SqlInt64
        []
        True
        Nothing
    persistFieldDef PersonName = FieldDef
        (HaskellName "name")
        (DBName "name")
        (FTTypeCon Nothing "String")
        SqlString
        []
        True
        Nothing
    persistFieldDef PersonAge = FieldDef
        (HaskellName "age")
        (DBName "age")
        (FTTypeCon Nothing "Int")
        SqlInt64
        []
        True
        Nothing
\end{lstlisting}

Как вы, возможно, и ожидали, определение типа данных~\lstinline'Person' очень
близко к определению, данному в оригинальной версии кода, где использовался
Template Haskell. Мы также имеем обобщённый алгебраический тип данный (ОАТД),
предоставляющий отдельный конструктор для каждого поля. Этот ОАТД кодирует как
тип сущности, так и тип поля. Мы используем его конструкторы повсюду в
Persistent, например, чтобы убедиться, что когда мы применяем фильтр, типы
фильтруемого значения и поля совпадают.

Мы можем использовать сгенерированный тип~\lstinline'Person' как и любой другой
тип языка Haskell, а затем передать его в одну из функций модуля Persistent.

\begin{lstlisting}
{-# LANGUAGE EmptyDataDecls    #-}
{-# LANGUAGE FlexibleContexts  #-}
{-# LANGUAGE GADTs             #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE QuasiQuotes       #-}
{-# LANGUAGE TemplateHaskell   #-}
{-# LANGUAGE TypeFamilies      #-}
import           Control.Monad.IO.Class  (liftIO)
import           Database.Persist
import           Database.Persist.Sqlite
import           Database.Persist.TH

share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persistLowerCase|
Person
    name String
    age Int Maybe
    deriving Show
|]

main :: IO ()
main = runSqlite ":memory:" $ do
    michaelId <- insert $ Person "Michael" $ Just 26
    michael <- get michaelId
    liftIO $ print michael
\end{lstlisting}

Мы начинаем со стандартного кода подключения к базе данных. В данном случае, мы
использовали функции для работы с одним соединением. Модуль Persistent также
предоставляет функции для работы с пулом соединений, которые использовать в
боевом окружении обычно предпочтительнее.

В приведённом примере мы видим две функции. Функция~\lstinline'insert' создаёт новую запись
в базе данных и возвращает её ID. Как и всё остальное в модуле Persistent, ID
являются типобезопасными. Более подробно о том, как работают эти ID, мы узнаем
ниже. Итак, код \lstinline'insert $ Person "Michael" 25',
возвращает значение типа~\lstinline'PersonId'.

Следующая функция, которую мы видим,~--- это \lstinline'get'. Она пытается
загрузить из базы данных значение, используя заданный ID. При использовании
Persistent вам никогда не придётся беспокоиться, что вы, возможно, используете
ключ не от той таблицы. Код, который пытается получить другую сущность
(например,~\lstinline'House'), используя~\lstinline'PersonId', никогда не будет
скомпилирован.

\subsection{PersistStore}

Последний момент, который остался без объяснения в предыдущем примере: что
делает функция~\lstinline'runSqlite'? И что это за монада, в которой
выполняются все наши действия с базой данных?

Все действия с базой данных должны выполняться в
экземпляре~\lstinline'PersistStore'. Как следует из его названия, каждое
хранилище (PostgreSQL, SQLite, MongoDB) имеет свой
экземпляр~\lstinline'PersistStore'. Именно в нём происходит преобразование из
значений~\lstinline'PersistValue' в значения, специфичные для конкретной СУБД,
генерируются запросы SQL и так далее.

\begin{remark}
    Как вы, вероятно, догадываетесь, несмотря на то, что
    \lstinline'PersistStore' предоставляет безопасный, хорошо типизированный
    интерфейс, во время взаимодействия с базой данных многое может пойти не
    так. Однако, тестируя код автоматически и тщательно в каждом отдельном
    месте, мы можем централизовать склонный к ошибкам код и убедиться, что он
    настолько свободен от ошибок, насколько это вообще возможно.
\end{remark}

Функция \lstinline'runSqlite' создаёт отдельное соединение с базой данных,
используя предоставленную строку. Для тестов мы воспользуемся строкой
<<:memory:>>, которая означает использовать базу данных, расположенную в
памяти. SQLite и PostgreSQL используют один и тот же
экземпляр~\lstinline'PersistStore': \lstinline'SqlPersist'.
\lstinline'runSqlite' выполняет действие \lstinline'SqlPersist', предоставляя
ему созданное значение соединения.

\begin{remark}
    В действительности существует ещё несколько классов типов~--- это
    \lstinline'PersistUpdate' и~\lstinline'PersistQuery'. Различные классы
    типов предоставляют различную функциональность, что позволяет нам писать
    бэкенды, использующие более простые хранилища (например, Redis) несмотря на
    то, что они не обладают всей высокоуровневой функциональностью,
    предоставляемой Persistent.
\end{remark}

Важный момент, который следует отметить, заключается в том, что каждый
отдельный вызов~\lstinline'runSqlite' выполняется в отдельной транзакции.
Отсюда два следствия:

\begin{itemize}
  \item Для многих СУБД выполнение коммита может быть дорогой операцией.
      Помещая множество запросов в одну транзакцию, вы можете существенно
      ускорить выполнение кода.

  \item Если где-либо внутри вызова~\lstinline'runSqlite' бросается исключение,
      все выполненные действия будут отменены (rollback) (конечно, если
      используемый бэкенд поддерживает откат изменений).

        \begin{remark}
            На самом деле, у этого следствия есть далеко идущие последствия,
            сразу не заметные. Ряд функций Yesod, работающих по короткому циклу
            (short-circuit functions), например, редиректы, реализованы с
            использованием исключений. Если вы используете такую функцию внутри
            блока Persistent, она откатит всю транзакцию.
        \end{remark}
\end{itemize}

\section{Миграции}

Мне очень жаль, но всё это время я вам лгал: пример из предыдущего раздела на
самом деле не работает. Если вы попытаетесь запустить его, то получите ошибку о
несуществующей таблице.

При работе с реляционными СУБД, изменение схемы базы данных обычно является
большой проблемой. Вместо того, чтобы возлагать эту проблему на плечи
пользователя, Persistent делает шаг вперёд и протягивает руку помощи. Только
нужно его об этом \emph{попросить}. Вот как примерно это выглядит:

\sourcecode{persistent}{migration.hs}

Благодаря этому небольшому изменению, Persistent будет автоматически создавать
для вас таблицу~\lstinline'Person'. Разбиение между
функциями~\lstinline'runMigration' и~\lstinline'migrate' позволяет производить
миграции множества таблиц одновременно.

Это хорошо работает, когда речь идёт о нескольких сущностях, но становится
несколько утомительным при работе с десятками. Вместо того, чтобы повторяться,
Persistent предлагает функцию~\lstinline'mkMigrate:'

\sourcecode{persistent}{mkmigrate.hs}

\lstinline'mkMigrate'~--- это функция Template Haskell, которая создаёт новую
функцию, что автоматически вызывающую~\lstinline'migrate' для всех сущностей,
объявленных в блоке~\lstinline'persist'. Функция~\lstinline'share'~--- это
небольшая вспомогательная функция, который передаёт информацию из
блока~\lstinline'persist' каждой из функций Template Haskell, а затем
объединяет результаты их выполнения.

В Persistent используются очень консервативные правила относительно того, что
следует делать во время миграции. Сначала он загружает из базы данных всю
информацию о таблицах, вместе со всеми объявленными типами данных SQL. Эту
информацию он сравнивает с определениями сущностей, приведёнными в коде. В
следующих случаях схема базы данных будет изменена автоматически:

\begin{itemize}
    \item Изменился тип данных поля. Но СУБД может возражать против такого
        изменения, если данные не могут быть преобразованы.

    \item Было добавлено новое поле. Однако если поле не может быть пустым
        (NULL), не было предоставлено значение по умолчанию (как это сделать,
        мы обсудим ниже), и в таблице уже есть какие-то данные, СУБД не
        позволит добавить поле.

    \item Некоторое поле отныне может быть пустым. В обратном случае Persistent
        попытается выполнить преобразование, если СУБД позволит это сделать.

    \item Была добавлена совершенно новая сущность.
\end{itemize}

Однако есть и случаи, которые Persistent не в состоянии обработать:

\begin{itemize}
    \item Переименование сущностей или полей. У Persistent нет никакой
        возможности узнать, что поле <<name>> было переименовано в
        <<fullName>>. Всё, что он видит~--- это старое поле с именем <<name>> и
        новое поле с именем <<fullName>>.

    \item Удаление полей. Поскольку это может привести к потере данных, по
        умолчанию Persistent отказывается выполнять такие преобразования. Вы
        можете настоять на этом, воспользовавшись
        функцией~\lstinline'runMigrationUnsafe'
        вместо~\lstinline'runMigration', но это \textbf{не} рекомендуется.
\end{itemize}

Функция \lstinline'runMigration' выводит выполняемые миграции в STDERR (если
вам не нравится такое поведение, воспользуйтесь
функцией~\lstinline'runMigrationSilent'). По возможности она использует запросы
\texttt{ALTER TABLE}. Однако в SQLite \texttt{ALTER TABLE} имеет очень малые
возможности, поэтому Persistent приходится прибегнуть к копированию данных из
одной таблицы в другую.

Наконец, если вы хотите, чтобы вместо \emph{выполнения} миграций Persistent дал
вам подсказку по самостоятельному выполнению этих миграцией, воспользуйтесь
функцией~\lstinline'printMigration'. Эта функция выводит действия, которые были
бы выполнены функцией~\lstinline'runMigration'. Это может быть полезно в случае
выполнения миграций, на который Persistent не способен, выполнения
дополнительных SQL-запросов во время миграций, или же просто для
протоколирования происходящих миграций.

\section{Уникальность}

Помимо объявления полей у сущности мы также можем объявлять ограничение
уникальности. Типичный пример~--- это требование уникальности имени
пользователя:

\begin{lstlisting}
User
    username Text
    UniqueUsername username
\end{lstlisting}

В то время, как имя каждого поля должно начинаться с маленькой буквы,
ограничение уникальности должно начинаться с большой буквы, так как оно будет
представлено в Haskell как конструктор типа данных.

\sourcecode{persistent}{uniqueness.hs}

Чтобы сообщить об уникальности комбинации нескольких полей, добавим одну
дополнительную строку в наше определение. Persistent знает, что таким образом
определяется уникальный конструктор, потому что строка начинается с заглавной
буквы. Каждое последующее слово должно быть именем поля в сущности.

Главное ограничение, связанное с уникальностью, состоит в том, что она может
использоваться только для непустых (non-null) полей. Причина заключается в том,
что стандарт SQL неоднозначен относительно уникальности пустых полей (например,
NULL=NULL является истиной или ложью?). К тому же, в большинстве СУБД
реализованы правила, которые \emph{противоречат} правилам для соответствующих
типов данных в Haskell (например, в PostgreSQL NULL=NULL~--- это ложь, а в
Haskell Nothing=Nothing есть True).

В дополнение к предоставлению гарантий на уровне СУБД относительно
согласованности данных, ограничение уникальности также может быть использовано
для выполнения некоторых специфических запросов из кода на Haskell, как,
например, в случае с~\lstinline'getBy', продемонстрированном выше. Здесь используется
ассоциативный тип~\lstinline'Unique'. В конце приведённого выше примера используется
следующий конструктор:

\begin{lstlisting}
PersonName :: String -> String -> Unique Person
\end{lstlisting}

\begin{remark}
    В случае использования MongoDB ограничение уникальности не может быть
    использовано~--- вы должны создать уникальный индекс по полю.
\end{remark}

\section{Запросы}

В зависимости от вашей цели, могут быть использованы различные запросы к базе
данных. В некоторых запросах используется численный ID, когда в других
происходит фильтрация по значению поля. Запросы также различаются по количеству
значений, которые они возвращают. Одни должны возвращать не более одного
результата (если ключ поиска уникален), другие же могут возвращать множество
результатов.

В связи с этим Persistent предоставляет множество различных функций для
выполнения запросов. Как обычно, мы стараемся закодировать с помощью типов
столько инвариантов, сколько возможно. Например, если запрос может возвращать
либо 0, либо 1 результат, используется обёртка~\lstinline'Maybe'. Если же
запрос может вернуть много результатов, возвращается список.

\subsection{Выборка по ID}

Простейший запрос, который может быть выполнен в Persistent~--- это выборка по
ID. Поскольку в этом случае значение может существовать или не существовать,
возвращаемое значение оборачивается в~\lstinline'Maybe'.

Использование функции get:

\begin{lstlisting}
    personId <- insert $ Person "Michael" "Snoyman" 26
    maybePerson <- get personId
    case maybePerson of
        Nothing -> liftIO $ putStrLn "Just kidding, not really there"
        Just person -> liftIO $ print person
\end{lstlisting}

Это может быть очень удобно на сайтах, предоставляющих URL
типа~\emph{/person/5}. Однако, в таких случаях мы обычно не беспокоимся
о~\lstinline'Maybe', а просто хотим получить значение или вернуть код 404, если
оно не найдено. К счастью, есть функция~\lstinline'get404' (предоставляемая
пакетов yesod-persistent), которая поможет нам в этом. Мы разберёмся с этим
вопросом более детально, когда дойдём до интеграции с Yesod.

\subsection{Выборка по уникальному ключу}

Функция~\lstinline'getBy' почти идентична~\lstinline'get', за исключением:
\begin{itemize}
    \item принимает ограничение уникальности, т.е. вместо ID принимает
        значение~\lstinline'Unique'.

    \item возвращает значение типа~\lstinline'Entity', представляющее собой
        комбинацию ID и собственно значения.
\end{itemize}

\begin{lstlisting}
    personId <- insert $ Person "Michael" "Snoyman" 26
    maybePerson <- getBy $ PersonName "Michael" "Snoyman"
    case maybePerson of
        Nothing -> liftIO $ putStrLn "Just kidding, not really there"
        Just (Entity personId person) -> liftIO $ print person
\end{lstlisting}

Аналогично~\lstinline'get404', также существует функция~\lstinline'getBy404'.

\subsection{Функции выборок}

Скорее всего, вам хотелось бы выполнять более сложные запросы, например, найти
всех людей определённого возраста, все свободные машины синего цвета, всех
пользователей без указанного email и т.д. Для этого вам понадобится одна из
следующих функций выборок.

Все эти функции имеют похожий интерфейс и немного различающиеся возвращаемые
значения:

\begin{description}
    \item[selectSource] \hfill \\
        Возвращает источник (тип данных \lstinline'Source'), содержащий все ID
        и значения из базы данных. Позволяет писать поточный код.

    \begin{remark}
        \lstinline'Source'~--- это тип для поток данных, предоставляемый
        пакетом~\texttt{conduit}. Рекомендую чтение
        \footnotehref{https://www.fpcomplete.com/user/snoyberg/library-documentation/conduit-overview}%
        {учебника по conduit на сайте School of Haskell} для введения в тему.
    \end{remark}

    \item[selectList] \hfill\\
        Возвращает список, содержащий все ID и значения из базы данных. Все
        записи будут помещены в память.

    \item[selectFirst] \hfill \\
        Возвращает первый ID и первое значение из базы данных, если они есть.

    \item[selectKeys] \hfill \\
        Возвращает только ключи, без значений, в виде значения
        типа~\lstinline'Source'.
\end{description}

Чаще всего используется функция~\lstinline'selectList', так что мы рассмотрим
её отдельно. После этого понять остальные функции будет проще простого.

Функция~\lstinline'selectList' принимает два аргумента: список фильтров (тип
данных~\lstinline'Filter') и список опций выборки (тип
данных~\lstinline'SelectOpt'). Первый из них определяет ограничения,
накладываемые на свойства сущностей, и позволяет использовать предикаты
<<равно>>, <<меньше чем>>, <<принадлежит множеству>> и т.п. Опции выборки
предоставляют три различных возможности: сортировка, ограничение количества
возвращаемых строк и смещение возвращаемого значения на заданное количество
строк.

\begin{remark}
    Комбинация из ограничения и смещения очень важна, она позволяет реализовать
    эффективное разбиение на страницы в вашем веб-приложении.
\end{remark}

Сразу перейдём к примеру с фильтрацией, а затем проанализируем его:
\begin{lstlisting}
    people <- selectList [PersonAge >. 25, PersonAge <=. 30] []
    liftIO $ print people
\end{lstlisting}

Несмотря на простоту примера, необходимо отметить три момента:

\begin{itemize}
    \item \lstinline'PersonAge'~--- это конструктор связанного фантомного типа.
        Звучит ужасающе, однако действительно важно лишь то, что он однозначно
        определяет столбец <<age>> таблицы <<person>>, а также знает, что
        возраст на самом деле является значением типа~\lstinline'Int'. (В этом
        и состоит его фантомность.)

    \item В нашем распоряжении целый набор фильтрующих операторов пакета
        Persistent. Они довольно прямолинейны и делают в точности то, что вы от
        них ожидаете. Однако тут есть три тонких момента, которые я объясню
        ниже.

    \item Список фильтров объединяется логическим И, то есть, ограничение
        следует читать, как <<возраст больше 25-и И возраст меньше или равен
        30-и>>. Использование логического ИЛИ мы рассмотрим ниже.
\end{itemize}

Также имеется оператор с удивительным названием <<не равно>>. Мы используем
обозначение \lstinline'!=.', поскольку \lstinline'/=.' используется при
UPDATE-запросах (ради <<разделяй-и-устанавливай>>, о котором я расскажу позже).
Не беспокойтесь, если вы воспользуетесь неверным оператором, компилятор
предупредит вас. Ещё два удивительных оператора~--- это <<принадлежит
множеству>> и <<не принадлежит множеству>>. Они обозначаются, соответственно,
\lstinline'<-.' и \lstinline'/<-.' (оба с точкой на конце).

Что же касается логического ИЛИ, для него есть оператор \lstinline'||.'.
Например:

\begin{lstlisting}
    people <- selectList
        (       [PersonAge >. 25, PersonAge <=. 30]
            ||. [PersonFirstName /<-. ["Adam", "Bonny"]]
            ||. ([PersonAge ==. 50] ||. [PersonAge ==. 60])
        )
        []
    liftIO $ print people
\end{lstlisting}

Этот (совершенно нелепый) пример означает <<найти людей, чей возраст составляет
от 26-и до 30-и лет включительно ИЛИ чьё имя не Адам и не Бонни ИЛИ чей
возраст~--- 50 или 60 лет>>.

\subsubsection{SelectOpt}

Все наши вызовы~\lstinline'selectList' имели пустой список в качестве второго аргумента.
Это не задаёт никаких параметров и означает <<сортируй на усмотрение СУБД,
возвращай все результаты, не пропускай никаких результатов>>. SelectOpt имеет
четыре конструктора, которые могут быть использованы для изменения этого
поведения:

\begin{description}
    \item[Asc] \hfill \\
        Сортировать по заданному столбцу в неубывающем порядке.
        Тут используется такой же фантомный тип, как и при фильтрации,
        например,~\lstinline'PersonAge'.

    \item[Desc] \hfill \\
        Аналогично \lstinline'Asc', только в невозрастающем порядке.

    \item[LimitTo] \hfill \\
        Принимает аргумент типа~\lstinline'Int'. Вернуть не более указанного
        количества результатов.

    \item[OffsetBy] \hfill \\
        Также принимает аргумент типа~\lstinline'Int'. Пропустить указанное
        количество результатов.
\end{description}

В следующем отрывке кода определяется функция, которая разбивает результат на
страницы. Она возвращает всех людей старше 18-и лет, отсортированных по
возрасту (более старшие идут первыми). Люди с одинаковым возрастом сортируются
по фамилиям, а затем по именам.

\begin{lstlisting}
resultsForPage pageNumber = do
    let resultsPerPage = 10
    selectList
        [ PersonAge >=. 18
        ]
        [ Desc PersonAge
        , Asc PersonLastName
        , Asc PersonFirstName
        , LimitTo resultsPerPage
        , OffsetBy $ (pageNumber - 1) * resultsPerPage
        ]
\end{lstlisting}

\section{Манипуляции с данными}

Извлечение данных~--- это только полдела. Нам также необходимо иметь
возможность добавлять данные и модифицировать данные, находящиеся в базе.

\subsection{Вставка}

Иметь возможность работать с данными из базы~--- это здорово и замечательно, но
как эти данные туда попадут? Для этого есть функция insert. Вы просто передаёте
ей значение, а она возвращает ID.

В связи с этим имеет смысл немного пояснить философию Persistent. Во многих ORM
типы, используемые для работы с данными, непрозрачны. Вам приходится
продираться через определяемый ими интерфейс, чтобы получить, а затем изменить
данные. Однако в Persistent всё иначе~--- для всего используются старые добрые
алгебраические типы данных. Таким образом, вы по-прежнему можете иметь огромный
выигрыш от использования сопоставления с образцом, каррирования и всего
остального, к чему вы привыкли.

Однако есть вещи, которые мы \emph{не можем} делать. Например, нет способа
автоматически обновлять данные в базе данных при каждом их изменении в Haskell.
Конечно, учитывая позицию языка Haskell в отношении чистоты и неизменяемости,
от этого всё равно было бы мало проку, так что не будем лить слёзы.

Тем не менее, есть момент, который часто беспокоит новичков. Почему ID и
значения совершенно разделены? Казалось бы, куда логичнее было бы включить ID в
само значение. Другими словами, вместо:

\begin{lstlisting}
data Person = Person { name :: String }
\end{lstlisting}

... сделать так:

\begin{lstlisting}
data Person = Person { personId :: PersonId, name :: String }
\end{lstlisting}

Одна из проблем сразу бросается в глаза. Как прикажете производить вставку?
Если \lstinline'Person' требуется ID, а ID возвращается
функцией~\lstinline'insert', которой в свою очередь требуется
\lstinline'Person', мы получаем проблему курицы и яйца. Мы могли бы решить эту
проблему, используя значение~\lstinline'undefined', однако это верный способ
нарваться на неприятности.

Вы скажете, хорошо, давайте попробуем что-то более безопасное:

\begin{lstlisting}
data Person = Person { personId :: Maybe PersonId, name :: String }
\end{lstlisting}

Я определённо предпочитаю писать \lstinline'insert $ Person Nothing "Michael"'
вместо \lstinline'insert $ Person undefined "Michael"'.
И наши типы стали
намного проще, не так ли? Например, \lstinline'selectList' теперь может
возвращать просто \lstinline'[Person]' вместо уродливого \lstinline'[Entity Person]'.

Проблема заключается в том, что <<уродство>> оказывается невероятно полезным.
Запись \lstinline'Entity Person' делает очевидным тот факт, что мы работаем со
значением, которое находится в базе данных. Допустим, мы хотим создать ссылку
на другую страницу, в которой присутствует \lstinline'PersonId' (не такой уж
редкий случай, как мы вскоре выясним). \lstinline'Entity Person' недвусмысленно
предоставляет доступ к требуемой информации. Встраивание \lstinline'PersonId' в
\lstinline'Person' с обёрткой~\lstinline'Maybe' означает дополнительную
проверку на \lstinline'Just' во время выполнения, вместо более надёжной
проверки при компиляции.

Наконец, в случае присоединения ID к значению имеет место семантическое
несоответствие. \lstinline'Person'~--- это значение. Два человека являются идентичными (с
точки зрения базы данных), если все их поля одинаковы. Присоединяя ID к
значению, мы начинаем говорить не о человеке, а о строке в базе данных.
Равенство перестаёт быть равенством, оно превращается в идентичность: <<это
\emph{тот же самый человек}>> вместо <<это такой же человек>>.

Другими словами, есть некоторые раздражающие моменты в отделении ID от
значения, но в конце концов, это \emph{правильный} подход, который в целом
ведёт к лучшему, менее ошибочному коду.

\subsection{Обновление}

Теперь, в контексте нашего обсуждения, подумаем об обновлении. Вот простейший
способ сделать обновление:

\begin{lstlisting}
let michael = Person "Michael" 26
    michaelAfterBirthday = michael { personAge = 27 }
\end{lstlisting}

Однако, в действительности этот код ничего не обновляет. Он просто создаёт
новое значение типа~\lstinline'Person', основанное на старом значении. Когда мы
говорим об обновлении, мы имеем ввиду \emph{не} модификацию значений в Haskell.
(И вправду, не стоило бы этого делать, поскольку данные в Haskell неизменяемы.)

На самом деле, мы ищем способ изменить строки в таблице. И проще всего сделать
это с помощью функции~\lstinline'update':

\begin{lstlisting}
    personId <- insert $ Person "Michael" "Snoyman" 26
    update personId [PersonAge =. 27]
\end{lstlisting}

Функция~\lstinline'update' принимает два аргумента: ID и список значений
типа~\lstinline'Update'. Простейший способ обновления поля заключается в
присвоении ему нового значения, однако этот способ не всегда лучший. Что, если вы
хотите увеличить чей-то возраст на единицу, но текущий возраст вам не известен?
В Persistent предусмотрено и это:

\begin{lstlisting}
haveBirthday personId = update personId [PersonAge +=. 1]
\end{lstlisting}

Как и следовало ожидать, в нашем распоряжении есть все базовые математические
операторы: \lstinline'+=.', \lstinline'-=.', \lstinline'*=.' и \lstinline'/=.'
(все~--- с завершающей точкой). Они не только удобны для обновления единичной
записи, но и необходимы для соблюдения гарантий ACID. Представьте, что бы мы
делали без этих операторов. Нам приходилось бы извлекать из базы
\lstinline'Person', увеличивать возраст, а затем обновлять значение в базе
данных на новое. Как только у вас появляется два процесса или потока,
одновременно работающих с базой данных, вы попадаете в мир боли (подсказка:
состояние гонки).

Иногда мы хотим обновить несколько строк одновременно (например, повысить
зарплату на 5\% всем сотрудникам). Функция~\lstinline'updateWhere' принимает
два аргумента: список фильтров и список обновлений, которые следует применить.

\begin{lstlisting}
    updateWhere [PersonFirstName ==. "Michael"] [PersonAge *=. 2] -- это был длинный день
\end{lstlisting}

Иногда хочется просто заменить одно значение в базе данных на другое. Для этого
(сюрприз!) есть функция~\lstinline'replace':

\begin{lstlisting}
    personId <- insert $ Person "Michael" "Snoyman" 26
    replace personId $ Person "John" "Doe" 20
\end{lstlisting}

\subsection{Удаление}

Как ни печально, иногда мы вынуждены расстаться с нашими данными. Для этого у
нас есть три функции:
\begin{description}
    \item[delete] Удалить по ID

    \item[deleteBy] Удалить по уникальному ключу

    \item[deleteWhere] Удалить по множеству фильтров
\end{description}

\begin{lstlisting}
    personId <- insert $ Person "Michael" "Snoyman" 26
    delete personId
    deleteBy $ PersonName "Michael" "Snoyman"
    deleteWhere [PersonFirstName ==. "Michael"]
\end{lstlisting}

С помощью \lstinline'deleteWhere' мы можем удалить вообще все данные из
таблицы. Нужно только подсказать GHC, какая таблица нас интересует:

\begin{lstlisting}
    deleteWhere ([] :: [Filter Person])
\end{lstlisting}

\section{Атрибуты}

До сих пор мы видели базовый синтаксис для наших блоков
\lstinline'persistLowerCase'~--- строка с именем сущности, за которой для
каждого поля идёт по одной строке с отступами, состоящей из двух слов: имени
поля и типа данных поля. Persistent поддерживает не только это. После двух слов
в строке вы можете указать произвольный список атрибутов.

Допустим, вы хотите, чтобы сущность~\lstinline'Person' имела необязательный
возраст, а также метку времени добавления в систему. Для сущностей, уже
находящихся в базе данных, в качестве этого времени мы хотим использовать
текущее время.

\sourcecode{persistent}{attributes.hs}

\lstinline'Maybe' является встроенным атрибутом из одного слова. Он делает поле
необязательным. Это означает, что в Haskell данное поле будет обёрнуто
в~\lstinline'Maybe', а в SQL оно сможет иметь значение NULL.

Атрибут \lstinline'default' зависит от используемого бэкенда и может
использовать любой синтаксис, лишь бы он был понятен СУБД. В приведённом
примере используется встроенная функция СУБД~\lstinline'CURRENT_TIME'.
Допустим, теперь мы хотим добавить в сущность \lstinline'Person' поле с любимым
языком программирования:

\sourcecode{persistent}{attribute-default.hs}

\begin{remark}
    Атрибут \lstinline'default' абсолютно никак не влияет на код на Haskell, то
    есть, вам по-прежнему придётся заполнять все значения. Атрибут влияет
    только на схему базы данных и автоматические миграции.
\end{remark}

Мы должны заключить строку в одинарные кавычки, чтобы СУБД могла правильно
интерпретировать её. Также Persistent позволяет использовать двойные кавычки
для строк, содержащих пробелы. Например, если мы хотим сделать страной по
умолчанию Российскую Федерацию, то должны написать:

\sourcecode{persistent}{attribute-whitespace.hs}

Последний трюк, который вы можете проделать с атрибутами~--- это указать имена
таблиц и столбцов, используемые в SQL. Это может пригодиться при взаимодействии
с существующими базами данных.

\begin{lstlisting}
share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persistLowerCase|
Person sql=the-person-table id=numeric_id
    firstName String sql=first_name
    lastName String sql=fldLastName
    age Int "sql=The Age of the Person"
    PersonName firstName lastName
    deriving Show
|]
\end{lstlisting}

Есть ещё ряд возможностей доступны в синтаксисе определения сущностей.
Актуальный список поддерживается в
\footnotehref{https://github.com/yesodweb/yesod/wiki/Persistent-entity-syntax}%
{Yesod вики}.

\section{Отношения}

Persistent поддерживает ссылки между типами данных, таким образом, что они
остаются согласованными в поддерживаемых не-SQL базах данных. Ссылка создаётся
путём добавления ID в связанную сущность. Вот как выглядит пример для человека
с большим количеством машин:

\sourcecode{persistent}{relations.hs}

С помощью этой техники вы можете определять отношения один-ко-многим. Чтобы
определить отношение многие-ко-многим, нам понадобится связующая сущность,
которая имеет отношения один-ко-многим с каждой из оригинальных таблиц. В
данном случае будет хорошей идеей воспользоваться ограничением уникальности.
Допустим, мы хотим смоделировать ситуацию, в которой мы отслеживаем, какие люди
в каких магазинах делают покупки:

\sourcecode{persistent}{many-to-many.hs}

\begin{remark}
    Поскольку суффикс \lstinline'Id' в имени типа используется в Persistent для
    обозначения связи по внешнему ключу, в настоящий момент не представляется
    возможным использовать неключевые типы, чьё имя заканчивается на Id.
    Простое решение этой проблемы заключается в определении синонима типа с
    другим суффиксом, например:

    \begin{lstlisting}
    data MyExistingTypeEndingInId = ...
    type IdIsNotTheSuffix = MyExistingTypeEndingInId
    [persist|
    Person
        someField IdIsNotTheSuffix
    \end{lstlisting}
\end{remark}

\section{Подробнее о типах}

До сих пор мы говорили о \lstinline'Person' и~\lstinline'PersonId' без особого
объяснения, чем они на самом деле являются. В простейшем случае, если мы
говорим только о реляционных базах данных, \lstinline'PersinId' мог бы быть
просто \lstinline'type PersonId = Int64'. Но в этом случае на уровне типов
ничто не связывало бы \lstinline'PersonId' и сущность~\lstinline'Person'. В
результате вы могли бы по ошибке воспользоваться \lstinline'PersonId' и
получить~\lstinline'Car'. Для моделирования таких отношений мы используем
фантомные типы. Итак, наш следующий наивный шаг был бы следующим:

\begin{lstlisting}
newtype Key entity = Key Int64
type PersonId = Key Person
\end{lstlisting}

И это действительно отлично работает до тех пор, пока вы не столкнётесь с
бэкендом, который не использует \lstinline'Int64' для ID. И это далеко не
теоретический вопрос, поскольку MongoDB для этих целей использует тип
\lstinline'ByteString'. Итак, нам нужно значение ключа, которое может содержать
либо \lstinline'Int64', либо~\lstinline'ByteString'. Кажется, настало отличное
время для применения суммарных типов:

\begin{lstlisting}
data Key entity = KeyInt Int64 | KeyByteString ByteString
\end{lstlisting}

Но, на самом деле, это путь к неприятностям. В следующий раз нам попадётся
бэкенд, который использует в качестве ключа временные метки и нам придётся
ввести дополнительный конструктор для~\lstinline'Key'. Так может продолжаться
какое-то время. К счастью, у нас уже есть суммарный тип, предназначенный для
представления произвольных данных, \lstinline'PersistValue':

\begin{lstlisting}
newtype Key entity = Key PersistValue
\end{lstlisting}

Но тут есть другая проблема. Скажем, у нас есть веб-приложение, которое
принимает ID в качестве параметра от пользователя. Этому приложению придётся
принимать параметр, как~\lstinline'Text', а затем пытаться преобразовать его
в~\lstinline'Key'. Нет проблем, давайте напишем функцию, которая
преобразовывает~\lstinline'Text' в~\lstinline'PersistValue', а затем передадим
возвращаемое ею значение в конструктор~\lstinline'Key'. Правильно?

Нет, неправильно. Мы пробовали, и это к большой проблеме. Всё закончилось тем,
что нам пришлось принимать ключи, которых не может быть. Например, если мы
имеем дело с SQL, ключ должен быть целым числом. Но при подходе, описанном
выше, в качестве ключа мы разрешаем принимать произвольные текстовые данные. В
результате мы получали 500-ые ошибки, потому что СУБД была в шоке от попыток
сравнивать целочисленные поля с текстом.

Что нам действительно нужно, это способ преобразования текста
в~\lstinline'Key', но с учётом правил используемого бэкенда. И как только
вопрос становится сформулирован таким образом, мы тут же получаем ответ~---
добавить ещё одного фантома. В действительности, определение~\lstinline'Key' в
Persistent следующее:

\begin{lstlisting}
newtype KeyBackend backend entity = Key { unKey :: PersistValue }
type Key val = KeyBackend (PersistEntityBackend val) val
\end{lstlisting}

Эта слегка устрашающая формулировка означает: у нас есть
тип~\lstinline'KeyBackend', параметрами которого являются бэкенд и сущность.
Однако, у нас \textbf{также} есть упрощённый тип~\lstinline'Key', который
использует один и тот же бэкенд и для сущности, и для ключа, что практически
всегда является корректным допущением.

И это прекрасно работает. Теперь мы можем получить функцию
\lstinline'Text -> KeyBackend MongoDB entity' и функцию
\lstinline'Text -> KeyBackend SqlPersist entity', после
чего всё работает, как по маслу.

\subsection{Усложняем, обобщаем}
По умолчанию, Persistent зафиксирует ваши типы данных для работы с конкретным
бэкендом БД. При использовании~\lstinline'sqlSettings' это будет
тип~\lstinline'SqlBackend'. Но если вы хотите написать код Persistent, который
может быть использован для нескольких бэкендов, вы можете подключить более
общие типы, заменив~\lstinline'sqlSettings'
на~\lstinline'sqlSettings {mpsGeneric = True }'.

Чтобы разобраться, зачем это нужно, рассмотрим отношения. Допустим, мы хотим
представить блоги и посты в них. Мы использовали бы такое описание сущностей:

\begin{lstlisting}
Blog
    title Text
Post
    title Text
    blogId BlogId
\end{lstlisting}

Но как это будет выглядеть с точки зрения типа данных~\lstinline'Key'?

\begin{lstlisting}
data Blog = Blog { blogTitle :: Text }
data Post = Post { postTitle :: Text, postBlogId :: KeyBackend <что должно быть здесь?> Blog }
\end{lstlisting}

Мы должны указать какой-то бэкенд. В теории, мы можем явно
подставить~\lstinline'SqlPersist' или~\lstinline'Mongo', но тогда наши типы
данных будут работать только с одним бэкендом. Для одного приложения это может
быть приемлемым, но как насчёт библиотек с определениями типов данных, которые
могут использоваться в различных приложениях с различными бэкендами?

Так что, всё становится чуть сложнее. На самом деле, наши типы такие:

\begin{lstlisting}
data BlogGeneric backend = Blog { blogTitle :: Text }
data PostGeneric backend = Post { postTitle :: Text, postBlogId :: KeyBackend backend (BlogGeneric backend) }
\end{lstlisting}

Обратите внимание, что мы всё ещё используем короткие имена для конструкторов и
записей. Наконец, чтобы предоставить простой интерфейс для нормального кода, мы
определяем кое-какие синонимы типов:

\begin{lstlisting}
type Blog = BlogGeneric SqlPersist
type BlogId = Key SqlPersist Blog
type Post = PostGeneric SqlPersist
type PostId = Key SqlPersist Post
\end{lstlisting}

И, конечно, Persistent не завязан жёстко на \lstinline'SqlPersist' где-либо.
Это параметр~\lstinline'sqlSettings', что вы передали в~\lstinline'mkPersist',
говорит нам использовать~\lstinline'SqlPersist'. В коде, использующем Mongo,
вместо него будет использован параметр~\lstinline'mongoSettings'.

Описанное выше может показаться несколько сложным, но при написании
пользовательского кода всё это едва ли когда-нибудь вам понадобится.
Просмотрите ещё раз эту главу~--- нам ни разу не приходилось работать
с~\lstinline'Key' или~\lstinline'Generic' напрямую. Наиболее распространённое
место, где они могут всплыть,~--- это сообщения компилятора об ошибках. Поэтому
важно знать об этом, но вряд ли придётся сталкиваться с этим ежедневно.

\section{Поля произвольного типа}

Однажды, вы захотите определить собственное поле для использования в своём
хранилище. Наиболее типичный случай~--- это перечисление, например состояние
найма сотрудников. Для этого Persistent предоставляет специальную функцию
Template Haskell:

\sourcecode{persistent}{Employment.hs}

\sourcecode{persistent}{custom-fields.hs}

\lstinline'derivePersistField' позволяет хранить данные в базе, используя
строковые поля, а также реализует сериализацию с помощью экземпляров
классов~\lstinline'Read' и~\lstinline'Show' вашего типа данных. Это может быть
не так эффективно, как использование целых чисел, зато удобнее вот в каком
плане. Даже если в будущем вы добавите новые конструкторы, данные в базе
останутся валидными.

\begin{remark}
    Мы разделили наш пример на два отдельных модуля. Это необходимо из-за
    ограничения стадий GHC (GHC stage restriction), по сути означающее, что, в
    большинстве случаев, созданный Template Haskell код не может
    использоваться в том же самом модуле.
\end{remark}

\section{Persistent: сырой SQL}

Пакет Persistent предоставляет типобезопасный интерфейс к хранилищу данных. Он
старается не зависеть от используемого бэкенда, например, не полагаясь на
реляционные возможности SQL. По моему опыту в 95\% случаев вы с лёгкостью
решите стоящую перед вами задачу, используя высокоуровневый интерфейс. (В
действительности, большинство моих веб-приложений используют только
высокоуровневый интерфейс.)

Но иногда возникает желание использовать возможности, специфичные для
конкретного бэкенда. Одной из таких возможностей, которую мне приходилось
использовать, был полнотекстовый поиск. В этом случае в SQL-запросе требуется
использовать LIKE, который не моделируется в Persistent. Давайте попробуем
найти всех людей с фамилией <<Snoyman>> и вывести найденные записи.

\begin{remark}
    На самом деле, вы \emph{можете} воспользоваться оператором LIKE с помощью
    нормального синтаксиса, поскольку в Persistent 0.6 была добавлена
    возможность, позволяющая использовать операторы, специфичные для бэкенда.
    Но это всё равно хороший пример, так что давайте рассмотрим его.
\end{remark}

\sourcecode{persistent}{raw-sql.hs}

Также существует высокоуровневая поддержка для автоматизированной сериализации.
Подробности вы можете найти в Haddock-документации по API.

\section{Интеграция с Yesod}

Итак, вы прониклись всей мощью Persistent. Как теперь интегрировать его с
Yesod-приложением? Если вы используете каркас сайта, большая часть работы уже
была проделана за вас. Но, по традиции, сейчас мы проделаем всё вручную, чтобы
лучше понять, как всё устроено.

Пакет yesod-persistent представляет собой <<клей>> между Persistent и Yesod. Он
предоставляет класс типов~\lstinline'YesodPersist', который стандартизует
доступ к базе данных с помощью метода~\lstinline'runDB'. Вот как это выглядит в
действии.

\sourcecode{persistent}{persistent-yesod.hs}

Тут есть два важных момента для общего использования. Для выполнения действий
над базой данных из монады~\lstinline'Handler' используется
функция~\lstinline'runDB'. Внутри \lstinline'runDB' вы можете использовать все
те функции, о которых шла речь выше, например, \lstinline'insert'
и~\lstinline'selectList'.

\begin{remark}
    \lstinline'runDB' имеет тип
    \lstinline'runDB :: YesodDB site a -> HandlerT site IO a'.
    \lstinline'YesodDB' определён, как:

    \begin{lstlisting}
    type YesodDB site = YesodPersistBackend site (HandlerT site IO)
    \end{lstlisting}

    Поскольку он построен на связанном типе~\lstinline'YesodPersistBackend', то
    он использует соответствующий для текущего сайта бэкенд.
\end{remark}

Другая новая фишка~--- это~\lstinline'get404'. Эта функция работает в точности,
как~\lstinline'get', только вместо того, чтобы возвращать~\lstinline'Nothing',
когда результат не может быть найден, она возвращает страницу с сообщением об
ошибке 404. В функции~\lstinline'getPersonR' использован очень распространённый
в реальных приложениях на Yesod подход~--- значение получается через
функцию~\lstinline'get404', а затем в зависимости от результата возвращается
ответ.

\section{SQL посложнее}
Persistent старается быть независимым от бэкенда. Преимущество такого
подхода~--- код, который может быть легко переносимым между типами бэкендов.
Недостаток~--- потеря некоторых специфичных для бэкенда возможностей. Возможно,
наибольшая потеря~--- поддержка объединений (join) SQL.

К счастью, благодаря Фелипе Лёсса (Felipe Messa), вы можете получить свой
кусочек торта и съесть его.
Библиотека~\footnotehref{http://hackage.haskell.org/package/esqueleto}{Esqueleto}
предоставляет средства для написания типо-безопасных SQL запросов, используя
существующую инфраструктуру Persistent. Документация Haddocks для этого пакета
содержит хорошее введение в использование библиотеке. И поскольку она
использует множество концепций Persistent, большая часть ваших знаний о
Persistent должна легко перенестись и на неё.

\section{Не только SQLite}
Чтобы не усложнять примеры этой главы, мы использовали бэкенд для SQLite. В
завершение обсуждения, вот пример из введения, переписанный для использования с
PostgreSQL:

\sourcecode{persistent}{postgre.hs}

\section{Выводы}

Persistent приносит строгую типизацию языка Haskell в ваш слой доступа к
данным. Вместо того, чтобы писать склонный к возникновению ошибок,
нетипизированный доступ к данным, или вручную писать шаблонный код
сериализации, вы можете автоматизировать работу, используя Persistent.

Цель состоит в том, чтобы \emph{большую часть} времени предоставлять всё
необходимое. В тех же случаях, когда вам нужно более мощное средство,
Persistent предоставляет прямой доступ к нижележащему хранилищу данных, так что
вы можете написать любое пятистороннее объединение таблиц, какое пожелаете.

Persistent напрямую интегрируется в общий рабочий процесс с Yesod. И речь тут
идёт не только о небольших пакетах вроде \texttt{yesod-persistent}~--- пакеты
вроде \texttt{yesod-form} и~\texttt{yesod-auth} также прекрасно взаимодействуют
с Persistent.
