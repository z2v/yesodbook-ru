\chapter{Основы}\label{chap:basics}

Первый шаг при изучении любой новой технологии --- сделать так, чтобы она заработала. Цель
данной главы --- познакомить вас с простым приложением Yesod и охватить некоторые основные
концепции и терминологию.

\section{Здравствуй, Мир}

Давайте начнём эту книгу, как полагается: сделаем простую web-страницу, на которой
выводится <<\texttt{Здравствуй, Мир!}>>:

\begin{lstlisting}
{-# LANGUAGE TypeFamilies, QuasiQuotes, MultiParamTypeClasses,
             TemplateHaskell, OverloadedStrings #-}
import Yesod

data HelloWorld = HelloWorld

mkYesod "HelloWorld" [parseRoutes|
/ HomeR GET
|]

instance Yesod HelloWorld

getHomeR :: Handler RepHtml
getHomeR = defaultLayout [whamlet|Здравствуй, Мир!|]

main :: IO ()
main = warpDebug 3000 HelloWorld
\end{lstlisting}

Если вы сохраните этот код в файл \lstinline!helloworld.hs! и запустите его командой
\lstinline!runhaskell helloworld.hs!, то получите веб-сервер, запущенный на порту 3000.
Если вы откроете браузером страницу \lstinline'http://localhost:3000', то получите
следующий HTML-код:

\begin{lstlisting}[language=HTML]
<!DOCTYPE html>
<html><head><title></title></head><body>Здравствуй, Мир!</body></html>
\end{lstlisting}

Далее на протяжении главы мы ещё будем возвращаться к этому примеру.

\section{Маршрутизация}

Как и большинство современных веб-фреймворков, Yesod следует шаблону <<eдиная точка
входа>>. Это означает, что каждый запрос к приложению Yesod поступает через общую точку и
оттуда уже маршрутизируется. В отличие от этого подхода, в системах наподобие PHP и ASP вы
обычно создаете множество различных файлов, и веб-сервер автоматически направляет запросы
к соответствующему файлу.

Кроме того, Yesod использует декларативный стиль задания маршрутов. В приведенном выше
примере это выглядело так:

\begin{lstlisting}
mkYesod "HelloWorld" [parseRoutes|
/ HomeR GET
|]
\end{lstlisting}

\begin{remark}
  \lstinline!mkYesod! --- это функция Template Haskell, а \lstinline!parseRoutes! --- 
  обработчик квазицитирования.
\end{remark}

% I'd like to call it HomeR
% Похоже, здесь игра слов: "Я хочу назвать его Гомер".
По-русски это означает: создать в приложении \texttt{HelloWorld} один путь по имени
\lstinline!HomeR!. Он должен слушать запросы к / (корню приложения) и отвечать на
GET-запросы. \lstinline!HomeR! мы называем ресурсом, отсюда и суффикс <<R>> в названии.

\begin{remark}
  Суффикс <<R>> в именах ресурсов --- это просто соглашение, но его придерживаются
  практически повсеместно. Оно позволяет немного упростить чтение и понимание кода.
\end{remark}

% Тоже не придумал, на что заменить "подчищенную версию". Как один из многословных
% вариантов: "Вот версия, избавленная от многих несущественных подробностей:".
Функция TH \lstinline!mkYesod! генерирует довольно много кода: тип данных маршрута,
функцию диспетчеризации и функцию рендеринга. Мы рассмотрим их более подробно в
главе~\hyperref[chap:routing]{<<Маршрутизация URL и обработчики>>}. Но используя опцию GHC
\lstinline'-ddump-splices', мы можем посмотреть непосредственно на сгенерированный
код. Вот сильно подчищенная его версия:\marginpar{подчищенная звучит глупо, но более
  хорошего немногословного варианта не вижу}

\begin{lstlisting}
instance RenderRoute HelloWorld where
  data Route HelloWorld = HomeR
    deriving (Show, Eq, Read)
  renderRoute HomeR = ([], [])

instance YesodDispatch HelloWorld HelloWorld where
    yesodDispatch master sub toMaster app404 app405 method pieces =
        case dispatch pieces of
            Just f -> f
                master
                sub
                toMaster
                app404
                app405
                method
            Nothing -> app404
      where
        dispatch = Yesod.Routes.Dispatch.toDispatch
            [ Yesod.Routes.Dispatch.Route [] False onHome
            ]
        onHome [] = Just $ \master sub toMaster _app404 app405 method ->
            case method of
                "GET" -> yesodRunner
                    (fmap chooseRep getHomeR)
                    master
                    sub
                    (Just HomeR)
                    toMaster
                _ -> app405 HomeR

getHomeR = return ()

main :: IO ()
main = return ()
\end{lstlisting}
%$

% Второе предложение я не совсем понял, поэтому постарался перевести ближе к тексту.
% Возможно, требуется коррекция.
Что-то из этого вам, вероятно, пока непонятно. В частности, реализация
\lstinline!yesodDispatch! выглядит страшновато из-за того, что она должна быть
приспособлена к разным способам диспетчеризации и соответствовать модели, необходимой для
наших структур высокопроизводительной маршрутизации. Тем не менее, реализация
\lstinline!RenderRoute! вместе с ассоциированным типом данных должна дать вам хорошее
представление о том, что происходит внутри.

\section{Функция-обработчик}

% Продолжаю предполагать, что автор использует игру слов с HomeR.
Итак, у нас есть маршрут по имени \lstinline!HomeR!, и он отвечает на GET-запросы.  Как вы
определяете наш ответ? Вы пишете функцию-обработчик. Yesod следует стандартной схеме
именования таких функций: имя метода в нижнем регистре (т. е., GET становится
\lstinline!get!), после которого идёт имя марштута. В нашем случае эта функция будет
называться \lstinline!getHomeR!.

Большая часть вашего кода в Yesod будет находиться в функциях-обработчиках.  Именно здесь
вы обрабатываете пользовательский ввод, выполняете запросы к базе данных и создаете
ответы. В нашем простом примере мы создаем ответ с помощью функции
\lstinline!defaultLayout!. Эта функция оборачивает переданное ей содержимое в шаблон
вашего сайта. По умолчанию она создаёт файл HTML с doctype, тегами html, head и body. Как
мы увидим в главе~\hyperref[chap:yesod-typeclass]{<<Класс типов Yesod>>}, эта функция может
быть переопределена, чтобы делать гораздо больше.

В нашем примере в \lstinline!defaultLayout! мы передаем
\lstinline'[whamlet|Hello World!|]'. \lstinline!whamlet! --- это еще один обработчик
квазицитирования. В данном случае он преобразует синтаксис Hamlet в
\texttt{Widget}. Hamlet --- это движок HTML-шаблонов, используемый в Yesod по умолчанию.
Вместе со своими <<родственниками>> Cassius, Lucius и Julius он позволяет создавать HTML,
CSS и JavaScript типобезопасным образом с проверкой во время компиляции. Гораздо больше
информации по этому поводу мы увидим в ~\hyperref[chap:shakespeare]{главе о Shakespeare}.

Виджеты --- еще один краеугольный камень Yesod. Они позволяют вам создавать
модульные компоненты сайта, состоящие из HTML, CSS и JavaScipt,
и повторно использовать их в любом месте вашего сайта. Более детально мы будем их
рассматривать в главе~\hyperref[chap:widgets]{<<Виджеты>>}.

\section{Тип-основание}

Слово <<HelloWord>> появляется в нашем примере несколько раз. Каждое приложение Yesod
имеет тип-основание. Этот тип должен быть экземляром класса типов \lstinline!Yesod!,
который предоставляет общее место для определения различных настроек, определяющих
выполнение нашего приложения.

В нашем случае этот тип данных довольно скучный: он не содержит никакой информации. Тем не
менее, тип-основнание имеет существенное влияние на то, как выполняется наш пример: он
связывает воедино маршруты с определением экземпляра и дает им всем возможность
выполняться. На протяжении книги мы увидим, как тип-основание всплывает в разных местах.

Но типы-основания не обязательно должны быть скучными: они могут использоваться для
хранения множества полезной информации, обычно той, которая должна быть инициализирована
при запуске и использоваться повсюду. Вот некоторые наиболее распространённые примеры:

\begin{itemize}
  \item пул соединений с базой данных;
  \item настройки, загружаемые из конфигурационного файла;
  \item менеджер соединений HTTP.
\end{itemize}

\begin{remark}
% TODO: иврит не отображается в выходном файле
  Кстати, слово yesod (\textsf{יסוד}) означает <<основание>> на иврите.
\end{remark}

\section{Запуск}

Ещё раз мы упоминаем \lstinline!HelloWorld! в нашей основной функции. Тип-основание
содержит всю необходимую информацию для маршрутизации и ответов на запросы в нашем
приложении; теперь нам нужно просто преобразовать его в нечто, что можно запустить. Для
этого в Yesod есть полезная функция \lstinline!warpDebug!, которая запускает веб-сервер
Warp с отладочным выводом в указанный порт (в нашем случае это 3000).

Одной из особенностей Yesod является то, что вы не привязаны к единственной стратегии
развертывания. Yesod построен поверх Web Application Interface (WAI), позволяющего
запускать приложение через FastCGI, SCGI, Warp или даже как настольное приложение,
используя библиотеку WebKit. Мы рассмотрим некоторые из этих возможностей в
\hyperref[chap:deploying]{главе о развертывании}. И в конце данной главы мы рассмотрим сервер
разработки.

Warp является для Yesod основным способом развертывания. Это легковесный,
высокоэффективный веб-сервер, разработанный специально для хостинга приложений Yesod. Он
используется и вне Yesod для других разработок на Haskell (как для приложений, основанных
на фреймворках, так и для не зависящих от них), а также как стандартный файл-сервер в
различных боевых окружениях.

\section{Ресурсы и типобезопасные URL}

% Взял на себя смелость предположить, что такой вариант перевода лучше передает оттенки
% смысла оригинала. Возможно, я неправ. Запрашиваю обсуждение.
В нашем <<здравствуй-мире>> мы определили только один ресурс
(\lstinline!HomeR!). Веб-приложение обычно намного более интересно, когда в нем больше
одной страницы. Давайте посмотрим:

\begin{lstlisting}
{-# LANGUAGE TypeFamilies, QuasiQuotes, MultiParamTypeClasses,
             TemplateHaskell, OverloadedStrings #-}
import Yesod

data Links = Links

mkYesod "Links" [parseRoutes|
/ HomeR GET
/page1 Page1R GET
/page2 Page2R GET
|]

instance Yesod Links

getHomeR  = defaultLayout [whamlet|<a href=@{Page1R}>Go to page 1!|]
getPage1R = defaultLayout [whamlet|<a href=@{Page2R}>Go to page 2!|]
getPage2R = defaultLayout [whamlet|<a href=@{HomeR}>Go home!|]

main = warpDebug 3000 Links
\end{lstlisting}

В целом это очень похоже на <<Здравствуй, Мир>>. Тип-основание теперь \lstinline!Links!
вместо \lstinline!HelloWorld!, и помимо ресурса \lstinline!HomeR! мы добавили
\lstinline!Page1R! и \lstinline!Page2R!. В связи с этим мы также добавили ещё две
функции-обработчика: \lstinline!getPage1R! и \lstinline!getPage2R!.

Единственная действительно новая особенность находится внутри квазицитирования
\lstinline'whamlet'. Мы углубимся в изучение этого синтаксиса в
\hyperref[chap:shakespeare]{главе о Shakespeare}, но мы можем увидеть, что

\begin{lstlisting}
<a href=@{Page1R}> Перейти на страницу 1!
\end{lstlisting}
создаёт ссылку на ресурс \lstinline!Page1R!. Здесь важно отметить, что \lstinline!Page1R!
--- это конструктор данных. Делая каждый ресурс конструктором данных, мы получаем
возможность, называемую типобезопасными URL. Вместо соединения строк для получения URL мы
создаём старое доброе значение Haskell. Используя @-интерполяцию (\lstinline!@{...}!),
Yesod автоматически отображает эти значения в текстовые ссылки перед отправкой их
пользователю. Мы можем увидеть, как это реализовано, еще раз посмотрев на вывод
\lstinline!--dump-splices!:

\begin{lstlisting}
instance RenderRoute Links where
    data Route Links = HomeR | Page1R | Page2R
      deriving (Show, Eq, Read)

    renderRoute HomeR  = ([], [])
    renderRoute Page1R = (["page1"], [])
    renderRoute Page2R = (["page2"], [])

main :: IO ()
main = return ()
\end{lstlisting}

% FIXME: похоже, что returnRoute - это опечатка в книге, а на самом деле
% подразумевалось renderRoute. Пока править не буду, нужно, чтобы посмотрел
% специалист.
В ассоциированном с \lstinline!Links! типе \lstinline!Route! у нас есть дополнительные
конструкторы для \lstinline!Page1R! и \lstinline!Page2R!. У нас также есть более хорошее
представление о возвращаемых значенях \lstinline!returnRoute!.\marginpar{Есть подозрение,
  что вместо returnRoute должно быть renderRoute} Первый элемент кортежа содержит
компоненты пути для данного маршрута. Второй элемент содержит параметры строки запроса;
практически во всех вариантах использования это будет пустой список.

Трудно переоценить значение типобезопасных URL. Они позволяют вам достичь большой гибкости
и надёжности при разработке приложения. Мы можете произвольным образом менять URL
ресурсов, ни разу не повредив ссылки на них. В главе~\hyperref[chap:routing]{<<Маршрутизация
  URL и обработчики>>} мы увидим, что маршруты могут принимать параметры, как, например,
URL записи в блоге, принимающий идентификатор поста.

% Перевод slug как "транслитерированное название" был более корректным, но смотрелся коряво.
% Думаю, если оставить просто "название", смысл не пострадает.
Предположим, вы хотите перейти от маршрутизации по числовому идентификатору поста к
маршрутизации по шаблону <<\texttt{год/месяц/название}>>. В традиционном веб-фреймворке
вам придётся исправить каждую ссылку на пост в блоге, и если вы пропустите хотя бы одну,
то будете получать ошибки 404 во время выполнения. В Yesod всё, что вам придётся сделать,
--- это обновить маршрут и перекомпилировать приложение: GHC сам найдёт все ссылки,
которые должны быть откорректированы.

\section{Каркас сайта}

При установке Yesod вы получаете как библиотеку Yesod, так и исполняемый файл
\lstinline!yesod!. Этот исполняемый файл принимает несколько команд, но первая команда, с
которой вы захотите познакомиться, --- это \lstinline!yesod init!. Она задаст вам
несколько вопросов, а затем сгенерирует каталог, содержащий каркас сайта по умолчанию. В
этом каталоге вы можете выполнить \lstinline'cabal install --only-dependencies', чтобы
установить дополнительные зависимости (такие как бэкэнды баз данных), и затем
\lstinline'yesod devel', чтобы запустить сайт.

Каркас сайта дает вам <<из коробки>> множество установившихся практик, располагая файлы и
настраивая зависимости проверенным временем образом, применяемым в большинстве боевых
сайтов на Yesod. Однако все эти удобства могут встать на пути изучения Yesod. Поэтому на
протяжении большей части этой книги инструмент построения каркаса сайта не используется, и
работа идет напрямую с Yesod как с библиотекой.

Мы рассмотрим структуру каркаса сайта во всех подробностях позже.

\section{Сервер разработки}

% Сделал избыточный перевод: "hit refresh" -> "обновляете страницу в браузере". Мне
% это кажется разумным, но я готов это обсуждать.
% TODO: я не понял, что именно значит фраза "we'll need to call runhaskell from scratch",
% поэтому перевод требует проверки.
Одним из преимуществ интерпретируемых языков перед компилируемыми является быстрое
прототипирование: вы просто сохраняете изменения в файл и обновляете страницу в
браузере. Если мы хотим внести изменения в приведенные выше приложения Yesod, нам придется
вызывать \lstinline!runhaskell! с самого начала, что может быть немного утомительно.

К счастью, существует решение этой проблемы: \lstinline'yesod devel' автоматически
пересобирает код и перезагружает ваш код. Это может быть отличным способом разработки
ваших Yesod-проектов, и когда вы будете готовы перейти на боевой сервер, вы все равно
получите в результате компиляции невероятно эффективный код. Построение каркаса Yesod
настраивает всё для вас автоматически. Это позволяет использовать лучшее из двух миров:
быстрое прототипирование и быстрый боевой код.

Подготовка вашего кода для использования с \lstinline!yesod devel! немного более сложна,
поэтому наши примеры будут просто использовать \lstinline!warpDebug!. Но когда вы будете
готовы создавать реальные приложения, \lstinline'yesod devel' будет ждать вас.

\section{Выводы}

Каждое Yesod-приложение строится вокруг типа-основания.  Мы ассоциируем некоторые ресурсы
с этим типом данных и определяем несколько функций-обработчиков, а Yesod занимается всей
маршрутизацией. Эти ресурсы также являются конструкторами данных, которые позволяют нам
использовать типобезопасные URL.

В силу того, что приложения Yesod построены поверх WAI, они могут работать с различными
бэкэндами. \lstinline!warpDebug! --- это простой путь начать работу, так как он
поставляется с Yesod. Для быстрой разработки выбором является \lstinline!yesod devel!. А
когда вы будете готовы перейти к боевому использованию, у вас будет
выскопопроизводительный сервер Warp.

При разработке приложений для Yesod у вас будет выбор из множества стилей кодирования:
квазицитирование или внешние файлы, \lstinline{warpDebug} или \lstinline'yesod devel', и
так далее. Примеры в этой книге используют стили, наиболее облегчающие копирование кода,
но более мощные возможности будут доступны, когда вы начнете создавать реальные приложения
Yesod.
