\chapter{Основы}\label{chap:basics}

Первый шаг при изучении любой новой технологии~--- сделать так, чтобы она заработала. Цель
данной главы~--- познакомить вас с простым приложением Yesod и охватить некоторые основные
концепции и терминологию.

\section{Здравствуй, Мир}

Давайте начнём эту книгу, как полагается: сделаем простую веб-страницу, на которой
выводится <<\texttt{Здравствуй, Мир!}>>:
\includecode{03/hello-world.hs}

Если вы сохраните этот код в файл \lstinline!helloworld.hs! и запустите его командой
\lstinline!runhaskell helloworld.hs!, то получите веб-сервер, запущенный на порту 3000.
Если вы откроете браузером страницу \lstinline'http://localhost:3000', то получите
следующий HTML-код:

\begin{lstlisting}[language=HTML]
<!DOCTYPE html>
<html><head><title></title></head><body>Здравствуй, Мир!</body></html>
\end{lstlisting}

Далее на протяжении главы мы ещё будем возвращаться к этому примеру.

\section{Маршрутизация}

Как и большинство современных веб-фреймворков, Yesod следует шаблону
\footnotehref{http://en.wikipedia.org/wiki/Front\_Controller\_pattern}{<<единая точка входа>>}.
Это означает, что каждый запрос к приложению Yesod поступает через общую точку и
оттуда уже маршрутизируется. В отличие от этого подхода, в системах наподобие PHP и ASP вы
обычно создаёте множество различных файлов, и веб-сервер автоматически направляет запросы
к соответствующему файлу.

Кроме того, Yesod использует декларативный стиль задания маршрутов. В приведённом выше
примере это выглядело так:

\begin{lstlisting}
mkYesod "HelloWorld" [parseRoutes|
/ HomeR GET
|]
\end{lstlisting}

\begin{remark}
  \lstinline!mkYesod!~--- это функция Template Haskell, а \lstinline!parseRoutes!~---
  обработчик квазицитирования.
\end{remark}

% I'd like to call it HomeR
% Похоже, здесь игра слов: "Я хочу назвать его Гомер".
По-русски это означает: создать в приложении \texttt{HelloWorld} один путь по имени
\lstinline!HomeR!. Он должен слушать запросы к \texttt{/} (корню приложения) и отвечать на
GET-запросы. Мы называем \lstinline!HomeR! ресурсом, отсюда и суффикс <<R>> в названии.

\begin{remark}
  Суффикс <<R>> в именах ресурсов~--- это просто соглашение, но его придерживаются
  практически повсеместно. Оно позволяет немного упростить чтение и понимание кода.
\end{remark}

% Тоже не придумал, на что заменить "подчищенную версию". Как один из многословных
% вариантов: "Вот версия, избавленная от многих несущественных подробностей:".
Функция TH \lstinline!mkYesod! генерирует довольно много кода: тип данных маршрута,
функции разбора (parser) и рендеринга (render), функцию диспетчеризации (dispatch),
и некоторые вспомогательные типы. Мы рассмотрим их более подробно в
главе~\hyperref[chap:routing]{<<Маршрутизация URL и обработчики>>}. Но используя опцию GHC
\lstinline'-ddump-splices', мы можем посмотреть непосредственно на сгенерированный
код. Вот сильно подчищенная его версия:\marginpar{подчищенная звучит глупо, но более
  хорошего немногословного варианта не вижу}

\begin{lstlisting}
instance RenderRoute HelloWorld where
    data Route HelloWorld = HomeR
        deriving (Show, Eq, Read)
    renderRoute HomeR = ([], [])

instance ParseRoute HelloWorld where
    parseRoute ([], _) = Just HomeR
    parseRoute _       = Nothing

instance YesodDispatch HelloWorld where
    yesodDispatch env req =
        yesodRunner handler env mroute req
      where
        mroute = parseRoute (pathInfo req, textQueryString req)
        handler =
            case mroute of
                Nothing -> notFound
                Just HomeR ->
                    case requestMethod req of
                        "GET" -> getHomeR
                        _     -> badMethod

type Handler = HandlerT HelloWorld IO
\end{lstlisting}
%$

Здесь мы можем увидеть, что класс~\lstinline'RenderRoute' определяет
\textbf{ассоциированный тип данных}, предоставляющий пути для нашего
приложения. В этом простом примере, у нас только один путь: \lstinline{HomeR}.
В настоящем приложении, у нас их может быть намного больше, и они могут быть
гораздо сложнее, чем наш \lstinline{HomeR}.

Функция~\lstinline{renderRoute} принимает путь и преобразует его в список
компонент пути и список параметров запроса. Опять же, наш пример прост, поэтому и
код столь же прост: оба списка пусты.

Класс~\lstinline{ParseRoute} предоставляет обратную функцию~---
\lstinline{parseRoute}. Здесь мы встречаем первый серьёзный аргумент для нашего
использования Template Haskell: он обеспечивает, что разбор и рендеринг путей
корректно соответствуют друг другу. Такого вида код может легко стать трудным
для поддержания в синхронном виде при ручном написании. Полагаясь на генерацию
кода, мы позволяем компилятору (и Yesod) управлять этими деталями для нас.

Класс~\lstinline{YesodDispatch} предоставляет средства для получения входящего
запроса и передачи его соответствующей функции-обработчику. Процесс, по
существу, это:
\begin{enumerate}
    \item Разобрать запрос.
    \item Выбрать функция-обработчик.
    \item Запустить функцию-обработчик.
\end{enumerate}

Генерация кода следует простому соглашению для сопоставления путей имени
функции-обработчика, которое мы опишем в следующем разделе.

Наконец, у нас есть простой синоним типа~\lstinline{Handler}, слегка
упрощающий написание нашего кода.

Здесь ещё много что происходит помимо описанного. Сгенерированный код
диспетчеризации, на самом деле, использует гораздо более эффективную структуру
данных, создаётся большее количество экземпляров классов типов, и есть другие
случаи для обработки, например, подсайты. Мы погрузимся в детали далее на
протяжении книги, особенно в главе~\hyperref[chap:request]{<<Вглубь запроса>>}.

\section{Функция-обработчик}

% Продолжаю предполагать, что автор использует игру слов с HomeR.
Итак, у нас есть маршрут по имени \lstinline!HomeR!, и он отвечает на \texttt{GET}-запросы.  Как вы
определяете наш ответ? Вы пишете функцию-обработчик. Yesod следует стандартной схеме
именования таких функций: имя метода в нижнем регистре (т. е., \texttt{GET} становится
\lstinline!get!), после которого идёт имя маршрута. В нашем случае эта функция будет
называться~\lstinline!getHomeR!.

Большая часть вашего кода в Yesod будет находиться в функциях-обработчиках.  Именно здесь
вы обрабатываете пользовательский ввод, выполняете запросы к базе данных и создаёте
ответы. В нашем простом примере мы создаём ответ с помощью функции
\lstinline!defaultLayout!. Эта функция оборачивает переданное ей содержимое в шаблон
вашего сайта. По умолчанию она создаёт файл HTML с \texttt{doctype}, тегами \texttt{html}, \texttt{head} и \texttt{body}. Как
мы увидим в главе~\hyperref[chap:yesod-typeclass]{<<Класс типов Yesod>>}, эта функция может
быть переопределена, чтобы делать гораздо больше.

В нашем примере в \lstinline!defaultLayout! мы передаём
\lstinline'[whamlet|Hello World!|]'. \lstinline!whamlet!~--- это ещё один обработчик
квазицитирования. В данном случае он преобразует синтаксис Hamlet в
\lstinline{Widget}. Hamlet~--- это движок HTML-шаблонов, используемый в Yesod по умолчанию.
Вместе со своими <<родственниками>> Cassius, Lucius и Julius он позволяет создавать HTML,
CSS и JavaScript типобезопасным образом с проверкой во время компиляции. Гораздо больше
информации по этому поводу мы увидим в~\hyperref[chap:shakespeare]{главе о Шекспировских шаблонах}.

Виджеты~--- ещё один краеугольный камень Yesod. Они позволяют вам создавать
модульные компоненты сайта, состоящие из HTML, CSS и JavaScipt,
и повторно использовать их в любом месте вашего сайта. Более детально мы будем их
рассматривать в главе~\hyperref[chap:widgets]{<<Виджеты>>}.

\section{Тип-основание}

Слово <<HelloWord>> появляется в нашем примере несколько раз. Каждое приложение Yesod
имеет тип-основание. Этот тип должен быть экземпляром класса типов~\lstinline!Yesod!,
который предоставляет общее место для определения различных настроек, определяющих
выполнение нашего приложения.

В нашем случае этот тип данных довольно скучный: он не содержит никакой информации. Тем не
менее, тип-основнание имеет существенное влияние на то, как выполняется наш пример: он
связывает воедино маршруты с определением экземпляра и даёт им всем возможность
выполняться. На протяжении книги мы увидим, как тип-основание всплывает в разных местах.

Но типы-основания не обязательно должны быть скучными: они могут использоваться для
хранения множества полезной информации, обычно той, которая должна быть инициализирована
при запуске и использоваться повсюду. Вот некоторые наиболее распространённые примеры:

\begin{itemize}
  \item Пул соединений с базой данных;
  \item Настройки, загружаемые из конфигурационного файла;
  \item Менеджер соединений HTTP;
  \item Генератор случайных чисел.
\end{itemize}

\begin{remark}
% TODO: иврит не отображается в выходном файле
    Кстати, слово yesod (\textsf{יסוד}) означает \emph{основание} на иврите.
\end{remark}

\section{Запуск}

Ещё раз мы упоминаем \lstinline!HelloWorld! в нашей основной функции. Тип-основание
содержит всю необходимую информацию для маршрутизации и ответов на запросы в нашем
приложении; теперь нам нужно просто преобразовать его в нечто, что можно запустить. Для
этого в Yesod есть полезная функция \lstinline!warp!, которая запускает веб-сервер
Warp с настройками по умолчанию на указанном порту (в нашем случае это 3000).

Одной из особенностей Yesod является то, что вы не привязаны к единственной стратегии
развёртывания. Yesod построен поверх Web Application Interface (WAI), позволяющего
запускать приложение через FastCGI, SCGI, Warp или даже как настольное приложение,
используя библиотеку WebKit. Мы рассмотрим некоторые из этих возможностей в
\hyperref[chap:deploying]{главе о развёртывании}. И в конце данной главы мы рассмотрим сервер
разработки.

Warp является для Yesod основным способом развёртывания. Это легковесный,
высокоэффективный веб-сервер, разработанный специально для хостинга приложений Yesod. Он
используется и вне Yesod для других разработок на Haskell (как для приложений, основанных
на фреймворках, так и для не зависящих от них), а также как стандартный файл-сервер в
различных боевых окружениях.

\section{Ресурсы и типобезопасные URL}

% Взял на себя смелость предположить, что такой вариант перевода лучше передаёт оттенки
% смысла оригинала. Возможно, я неправ. Запрашиваю обсуждение.
В нашем <<здравствуй-мире>> мы определили только один ресурс
(\lstinline!HomeR!). Веб-приложение обычно намного более интересно, когда в нём больше
одной страницы. Давайте посмотрим:
\includecode{03/routes.hs}

В целом это очень похоже на <<Здравствуй, Мир>>. Тип-основание теперь \lstinline!Links!
вместо \lstinline!HelloWorld!, и помимо ресурса \lstinline!HomeR! мы добавили
\lstinline!Page1R! и \lstinline!Page2R!. В связи с этим мы также добавили ещё две
функции-обработчика: \lstinline!getPage1R! и \lstinline!getPage2R!.

Единственная действительно новая особенность находится внутри квазицитирования
\lstinline'whamlet'. Мы углубимся в изучение этого синтаксиса в
\hyperref[chap:shakespeare]{главе о Шекспировских шаблонах}, но мы можем увидеть, что
\begin{lstlisting}
<a href=@{Page1R}>Перейти на страницу 1!
\end{lstlisting}
создаёт ссылку на ресурс \lstinline!Page1R!. Здесь важно отметить, что \lstinline!Page1R!~---
это конструктор данных. Делая каждый ресурс конструктором данных, мы получаем
возможность, называемую \emph{типобезопасными URL}. Вместо соединения строк для получения URL мы
создаём старое доброе значение Haskell. Используя @-интерполяцию (\lstinline!@{...}!),
Yesod автоматически отображает эти значения в текстовые ссылки перед отправкой их
пользователю. Мы можем увидеть, как это реализовано, ещё раз посмотрев на вывод
\texttt{--dump-splices}:

\begin{lstlisting}
instance RenderRoute Links where
    data Route Links = HomeR | Page1R | Page2R
      deriving (Show, Eq, Read)

    renderRoute HomeR  = ([], [])
    renderRoute Page1R = (["page1"], [])
    renderRoute Page2R = (["page2"], [])
\end{lstlisting}

% FIXME: похоже, что returnRoute - это опечатка в книге, а на самом деле
% подразумевалось renderRoute. Пока править не буду, нужно, чтобы посмотрел
% специалист.
В ассоциированном с \lstinline!Links! типе \lstinline!Route! у нас есть дополнительные
конструкторы для \lstinline!Page1R! и \lstinline!Page2R!. У нас также есть более хорошее
представление о возвращаемых значенях \lstinline!renderRoute!.
Первый элемент кортежа содержит
компоненты пути для данного маршрута. Второй элемент содержит параметры строки запроса;
практически во всех вариантах использования это будет пустой список.

Трудно переоценить значение типобезопасных URL. Они позволяют вам достичь большой гибкости
и надёжности при разработке приложения. Вы можете произвольным образом менять URL
ресурсов, ни разу не повредив ссылки на них. В главе~\hyperref[chap:routing]{<<Маршрутизация
  URL и обработчики>>} мы увидим, что маршруты могут принимать параметры, как, например,
URL записи в блоге, принимающий идентификатор поста.

% Перевод slug как "транслитерированное название" был более корректным, но смотрелся коряво.
% Думаю, если оставить просто "название", смысл не пострадает.
Предположим, вы хотите перейти от маршрутизации по числовому идентификатору поста к
маршрутизации по шаблону <<\texttt{год/месяц/название}>>. В традиционном веб-фреймворке
вам придётся исправить каждую ссылку на пост в блоге, и если вы пропустите хотя бы одну,
то будете получать ошибки 404 во время выполнения. В Yesod всё, что вам придётся сделать,~---
это обновить маршрут и перекомпилировать приложение: GHC сам найдёт все ссылки,
которые должны быть откорректированы.

\section{Каркас сайта}

При установке Yesod вы получаете как библиотеку Yesod, так и исполняемый файл
\texttt{yesod}. Этот исполняемый файл принимает несколько команд, но первая команда, с
которой вы захотите познакомиться,~--- это \texttt{yesod init}. Она задаст вам
несколько вопросов, а затем сгенерирует каталог, содержащий каркас сайта по умолчанию. В
этом каталоге вы можете выполнить \texttt{cabal install --only-dependencies}, чтобы
установить дополнительные зависимости (такие как бэкэнды баз данных), и затем
\texttt{yesod devel}, чтобы запустить сайт.

Каркас сайта даёт вам <<из коробки>> множество установившихся практик, располагая файлы и
настраивая зависимости проверенным временем образом, применяемым в большинстве боевых
сайтов на Yesod. Однако все эти удобства могут встать на пути изучения Yesod. Поэтому на
протяжении большей части этой книги инструмент построения каркаса сайта не используется, и
работа идёт напрямую с Yesod как с библиотекой. Но если вы собираетесь делать
настоящий сайт, я настойчиво рекомендую использовать каркас.

Мы рассмотрим структуру каркаса сайта во всех подробностях в
соответствующей~\hyperref[chap:scaffolding]{главе}.

\section{Сервер разработки}

% Сделал избыточный перевод: "hit refresh" -> "обновляете страницу в браузере". Мне
% это кажется разумным, но я готов это обсуждать.
% TODO: я не понял, что именно значит фраза "we'll need to call runhaskell from scratch",
% поэтому перевод требует проверки.
Одним из преимуществ интерпретируемых языков перед компилируемыми является быстрое
прототипирование: вы просто сохраняете изменения в файл и обновляете страницу в
браузере. Если мы хотим внести изменения в приведённые выше приложения Yesod, нам придётся
заново вызывать~\texttt{runhaskell}, что может быть немного утомительным.

К счастью, существует решение этой проблемы: \texttt{yesod devel} автоматически
пересобирает код и перезагружает ваш код. Это может быть отличным способом разработки
ваших Yesod-проектов, и когда вы будете готовы перейти на боевой сервер, вы всё равно
получите в результате компиляции невероятно эффективный код. Построение каркаса Yesod
настраивает всё для вас автоматически. Это позволяет использовать лучшее из двух миров:
быстрое прототипирование \textbf{и} быстрый боевой код.

Подготовка вашего кода для использования с \texttt{yesod devel} немного более сложна,
поэтому наши примеры будут просто использовать \lstinline!warp!. К счастью,
каркас сайта полностью сконфигурирован для использования сервера разработки,
поэтому, когда вы будете готовы создавать реальные приложения, он будет ждать вас.

\section{Выводы}

Каждое Yesod-приложение строится вокруг типа-основания.  Мы ассоциируем некоторые ресурсы
с этим типом данных и определяем несколько функций-обработчиков, а Yesod занимается всей
маршрутизацией. Эти ресурсы также являются конструкторами данных, которые позволяют нам
использовать типобезопасные URL.

В силу того, что приложения Yesod построены поверх WAI, они могут работать с различными
бэкэндами. Для простых приложений, функция \lstinline{warp} предоставляет
удобный способ использования веб-сервера~Warp. Для быстрой разработки,
\texttt{yesod devel} является хорошим выбором. А когда вы готовы перейти на
продуктивную среду, у вас в руках вся мощь и гибкость настройки Warp (или
любого другого обработчика WAI) под ваши нужды.

При разработке приложений для Yesod у вас будет выбор из множества стилей кодирования:
квазицитирование или внешние файлы, \lstinline{warp} или \texttt{yesod devel}, и
так далее. Примеры в этой книге используют стили, наиболее облегчающие копирование кода. Но когда вы начнёте создавать реальные приложения с помощью
Yesod, вам будут доступны более мощные средства.
