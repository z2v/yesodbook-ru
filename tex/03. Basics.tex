\section{Основы}

Первым шагом при изучении новой технологии является её запуск. Цель данной главы 
познакомить вас с простым Yesod приложением, показать основные подходы, и ввести
терминогию.

\subsection{Здравствуй, Мир}

Давайте начнём книгу как это принято: сделаем простую web страницу, которая выводит
\texttt{Здравствуй, Мир}

\begin{lstlisting}
{-# LANGUAGE TypeFamilies, QuasiQuotes, MultiParamTypeClasses,
             TemplateHaskell, OverloadedStrings #-}
import Yesod

data HelloWorld = HelloWorld

mkYesod "HelloWorld" [parseRoutes|
/ HomeR GET
|]

instance Yesod HelloWorld

getHomeR :: Handler RepHtml
getHomeR = defaultLayout [whamlet|Здравствуй, Мир!|]

main :: IO ()
main = warpDebug 3000 HelloWorld
\end{lstlisting}

Если вы сохраните этот код в файл \lstinline'helloworld.hs' и запустите его командой
\lstinline'runhaskell helloworld.hs', то будет на 3000 порту будет запится веб сервер. 
Если вы откроете браузером страницу \lstinline'http://localhost:3000',
то вы получите следующий HTML код:

\begin{lstlisting}[language=HTML]
<!DOCTYPE html>
<html><head><title></title></head><body>Здравствуй, Мир!</body></html>
\end{lstlisting}

Далее в главе мы ещё вернёмся к этому примеру.

\subsection{Маршрутизация}

Как и большинство современных веб фреймворов, Yesod использует шаблон eдиной точки входа. 
Это обозначает, что каждый запрос к приложению yesod будет обрабатываться в общей точке и 
перенаправляться оттуда. Другой подход используется в таких системах как PHP или ASP, 
где обычно создаются отдельные файлы и WEB сервер автоматически перенаправляет запрос 
к соотвествующему файлу.

В дополнение, Yesod использует декларативный стиль для задания маршрутов. 
В вышеприведенном примере он выглядит следующим образом:

\begin{lstlisting}
mkYesod "HelloWorld" [parseRoutes|
/ HomeR GET
|]
\end{lstlisting}

\lstinline'mkYesod' Template Haskell функция, а parseRoutes это 
обработчик квазицитирования. По русски это обознает: создать один 
путь в приложении HelloWorld . Я бы хотел назвать его HomeR, и он 
должен слушать запросы к / (корень приложения), 
и отвечать на GET-запросы. Назовём HomeR ресурсом, отсюда суффикс 
``R'' в названии.

Суффикс R в названиях ресурсов это просто соглашение, но это общее соглашение. 
Оно позволяет чуть упростить чтение и понимание кода.

TH функиця \lstinline'mkYesod' генерирует немного кода: тип данных маршрута, 
функцию диспечеризации и функцию отображения. Мы рассмотрим их более внимательно в главе 
\ref{chapter:routing}. Маршрутизация URL и обработчики.
Но использовав опцию GHC \lstinline'-ddump-splices', мы можем сразу же увидеть 
сгенерированный код. Сильно подчищенная версия:

\begin{lstlisting}
instance RenderRoute HelloWorld where
  data Route HelloWorld = HomeR
    deriving (Show, Eq, Read)
  renderRoute HomeR = ([], [])

instance YesodDispatch HelloWorld HelloWorld where
    yesodDispatch master sub toMaster app404 app405 method pieces =
        case dispatch pieces of
            Just f -> f
                master
                sub
                toMaster
                app404
                app405
                method
            Nothing -> app404
      where
        dispatch = Yesod.Routes.Dispatch.toDispatch
            [ Yesod.Routes.Dispatch.Route [] False onHome
            ]
        onHome [] = Just $ \master sub toMaster _app404 app405 method ->
            case method of
                "GET" -> yesodRunner
                    (fmap chooseRep getHomeR)
                    master
                    sub
                    (Just HomeR)
                    toMaster
                _ -> app405 HomeR

getHomeR = return ()

main :: IO ()
main = return ()
\end{lstlisting}

Некоторые вещи пока ещё не понятны. В целом, реализация \lstinline'yesodDispatch'
достаточно сложна и удовлетворяет различным вариантам диспетчеризации и подходит под
требования используемых нами высокопроизводительных маршрутизационных структур.
Тем не менее реализация RenderRoute со всеми связанными структурами данных должы 
давать представление о том, что происходит под поверхностью\marginpar{under the surface = внутри}. %FIXME (внутри) 

\subsection{Функции обработчики}

Итак у нас есть маршрут названный \texttt{HomeR}, и он отвечает на \texttt{GET} запросы. 
Как вы установить ответ? Вы должны написать функцию обработчикю. В Yesod следует
стандартизованной схеме именования таких функций: 
метод написанный строчными буквами (т.е. GET становится get), после которого идёт 
название марштута.В нашем случае эта функция будет называться \lstinline'getHomeR'.

Большая часть вашего кода в Yesod будет находиться в функциях обработчиках. 
Именно здесь обрабатывается пользовательский ввод, совершаются запросы к базе данных и создаются ответы. 
В нашем простом примере, мы создали ответ с помощью функции \lstinline'defaultLayout'. 
Эта функция оборачивает передеанное ей содержимое шаблоном нашего сайта. 
По умолчанию, она создаёт HTML файл с установленным doctype, html тегами head и body. 
Как мы увидим в главе~\ref{ch:typeclass} Yesod typeclass, эта функция может быть перегружена,
для увеличения функционала.

В нашем примере в \lstinline'defaultLayout' мы передали \lstinline'[whamlet|Hello World!|]', 
\lstinline'whamlet' это тоже функция квазицитирования. В данном случае, оно конвертирует 
\texttt{Hamlet} синтакс в виджет. \textt{Hamlet} это движок \textt{HTML} шаблонов используемый
в Yesod по умолчанию. Вместе с ``родственниками'' \texttt{Cassius}, \texttt{Lucius} и \texttt{Julius}, 
вы можете создавать HTML, CSS и Javascript типобезопасным спобом, т.е. 
их корректность будет полностью проверяющимся во времени компиляции. Мы рассмотрим это подробнее в 
главе~\ref{ch:shakespeare} Shakespeare.

Виджеты -- другой краеугольный камень Yesod. Они позволяют создавать модульные компоненты сайта 
состоящие из HTML, CSS и Javascipt и переиспользовать их в других сайтах. Мы погрузимся в детали
в главе~\ref{ch:widgets} виджеты.

\subsection{Основание}

Слово появляется в нашем примере ``HelloWord'' несколько раз. Каждое приложение 
Yesod имеет основой тип. Этот тип должен быть экземляром класса типов Yesod, 
который предоставляет общее место для определения различных настроек определяющих 
выполнение приложения.

В нашем случае этот тип данных достаточно скучный: он не содержит никакой информации. 
Тем не менее, основной тип данных является определяющим в выполнении примера: 
он связывает маршруты с экземплярами декларацией и позволяет всему выполняться. 
В течении книги мы посмотрим как основной тип данных всплывает во многих местах.

Но основные тип не обязательно скучные: они могут быть использованы для 
хранения различной полезной
информации, обнычно это хрень, которая должна быть инициализирована перед запуском и 
использована всюду. Вот несколько наиболее частых примеров:

\begin{itemize}
  \item пул соединений с базой данных
  \item настройки загружаются из конфигурационного файла
  \item менеджер соединений HTTP
\end{itemize}

К слову, слово Yesod (יסוד) обозначает основной на иврите.

\subsction{Запуск}

Ещё раз отметим, что HelloWorld это наша основная функция. Наша основа содержит всю
необходимую информацию для маршрутизации и ответов на запросы к нашему приложению;
сейчас необходимо преобразовать это в нечто, что можно запустить. Для этого полезна
функция Yesod \lstinline'warpDebug', которая запускает Warp вебсервер, с включенным отладочным
выводом,на указанном порту (в нашем случае это 3000).

Одна из полезных возможностей Yesod заключается к том, что вы не привязаны к единственной
стратегии (deployment). Yesod сделан повер Web Application Interface (WAI), позволяющем
запускаться через FastCGI, SCGI, Warp или даже как desktop applicatio используя библиотеку
Webkit. Мы рассмотрим некоторые из этих возможностей далее в главе ``Развертывание''.

%FIXME
Warp является основным из вариантов разворачивания Yesod. Это легковесный, высокоэффективный
веб сервер разработанный специально для хостинга Yesod. Он так же используется и вне Yesod
для других разработок на Haskell (как фреймоврков так и не фреймворк приложений), так же 
как стандартный файлсервер для различных production окружений\marginpar{как-то криво всё}.

\subsection{Ресурсы и тип-независимые URL}

В нашем приложении здравствуй мир, мы определеили только один ресурс (HomeR).
Веб приложение обычно более exciting и использует более чем одну страницу. Давайте рассмотрим:

\begin{lstlisting}
{-# LANGUAGE TypeFamilies, QuasiQuotes, MultiParamTypeClasses,
             TemplateHaskell, OverloadedStrings #-}
import Yesod

data Links = Links

mkYesod "Links" [parseRoutes|
/ HomeR GET
/page1 Page1R GET
/page2 Page2R GET
|]

instance Yesod Links

getHomeR  = defaultLayout [whamlet|<a href=@{Page1R}>Go to page 1!|]
getPage1R = defaultLayout [whamlet|<a href=@{Page2R}>Go to page 2!|]
getPage2R = defaultLayout [whamlet|<a href=@{HomeR}>Go home!|]

main = warpDebug 3000 Links
\end{lstlisting}

В целом приме очень близок к \lstinline'Hello World'. Наш основной тип теперь 
\lstinline'Links' вместо \lstinline'HelloWorld', и в дополнение к ресурсу \lstinline'HomeR', мы 
добавили \lstinline'Page1R' и \lstinline'Page2R'. И так же мы добавили ещё 
два обработчика \lstinline'getPage1R' и \lstinline'getPage2R'.

Единственное действительно новая возможность -- это использование функции 
квазицитирование \lstinline'whamlet'. Мы углубимся в синтакс в главе~\ref{ch:shakespeare} Shakespeare, 
но сейчас мы можем понять, что

\begin{lstlisting}
<a href=@{Page1R}>Go to page 1!
\end{lstlisting}

создаёт ссылку на ресурс \lstinline'Page1R'. Важно заметить, что \lstinline'Page1R' это конструктор 
данных. Создавая конструктор для каждого ресурса, мы получаем возможность, назваемую типобезопасные ссылки.
Вместо того, чтобы соединять строки строки, чтобы получить ссылку, мы создаём старую добрую 
переменную Haskell.\marginpar{plain old haskell value}
Используя at-sign интерполяцию (@{\ldots}), Yesod автоматически отображает
эти значения в текстовые ссылки перед передачей их пользователю. Мы можем увидеть, как это
реализовано, снова просмотрев вывод \lstinline'--dump-splices':

\begin{lstlisting}
instance RenderRoute Links where
    data Route Links = HomeR | Page1R | Page2R
      deriving (Show, Eq, Read)

    renderRoute HomeR  = ([], [])
    renderRoute Page1R = (["page1"], [])
    renderRoute Page2R = (["page2"], [])

main :: IO ()
main = return ()
\end{lstlisting}

В \lstinline'Route' ассоциированном типа для \lstinline'Links', у нас есть 
дополнительные конструкторы для \lstinline'Page1R' и \lstinline'Page2R'.
У нас так же есть более хороший картина возвращаемых значений \lstinline'returnRoute'. П
ервая часть кортежа выдает части пути для данного маршрута. Второе значение определяет
параметры строки запроса, практически для всех вариантов использования это будет пустой список.

Очень тяжело переоценить типобизопасные ссылки. Они позволяют достичь огромной гибкости и надёжности 
при создании приложения. Мы можете изменять URL ресурсов без ломания ссылок. 
В главе~\ref{ch:routing}Маршрутизация, мы увидим, что маршруты могут принимать параметры, 
например URL записи в блоге принимает ID поста.

Предположим, что вы хотите изменить пути от численного ID к год/месяц/транслитеризованное название. В обычном 
веб фреймворке, вам придётся обновить все ссылки на блог посты, и если вы потеряете хотя бы один, то 
получите ошибку 404 во время исполнения. В Yesod, всё что вам придётся следать это обновить 
путь и собрать приложение, GHC укажет на все ссылки которые должны быть откорретированы.

\subsection{Каркас сайта}

При установке Yesod вы получаете как библиотеку Yesod, так и исполняемый файл. Этот исполняемый файл
может принимать небольшое количество команд, но первая команда с какой вы захотите познакомиться это
yesod init. Она задаст несколько вопросов и создаст каталог содержащий каркас сайта. В этом каталоге
вы можете запустить \lstinline'cabal install--only-dependencies' для того, чтобы установить дополнительные
зависимости (такие как бекенды баз данных), и затем \lstinline'yesod devel' для того чтобы запустить сайт.

Каркас сайта даст вам большое количество хороших практик прямо из коробки, установит файлы и
зависимости в подходе проверенном временем используемым в большинстве ,,боевых`` сайтов на Yesod.
Хотя на это convience может быть использована, чтобы действительно научиться Yesod. 
Несмотря на это, в этой книге не используются каркас сайта, и идет работа напрямую с 
библиотекой Yesod.

Мы рассмотрим струкруру каркаса во всех подробностях в далее.

\subsection{Разрабочтеский сервер}

Одной из полезных возможностей интерпретируемых языков над компилируемыми является быстрое прототипирование: 
вы сохраняете изменения в файл и нажимаете обновить. Если мы хотим внести изменения в Yesod
приложение выше, мы должно вызвать runhaskell сначала, что может быть немного утомительно.

К счастью слуществует решение: \lstinline'yesod devel' автоматически пересобирает и перезагружает
код. Так что хорошим вариантом разработки Yesod проектов, и когда вы перейдёте на боевой сервер,
вы так же получите собраный проект для неверноятно эффективного кода. Каркас Yesod автоматически
настраивает всё для вас. Это позволяет использовать лучшее из двух миров: быстрое прототипирование 
и быстрый боевой код.

Необходимо немного побольше разобраться для того, чтобы настроить код, чтобы он был использован
\lstinline'yesod devel', подэтому наши примеры будут использовать просто warpDebug. Но когда вы будете готовы
создать ваше первое реальное приложение, \lstinline'yesod devel' будет ждать вас.\marginpar{кривой перевод}

\subsection{Выводы}

Каждое Есод приложение строится вокруг основного типа данных. Мы ассоциируем некоторые ресурсы
с типами данных и определяем функции обработчики для каждого из маршрутов. Эти ресурсы так же
являются конструкторами, которые позволяют нам использовать типо-безопасные URL.

Запускаемые поверх WAI, приложения yesod могет быть запущены на различных бекендах, warpDebug
это простой путь к началу, т.к. поставляется вместе с Yesod. Для быстрой разработки, хорошим
выбором является yesod devel. Акогда вы будете готовы для production, то у вас будет выскопопроизводительным
вариантом будет Warp.

При разработке Yesod у вас будет много выборов стиля написания: квазицитирование или внешние файлы,
\lstinline'warpDebug' или \lstinline'yesod devel' и так далее. Примеры в этой книги построены 
таким образом, чтобы их было просто копировать и вставлять, но гораздо более мощные варианты 
будут доступны, когда вы начнете создавать реальные Yesod приложения.
