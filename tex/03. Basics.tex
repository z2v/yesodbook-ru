\chapter{Основы}\label{ch:basics}

Первым шагом при изучении новой технологии является её запуск. Цель данной главы 
познакомить вас с простым Yesod приложением, показать основные подходы, и ввести
терминогию.

\section{Здравствуй, Мир}

Давайте начнём книгу как это принято: сделаем простую web страницу, которая выводит
\texttt{Здравствуй, Мир}

\begin{lstlisting}
{-# LANGUAGE TypeFamilies, QuasiQuotes, MultiParamTypeClasses,
             TemplateHaskell, OverloadedStrings #-}
import Yesod

data HelloWorld = HelloWorld

mkYesod "HelloWorld" [parseRoutes|
/ HomeR GET
|]

instance Yesod HelloWorld

getHomeR :: Handler RepHtml
getHomeR = defaultLayout [whamlet|Здравствуй, Мир!|]

main :: IO ()
main = warpDebug 3000 HelloWorld
\end{lstlisting}

Если вы сохраните этот код в файл \lstinline!helloworld.hs! и запустите его командой
\lstinline!runhaskell helloworld.hs!, то будет на 3000 порту будет запущен веб сервер. 
Если вы откроете браузером страницу \lstinline'http://localhost:3000',
то вы получите следующий \texttt{HTML} код:

\begin{lstlisting}[language=HTML]
<!DOCTYPE html>
<html><head><title></title></head><body>Здравствуй, Мир!</body></html>
\end{lstlisting}

Далее в этой главе мы ещё вернёмся к этому примеру.

\section{Маршрутизация}

Как и большинство современных веб фреймворов, \texttt{Yesod} подстроен по шаблону eдиная
точка входа. Это обозначает, что каждый запрос к \texttt{Yesod} приложению будет 
обрабатываться в общей точке и маршрутизироваться оттуда. Противоположный
подход используется в таких системах как \texttt{PHP} или \texttt{ASP}, 
где обычно создаются отдельные файлы и WEB сервер автоматически перенаправляет 
запрос к соотвествующему файлу.\marginpar{in a contrast}.

В дополнение, Yesod использует декларативный стиль для задания маршрутов. 
В вышеприведенном примере он выглядит следующим образом:

\begin{lstlisting}
mkYesod "HelloWorld" [parseRoutes|
/ HomeR GET
|]
\end{lstlisting}

\lstinline!mkYesod! -- Template Haskell функция, а \lstinline!parseRoutes! -- 
обработчик квазицитирования. По русски это обознает: создать один 
путь в приложении \texttt{HelloWorld}. Назвать его \lstinline!HomeR!, и он 
должен слушать запросы к / (корень приложения), и отвечать на GET-запросы.
\marginpar{криво переведено I'd like to call it, т.к. если переводить дословно,
то предложения получаются не связанными}
Будем называть \lstinline!HomeR! ресурсом, отсюда суффикс ,,R`` в названии.

Суффикс ,,R`` в названиях ресурсов это просто соглашение, 
но это достаточно общее соглашение. Оно позволяет чуть упростить чтение и 
понимание кода.

\texttt{TH} функиця \lstinline!mkYesod! генерирует немного кода: 
тип данных маршрута, функцию диспечеризации и функцию рендерига\marginpar{функцию отображения, ответа или ещё как-то}. 
Мы рассмотрим их более внимательно в главе~\ref{chapter:routing}. 
Маршрутизация URL и обработчики.
Но использовав опцию GHC \lstinline'-ddump-splices', мы можем увидеть 
сгенерированный код прямо сейчас. Сильно подчищенная версия:\marginpar{подчищенная звучит глупо, но более хорошего немногословного варианта не вижу} 

\begin{lstlisting}
instance RenderRoute HelloWorld where
  data Route HelloWorld = HomeR
    deriving (Show, Eq, Read)
  renderRoute HomeR = ([], [])

instance YesodDispatch HelloWorld HelloWorld where
    yesodDispatch master sub toMaster app404 app405 method pieces =
        case dispatch pieces of
            Just f -> f
                master
                sub
                toMaster
                app404
                app405
                method
            Nothing -> app404
      where
        dispatch = Yesod.Routes.Dispatch.toDispatch
            [ Yesod.Routes.Dispatch.Route [] False onHome
            ]
        onHome [] = Just $ \master sub toMaster _app404 app405 method ->
            case method of
                "GET" -> yesodRunner
                    (fmap chooseRep getHomeR)
                    master
                    sub
                    (Just HomeR)
                    toMaster
                _ -> app405 HomeR

getHomeR = return ()

main :: IO ()
main = return ()
\end{lstlisting}

Некоторые вещи пока ещё не понятны. В частности, реализация \lstinline!yesodDispatch!
достаточно сложна и удовлетворяет различным вариантам диспетчеризации\marginpar{bit hairy and..}
и подходит под требования используемых нами высокопроизводительных 
маршрутизационных структур.
Тем не менее реализация \lstinline!RenderRoute! со всеми связанными 
структурами данных должы давать хорошее представление о том, что происходит 
под поверхностью\marginpar{under the surface = внутри}. %FIXME (внутри) 

\section{Функции обработчики}

Итак у нас есть маршрут названный \lstinline!HomeR!, и он отвечает на \texttt{GET} запросы. 
Как вы установить ответ? Вы должны написать функцию обработчик. \texttt{Yesod} следует
стандартизованной схеме именования таких функций: 
метод написанный строчными буквами (т.е. \texttt{GET} становится \lstinline!get!), после которого идёт 
название марштута. В нашем случае эта функция будет называться \lstinline!getHomeR!.

Большая часть вашего кода в \texttt{Yesod} будет находиться в функциях обработчиках. 
Именно здесь обрабатывается пользовательский ввод, совершаются запросы к базе данных и создаются ответы. 
В нашем простом примере, мы создали ответ с помощью функции \lstinline!defaultLayout!. 
Эта функция оборачивает шаблоном переданное ей содержимое.  По умолчанию, 
она создаёт \texttt{HTML} файл с установленным doctype, html тегами head и body. 
Как мы увидим в главе~\ref{ch:typeclass} Класс типов \texttt{Yesod}, 
эта функция может быть перегружена, для увеличения функционала.

В нашем примере в \lstinline!defaultLayout! мы передали 
\lstinline![whamlet|Hello World!|]!, \lstinline!whamlet! -- это тоже 
функция квазицитирования. В данном случае, она конвертирует 
\texttt{Hamlet} синтакс в виджет. \textt{Hamlet} -- это движок 
\textt{HTML} шаблонов используемый в \textt{Yesod} по умолчанию. 
Вместе с ,,родственниками`` \texttt{Cassius}, \texttt{Lucius} 
и \texttt{Julius}, он позволяет создавать \texttt{HTML}, \texttt{CSS}
и \texttt{Javascript} типобезопасным способом, т.е. их корректность будет 
полностью проверяться во время компиляции. Мы рассмотрим это подробнее в 
главе~\ref{ch:shakespeare} Shakespeare.

Виджеты -- другой краеугольный камень \texttt{Yesod}. Они позволяют создавать 
модульные компоненты сайта состоящие из \texttt{HTML}, \texttt{CSS} и 
\texttt{Javascipt} и переиспользовать их в других сайтах. 
Мы погрузимся в детали в главе~\ref{ch:widgets} Виджеты.

\section{Тип-Основание}

Слово ,,HelloWord`` появляется в нашем примере несколько раз. Каждое приложение 
\texttt{Yesod} имеет тип-основание. Этот тип должен быть экземляром класса 
типов \texttt{Yesod}, и он предоставляет общее место для определения 
различных настроек определяющих выполнение приложения.

В нашем случае этот тип данных достаточно скучен\marginpar{boring}: он не содержит никакой 
информации. Тем не менее, тип-основнание определяет в выполнение примера: 
он связывает маршруты с декларацией и позволяет выполняться. 
В течении книги мы посмотрим как тип-основание всплывает в разных местах.

Но тип-основание тип не обязательно скучен: он можеь быть использован для 
хранения различной полезной информации, обычно это вещи\marginpar{stuff?},
которые должны быть инициализированы перед запуском и 
использована всюду. Вот некоторые наиболее частые примеры:

\begin{itemize}
  \item пул соединений с базой данных,
  \item настройки загружаются из конфигурационного файла,
  \item менеджер соединений \texttt{HTTP}.
\end{itemize}

К слову, слово \texttt{Yesod} (יסוד) обозначает основной на иврите.

\subsection{Запуск}

Ещё раз обратимся к типу \lstinline!HelloWorld! в основной функции.
Тип-основание содержит всю необходимую информацию для маршрутизации и 
ответов на запросы к нашему приложению;
сейчас необходимо преобразовать это в нечто, что можно запустить. 
Для этого полезна функция Yesod \lstinline!warpDebug!, которая 
запускает вебсервер \texttt{Warp}, с включенным отладочным
выводом, на указанном порту (в нашем случае это $3000$).

Одна из полезных возможностей \texttt{Yesod} заключается к том, 
что вы не привязаны к единственной стратегии развертывания приложения. 
\texttt{Yesod} сделан повер \texttt{Web Application Interface (WAI)}, 
позволяющем запускать приложение через \texttt{FastCGI}, 
\texttt{SCGI}, \texttt{Warp} или даже как 
desktop application\marginpar{desktop application} используя библиотеку
\texttt{Webkit}. Мы рассмотрим некоторые из этих возможностей 
далее в главе ,,Развертывание``.

%FIXME
Warp является основным из вариантов разворачивания \texttt{Yesod}. 
Это легковесный, высокоэффективный веб сервер разработанный 
специально для хостинга \texttt{Yesod} проектов. Он так же используется 
и вне \texttt{Yesod} для других разработок на Haskell (как фреймоврков 
так и не фреймворк приложений), так же как стандартный файлсервер 
для различных боевых окружений\marginpar{как-то криво всё}.

\section{Ресурсы и типобезопасные URL}

В нашем приложении здравствуй мир, мы определеили только один ресурс 
(\lstinline!HomeR!). Веб приложение обычно более привлекательны\marginpar{exiting} и  использует более чем одну страницу. Давайте рассмотрим:

\begin{lstlisting}
{-# LANGUAGE TypeFamilies, QuasiQuotes, MultiParamTypeClasses,
             TemplateHaskell, OverloadedStrings #-}
import Yesod

data Links = Links

mkYesod "Links" [parseRoutes|
/ HomeR GET
/page1 Page1R GET
/page2 Page2R GET
|]

instance Yesod Links

getHomeR  = defaultLayout [whamlet|<a href=@{Page1R}>Go to page 1!|]
getPage1R = defaultLayout [whamlet|<a href=@{Page2R}>Go to page 2!|]
getPage2R = defaultLayout [whamlet|<a href=@{HomeR}>Go home!|]

main = warpDebug 3000 Links
\end{lstlisting}

В целом пример очень близок к ,,Здравствуй, Мир``. Наш тип-основание
теперь \lstinline!Links! вместо \lstinline!HelloWorld!, и в дополнение 
к ресурсу \lstinline!HomeR!, мы добавили \lstinline!Page1R! и 
\lstinline!Page2R!. И так же мы добавили ещё 
два обработчика \lstinline!getPage1R! и \lstinline!getPage2R!.

Единственное действительно новая возможность -- это использование обработчика  
квазицитирования \lstinline'whamlet'. Мы углубимся в синтакс в главе~\ref{ch:shakespeare} Shakespeare, но сейчас мы можем понять, что

\begin{lstlisting}
<a href=@{Page1R}>Go to page 1!
\end{lstlisting}

создаёт ссылку на ресурс \lstinline!Page1R!. Важно заметить, что 
\lstinline!Page1R! это конструктор типа данных. Создавая конструктор 
для каждого ресурса, мы получаем возможность, называемую типобезопасные 
ссылки. Вместо того, чтобы соединять строки строки, чтобы получить ссылку,
 мы создаём старую добрую переменную Haskell.\marginpar{plain old haskell value}
При применении at-sign интерполяцию (@{\ldots}), \texttt{Yesod}
автоматически отображает эти значения в текстовые ссылки перед 
передачей их пользователю. Мы можем увидеть, как это реализовано, 
в очередной раз просмотрев вывод \lstinline!--dump-splices!:

\begin{lstlisting}
instance RenderRoute Links where
    data Route Links = HomeR | Page1R | Page2R
      deriving (Show, Eq, Read)

    renderRoute HomeR  = ([], [])
    renderRoute Page1R = (["page1"], [])
    renderRoute Page2R = (["page2"], [])

main :: IO ()
main = return ()
\end{lstlisting}

В \lstinline!Route! ассоциированном типе для \lstinline!Links!, у нас 
есть дополнительные конструкторы для \lstinline!Page1R! и 
\lstinline!Page2R!. У нас так же есть более хорошая картина 
возвращаемых значений \lstinline!returnRoute!. Первая часть кортежа 
содержит части пути для данного маршрута. Второе значение определяет
параметры строки запроса, практически для всех вариантов использования это будет пустой список.

Очень тяжело переоценить значение типобизопасныч ссылок. Они позволяют 
достичь огромной гибкости и надёжности при создании приложения. Мы можете 
изменять \texttt{URL} ресурсов без повреждения ссылок. 
В главе~\ref{ch:routing}Маршрутизация, мы увидим, что маршруты могут 
принимать параметры, например \texttt{URL} записи в блоге принимает 
\texttt{ID} поста.

Предположим, что вы хотите изменить пути от численного \texttt{ID} к 
\texttt{год/месяц/транслитеризованное} название. В обычном 
веб фреймворке, вам придётся обновить все ссылки на блог посты, и если вы потеряете хотя бы один, то 
получите ошибку 404 во время исполнения. В \texttt{Yesod}, всё что вам придётся следать это обновить 
путь и собрать приложение, \texttt{GHC} укажет на все ссылки которые должны быть откорретированы.

\section{Каркас сайта}

При установке \texttt{Yesod} вы получаете как библиотеку \texttt{Yesod}, 
так и исполняемый файл. Этот исполняемый файл может принимать небольшое 
количество команд, но первая команда с какой вы захотите познакомиться 
это \texttt{yesod init}. Она задаст несколько вопросов и создаст каталог 
содержащий каркас сайта. В этом каталоге
вы можете запустить \lstinline'cabal install--only-dependencies' для того, чтобы установить дополнительные
зависимости (такие как бекенды баз данных), и затем \lstinline'yesod devel' для того чтобы запустить сайт.

Каркас сайта покажет вам большое количество хороших практик прямо 
из коробки, установит файлы и зависимости в подходе проверенном временем используемым в большинстве ,,боевых`` сайтов на \texttt{Yesod}.\marginpar{кривой перевод}
Хотя на это удобство может быть поняты при обучении  \texttt{Yesod}.
Поэтому, в этой книге не используются каркас сайта, 
и идет работа напрямую с библиотекой \texttt{Yesod}.

Мы рассмотрим структуру каркаса во всех подробностях в далее.

\section{Разработческий сервер}

Одной из полезных возможностей интерпретируемых языков над компилируемыми является быстрое прототипирование: 
вы просто сохраняете изменения в файл и нажимаете обновить. 
Если мы хотим внести изменения в \texttt{Yesod} приложение выше, 
мы должны сначала вызвать \lstinline!runhaskell!, что может быть немного 
утомительно.

К счастью существует решение: \lstinline'yesod devel' автоматически 
пересобирает код и перезагружает приложение Так это хоченнь хороший вариант
разработки Yesod проектов, и когда вы перейдёте на боевой сервер,
вы получите собраный проект с неверноятно эффективным кодом. Каркас Yesod автоматически
настраивает всё для вас. Это позволяет использовать лучшее из двух миров: 
быстрое прототипирование и быстрый боевой код.

Необходимо немного побольше разобраться для того, чтобы настроить код, 
для использования \lstinline!yesod devel!, подэтому наши примеры будут 
использовать просто \lstinline!warpDebug!. Но когда вы будете готовы
создать ваше первое реальное приложение, \lstinline'yesod devel' будет ждать вас.\marginpar{кривой перевод}

\section{Выводы}

Каждое \texttt{Yesod} приложение строится вокруг тип-основания. 
Мы ассоциируем некоторые ресурсы с типами данных и определяем функции обработчики 
для каждого из маршрутов. Эти ресурсы так же являются конструкторами данных, 
которые позволяют нам использовать типобезопасные URL.

Запускаемые поверх \texttt{WAI}, приложения yesod могут быть запущены на различных 
бекендах, \lstinline!warpDebug! это простой путь запуска проекта, т.к.
поставляется вместе с Yesod. Для быстрой разработки, хорошим выбором является yesod devel. 
А когда вы будете готовы для боевых серверов, то у вас будет выскопопроизводительный
сервер \texttt{Warp}.

При разработке \texttt{Yesod} у вас будет много выборов стиля написания: 
квазицитирование или внешние файлы,
\lstinline{warpDebug} или \lstinline'yesod devel' и так далее. Примеры в этой книги построены 
таким образом, чтобы их было просто копировать и вставлять, но гораздо более мощные варианты 
будут доступны, когда вы начнете создавать реальные Yesod приложения.
