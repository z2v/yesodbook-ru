\chapter{Основы}\label{ch:basics}

Первый шаг при изучении любой новой технологии~--- заставить ее работать. Цель данной
главы~--- познакомить вас с простым приложением Yesod и охватить некоторые основные
концепции и терминологию.

\section{Здравствуй, Мир}

Давайте начнём эту книгу должным образом: сделаем простую web-страницу, которая выводит
<<\texttt{Здравствуй, Мир!}>>:

\begin{lstlisting}
{-# LANGUAGE TypeFamilies, QuasiQuotes, MultiParamTypeClasses,
             TemplateHaskell, OverloadedStrings #-}
import Yesod

data HelloWorld = HelloWorld

mkYesod "HelloWorld" [parseRoutes|
/ HomeR GET
|]

instance Yesod HelloWorld

getHomeR :: Handler RepHtml
getHomeR = defaultLayout [whamlet|Здравствуй, Мир!|]

main :: IO ()
main = warpDebug 3000 HelloWorld
\end{lstlisting}

Если вы сохраните этот код в файл \lstinline!helloworld.hs! и запустите его командой
\lstinline!runhaskell helloworld.hs!, то получите веб-сервер, запущенный на порту 3000.
Если вы откроете браузером страницу \lstinline'http://localhost:3000', то получите
следующий \texttt{HTML} код:

\begin{lstlisting}[language=HTML]
<!DOCTYPE html>
<html><head><title></title></head><body>Здравствуй, Мир!</body></html>
\end{lstlisting}

Далее на протяжении главы мы ещё будем возвращаться к этому примеру.

\section{Маршрутизация}

Как и большинство современных веб-фреймворков, \texttt{Yesod} следует шаблону <<eдиная
точка входа>>. Это означает, что каждый запрос к приложению \texttt{Yesod} поступает через
общую точку и оттуда уже маршрутизируется. В отличие от этого подхода, в таких системах,
как \texttt{PHP} и \texttt{ASP}, вы обычно создаете множество различных файлов, и
веб-сервер автоматически направляет запросы к соответствующему файлу.

Кроме того, Yesod использует декларативный стиль задания маршрутов. В приведенном выше
примере это выглядело так:

\begin{lstlisting}
mkYesod "HelloWorld" [parseRoutes|
/ HomeR GET
|]
\end{lstlisting}

\lstinline!mkYesod! --- это функция Template Haskell, а \lstinline!parseRoutes! --- 
обработчик квазицитирования.

% I'd like to call it HomeR
% Похоже, здесь игра слов: "Я хочу назвать его Гомер".
По-русски это означает: создать в приложении \texttt{HelloWorld} один путь по имени
\lstinline!HomeR!. Он должен слушать запросы к / (корню приложения) и отвечать на
GET-запросы.  \marginpar{криво переведено I'd like to call it, т.к. если переводить
  дословно, то предложения получаются не связанными} \lstinline!HomeR! мы называем
ресурсом, отсюда и суффикс <<R>> в названии.

Суффикс <<R>> в именах ресурсов --- это просто соглашение, но его придерживаются
практически повсеместно. Оно позволяет немного упростить чтение и понимание кода.

% Тоже не придумал, на что заменить "подчищенную версию". Как один из многословных
% вариантов: "Вот версия, избавленная от многих несущественных подробностей:".
Функиция \texttt{TH} \lstinline!mkYesod! генерирует довольно много кода: тип данных
маршрута, функцию диспетчеризации и функцию рендеринга\marginpar{функцию отображения,
  ответа или ещё как-то}. Мы рассмотрим их более подробнов главе~\ref{ch:routing}.
Маршрутизация URL и обработчики. Но используя опцию GHC \lstinline'-ddump-splices', мы
можем посмотреть непосредственно на сгенерированный код. Вот сильно подчищенная его
версия:\marginpar{подчищенная звучит глупо, но более хорошего немногословного варианта не
  вижу}

\begin{lstlisting}
instance RenderRoute HelloWorld where
  data Route HelloWorld = HomeR
    deriving (Show, Eq, Read)
  renderRoute HomeR = ([], [])

instance YesodDispatch HelloWorld HelloWorld where
    yesodDispatch master sub toMaster app404 app405 method pieces =
        case dispatch pieces of
            Just f -> f
                master
                sub
                toMaster
                app404
                app405
                method
            Nothing -> app404
      where
        dispatch = Yesod.Routes.Dispatch.toDispatch
            [ Yesod.Routes.Dispatch.Route [] False onHome
            ]
        onHome [] = Just $ \master sub toMaster _app404 app405 method ->
            case method of
                "GET" -> yesodRunner
                    (fmap chooseRep getHomeR)
                    master
                    sub
                    (Just HomeR)
                    toMaster
                _ -> app405 HomeR

getHomeR = return ()

main :: IO ()
main = return ()
\end{lstlisting}
%$

% Второе предложение я не совсем понял, поэтому постарался перевести ближе к тексту.
% Возможно, требуется коррекция.
Что-то из этого вам, вероятно, пока непонятно. В частности, реализация
\lstinline!yesodDispatch! выглядит немного страшновато из-за того, что она должна быть
приспособлена к разным способам диспетчеризации и соответствовать модели, необходимой для
наших структур высокопроизводительной маршрутизации. Тем не менее, реализация
\lstinline!RenderRoute! вместе с ассоциированным типом данных уже должна дать вам хорошее
представление о том, что происходит внутри.

\section{Функция-обработчик}

% Продолжаю предполагать, что автор использует игру слов с HomeR.
Итак, у нас есть маршрут по имени \lstinline!HomeR!, и он отвечает на
\texttt{GET}-запросы.  Как вы определяете наш ответ? Вы пишете
функцию-обработчик. \texttt{Yesod} следует стандартной схеме именования таких функций: имя
метода в нижнем регистре (т. е., \texttt{GET} становится \lstinline!get!), после которого
идёт имя марштута. В нашем случае эта функция будет называться \lstinline!getHomeR!.

Большая часть вашего кода в \texttt{Yesod} будет находиться в функциях-обработчиках.
Именно здесь вы обрабатываете пользовательский ввод, выполняете запросы к базе данных и
создаете ответы. В нашем простом примере мы создаем ответ с помощью функции
\lstinline!defaultLayout!. Эта функция оборачивает переданное ей содержимое в шаблон
вашего сайта. По умолчанию она создаёт файл \texttt{HTML} с doctype, тегами html, head и
body. Как мы увидим в главе~\ref{ch:yesod-typeclass}, эта функция может быть
переопределена, чтобы делать гораздо больше.

В нашем примере в \lstinline!defaultLayout! мы передаем \lstinline'[whamlet|Hello
World!|]'. \lstinline!whamlet! --- это еще один обработчик квазицитирования. В данном
случае он преобразует синтаксис \texttt{Hamlet} в \texttt{Widget}. \texttt{Hamlet} --- это
движок \texttt{HTML}-шаблонов, используемый в \texttt{Yesod} по умолчанию.  Вместе со
своими <<родственниками>> \texttt{Cassius}, \texttt{Lucius} и \texttt{Julius} он позволяет
создавать \texttt{HTML}, \texttt{CSS} и \texttt{Javascript} типобезопасным образом с
проверкой во время компиляции. Гораздо больше по этому поводу мы увидим в
главе~\ref{ch:shakespeare}.

Виджеты --- еще один краеугольный камень \texttt{Yesod}. Они позволяют вам создавать
модульные компоненты сайта, состоящие из \texttt{HTML}, \texttt{CSS} и \texttt{Javascipt},
и повторно использовать их в любом месте вашего сайта. Более детально мы будем их
рассматривать в главе~\ref{ch:widgets}.

\section{Тип-основание}

Слово <<HelloWord>> появляется в нашем примере несколько раз. Каждое приложение
\texttt{Yesod} имеет тип-основание. Этот тип должен быть экземляром класса типов
\texttt{Yesod}, который предоставляет общее место для определения различных настроек,
определяющих выполнение нашего приложения.

В нашем случае этот тип данных довольно скучный\marginpar{boring}: он не содержит никакой
информации. Тем не менее, тип-основнание имеет существенное влияние на то, как выполняется
наш пример: он связывает воедино маршруты с определением экземпляра и дает им всем
возможность выполняться. На протяжении книги мы посмотрим как тип-основание всплывает в
разных местах.

Но типы-основания не обязательно должны быть скучными: они могут использоваться для
множества полезной информации, обычно той, которая должна быть инициализирована при
запуске и использоваться повсюду. Вот некоторые наиболее распространённые примеры:

\begin{itemize}
  \item пул соединений с базой данных;
  \item настройки, загружаемые из конфигурационного файла;
  \item менеджер соединений \texttt{HTTP}.
\end{itemize}

Кстати, слово \texttt{Yesod} (יסוד) означает <<основание>> на иврите.

\subsection{Запуск}

Ещё раз обратимся к типу \lstinline!HelloWorld! в основной функции.
Тип-основание содержит всю необходимую информацию для маршрутизации и 
ответов на запросы к приложению;
сейчас необходимо преобразовать это в нечто, что можно запустить. 
Для этого полезна функция Yesod \lstinline!warpDebug!, которая 
запускает вебсервер \texttt{Warp}, с включенным отладочным
выводом, на указанном порту (в нашем случае это $3000$).

Одна из полезных возможностей \texttt{Yesod} заключается к том, 
что вы не привязаны к единственной стратегии развертывания приложения. 
\texttt{Yesod} сделан повер \texttt{Web Application Interface (WAI)}, 
позволяющем запускать приложение через \texttt{FastCGI}, 
\texttt{SCGI}, \texttt{Warp} или даже как 
desktop application\marginpar{desktop application} используя библиотеку
\texttt{Webkit}. Мы рассмотрим некоторые из этих возможностей 
далее в главе ,,Развертывание``.

%FIXME
Warp является основным из вариантов разворачивания \texttt{Yesod}. 
Это легковесный, высокоэффективный веб сервер разработанный 
специально для хостинга \texttt{Yesod} проектов. Он так же используется 
и вне \texttt{Yesod} для других разработок на Haskell (как фреймоврков 
так и не фреймворк приложений), так же как стандартный файлсервер 
для различных боевых окружений\marginpar{как-то криво всё}.

\section{Ресурсы и типобезопасные URL}

В приложении здравствуй мир, мы определеили только один ресурс 
(\lstinline!HomeR!). Веб приложение обычно более привлекательны\marginpar{exiting} и  использует более чем одну страницу. Давайте рассмотрим:

\begin{lstlisting}
{-# LANGUAGE TypeFamilies, QuasiQuotes, MultiParamTypeClasses,
             TemplateHaskell, OverloadedStrings #-}
import Yesod

data Links = Links

mkYesod "Links" [parseRoutes|
/ HomeR GET
/page1 Page1R GET
/page2 Page2R GET
|]

instance Yesod Links

getHomeR  = defaultLayout [whamlet|<a href=@{Page1R}>Go to page 1!|]
getPage1R = defaultLayout [whamlet|<a href=@{Page2R}>Go to page 2!|]
getPage2R = defaultLayout [whamlet|<a href=@{HomeR}>Go home!|]

main = warpDebug 3000 Links
\end{lstlisting}

В целом пример очень близок к ,,Здравствуй, Мир``. Тип-основание
теперь \lstinline!Links! вместо \lstinline!HelloWorld!, и в дополнение 
к ресурсу \lstinline!HomeR!, мы добавили \lstinline!Page1R! и 
\lstinline!Page2R!. И так же мы добавили ещё 
два обработчика \lstinline!getPage1R! и \lstinline!getPage2R!.

Единственное действительно новая возможность -- это использование обработчика  
квазицитирования \lstinline'whamlet'. Мы углубимся в синтакс в главе~\ref{ch:shakespeare} Shakespeare, но сейчас мы можем понять, что

\begin{lstlisting}
<a href=@{Page1R}>Go to page 1!
\end{lstlisting}

создаёт ссылку на ресурс \lstinline!Page1R!. Важно заметить, что 
\lstinline!Page1R! это конструктор типа данных. Создавая конструктор 
для каждого ресурса, мы получаем возможность, называемую типобезопасные 
ссылки. Вместо того, чтобы соединять строки строки, чтобы получить ссылку,
 мы создаём старую добрую переменную Haskell.\marginpar{plain old haskell value}
При применении at-sign интерполяцию (@{\ldots}), \texttt{Yesod}
автоматически отображает эти значения в текстовые ссылки перед 
передачей их пользователю. Мы можем увидеть, как это реализовано, 
в очередной раз просмотрев вывод \lstinline!--dump-splices!:

\begin{lstlisting}
instance RenderRoute Links where
    data Route Links = HomeR | Page1R | Page2R
      deriving (Show, Eq, Read)

    renderRoute HomeR  = ([], [])
    renderRoute Page1R = (["page1"], [])
    renderRoute Page2R = (["page2"], [])

main :: IO ()
main = return ()
\end{lstlisting}

В \lstinline!Route! ассоциированном типе для \lstinline!Links!, у нас 
есть дополнительные конструкторы для \lstinline!Page1R! и 
\lstinline!Page2R!. У нас так же есть более хорошая картина 
возвращаемых значений \lstinline!returnRoute!. Первая часть кортежа 
содержит части пути для данного маршрута. Второе значение определяет
параметры строки запроса, практически для всех вариантов использования это будет пустой список.

Очень тяжело переоценить значение типобизопасныч ссылок. Они позволяют 
достичь огромной гибкости и надёжности при создании приложения. Мы можете 
изменять \texttt{URL} ресурсов без повреждения ссылок. 
В главе~\ref{ch:routing}Маршрутизация, мы увидим, что маршруты могут 
принимать параметры, например \texttt{URL} записи в блоге принимает 
\texttt{ID} поста.

Предположим, что вы хотите изменить пути от численного \texttt{ID} к 
\texttt{год/месяц/транслитеризованное} название. В обычном 
веб фреймворке, вам придётся обновить все ссылки на блог посты, и если вы потеряете хотя бы один, то 
получите ошибку 404 во время исполнения. В \texttt{Yesod}, всё что вам придётся следать это обновить 
путь и собрать приложение, \texttt{GHC} укажет на все ссылки которые должны быть откорретированы.

\section{Каркас сайта}

При установке \texttt{Yesod} вы получаете как библиотеку \texttt{Yesod}, 
так и исполняемый файл. Этот исполняемый файл может принимать небольшое 
количество команд, но первая команда с какой вы захотите познакомиться 
это \texttt{yesod init}. Она задаст несколько вопросов и создаст каталог 
содержащий каркас сайта. В этом каталоге
вы можете запустить \lstinline'cabal install--only-dependencies' для того, чтобы установить дополнительные
зависимости (такие как бекенды баз данных), и затем \lstinline'yesod devel' для того чтобы запустить сайт.

Каркас сайта покажет вам большое количество хороших практик прямо 
из коробки, установит файлы и зависимости в подходе проверенном временем используемым в большинстве ,,боевых`` сайтов на \texttt{Yesod}.\marginpar{кривой перевод}
Хотя на это удобство может быть поняты при обучении  \texttt{Yesod}.
Поэтому, в этой книге не используются каркас сайта, 
и идет работа напрямую с библиотекой \texttt{Yesod}.

Мы рассмотрим структуру каркаса во всех подробностях в далее.

\section{Разработческий сервер}

Одной из полезных возможностей интерпретируемых языков над компилируемыми является быстрое прототипирование: 
вы просто сохраняете изменения в файл и нажимаете обновить. 
Если мы хотим внести изменения в \texttt{Yesod} приложение выше, 
мы должны сначала вызвать \lstinline!runhaskell!, что может быть немного 
утомительно.

К счастью существует решение: \lstinline'yesod devel' автоматически 
пересобирает код и перезагружает приложение Так это хоченнь хороший вариант
разработки Yesod проектов, и когда вы перейдёте на боевой сервер,
вы получите собраный проект с неверноятно эффективным кодом. Каркас Yesod автоматически
настраивает всё для вас. Это позволяет использовать лучшее из двух миров: 
быстрое прототипирование и быстрый боевой код.

Необходимо немного побольше разобраться для того, чтобы настроить код, 
для использования \lstinline!yesod devel!, поэтому примеры будут 
использовать просто \lstinline!warpDebug!. Но когда вы будете готовы
создать ваше первое реальное приложение, \lstinline'yesod devel' будет ждать вас.\marginpar{кривой перевод}

\section{Выводы}

Каждое \texttt{Yesod} приложение строится вокруг тип-основания. 
Мы ассоциируем некоторые ресурсы с типами данных и определяем функции обработчики 
для каждого из маршрутов. Эти ресурсы так же являются конструкторами данных, 
которые позволяют нам использовать типобезопасные URL.

Запускаемые поверх \texttt{WAI}, приложения yesod могут быть запущены на различных 
бекендах, \lstinline!warpDebug! это простой путь запуска проекта, т.к.
поставляется вместе с Yesod. Для быстрой разработки, хорошим выбором является yesod devel. 
А когда вы будете готовы для боевых серверов, то у вас будет выскопопроизводительный
сервер \texttt{Warp}.

При разработке \texttt{Yesod} у вас будет много выборов стиля написания: 
квазицитирование или внешние файлы,
\lstinline{warpDebug} или \lstinline'yesod devel' и так далее. Примеры в этой книги построены 
таким образом, чтобы их было просто копировать и вставлять, но гораздо более мощные варианты 
будут доступны, когда вы начнете создавать реальные Yesod приложения.
