\chapter{Монады в Yesod}\label{chap:yesod_monads}

Как вы уже увидели, в этой книге появлялось несколько монад: \lstinline'Handler',
\lstinline'Widget' и \lstinline'YesodDB'
(для \lstinline'Persistent'). Как и всякая монада, каждая из них предоставляет некоторую
специфическую функциональность: \lstinline'Handler' предоставляет доступ к запросу и
позволяет
отправлять ответы, Widget содержит HTML, CSS и Javascript, а YesodDB позволяет делать
запросы к базе данных. В терминах Model-View-Controller (MVC), мы могли бы рассматривать
\lstinline'YesodDB' как модель, \lstinline'Widget' --- как представление, а
\lstinline'Handler' --- как контроллер.

До сих пор у нас были представлены очень простые способы использования этих монад: 
основной обработчик работает в монаде \lstinline'Handler', используя \lstinline'runDB' для
выполнения запроса в YesodDB и \lstinline'defaultLayout' для возврата монады
\lstinline'Widget', которая, в свою очередь, была создана
вызовом \lstinline'toWidget'.

Тем не менее, если у нас будет глубокое понимание этих типов, мы сможем достичь более интересных результатов.

\section{Трансформаторы монад}
Монады они как луковицы. Монады не как пирожные. Вроде бы Шрек.\marginpar{оформить
цитатой}

Прежде чем мы углубимся в монады Yesod, мы должны немного понимать трансформаторы монад. 
(Если вы уже знаете о трансформаторах монад всё, вы, скорее всего, можете пропустить этот
раздел.) Различные монады предоставляют различную функциональность: \lstinline'Reader'
предоставляет доступ только для чтения к некоторым данных по всему вычислению,
\lstinline'Error' позволяет обрывать вычисления, и так далее.

Однако, часто вы захотите иметь возможность объединить функциональные возможности 
некоторых из этих монад. В конце концов, почему бы не иметь вычисление с доступом только
для чтения к некоторым параметрам настройки, которое в любой момент могло бы прерваться с
ошибкой? Одним из подходов было бы написать новую монаду, например
\lstinline'ReaderError', но это имеет очевидный недостаток экспоненциальной сложности:
будет нужно писать новую монаду для каждой возможной комбинации.

Вместо этого мы используем трансформаторы монад. Вместе с \lstinline'Reader', у нас есть
\lstinline'ReaderT', который добавляет функциональность \lstinline'Reader' к любой другой
монаде. Таким образом, мы могли бы представить \lstinline'ReaderError' как
(концептуально):

\begin{lstlisting}
type ReaderError = ReaderT Error
\end{lstlisting}

Чтобы получить доступ к параметрам настройки, мы можем использовать функцию
\lstinline'ask'. А что насчет обрывания вычисления? Мы бы хотели вызвать
\lstinline'throwError', но это не вполне будет работать. Вместо этого мы должны
использовать \lstinline'lift', что бы втянуть наш вызов в монаду на уровень выше. Другими
словами:

\begin{lstlisting}
throwError :: errValue -> Error
lift . throwError :: errValue -> ReaderT Error
\end{lstlisting}
  
Сейчас вы должны уловить несколько идей:
\begin{itemize}
\item  Трансформатор может быть использован для добавления функциональных возможностей в
существующие монады.
\item  Трансформатор должен всегда обёртываться вокруг существующей монады.
\item  Функциональные возможности получившейся монады будут зависеть не только от
трансформатора монады, но и от монады, обёрнутой внутри.
\end{itemize}

Отличный пример последнего утверждения --- это монада \lstinline'IO'. Независимо от того,
сколько слоев трансформаторов у вас есть вокруг \lstinline'IO', там всё ещё есть ядро
\lstinline'IO', то есть вы можете выполнять I/O в любом из этих стеков трансформаторов
монад. Вы будете часто видеть код, который выглядит как 
\lstinline'liftIO $ putStrLn "Hello There!"'.

\section{Три трансформатора}

Мы уже обсуждали два трансформатора ранее: \lstinline'Handler' и \lstinline'Widget'.
Напомним два особых факта про них:
\begin{itemize}
\item  С целью улучшения сообщений об ошибках, они не являются фактическими
трансформаторами. Вместо этого, они объявлены как \lstinline'newtype' с жёстко заданной
внутренней монадой. 
\begin{remark}Помните, что именно поэтому Yesod предоставляет специальную функцию
\lstinline'lift', которая работает для \lstinline'Handler' и \lstinline'Widget'.
\end{remark}
\item  На самом деле у них есть дополнительные параметры типа для дополнительного и
основного сайта. В результате, библиотеки Yesod предоставляют 
\lstinline'GHandler sub master a' и \lstinline'GWidget sub master a', и каждый сайт
получает пару синонимов типов \lstinline'type Handler = GHandler MyApp MyApp' и
\lstinline'type Widget = GWidget MyApp MyApp ()'.
\end{itemize}

В пакете \hyperref[chap:persistent]{Persistent}, у есть класс типов который называется
\lstinline'PersistStore'. Этот класс типов
определяет все примитивные операции которые можно выполнять с базой данных, к примеру
получать данные (\lstinline'get'). Этот класс типов по существу выглядит как 
\lstinline'class (Monad (b m)) => PersistStore b m'. Где \lstinline'b' определяет сервер
базы данных, а на самом деле является трансформатором монады, а \lstinline'm' является
внутренней монадой, которую \lstinline'b' оборачивает. И SQL, и MongoDB имеют свои
собственные экземпляры; в случае SQL, он выглядит
так:

\begin{lstlisting}
instance MonadBaseControl IO m => PersistBackend SqlPersist m
\end{lstlisting}

Это означает, что вы можете работать с базой данных SQL при любой базовой монаде, до тех 
пор, пока эта монада поддерживает \lstinline'MonadBaseControl IO', что позволяет правильно
обрабатывать исключения на стеке монад. В общем, это означает означает любой стек
трансформаторов, построенный вокруг \lstinline'IO' (кроме исключительных случаев, как
\lstinline'ContT'). К счастью для нас, это включает в себя как \lstinline'Handler' так и
\lstinline'Widget'. Следовательно мы можем наслаивать наш Persistent трансформатор на
\lstinline'Handler' или \lstinline'Widget'.

\begin{remark}
Это не всегда было так. Перед Yesod 0.10, Yesod был построен на базе пакета enumerators, 
который не поддерживает \lstinline'MonadBaseControl'. В Yesod 0.10, мы перешли к пакету 
\hyperref[chap:intro]{conduit},
который значительно упрощает всё, что мы здесь обсуждаем.
\end{remark}

Для того, чтобы упростить обращение к соответствующим Persistent трансформаторам, пакет 
\footnotehref{http://hackage.haskell.org/package/yesod-persistent}{yesod-persistent}
 определяет
ассоциированный тип \lstinline'YesodPersistBackend'. Например, если у нас есть сайт
который называется \lstinline'MyApp' и использует SQL, мы можем определить что-то вроде 
\lstinline'type instance YesodPersistBackend MyApp = SqlPersist'.

Когда мы захотим выполнить наши действия с базой данных, у нас будет
\lstinline'SqlPersist' обернутый вокруг \lstinline'Handler' или \lstinline'Widget'. Так мы
сможем использовать стандартные функции развертки Persistent (например,
\lstinline'runSqlPool') для исполнения действия и возврата в нормальный
\lstinline'Handler/Widget'. Для автоматизации этого, предоставляется функция
\lstinline'runDB'. Суммируя все это, мы теперь можем исполнять действия с базой данных
внутри наших обработчиков и виджетов.

Большую часть времени в коде Yesod, особенно до сих пор, виджеты рассматривались как 
контейнеры без возможности действий, которые просто объединяют вместе HTML, CSS и
Javascript. Но если вы посмотрите на последний абзац еще раз, вы поймете, что это не
совсем так. Поскольку виджет это трансформатор над обработчиком, всё что вы делаете в
обработчике может быть сделано в виджете, в том числе и операции с базой данных. Все, что
вам нужно сделать, это протянуть вызов, используя \lstinline'lift'.

\section{Пример: навигационная панель на основе базы данных}

Давайте применим некоторые из новых знаний на практике. Мы хотим создать
\lstinline'Widget', который генерирует свой вывод на основе содержимого базы данных. Ранее
мы бы загрузили данные в \lstinline'Handler', а затем передали эти данные в
\lstinline'Widget'. Теперь загрузим данные в самом \lstinline'Widget'. Это хорошо для
модульности, так как этот \lstinline'Widget' сможет использоваться в любом
\lstinline'Handler', каком мы захотим, без необходимости передавать содержимое базы
данных.

\begin{lstlisting}
{-# LANGUAGE OverloadedStrings, TypeFamilies, TemplateHaskell, FlexibleContexts,
             QuasiQuotes, TypeFamilies, MultiParamTypeClasses, GADTs #-}
import Yesod
import Database.Persist.Sqlite
import Data.Text (Text)
import Data.Time

share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persist|
Link
    title Text
    url Text
    added UTCTime
|]

data LinksExample = LinksExample ConnectionPool

mkYesod "LinksExample" [parseRoutes|
/ RootR GET
/add-link AddLinkR POST
|]

instance Yesod LinksExample

instance RenderMessage LinksExample FormMessage where
    renderMessage _ _ = defaultFormMessage

instance YesodPersist LinksExample where
    type YesodPersistBackend LinksExample = SqlPersist
    runDB db = do
        LinksExample pool <- getYesod
        runSqlPool db pool

getRootR :: Handler RepHtml
getRootR = defaultLayout [whamlet|
<form method=post action=@{AddLinkR}>
    <p>
        Add a new link to #
        <input type=url name=url value=http://>
        \ titled #
        <input type=text name=title>
        \ #
        <input type=submit value="Add link">
<h2>Existing links
^{existingLinks}
|]

existingLinks :: Widget
existingLinks = do
    links <- lift $ runDB $ selectList [] [LimitTo 5, Desc LinkAdded]
    [whamlet|
<ul>
    $forall Entity _ link <- links
        <li>
            <a href=#{linkUrl link}>#{linkTitle link}
|]

postAddLinkR :: Handler ()
postAddLinkR = do
    url <- runInputPost $ ireq urlField "url"
    title <- runInputPost $ ireq textField "title"
    now <- liftIO getCurrentTime
    runDB $ insert $ Link title url now
    setMessage "Link added"
    redirect RootR

main :: IO ()
main = withSqlitePool "links.db3" 10 $ \pool -> do
    runSqlPool (runMigration migrateAll) pool
    warpDebug 3000 $ LinksExample pool
\end{lstlisting}

В частности обратите внимание на функцию \lstinline'existingLinks'. Видите, что всё, что
нужно сделать, это применить \lstinline'lift' к нормальному действию с базой данных. А в
\lstinline'getRootR', мы трактуем \lstinline'existingLinks' как обычный
\lstinline'Widget', вообще без никаких специальных параметров. Смотрите на рисунке вывод
этого приложения.

\begin{figure}[tbh]
  \centering
  \caption{Скриншот панели навигации}
  \includegraphics[scale=0.5]{13-yesods-monads-image-01.png}
\end{figure}

\section{Пример: запрос информации}

Таким же образом вы можете получить информацию по запросу внутри \lstinline'Widget'. В
этом примере мы определяем порядок сортировки списка на основе GET параметров.

\begin{lstlisting}
{-# LANGUAGE OverloadedStrings, TypeFamilies, TemplateHaskell,
             QuasiQuotes, TypeFamilies, MultiParamTypeClasses, GADTs #-}
import Yesod
import Data.Text (Text)
import Data.List (sortBy)
import Data.Ord (comparing)

data Person = Person
    { personName :: Text
    , personAge :: Int
    }

people :: [Person]
people =
    [ Person "Miriam" 25
    , Person "Eliezer" 3
    , Person "Michael" 26
    , Person "Gavriella" 1
    ]

data People = People

mkYesod "People" [parseRoutes|
/ RootR GET
|]

instance Yesod People

instance RenderMessage People FormMessage where
    renderMessage _ _ = defaultFormMessage


getRootR :: Handler RepHtml
getRootR = defaultLayout [whamlet|
<p>
    <a href="?sort=name">Sort by name
    \ | #
    <a href="?sort=age">Sort by age
    \ | #
    <a href="?">No sort
^{showPeople}
|]

showPeople :: Widget
showPeople = do
    msort <- lift $ runInputGet $ iopt textField "sort"
    let people' =
            case msort of
                Just "name" -> sortBy (comparing personName) people
                Just "age"  -> sortBy (comparing personAge)  people
                _           -> people
    [whamlet|
<dl>
    $forall person <- people'
        <dt>#{personName person}
        <dd>#{show $ personAge person}
|]

main :: IO ()
main = warpDebug 3000 People
\end{lstlisting}

Повторим, всё что нужно сделать, это протянуть функцию стандартную для \lstinline'Handler'
(в данном случае, \lstinline'runInputGet'), чтобы исполнить её в нашем \lstinline'Widget'.

\section{Выводы}

Если вы полностью проигнорировали эту главу, вы все равно сможете с большой пользой 
использовать Yesod. Преимущество понимания того, как взаимодействуют монады Yesod, в том,
чтобы иметь возможность производить более чистый и более модульный код. Способность
выполнять произвольные действия в \lstinline'Widget' может быть мощным инструментом, и
понимание того, как взаимодействуют \lstinline'Persistent' и ваш \lstinline'Handler' код,
может помочь вам сделать более обоснованные проектные решения в вашем приложении.
