\chapter{Монады в Yesod}\label{chap:yesod_monads}

Как вы уже увидели, в этой книге появлялось несколько монад: \lstinline'Handler',
\lstinline'Widget' и \lstinline'YesodDB'
(для \lstinline'Persistent'). Как и всякая монада, каждая из них предоставляет некоторую
специфическую функциональность: \lstinline'Handler' предоставляет доступ к запросу и
позволяет
отправлять ответы, Widget содержит HTML, CSS и Javascript, а YesodDB позволяет делать
запросы к базе данных. В терминах Model-View-Controller (MVC), мы могли бы рассматривать
\lstinline'YesodDB' как модель, \lstinline'Widget' --- как представление, а
\lstinline'Handler' --- как контроллер.

До сих пор у нас были представлены очень простые способы использования этих монад: 
основной обработчик работает в монаде \lstinline'Handler', используя \lstinline'runDB' для
выполнения запроса в YesodDB и \lstinline'defaultLayout' для возврата монады
\lstinline'Widget', которая, в свою очередь, была создана
вызовом \lstinline'toWidget'.

Тем не менее, если у нас будет глубокое понимание этих типов, мы сможем достичь более интересных результатов.

\section{Трансформаторы монад}

\vspace{1em}\hfill{}\begin{minipage}{150pt}{\begin{spacing}{0.9}
\small\noindent\textit{Монады, они как луковицы. Монады не как пирожные.}\end{spacing}
\vspace{1em}
\hfill{}{Вроде бы Шрек.}}\vspace{2em}
\end{minipage}

Прежде чем мы углубимся в монады Yesod, мы должны немного понимать трансформаторы монад. 
(Если вы уже знаете о трансформаторах монад всё, вы, скорее всего, можете пропустить этот
раздел.) Различные монады предоставляют различную функциональность: \lstinline'Reader'
предоставляет доступ только для чтения к некоторым данных по всему вычислению,
\lstinline'Error' позволяет обрывать вычисления, и так далее.

Однако, часто вы захотите иметь возможность объединить функциональные возможности 
некоторых из этих монад. В конце концов, почему бы не иметь вычисление с доступом только
для чтения к некоторым параметрам настройки, которое в любой момент могло бы прерваться с
ошибкой? Одним из подходов было бы написать новую монаду, например
\lstinline'ReaderError', но это имеет очевидный недостаток экспоненциальной сложности:
будет нужно писать новую монаду для каждой возможной комбинации.

Вместо этого мы используем трансформаторы монад. Вместе с \lstinline'Reader', у нас есть
\lstinline'ReaderT', который добавляет функциональность \lstinline'Reader' к любой другой
монаде. Таким образом, мы могли бы представить \lstinline'ReaderError' как
(концептуально):

\begin{lstlisting}
type ReaderError = ReaderT Error
\end{lstlisting}

Чтобы получить доступ к параметрам настройки, мы можем использовать функцию
\lstinline'ask'. А что насчет обрывания вычисления? Мы бы хотели вызвать
\lstinline'throwError', но это не вполне будет работать. Вместо этого мы должны
использовать \lstinline'lift', что бы втянуть наш вызов в монаду на уровень выше. Другими
словами:

\begin{lstlisting}
throwError :: errValue -> Error
lift . throwError :: errValue -> ReaderT Error
\end{lstlisting}
  
Сейчас вы должны уловить несколько идей:
\begin{itemize}
\item  Трансформатор может быть использован для добавления функциональных возможностей в
существующие монады.
\item  Трансформатор должен всегда обёртываться вокруг существующей монады.
\item  Функциональные возможности получившейся монады будут зависеть не только от
трансформатора монады, но и от монады, обёрнутой внутри.
\end{itemize}

Отличный пример последнего утверждения --- это монада \lstinline'IO'. Независимо от того,
сколько слоев трансформаторов у вас есть вокруг \lstinline'IO', там всё ещё есть ядро
\lstinline'IO', то есть вы можете выполнять I/O в любом из этих стеков трансформаторов
монад. Вы будете часто видеть код, который выглядит как 
\lstinline'liftIO $ putStrLn "Hello There!"'.

\section{Три трансформатора}

Мы уже обсуждали два трансформатора ранее: \lstinline'Handler' и \lstinline'Widget'.
Напомним два особых факта про них:
\begin{itemize}
\item  С целью улучшения сообщений об ошибках, они не являются фактическими
трансформаторами. Вместо этого, они объявлены как \lstinline'newtype' с жёстко заданной
внутренней монадой. 
\begin{remark}Помните, что именно поэтому Yesod предоставляет специальную функцию
\lstinline'lift', которая работает для \lstinline'Handler' и \lstinline'Widget'.
\end{remark}
\item  На самом деле у них есть дополнительные параметры типа для дополнительного и
основного сайта. В результате, библиотеки Yesod предоставляют 
\lstinline'GHandler sub master a' и \lstinline'GWidget sub master a', и каждый сайт
получает пару синонимов типов \lstinline'type Handler = GHandler MyApp MyApp' и
\lstinline'type Widget = GWidget MyApp MyApp ()'.
\end{itemize}

В пакете \hyperref[chap:persistent]{Persistent}, у есть класс типов который называется
\lstinline'PersistStore'. Этот класс типов
определяет все примитивные операции которые можно выполнять с базой данных, к примеру
получать данные (\lstinline'get'). Этот класс типов по существу выглядит как 
\lstinline'class (Monad (b m)) => PersistStore b m'. Где \lstinline'b' определяет сервер
базы данных, а на самом деле является трансформатором монады, а \lstinline'm' является
внутренней монадой, которую \lstinline'b' оборачивает. И SQL, и MongoDB имеют свои
собственные экземпляры; в случае SQL, он выглядит
так:

\begin{lstlisting}
instance MonadBaseControl IO m => PersistBackend SqlPersist m
\end{lstlisting}

Это означает, что вы можете работать с базой данных SQL при любой базовой монаде, до тех 
пор, пока эта монада поддерживает \lstinline'MonadBaseControl IO', что позволяет правильно
обрабатывать исключения на стеке монад. В общем, это означает означает любой стек
трансформаторов, построенный вокруг \lstinline'IO' (кроме исключительных случаев, как
\lstinline'ContT'). К счастью для нас, это включает в себя как \lstinline'Handler' так и
\lstinline'Widget'. Следовательно мы можем наслаивать наш Persistent трансформатор на
\lstinline'Handler' или \lstinline'Widget'.

\begin{remark}
Это не всегда было так. Перед Yesod 0.10, Yesod был построен на базе пакета enumerators, 
который не поддерживает \lstinline'MonadBaseControl'. В Yesod 0.10, мы перешли к пакету 
\href{http://hackage.haskell.org/package/conduit}{conduit}\footnotemark,
который значительно упрощает всё, что мы здесь обсуждаем.
\end{remark}
\footnotetext{\href{http://hackage.haskell.org/package/conduit}{\texttt{http://hackage.haskell.org/package/conduit}}}

Для того, чтобы упростить обращение к соответствующим Persistent трансформаторам, пакет 
\footnotehref{http://hackage.haskell.org/package/yesod-persistent}{yesod-persistent}
 определяет
ассоциированный тип \lstinline'YesodPersistBackend'. Например, если у нас есть сайт
который называется \lstinline'MyApp' и использует SQL, мы можем определить что-то вроде 
\lstinline'type instance YesodPersistBackend MyApp = SqlPersist'.

Когда мы захотим выполнить наши действия с базой данных, у нас будет
\lstinline'SqlPersist' обернутый вокруг \lstinline'Handler' или \lstinline'Widget'. Так мы
сможем использовать стандартные функции развертки Persistent (например,
\lstinline'runSqlPool') для исполнения действия и возврата в нормальный
\lstinline'Handler/Widget'. Для автоматизации этого, предоставляется функция
\lstinline'runDB'. Суммируя все это, мы теперь можем исполнять действия с базой данных
внутри наших обработчиков и виджетов.

Большую часть времени в коде Yesod, особенно до сих пор, виджеты рассматривались как 
контейнеры без возможности действий, которые просто объединяют вместе HTML, CSS и
Javascript. Но если вы посмотрите на последний абзац еще раз, вы поймете, что это не
совсем так. Поскольку виджет это трансформатор над обработчиком, всё что вы делаете в
обработчике может быть сделано в виджете, в том числе и операции с базой данных. Все, что
вам нужно сделать, это протянуть вызов, используя \lstinline'lift'.

\section{Пример: навигационная панель на основе базы данных}

Давайте применим некоторые из новых знаний на практике. Мы хотим создать
\lstinline'Widget', который генерирует свой вывод на основе содержимого базы данных. Ранее
мы бы загрузили данные в \lstinline'Handler', а затем передали эти данные в
\lstinline'Widget'. Теперь загрузим данные в самом \lstinline'Widget'. Это хорошо для
модульности, так как этот \lstinline'Widget' сможет использоваться в любом
\lstinline'Handler', каком мы захотим, без необходимости передавать содержимое базы
данных.

\lstinputlisting{../hs/13-navbar.hs}

В частности обратите внимание на функцию \lstinline'existingLinks'. Видите, что всё, что
нужно сделать, это применить \lstinline'lift' к нормальному действию с базой данных. А в
\lstinline'getRootR', мы трактуем \lstinline'existingLinks' как обычный
\lstinline'Widget', вообще без каких-либо специальных параметров. Смотрите на рисунке
вывод этого приложения.

\begin{figure}[tbh]
  \centering
  \caption{Скриншот панели навигации}
  \includegraphics[scale=0.5]{13-yesods-monads-image-01.png}
\end{figure}

\section{Пример: запрос информации}

Таким же образом вы можете получить информацию по запросу внутри \lstinline'Widget'. В
этом примере мы определяем порядок сортировки списка на основе GET параметров.

\lstinputlisting{../hs/13-request-information.hs}

Повторим, всё что нужно сделать, это протянуть функцию стандартную для \lstinline'Handler'
(в данном случае, \lstinline'runInputGet'), чтобы исполнить её в нашем \lstinline'Widget'.

\section{Выводы}

Если вы полностью проигнорировали эту главу, вы все равно сможете с большой пользой 
использовать Yesod. Преимущество понимания того, как взаимодействуют монады Yesod, в том,
чтобы иметь возможность производить более чистый и более модульный код. Способность
выполнять произвольные действия в \lstinline'Widget' может быть мощным инструментом, и
понимание того, как взаимодействуют \lstinline'Persistent' и ваш \lstinline'Handler' код,
может помочь вам сделать более обоснованные проектные решения в вашем приложении.
