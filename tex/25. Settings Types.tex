\chapter{Типы для настроек}
Представим, что вы пишете веб сервер. Вы хотите, чтобы вашему серверу
передавали порт для прослушивания и приложение для запуска. И вы
создаёте следующую функцию:
\begin{lstlisting}
run :: Int -> Application -> IO ()
\end{lstlisting}

Но внезапно вы понимаете, что некоторые люди захотят настроить
продолжительность ожидания. И тогда вы меняете своё API:
\begin{lstlisting}
run :: Int -> Int -> Application -> IO ()
\end{lstlisting}

В итоге, какой \lstinline!Int! для времени ожидания, а какой для
номера порта? Да, вы могли бы создать какие-нибудь синонимы для типов
или прокомментировать ваш код. Но здесь есть ещё одна проблема,
пробирающаяся в ваш код: такая функция \lstinline!run! становится
неподдерживаемой. Скоро потребуется получать дополнительный параметр
для обозначения, как следует обрабатывать исключения, а затем ещё один
для управления, к какому хосту привязываться, и так далее.

Поэтому более масштабируемое решение~--- ввести тип данных для
настроек:
\begin{lstlisting}
data Settings = Settings
    { settingsPort :: Int
    , settingsHost :: String
    , settingsTimeout :: Int
    }
\end{lstlisting}
И это делает вызывающий код почти самодокументированным:
\begin{lstlisting}
run Settings
    { settingsPort = 8080
    , settingsHost = "127.0.0.1"
    , settingsTimeout = 30
    } myApp
\end{lstlisting}

Великолепно, яснее быть не может, не так ли? Да так, но что случится, когда у вас
будет 50 настроек для вашего веб сервера. Вы действительно хотите
задавать их все каждый раз? Конечно, нет. Так что вместо этого, веб
сервер должен предоставлять набор значений по умолчанию:
\begin{lstlisting}
defaultSettings = Settings 3000 "127.0.0.1" 30
\end{lstlisting}
И теперь, вместо необходимости писать длинный кусок кода как выше,
мы можем отделаться лишь этим:
\begin{lstlisting}
run defaultSettings { settingsPort = 8080 } myApp -- (1)
\end{lstlisting}

Это замечательно, за исключением одно маленького
препятствия. Допустим, мы решаем добавить дополнительную запись в
\lstinline!Settings!. Любой код во внешнем мире, выглядящий как
\begin{lstlisting}
run (Settings 8080 "127.0.0.1" 30) myApp -- (2)
\end{lstlisting}
станет нерабочим, так как теперь конструктор~\lstinline!Settings!
принимает 4 аргумента. Правильной вещью стало бы увеличение номера
основной версии (major version), чтобы не нарушить работоспособность
зависимых пакетов. Но менять номер основной версии для каждого
минимального изменения настроек~--- это неудобство. Решение? Не
экспортировать конструктор~\lstinline!Settings!:
\begin{lstlisting}
module MyServer
    ( Settings
    , settingsPort
    , settingsHost
    , settingsTimeout
    , run
    , defaultSettings
    ) where
\end{lstlisting}

С таким подходом, никто не сможет написать код наподобие (2), поэтому
вы можете свободно добавлять новые настройки, не боясь поломать код.

Единственный недостаток такого подхода~-- сразу неочевидно из
документации Haddocks, что вы фактически можете менять настройки,
используя синтаксис записей. Основная идея этой главы: прояснить, что
происходит в библиотеках, использующих эту технику.

Я сам использую эту технику в нескольких местах, не стесняйтесь
заглянуть в Haddocks, чтобы понять, что я имею в виду.
\begin{itemize}
\item Warp: Settings
\item http-conduit: Request и ManagerSettings
\item xml-conduit:
  \begin{itemize}
  \item Разбор: ParseSettings
  \item Представление: RenderSettings
  \end{itemize}
\end{itemize}

Сопутствующее замечание (As a tangential issue - FIXME): http-conduit
и xml-conduit фактически создают экземпляры класса
типов~\lstinline!Default! из пакета Data.Default вместо объявления
своего нового идентификатора. Это означает, что вы можете просто
печатать \lstinline!def! вместо \lstinline!defaultParserSettings!.
