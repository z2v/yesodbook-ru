\chapter{Пакет xml-conduit}

Многих разработчиков трясёт от одной только мысли о работе с XML файлами. XML имеет репутацию формата, имеющего излишне усложнённую модель данных, запутанные библиотеки и целые слои сложностей, находящиеся между разработчиком и его целью. Но я смею заверить, что многое из этого относится скорее к проблемам языков программирования и библиотек, чем к самому формату XML.

Как я уже отмечал, система типов языка Haskell позволяет нам с лёгкостью свести любую проблему к её самой базовой форме. Пакет \footnotehref{http://hackage.haskell.org/package/xml-types}{xml-types} аккуратно преобразует модель данных XML (поддерживается работа как с целыми документами, так и с потоком данных) в простые алгебраические типы данных. Стандартные неизменяемые структуры данных языка Haskell упрощают преобразование документов, а простой набор функций делает разбор и отображение лёгкими и непринуждёнными.

Рассмотрим пакет \footnotehref{http://hackage.haskell.org/package/xml-conduit}{xml-conduit}. В нём используется множество подходов, которые Yesod в целом применяет для получения высокой производительности: пакеты \footnotehref{http://hackage.haskell.org/package/blaze-builder}{blaze-builder}, \footnotehref{http://hackage.haskell.org/package/text}{text}, \footnotehref{http://hackage.haskell.org/package/conduit}{conduit} и \footnotehref{http://hackage.haskell.org/package/attoparsec}{attoparsec}. С точки зрения пользователя он предоставляет всё, начиная с простейших API (\lstinline!readFile!/\lstinline!writeFile!) и заканчивая полным контролем над потоками событий XML.

В дополнение к \lstinline!xml-conduit!, есть ещё несколько связанных пакетов, например, \footnotehref{http://hackage.haskell.org/package/xml-hamlet}{xml-hamlet} и \footnotehref{http://hackage.haskell.org/package/xml2html}{xml2html}. Мы рассмотрим и как их использовать, и когда это следует делать.

\section{Краткое содержание} % Synopsis
\begin{lstlisting}[language=XML, caption={Входной XML файл}]
<document title="My Title">
    <para>This is a paragraph. It has <em>emphasized</em> and <strong>strong</strong> words.</para>
    <image href="myimage.png"/>
</document>
\end{lstlisting}

\includecode[caption={Код на Haskell}]{27/synopsis.hs}

 % XHTML для lstlisting неизвестен
\begin{lstlisting}[language=HTML, caption={Выходные данные в формате XHTML}]
<?xml version="1.0" encoding="UTF-8"?>
<html>
    <head>
        <title>
            My Title
        </title>
    </head>
    <body>
        <p>
            This is a paragraph. It has
            <i>
                emphasized
            </i>
            and
            <b>
                strong
            </b>
            words.
        </p>
        <img src="myimage.png"/>
    </body>
</html>
\end{lstlisting}

\section{Типы} % Types

Воспользуемся восходящим подходом для анализа типов. Помимо прочего, этот раздел будет служить введением в саму модель данных XML, так что не беспокойтесь, если вы не вполне знакомы с ней.

Я думаю, первое место, где Haskell по-настоящему показывает свою силу, это тип данных \footnotehref{http://hackage.haskell.org/packages/archive/xml-types/latest/doc/html/Data-XML-Types.html\#t:Name}{\lstinline!Name!}. Многие языки программирования (например, Java) испытывают трудности с выразительным представлением имён в XML. Проблема заключается в том, что на самом деле эти имена состоят из трёх частей: локального имени, пространства имён (необязательно) и префикса (также необязательно). Для наглядности рассмотрим следующий кусок XML-документа:
\begin{lstlisting}[language=XML]
<no-namespace/>
<no-prefix xmlns="first-namespace" first-attr="value1"/>
<foo:with-prefix xmlns:foo="second-namespace" foo:second-attr="value2"/>
\end{lstlisting}

Первый тег имеет локальное имя \lstinline!no-namespace!, не имеет префикса и не принадлежит какому-либо пространству имён. Второй тег (с локальным именем \lstinline!no-prefix!) \emph{также} не имеет префикса, но он принадлежит пространству имён~\lstinline!first-namespace!. Однако, атрибут~\lstinline!first-attr! не наследует это пространство имён: пространства имён атрибутов всегда должны точно задаваться с помощью префикса.

\begin{remark}
Пространства имён почти всегда представляют собой своего рода URI, хотя ничего подобного не требуется ни в одной спецификации.
\end{remark}

Третий тег имеет локальное имя~\lstinline!with-prefix!, префикс~\lstinline!foo! и принадлежит пространству имён~\lstinline!second-namespace!. Его атрибут имеет локальное имя~\lstinline!second-attr!, имеет тот же префикс и принадлежит тому же пространству имён. Атрибуты~\lstinline!xmlns! и~\lstinline!xmlns:foo! являются частью спецификации пространства имён и не рассматриваются в качестве атрибутов соответствующих элементов.

Ещё раз: из чего состоит имя? Из локального имени, а также необязательных префикса и пространства имён. Похоже на подходящий случай для применения записей:
\begin{lstlisting}
data Name = Name
    { nameLocalName :: Text
    , nameNamespace :: Maybe Text
    , namePrefix :: Maybe Text
    }
\end{lstlisting}

Согласно стандарту пространств имён в XML, два имени считаются эквивалентными, если они имеют одинаковое локальное имя и принадлежат одному пространству имён. Другими словами, префикс неважен. Потому в пакете \lstinline!xml-types! определены экземпляры классов \lstinline!Eq! и \lstinline!Ord!, игнорирующие префиксы.

Последний экземпляр класса типов, который стоит упомянуть,~--- это \lstinline!IsString!. Было бы очень утомительно печатать \lstinline!Name "p" Nothing Nothing! каждый раз, когда нам нужен новый параграф. Если вы включите расширение \lstinline!OverloadedStrings!, \lstinline!"p"! будет преобразовываться во всё это хозяйство самостоятельно! Кроме того, экземпляр \lstinline!IsString! распознаёт так называемою нотацию Кларка, которая позволяет использовать в именах префикс с пространством имён в фигурных скобках. Другими словами:
\begin{lstlisting}
"{namespace}element" == Name "element" (Just "namespace") Nothing
"element" == Name "element" Nothing Nothing
\end{lstlisting}

\subsection{Четыре типа узлов} % The Four Types of Nodes
XML-документы представляют собой дерево вложенных узлов. По факту, существует четыре различных типа узлов~--- элементы, содержимое (то есть, текст), комментарии, а также инструкции по обработке (processing instructions).

\begin{remark}
Вероятно, вы не знакомы с последними, поскольку они используются довольно редко. Инструкции по обработке обозначаются следующим образом:
\begin{lstlisting}[language=XML]
<?target data?>
\end{lstlisting}

Есть два удивительных факта об инструкциях по обработке:
\begin{itemize}
\item Инструкции по обработке не имеют атрибутов. Несмотря на то, что вам могут попасться инструкции, имеющие атрибуты, на самом деле не существует никаких правил относительно этих данных в инструкциях.
\item Строка <?xml ...?> в начале документам не является инструкцией по обработке. Это просто начало документа (также известное, как объявление XML), и, так получилось, что оно выглядит поразительно похожим на инструкции по обработке. Разница заключается в том, что строка <?xml ...?> не появится в разобранных данных.
\end{itemize}

\end{remark}

Учитывая, что каждая инструкция имеет два фрагмента текста, связанных с ней (target и data), получается очень простой тип данных:
\begin{lstlisting}
data Instruction = Instruction
    { instructionTarget :: Text
    , instructionData :: Text
    }
\end{lstlisting}

Для комментариев нет специального типа, потому что они представляют собой обычный текст. Зато содержимое куда интереснее~--- оно может состоять из простого текста или неразрешённых сущностей (например,~\lstinline!&copyright-statement;!). Пакет \footnotehref{http://hackage.haskell.org/package/xml-types}{xml-types} оставляет эти сущности неразрешёнными во всех типах данных, чтобы полностью соответствовать спецификации. Однако, на практике может быть очень трудно работать с такими типами данных. И, в большинстве случаев, неразрешённая сущность в конечном итоге приведёт к возникновению ошибки.

По этой причине модуль \footnotehref{http://hackage.haskell.org/packages/archive/xml-conduit/latest/doc/html/Text-XML.html}{Text.XML} определяет собственный набор типов данных для узлов, элементов и документов, в которых удаляются все неразрешённые сущности. Если вам нужно работать с неразрешёнными сущностями, используйте модуль \footnotehref{http://hackage.haskell.org/packages/archive/xml-conduit/latest/doc/html/Text-XML-Unresolved.html}{Text.XML.Unresolved}. Начиная с этого момента, мы сосредоточимся на типах данных модуля \lstinline!Text.XML!, которые, впрочем, почти идентичны версиям из пакета \lstinline!xml-types!.

В общем, заканчивая лирическое отступление: содержимое представляет собой обычный текст, и потому у него также нет специального типа данных. Последним типом узлов является элемент, который состоит из имени, списка атрибутов и списка дочерних узлов. Каждый атрибут состоит из двух частей~--- имени и значения. (В пакете \lstinline!xml-types! значение атрибута также может содержать неразрешённые сущности.) Итак, тип \lstinline!Element! определён следующим образом:
\begin{lstlisting}
data Element = Element
    { elementName :: Name
    , elementAttributes :: Map Name Text
    , elementNodes :: [Node]
    }
\end{lstlisting}

Возникает закономерный вопрос~--- а как должен выглядеть тип данных~\lstinline!Node!? Вот где Haskell по-настоящему показывает себя с лучшей стороны: его типы-суммы идеально представляют модель данных XML.

\begin{lstlisting}
data Node
    = NodeElement Element
    | NodeInstruction Instruction
    | NodeContent Text
    | NodeComment Text
\end{lstlisting}

\subsection{Документы}
Итак, у нас есть элементы и узлы, но как насчёт целых документов? Рассмотрим следующие типы данных:
\begin{lstlisting}
data Document = Document
    { documentPrologue :: Prologue
    , documentRoot :: Element
    , documentEpilogue :: [Miscellaneous]
    }

data Prologue = Prologue
    { prologueBefore :: [Miscellaneous]
    , prologueDoctype :: Maybe Doctype
    , prologueAfter :: [Miscellaneous]
    }

data Miscellaneous
    = MiscInstruction Instruction
    | MiscComment Text

data Doctype = Doctype
    { doctypeName :: Text
    , doctypeID :: Maybe ExternalID
    }

data ExternalID
    = SystemID Text
    | PublicID Text Text
\end{lstlisting}

В спецификации XML сказано, что документ может иметь только один корневой элемент (\lstinline!documentRoot!). Он также может содержать необязательное объявление типа документа (doctype). И тип документа, и корневой элемент разрешается окружать комментариями и инструкциями по обработке. (Также разрешены пробелы, но они игнорируются во время разбора.)

Так что там насчёт типа документа? Он определяет корневой элемент документа, а затем, необязательно, публичный (public) и системный (system) идентификаторы. Эти идентификаторы используются для ссылок на DTD-файлы, которые предоставляют больше информации о документе (например, правила валидации, атрибуты по умолчанию, разрешения сущностей). Рассмотрим несколько примеров:
\begin{lstlisting}[language=HTML]
<!DOCTYPE root> <!-- no external identifier -->
<!DOCTYPE root SYSTEM "root.dtd"> <!-- a system identifier -->
<!DOCTYPE root PUBLIC "My Root Public Identifier" "root.dtd"> <!-- public identifiers have a system ID as well -->
\end{lstlisting}

Это, друзья мои, и есть вся модель данных XML. На практике, в большинстве случаев вы можете просто игнорировать тип данных \lstinline!Document! и переходить сразу к \lstinline!documentRoot!.

\subsection{События} % Events
В дополнение к API для работы с документами пакет \lstinline!xml-types! также определяет тип данных \footnotehref{http://hackage.haskell.org/packages/archive/xml-types/latest/doc/html/Data-XML-Types.html\#t:Event}{\lstinline!Event!}. Он может быть использован для конструирования поточных инструментов, которые могут потреблять намного меньше оперативной памяти при решении определённых задач обработки (например, добавления нового атрибута всем элементам). Сейчас мы не будем рассматривать соответствующий API, однако, если вы посмотрите на него после прочтения этой главы, он наверняка покажется вам очень знакомым.

\begin{remark}
Вы можете найти пример использования <<поточного>> API в \hyperref[chap:sphinx]{главе 21, посвящённой работе со Sphinx}.
\end{remark}

\section{Модуль Text.XML}
Рекомендуемой точкой входа в пакет xml-conduit является модуль \footnotehref{http://hackage.haskell.org/packages/archive/xml-conduit/latest/doc/html/Text-XML.html}{Text.XML}. Этот модуль экспортирует все типы данных, которые могут вам потребоваться для манипулирования XML в DOM-стиле (Document Object Model, объектная модель документа), а также предоставляет несколько подходов к разбору и рендеренгу XML-документов. Начнём с простого:
\begin{lstlisting}
readFile :: ParseSettings -> FilePath -> IO Document
writeFile :: RenderSettings -> FilePath -> Document -> IO ()
\end{lstlisting}

Здесь вы видите типы данных \lstinline!ParseSettings! и \lstinline!RenderSettings!. Вы можете использовать их для изменения поведения парсера или рендерера, например, добавления сущностей или включения форматированного (то есть, с отступами) вывода. Оба типа являются экземплярами класса типов \footnotehref{http://hackage.haskell.org/packages/archive/data-default/latest/doc/html/Data-Default.html\#t:Default}{\lstinline!Default!}, так что вы можете просто использовать функцию \lstinline!def! в тех случаях, когда требуется предоставить значение одного из них. Собственно, так мы и собираемся поступать в оставшейся части этой главы. Дополнительную информацию вы можете найти в документации на Hackage.

Следует также отметить, что в дополнение к API для работы с файлами также имеются API для работы с текстом и байтовыми строками (bytestring). В функциях для работы с байтовыми строками реализовано интеллектуальное определение кодировки. Поддерживаются кодировки UTF-8, UTF-16 и UTF-32, с прямым (little endian) и обратным (big endian) порядком байт, как с BOM (Byte-Order Marker), так и без него. Весь вывод генерируется в UTF-8.

Для сложных выборок данных по XML-документам мы рекомендуем использовать API более высокого уровня для работы с курсорами. Стандартный API модуля \lstinline!Text.XML! не только формирует базис для этого более высокого уровня. Он также предоставляет отличный API для простого преобразования и генерации XML. Пример его использования вы можете найти в разделе <<Краткое содержание>> этой главы.

\subsection{Замечание относительно путей к файлам}
В приведённых выше сигнатурах функций вы видели тип \lstinline!FilePath!. Однако \emph{это не Prelude.FilePath}. В модуле \lstinline!Prelude! определяется синоним \lstinline!type FilePath = [Char]!. К сожалению, данный подход имеет множество ограничений, включая неопределённость кодировки имени файла, а также возможность использования различных символов в качестве разделителей в пути.

Вместо этого в \lstinline!xml-conduit! используется пакет \footnotehref{http://hackage.haskell.org/package/system-filepath}{system-filepath}, в котором определяется абстрактный тип \lstinline!FilePath!. Я лично нахожу такой подход более удобным. Пакет очень прост в использовании, так что здесь я не буду останавливаться на деталях. Вместо этого я приведу лишь краткие пояснения относительно его использования:
\begin{itemize}
\item Поскольку \lstinline!FilePath! является экземпляром класса \lstinline!IsString!, вы можете вводить обычные строки и они будут интерпретированы правильно, если активировано расширение \lstinline!OverloadedStrings!. (Я настоятельно рекомендую использовать его в любом случае, поскольку это делает работу со значениями типа \lstinline!Text! намного приятнее.)
\item Если вам требуется явное преобразование в или из \lstinline!FilePath! модуля \lstinline!Prelude!, вы должны использовать функции \footnotehref{http://hackage.haskell.org/packages/archive/system-filepath/latest/doc/html/Filesystem-Path-CurrentOS.html\#v:encodeString}{\lstinline!encodeString!} или \footnotehref{http://hackage.haskell.org/packages/archive/system-filepath/latest/doc/html/Filesystem-Path-CurrentOS.html\#v:decodeString}{\lstinline!decodeString!}, соответственно. Эти функции корректно обрабатывают кодировка пути к файлу.
\item Вместо того, чтобы вручную соединять имена директорий, имена файлов и их расширения, используйте операторы из модуля \lstinline!Filesystem.Path.CurrentOS!, например \lstinline!myfolder </> filename <.> extension!.
\end{itemize}
  
\section{Курсоры}
Допустим, вы хотите получить заголовок (title) из XHTML-документа. Вы можете сделать это с помощью интерфейса модуля~\lstinline!Text.XML!, который мы только что изучили, используя стандартное сопоставление с образцом потомков элементов. Но работа над программой с использованием этого подхода очень быстро станет утомительной. Вероятно, золотым стандартом для такого типа поиска является XPath, который позволяет вам обращаться к элементам, используя пути типа~\lstinline!/html/head/title!. Именно XPath вдохновил дизайн комбинаторов из модуля \footnotehref{http://hackage.haskell.org/packages/archive/xml-conduit/latest/doc/html/Text-XML-Cursor.html}{Text.XML.Cursor}.

Курсор представляет собой узел, который помнит своё положение в дереве; он может перемещаться вверх, в сторону или вниз. (Это реализовано с помощью приёма \footnotehref{http://www.haskell.org/haskellwiki/Tying\_the\_Knot}{"завязывание узлов"}.) Есть две функции, позволяющие преобразовывать типы модуля \lstinline!Text.XML! в курсоры~--- \lstinline!fromDocument! и~\lstinline!fromNode!.

Также имеется концепция оси (axis), определённой в виде \lstinline!type Axis = Cursor -> [Cursor]!. Проще всего понять эту концепцию на примере. Функция~\lstinline'child' возвращает список из нуля или более курсоров, которые являются потомками текущего курсора. Функция~\lstinline'parent' возвращает единственный родительский курсор входного курсора или пустой список для корневого элемента. И так далее.

Некоторые оси используют предикаты. Функция~\lstinline!element! обычно используется для фильтрации элементов по имени. Например, \lstinline!element "title"! вернёт входной элемент только в том случае, если он имеет имя "title", иначе будет возвращён пустой список.

Ещё одна функция, которая не вполне является осью, это \lstinline!content :: Cursor -> [Text]!. Для всех узлов с неким содержимым она возвращает содержимый текст, иначе возвращается пустой список.

Благодаря тому, что списки являются монадами, не составляет труда объединить всё вышесказанное воедино. Например, следующая программа предназначена для поиска заголовка XHTML-документа:

\includecode{27/cursor.hs}

В переводе на русский это значит:
\begin{itemize}
\item Найти все дочерние узлы корневого элемента.
\item Отфильтровать элементы, оставив лишь элементы с именем <<head>>.
\item Найти всех потомков (child) элементов, полученных на предыдущем шаге.
\item Отфильтровать элементы, оставив лишь элементы с именем <<title>>.
\item Найти всех наследников (descendant) полученных элементов. (Наследник~--- это потомок или наследник потомка. Да, это рекурсивное определение.)
\item Оставить только текстовые узлы.
\end{itemize}

Таким образом для входного документа:

\begin{lstlisting}[language=HTML]
<html>
    <head>
        <title>My <b>Title</b></title>
    </head>
    <body>
        <p>Foo bar baz</p>
    </body>
</html>
\end{lstlisting}

Мы получим в результате <<My Title>>. Это всё, конечно, здорово и замечательно, но вообще-то тут намного больше кода, чем в случае использования XPath. Для борьбы с этой многословностью Aristid Breitkreuz добавил в модуль Cursor набор операторов для обработки большинства случаев. С их помощью мы можем переписать наш пример следующим образом:

\includecode{27/cursor-operator.hs}

Оператор \lstinline!$/! применяет ось справа к потомкам (children) курсора слева. Оператор \lstinline!&/! практически идентичен, только используется он для комбинирования двух осей. Это общее правило в модуле \lstinline!Text.XML.Cursor!: операторы, начинающиеся со знака \$, напрямую применяют ось, а начинающиеся со знака \& объединяют две оси. Оператор \lstinline!&//! используется для применения оси ко всем наследникам (descendants).

Рассмотрим более сложный (или более надуманный?) пример. Имеется следующий документ:

\begin{lstlisting}[language=HTML]
<html>
    <head>
        <title>Headings</title>
    </head>
    <body>
        <hgroup>
            <h1>Heading 1 foo</h1>
            <h2 class="foo">Heading 2 foo</h2>
        </hgroup>
        <hgroup>
            <h1>Heading 1 bar</h1>
            <h2 class="bar">Heading 2 bar</h2>
        </hgroup>
    </body>
</html>
\end{lstlisting}

Мы хотим получить содержимое всех тегов \lstinline!h1!, которые предшествуют тегу \lstinline!h2! с атрибутом \lstinline!class!, имеющим значение <<bar>>. Для выполнения этого запутанного поиска мы можем написать:

\includecode{27/cursor-h1.hs}

Давайте попробуем разобраться, что здесь происходит. Сначала мы получаем все элементы h2 в документе. (Оператор \lstinline!$//! получает всех наследников корневого элемента.) Из них мы оставляем только те, что имеют атрибут~\lstinline!class! со значением <<bar>>. Оператор \lstinline!>=>! на самом деле является стандартным оператором из модуля \footnotehref{http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Monad.html}{\lstinline!Control.Monad!}; вот ещё одно преимущество того, что списки являются монадами. Функция~\lstinline!precedingSibling! находит все узлы, что идут перед заданным \emph{и} имеют с ним общего родителя. (Имеется также ось \lstinline!preceding!, которая принимает все предыдущие элементы в дереве.) Затем мы просто берём все элементы \lstinline!h1! и получаем их содержимое.

\begin{remark}
Эквивалентный XPath, для сравнения, будет \lstinline!//h2[@class ='bar']/preceding-sibling::h1//text()!.
\end{remark}

Хоть API курсоров и уступает XPath в краткости, зато он является стандартным кодом на Haskell и обеспечивает безопасность типов.

\section{Пакет xml-hamlet}
Благодаря простоте системы типов языка Haskell, создание XML-документов с помощью API модуля \lstinline!Text.XML! является крайне простым, хотя и несколько многословным. Следующий код:

\includecode{27/xml.hs}

... генерирует:

\begin{lstlisting}[language=XML]
<?xml version="1.0" encoding="UTF-8"?>
<html><head><title>My <b>Title</b></title></head><body><p>foo bar baz</p></body></html>
\end{lstlisting}

Это во много раз проще, чем использовать императивный API с изменяемыми состояниями (как, кхм, в Java), но всё же далеко от идеала, и к тому же делает неясными наши настоящие намерения. Для исправления ситуации у нас есть пакет \footnotehref{http://hackage.haskell.org/package/xml-hamlet}{xml-hamlet}, который использует квазицитирование и позволяет вводить XML, используя естественный синтаксис. Например, предыдущий пример может быть переписан так:

\includecode{27/xml-hamlet.hs}

Тут нужно обратить внимание на следующее:
\begin{itemize}
  \item Синтаксис практически идентичен Hamlet, если не считать отсутствия интерполяции URL (@{...}). Таким образом:
    \begin{itemize}
      \item Закрывающие теги не нужны.
      \item Имеет место чувствительность к пробелам.
      \item Если вам нужны пробелы в конце строки, используйте на конце \#. В начале строки используйте обратную косую черту.
    \end{itemize}
  
  \item XML-интерполяция возвращает список узлов. Поэтому вам потребуется оборачивать результат в обычную конструкцию из~\lstinline!Document! и корневого~\lstinline!Element!.
  \item Нет поддержки специальных атрибутов \lstinline!.class! и~\lstinline!#id!.
\end{itemize}

Как и в обычном Hamlet, вы можете использовать интерполяцию переменных и управляющие структуры. Рассмотрим это на чуть более сложном примере:

\includecode{27/xml-hamlet-vars.hs}

Ещё пара моментов:
\begin{itemize}
\item Caret-интерполяция (\verb'^{...}') принимает список узлов и, следовательно, может с лёгкостью включать другие xml-цитаты.
\item В отличие от Hamlet, hash-интерполяция (\verb'#{...}') не является полиморфной и может принимать \emph{только} значения типа~\lstinline!Text!.
\end{itemize}

\section{Пакет xml2html}
До сих пор в этой главе наши примеры вращались вокруг XHTML. Я делал это по той простой причине, что XHTML, скорее всего, окажется наиболее знакомой формой XML для большинства читателей. Но в этом есть и отрицательный момент, который следует признать: не всякий XHTML является корректным HTML. Существуют следующие расхождения:
\begin{itemize}
\item Некоторые <<пустые>> HTML-теги (например, \lstinline!img!, \lstinline!br!) не обязаны иметь парные закрывающие теги, и вообще-то не имеют права их иметь.
\item HTML не понимает самозакрывающиеся теги, поэтому \lstinline!<script></script>! и \lstinline!<script/>! означают разные вещи.
\item Объединяя два предыдущих пункта: <<пустые>> теги могут быть самозакрывающимися, однако это ничего не значит для браузера.
\item Во избежание недоразумений, HTML-документы следует начинать с инструкции~\lstinline!DOCTYPE!.
\item XML-объявление \lstinline!<?xml ...?>! не нужно в HTML-страницах.
\item В HTML нам не нужны пространства имён, в то время, как XHTML полон ими.
\item Содержимое тегов \lstinline!<style>! и \lstinline!<script>! не должно экранироваться. % В XHTML или HTML?
\end{itemize}

И вот здесь в игру вступает пакет~\texttt{xml2html}. Он предоставляет экземпляры класса \lstinline!ToHtml! для типов \lstinline!Node!, \lstinline!Document! и~\lstinline!Element!. Для их использования просто импортируйте модуль~\lstinline'Text.XML.Xml2Html'.

\includecode{27/xml2html.hs}

Выводит (пробелы добавлены вручную):

\begin{lstlisting}[language=HTML]
<!DOCTYPE HTML>
<html>
    <head>
        <title>Test</title>
        <script>if (5 < 6 || 8 > 9) alert("Hello World!");</script>
        <style>body > h1 { color: red }</style>
    </head>
    <body>
        <h1>Hello World!</h1>
    </body>
</html>
\end{lstlisting}%$
