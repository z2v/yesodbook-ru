\chapter{xml-conduit}

%TODO: перевести both a streaming and DOM-based approach во втором абзаце

Многих разработчиков трясет от одной только мысли о работе с XML файлами. XML имеет репутацию формата, имеющего излишне усложненную модель данных, запутанные библиотеки и толстый слой сложностей, находящихся между разработчиком и его целью. Но я смею заверить, что многое из этого относятся скорее к проблемам языков программирования и библиотек, чем формата XML.

Как я уже отмечал, система типов языка Haskell позволяет нам с легкостью свести любую проблему к ее самой базовой форме. Пакет xml-types аккуратно предобразует модель данных XML (both a streaming and DOM-based approach) в простые АТД. Стандартные неизменяемые структуры данных языка Haskell упрощают преобразование документов, а простой набор функций делает их парсинг и рендеринг легкими и непренужденными. % a simple set of functions makes parsing and rendering a breeze.

Рассмотрим пакет xml-conduit. Под его капотом используется множество подходов, которые Yesod обычно применяет для высокой производительности: blaze-builder, text, conduit и attoparsec. С точки зрения пользователя он предоставляет все, начиная с простейших API (readFile/writeFile) и заканчивая полным контролем над потоками событий XML.

В дополнение к xml-conduit, в игру вступает еще несколько связанных пакетов, например xml-hamlet и xml2html. Мы рассмотрим, как должны использоваться эти пакеты, а также когда это следует делать.

\section{Краткое содержание} % Synopsis

Входной XML файл:

\begin{lstlisting}[language=XML]
<document title="My Title">
    <para>This is a paragraph. It has <em>emphasized</em> and <strong>strong</strong> words.</para>
    <image href="myimage.png"/>
</document>
\end{lstlisting}

Код на Haskell:

\begin{lstlisting}
{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE OverloadedStrings #-}
import Prelude hiding (readFile, writeFile)
import Text.XML
import Text.Hamlet.XML

main :: IO ()
main = do
    -- readFile will throw any parse errors as runtime exceptions
    -- def uses the default settings
    Document prologue root epilogue <- readFile def "input.xml"

    -- root is the root element of the document, let's modify it
    let root' = transform root

    -- And now we write out. Let's indent our output
    writeFile def
        { rsPretty = True
        } "output.html" $ Document prologue root' epilogue

-- We'll turn out <document> into an XHTML document
transform :: Element -> Element
transform (Element _name attrs children) = Element "html" [] [xml|
<head>
    <title>
        $maybe title <- lookup "title" attrs
            \#{title}
        $nothing
            Untitled Document
<body>
    $forall child <- children
        ^{goNode child}
|]

goNode :: Node -> [Node]
goNode (NodeElement e) = [NodeElement $ goElem e]
goNode (NodeContent t) = [NodeContent t]
goNode (NodeComment _) = [] -- hide comments
goNode (NodeInstruction _) = [] -- and hide processing instructions too

-- convert each source element to its XHTML equivalent
goElem :: Element -> Element
goElem (Element "para" attrs children) =
    Element "p" attrs $ concatMap goNode children
goElem (Element "em" attrs children) =
    Element "i" attrs $ concatMap goNode children
goElem (Element "strong" attrs children) =
    Element "b" attrs $ concatMap goNode children
goElem (Element "image" attrs _children) =
    Element "img" (map fixAttr attrs) [] -- images can't have children
  where
    fixAttr ("href", value) = ("src", value)
    fixAttr x = x
goElem (Element name attrs children) =
    -- don't know what to do, just pass it through...
    Element name attrs $ concatMap goNode children
\end{lstlisting}%$

Выходные данные в формате XHTML:

\begin{lstlisting}[language=XML] % XHTML для lstlisting неизвестен
<?xml version="1.0" encoding="UTF-8"?>
<html>
    <head>
        <title>
            My Title
        </title>
    </head>
    <body>
        <p>
            This is a paragraph. It has 
            <i>
                emphasized
            </i>
            and 
            <b>
                strong
            </b>
            words.
        </p>
        <img src="myimage.png"/>
    </body>
</html>
\end{lstlisting}

\section{Типы} % Types

Воспользуемся восходящим подходом для анализа типов. Также этот раздел будет служить введением в саму модель данных XML, так что не беспокойтесь, если вы не вполне знакомы с ней.

Я думаю, первое место, где Haskell по-настоящему показывает свою силу, это тип данных xml-types:Data.XML.Types:Name. Многие языки программирования (например Java) сопротявляются введению выразительных имен. Проблема заключается в том, что на самом деле имя состоит из трех частей: локального имени, пространства имен (опционально), а также префикса (также опционально). Для наглядности рассмотрим следующий кусок XML документа:

\begin{lstlisting}[language=XML]
<no-namespace/>
<no-prefix xmlns="first-namespace" first-attr="value1"/>
<foo:with-prefix xmlns:foo="second-namespace" foo:second-attr="value2"/>
\end{lstlisting}

Первый тэг имеет локальное имя no-namespace, но не имеет префикса и не принадлежит пространству имен. Второй тэг (с локальным именем no-prefix) также не имеет префикса, но он принадлежит пространству имен first-namespace. Однако first-attr не наследует это пространство имен: пространства имен атрибутов всегда должны точно задаваться с помощью префикса.

\begin{remark}
Пространства имен почти всегда представляют собой своего рода URI, хотя ничего подобного не требуется ни в одной спецификации.
\end{remark}

Трегий тэг имеет локальное имя with-prefix, префикс foo и принадлежит пространству имен second-namespace. Его атрибут имеет локальное имя second-attr, имеет тот же префикс и принадлежит тому же пространству имен. Атрибуты xmlns и xmlns:foo являются частью спецификации пространства имен и не рассматриваются в качестве атрибутов соответствующих элементов.

Итак, из чего состоит имя? Каждое имя имеет локальное имя, а также опциональные префикс и пространство имен. Похоже на подходящий случай для применения записей:

\begin{lstlisting}
data Name = Name
    { nameLocalName :: Text
    , nameNamespace :: Maybe Text
    , namePrefix :: Maybe Text
    }
\end{lstlisting}

Согласно стандарту пространств имен в XML, два имени считаются эквивалентными, если они имеют одинаковое локальное имя и принадлежат одному пространству имен. Другими словами, префикс неважен. Потому в пакете xml-types определены экземпляры классов Eq и Ord, игнорирующие префиксы.

Последний экземпляр класса, который следует упомянуть, это IsString. Было бы очень утомительно печатать Name "p" Nothing Nothing каждый раз, когда нам нужен новый параграф. Если вы включите OverloadedStrings, "p" будет преобразовываться во все это хозяйство самостоятельно! Кроме того, экземлпяр IsString распознает нечто, называемое нотацией Кларка, что позволяет вам использовать в именах префикс с пространством имен в фигурных скобочках. Другими словами:

\begin{lstlisting}
"{namespace}element" == Name "element" (Just "namespace") Nothing
"element" == Name "element" Nothing Nothing
\end{lstlisting}

\section{Четыре типа узлов} % The Four Types of Nodes

XML-документы представляют собой дерево вложенных узлов. В действительности существует четыре различных типа узлов --- элементы, содержание (например, текст), комментарии, а также инструкции по обработке (processing instructions).

\begin{remark}
Вероятно, вы не знакомы с последними, поскольку они используются довольно редко. Они обозначаются следующим образом:

\begin{lstlisting}[language=XML]
<?target data?>
\end{lstlisting}

Есть два удивительных факта об инструкциях по обработке:

\begin{itemize}
\item Инструкции по обработке не имеют атрибутов. Несмотря на то, что вам могут попастся инструкции, имеющие атрибуты, на самом деле не существует никаких правил относительно этих данных в инструкциях. % While often times you'll see processing instructions that appear to have attributes, there are in fact no rules about that data of an instruction.
\item <?xml ...?> не является инструкцией по обработке. Это просто начало документа (также известное, как объявление XML), и так получилось, что оно выглядит поразительно похожим на инструкции по обработке. Разница заключается в том, что строка <?xml ...?> не появится в разобранных данных (parsed content).
\end{itemize}

\end{remark}

Учитывая, что инструкции имеют два куска текста, связанных с ним (target и data), получает очень простой тип данных:

\begin{lstlisting}
data Instruction = Instruction
    { instructionTarget :: Text
    , instructionData :: Text
    }
\end{lstlisting}

Комментариям не соответствует специального типа данных, потому что они представляют собой обычный текст. Зато содержание (content) куда интереснее --- оно может состоять из простого текста и неразрешенных сущностей (например, \&copyright-statement;). Пакет xml-types оставляет эти сущности неразрешенными во всех типах данных, чтобы полностью соответствовать спецификации. Однако на практике может быть очень трудно работать с такими типами данных. И в большинстве случаев неразрешенная сущность в конечном итоге приведет к возникновению ошибки.

По этой причине модуль xml-conduit:Text.XML определяет собственный набор типов данных для узлов, элементов и документов, в которых удаляются все неразрешенные сущности. Если вам нужно работать с неразрешенными сущностями, используйте модуль xml-conduit:Text.XML.Unresolved. Начиная с этого момента мы сосредоточимся на типах данных модуля Text.XML, поскольку они почти идентичны версиям из пакета xml-types.

В связи с вышесказанным, содержание также представляет собой обычный текст и потому у него также нет специального типа данных. Последним типом узлов является элемент, который состоит из имени, списка атрибутов и списка дочерних узлов. Атрибут состоит из двух частей - имени и значения. (В пакете xml-types, значение также может содержать неразрешенные сущности.) Итак, определим Element следующим образом:

\begin{lstlisting}
data Element = Element
    { elementName :: Name
    , elementAttributes :: [(Name, Text)]
    , elementNodes :: [Node]
    }
\end{lstlisting}

Возникает закономерный вопрос --- а как долже нвыглядеть тип данных Node? Вот где Haskell по-настоящему рулит: % This is where Haskell really shines: its sum types model the XML data model perfectly.

\begin{lstlisting}
  data Node
    = NodeElement Element
    | NodeInstruction Instruction
    | NodeContent Text
    | NodeComment Text
\end{lstlisting}

\section{Документы} % Documents

Итак, у нас есть элементы и узлы, но как на счет целых документов? Рассмотрим следующие типы данных: % Let's just lay out the datatypes:

\begin{lstlisting}
data Document = Document
    { documentPrologue :: Prologue
    , documentRoot :: Element
    , documentEpilogue :: [Miscellaneous]
    }

data Prologue = Prologue
    { prologueBefore :: [Miscellaneous]
    , prologueDoctype :: Maybe Doctype
    , prologueAfter :: [Miscellaneous]
    }

data Miscellaneous
    = MiscInstruction Instruction
    | MiscComment Text

data Doctype = Doctype
    { doctypeName :: Text
    , doctypeID :: Maybe ExternalID
    }

data ExternalID
    = SystemID Text
    | PublicID Text Text
\end{lstlisting}

В спецификации XML сказано, что документ может иметь только один корневой элемент (documentRoot). Он также может содержать опциональное объявление типа документа (doctype. Перед и после как типа документа, так и корневого элемента, разрешается иметь комментарии и инструкции по обработке. (Также можно иметь пробелы, но они и так игнорируются во время парсинга.)

Так что там на счет типа документа? Он определяет корневой элемент документа, а затем, опционально, публичный (public) и системый (system) идентификаторы. Они используются для ссылок на DTD-файлы, которые предоставляют больше информации о файле (например, правила валидации, атрибуты по-умолчанию, разрешения сущностей). Рассмотрим несколько примеров:

\begin{lstlisting}[language=HTML]
<!DOCTYPE root> <!-- no external identifier -->
<!DOCTYPE root SYSTEM "root.dtd"> <!-- a system identifier -->
<!DOCTYPE root PUBLIC "My Root Public Identifier" "root.dtd"> <!-- public identifiers have a system ID as well -->
\end{lstlisting}

Это, друзья мои, и есть вся модель данных XML. На практике, в большинстве случаев вы можете просто игнорировать тип данных Document и переходить сразу к documentRoot.

\section{События} % Events

In addition to the document API, xml-types defines an xml-types:Data.XML.Types:Event datatype. This can be used for constructing streaming tools, which can be much more memory efficient for certain kinds of processing (eg, adding an extra attribute to all elements). We will not be covering the streaming API currently, though it should look very familiar after analyzing the document API.

\begin{remark}
You can see an example of the streaming API in the Sphinx case study.
\end{remark}

\section{Text.XML}

The recommended entry point to xml-conduit is the xml-conduit:Text.XML module. This module exports all of the datatypes you'll need to manipulate XML in a DOM fashion, as well as a number of different approaches for parsing and rendering XML content. Let's start with the simple

\begin{lstlisting}
ones:readFile :: ParseSettings  -> FilePath -> IO Document
writeFile :: RenderSettings -> FilePath -> Document -> IO ()
\end{lstlisting}

This introduces the ParseSettings and RenderSettings datatypes. You can use these to modify the behavior of the parser and renderer, such as adding character entities and turning on pretty (i.e., indented) output. Both these types are instances of the data-default:Data.Default:Default typeclass, so you can simply use def when these need to be supplied. That is how we will supply these values through the rest of the chapter; please see the API docs for more information.

It's worth pointing out that in addition to the file-based API, there is also a text- and bytestring-based API. The bytestring-powered functions all perform intelligent encoding detections, and support UTF-8, UTF-16 and UTF-32, in either big or little endian, with and without a Byte-Order Marker (BOM). All output is generated in UTF-8.

For complex data lookups, we recommend using the higher-level cursors API. The standard Text.XML API not only forms the basis for that higher level, but is also a great API for simple XML transformations and for XML generation. See the synopsis for an example.

\section{Замечание относительно путей к файлам} % A note about file paths

In the type signature above, we have a type FilePath. However, {\bf this isn't Prelude.FilePath}. The standard Prelude defines a type synonym type FilePath = [Char]. Unfortunately, there are many limitations to using such an approach, including confusion of filename character encodings and differences in path separators.

Instead, xml-conduit uses the system-filepath package, which defines an abstract FilePath type. I've personally found this to be a much nicer approach to work with. The package is fairly easy to follow, so I won't go into details here. But I do want to give a few quick explanations of how to use it:

\begin{itemize}
\item Since a FilePath is an instance of IsString, you can type in regular strings and they will be treated properly, as long as the OverloadedStrings extension is enabled. (I highly recommend enabling it anyway, as it makes dealing with Text values much more pleasant.)
\item If you need to explicitly convert to or from Prelude's FilePath, you should use the encodeString and decodeString, respectively. This takes into account file path encodings.
\item Instead of manually splicing together directory names and file names with extensions, use the operators in the Filesystem.Path.CurrentOS module, e.g. myfolder </> filename <.> extension.
\end{itemize}
  
\section{Курсор} % Cursor

Suppose you want to pull the title out of an XHTML document. You could do so with the Text.XML interface we just described, using standard pattern matching on the children of elements. But that would get very tedious, very quickly. Probably the gold standard for these kinds of lookups is XPath, where you would be able to write /html/head/title. And that's exactly what inspired the design of the xml-conduit:Text.XML.Cursor combinators.

A cursor is an XML node that knows its location in the tree; it's able to traverse upwards, sideways, and downwards. (Under the surface, this is achieved by tying the knot.) There are two functions available for creating cursors from Text.XML types: fromDocument and fromNode.

We also have the concept of an Axis, defined as type Axis = Cursor -> [Cursor]. It's easiest to get started by looking at example axes: child returns zero or more cursors that are the child of the current one, parent returns the single parent cursor of the input, or an empty list if the input is the root element,
and so on.

In addition, there are some axes that take predicates. element is a commonly used function that filters down to only elements which match the given name. For example, element "title" will return the input element if its name is "title", or an empty list otherwise.

Another common function which isn't quite an axis is content :: Cursor -> [Text]. For all content nodes, it returns the contained text; otherwise, it returns an
empty list.

And thanks to the monad instance for lists, it's easy to string all of these together. For example, to do our title lookup, we would write the following program:

\begin{lstlisting}
{-# LANGUAGE OverloadedStrings #-}
import Prelude hiding (readFile)
import Text.XML
import Text.XML.Cursor
import qualified Data.Text as T

main :: IO ()
main = do
    doc <- readFile def "test.xml"
    let cursor = fromDocument doc
    print $ T.concat $
            child cursor >>= element "head" >>= child
                         >>= element "title" >>= descendant >>= content
\end{lstlisting}

What this says is:

\begin{itemize}
\item Get me all the child nodes of the root element
\item Filter down to only the elements named "head"
\item Get all the children of all those head elements
\item Filter down to only the elements named "title"
\item Get all the descendants of all those title elements. (A descendant is a child, or a descendant of a child. Yes, that was a recursive definition.)
\item Get only the text nodes.
\end{itemize}

So for the input document:

\begin{lstlisting}[language=HTML]
  <html>
    <head>
        <title>My <b>Title</b></title>
    </head>
    <body>
        <p>Foo bar baz</p>
    </body>
</html>
\end{lstlisting}

We end up with the output My Title. This is all well and good, but it's much more verbose than the XPath solution. To combat this verbosity, Aristid Breitkreuz added a set of operators to the Cursor module to handle many common cases. So we can rewrite our example as:

\begin{lstlisting}
{-# LANGUAGE OverloadedStrings #-}
import Prelude hiding (readFile)
import Text.XML
import Text.XML.Cursor
import qualified Data.Text as T

main :: IO ()
main = do
    doc <- readFile def "test.xml"
    let cursor = fromDocument doc
    print $ T.concat $
        cursor $/ element "head" &/ element "title" &// content
\end{lstlisting}%$

\$/ says to apply the axis on the right to the children of the cursor on the left. \&/ is almost identical, but is instead used to combine two axes together. This is a general rule in Text.XML.Cursor: operators beginning with \$ directly apply an axis, while \& will combine two together. \&// is used for applying an axis to all descendants.

Let's go for a more complex, if more contrived, example. We have a document that looks like:

\begin{lstlisting}[language=HTML]
  <html>
    <head>
        <title>Headings</title>
    </head>
    <body>
        <hgroup>
            <h1>Heading 1 foo</h1>
            <h2 class="foo">Heading 2 foo</h2>
        </hgroup>
        <hgroup>
            <h1>Heading 1 bar</h1>
            <h2 class="bar">Heading 2 bar</h2>
        </hgroup>
    </body>
</html>
\end{lstlisting}

We want to get the content of all the h1 tags which precede an h2 tag with a class attribute of "bar". To perform this convoluted lookup, we can write:

\begin{lstlisting}
{-# LANGUAGE OverloadedStrings #-}
import Prelude hiding (readFile)
import Text.XML
import Text.XML.Cursor
import qualified Data.Text as T

main :: IO ()
main = do
    doc <- readFile def "test2.xml"
    let cursor = fromDocument doc
    print $ T.concat $
        cursor $// element "h2"
               >=> attributeIs "class" "bar"
               >=> precedingSibling
               >=> element "h1"
               &// content
\end{lstlisting}%$

Let's step through that. First we get all h2 elements in the document. (\$// gets all descendants of the root element.) Then we filter out only those with class=bar. That >=> operator is actually the standard operator from base:Control.Monad; yet another advantage of the monad instance of lists. precedingSibling finds all nodes that come before our node and share the same parent. (There is also a preceding axis which takes all elements earlier in the tree.) We then take just the h1 elements, and then grab their content.

\begin{remark}
The equivalent XPath, for comparison, would be //h2[@class ='bar']/preceding-sibling::h1//text().
\end{remark}

While the cursor API isn't quite as succinct as XPath, it has the advantages of being standard Haskell code, and of type safety.

\section{xml-hamlet}

Thanks to the simplicity of Haskell's data type system, creating XML content with the Text.XML API is easy, if a bit verbose. The following code:

\begin{lstlisting}
{-# LANGUAGE OverloadedStrings #-}
import Text.XML
import Prelude hiding (writeFile)

main :: IO ()
main =
    writeFile def "test3.xml" $ Document (Prologue [] Nothing []) root []
  where
    root = Element "html" []
        [ NodeElement $ Element "head" []
            [ NodeElement $ Element "title" []
                [ NodeContent "My "
                , NodeElement $ Element "b" []
                    [ NodeContent "Title"
                    ]
                ]
            ]
        , NodeElement $ Element "body" []
            [ NodeElement $ Element "p" []
                [ NodeContent "foo bar baz"
                ]
            ]
        ]
\end{lstlisting}

produces

\begin{lstlisting}[language=XML]
<?xml version="1.0" encoding="UTF-8"?>
<html><head><title>My <b>Title</b></title></head><body><p>foo bar baz</p></body></html>
\end{lstlisting}

This is leaps and bounds easier than having to deal with an imperative, mutable-value-based API (cough, Java, cough), but it's far from pleasant, and obscures what we're really trying to achieve. To simplify things, we have the xml-hamlet package, which using Quasi-Quotation to allow you to type in your XML in a natural syntax. For example, the above could be rewritten as:

\begin{lstlisting}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE QuasiQuotes #-}
import Text.XML
import Text.Hamlet.XML
import Prelude hiding (writeFile)

main :: IO ()
main =
    writeFile def "test3.xml" $ Document (Prologue [] Nothing []) root []
  where
    root = Element "html" [] [xml|
<head>
    <title>
        My #
        <b>Title
<body>
    <p>foo bar baz
|]
\end{lstlisting}%$

Let's make a few points:

\begin{itemize}
\item The syntax is almost identical to normal Hamlet, except URL-interpolation (@{...}) has been removed. As such:

\begin{itemize}
\item No close tags.
\item Whitespace-sensitive.
\item If you want to have whitespace at the end of a line, use a \# at the end. At the beginning, use a backslash.
\end{itemize}
  
\item An xml interpolation will return a list of Nodes. So you still need to wrap up the output in all the normal Document and root Element constructs.
\item There is no support for the special .class and \#id attribute forms.
\end{itemize}

And like normal Hamlet, you can use variable interpolation and control structures. So a slightly more complex example would be:

\begin{lstlisting}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE QuasiQuotes #-}
import Text.XML
import Text.Hamlet.XML
import Prelude hiding (writeFile)
import Data.Text (Text, pack)

data Person = Person
    { personName :: Text
    , personAge :: Int
    }

people :: [Person]
people =
    [ Person "Michael" 26
    , Person "Miriam" 25
    , Person "Eliezer" 3
    , Person "Gavriella" 1
    ]

main :: IO ()
main =
    writeFile def "people.xml" $ Document (Prologue [] Nothing []) root []
  where
    root = Element "html" [] [xml|
<head>
    <title>Some People
<body>
    <h1>Some People
    $if null people
        <p>There are no people.
    $else
        <dl>
            $forall person <- people
                ^{personNodes person}
|]

personNodes :: Person -> [Node]
personNodes person = [xml|
<dt>#{personName person}
<dd>#{pack $ show $ personAge person}
|]
\end{lstlisting}%$

A few more notes:

\begin{itemize}
\item The caret-interpolation (\^{...}) takes a list of nodes, and so can easily embed other xml-quotations.
\item Unlike Hamlet, hash-interpolations (\#{...}) are not polymorphic, and can only accept Text values.
\end{itemize}

\section{xml2html}

So far in this chapter, our examples have revolved around XHTML. I've done that so far simply because it is likely to be the most familiar form of XML for most of our readers. But there's an ugly side to all this that we must acknowledge: not all XHTML will be correct HTML. The following discrepancies exist:

\begin{itemize}
\item There are some void tags (e.g., img, br) in HTML which do not need to have close tags, and in fact are not allowed to.
\item HTML does not understand self-closing tags, so <script></script> and
<script/> mean very different things.
\item Combining the previous two points: you are free to self-close void tags, though to a browser it won't mean anything.
\item In order to avoid quirks mode, you should start your HTML documents with a DOCTYPE statement.
\item We do not want the XML declaration <?xml ...?> at the top of an HTML page
\item We do not want any namespaces used in HTML, while XHTML is fully namespaced.
\item The contents of <style> and <script> tags should not be escaped.
\end{itemize}
  
That's where the xml2html package comes into play. It provides a ToHtml instance for Nodes, Documents and Elements. In order to use it, just import the Text.XML.Xml2Html module.

\begin{lstlisting}
{-# LANGUAGE OverloadedStrings, QuasiQuotes #-}
import Text.Blaze.Html (toHtml)
import Text.Blaze.Html.Renderer.String (renderHtml)
import Text.XML
import Text.Hamlet.XML
import Text.XML.Xml2Html ()

main :: IO ()
main = putStr $ renderHtml $ toHtml $ Document (Prologue [] Nothing []) root []

root :: Element
root = Element "html" [] [xml|
<head>
    <title>Test
    <script>if (5 < 6 || 8 > 9) alert("Hello World!");
    <style>body > h1 { color: red }
<body>
    <h1>Hello World!
|]
\end{lstlisting}%$

Outputs: (whitespace added)

\begin{lstlisting}[language=HTML]
  <!DOCTYPE HTML>
<html>
    <head>
        <title>Test</title>
        <script>if (5 < 6 || 8 > 9) alert("Hello World!");</script>
        <style>body > h1 { color: red }</style>
    </head>
    <body>
        <h1>Hello World!</h1>
    </body>
</html>
\end{lstlisting}%$
