\chapter{Persistent}\label{chap:persistent}

Формы представляют собой границу между пользователем и приложением. Другая граница, с которой нам приходится иметь дело, находится между приложением и хранилищем. Является ли это хранилище SQL базой данных, YAML- или бинарным файлом, вам с большой вероятностью придется попотеть, чтобы хранилище принимало типы данных вашего приложения. Persistent представляет собой ответ Yesod'а на проблему хранения данных. Это универсальный типобезопасный интерфейс к хранилищу данных для Haskell.

Haskell предлагает множество различных биндингов к базам данных. Однако большинство из них имеют малое представление о схеме базы данных и потому не обеспечивают полезных статических проверок. Кроме того, они вынуждают программиста использовать API и типы данных, зависящие от конкретной базы данных. Чтобы избавиться от этих проблем, программистами на Haskell была предпринята попытка пойти более революционным путем и создать хранилище данных, специфичное для Haskell, тем самым получив возможность с легкостью хранить любой тип данных Haskell. Эта возможность действительно прекрасна в некоторых случаях, но она делает программиста зависимым от техники хранения данных и используемой библиотеки, плохо взаимодейтсвует с другими языками, а также для обеспечения гибкости может требовать от программиста написания кучи кода, запрашивающего данные. В отличии от Persistent, который предоставляет выбор среди множества баз данных, каждая из которых оптимизирована для различных случаев, позволяет взаимодействовать с другими языками, а также использовать безопасный и производительный интерфейс запросов.

Persistent следует принципам безопасности типов и краткого, декларативного синтексиса. Среди других возможностей следует отметить:

\begin{itemize}
  \item Независимость от базы данных. Имеется первоклассная поддержка PostgreSQL, SQLite и MongoDB, а также эксперементальная поддержка CouchDB и находящаяся в разработке поддержка MySQL.
  \item Будучи нереляционным по своей природе, Persistent позволяет одновременно поддерживать множество слоев хранения данных и не обременен проблемами производительности, связанными с использованием JOIN'ов.
  \item Основным источником разочарования при использовании SQL баз данных является попытка изменения схемы базы данных. Persistent позволяет автоматически выполнять переход между базами данных. % схемами БД?
\end{itemize}

\section{Краткое содержание} % Synopsis

\begin{lstlisting}
{-# LANGUAGE QuasiQuotes, TemplateHaskell, TypeFamilies, OverloadedStrings #-}
{-# LANGUAGE GADTs, FlexibleContexts #-}

import Database.Persist
import Database.Persist.Sqlite
import Database.Persist.TH
import Control.Monad.IO.Class (liftIO)

share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persist|
Person
    name String
    age Int Maybe
    deriving Show
BlogPost
    title String
    authorId PersonId
    deriving Show
|]

main :: IO ()
main = withSqliteConn ":memory:" $ runSqlConn $ do
    runMigration migrateAll

    johnId <- insert $ Person "John Doe" $ Just 35
    janeId <- insert $ Person "Jane Doe" Nothing

    insert $ BlogPost "My fr1st p0st" johnId
    insert $ BlogPost "One more for good measure" johnId

    oneJohnPost <- selectList [BlogPostAuthorId ==. johnId] [LimitTo 1]
    liftIO $ print (oneJohnPost :: [Entity BlogPost])

    john <- get johnId
    liftIO $ print (john :: Maybe Person)

    delete janeId
    deleteWhere [BlogPostAuthorId ==. johnId]
\end{lstlisting}%$

\section{Решение <<пограничной>> проблемы} % Solving the boundary issue

Допустим, вы храните информацию о людях в SQL базе данных. Соответствующая таблица может выглядеть как-то так:

\begin{lstlisting}
CREATE TABLE Person(id SERIAL PRIMARY KEY, name VARCHAR NOT NULL, age INTEGER)
\end{lstlisting}

И если вы используете такую СУБД, как PostgreSQL, вы можете быть уверены, что СУБД никогда не сохранит какой-нибудь дополнительный текст в поле age. (Нельзя сказать то же самое в отношении SQLite, однако пока что забудем об этом). Для отображения этой таблицы вы можете захотеть создать примерно такой тип данных:

\begin{lstlisting}
data Person = Person
    { personName :: Text
    , personAge :: Int
    }
\end{lstlisting}

Все выглядит вполне типобезопасно --- схема базы данных соответствует типу данных в Haskell, СУБД гарантирует, что некорректные данные никогда не будут сохранены в таблице, и все в целом выглядит прикрасно. Ну, до поры до времени.

Вы хотите получить данные из базы данных, а слой базы данных отдает вам данные в нетипизированном формате.

\begin{itemize}
  \item Вы хотите найти все людей, старше 32-х лет, но по ошибке пишете <<тридцать два>> в SQL-запросе. И значете что? Все прекрасно скомпилируется и вы не узнаете о проблеме до тех пор, пока не запустите программу.
  \item Вы решили найти первых десятерых человек в алфавитном порядке. Нет проблем... до тех пор, пока вы не сделаете опечатку в SQL-запросе. И снова, вы не узнаете об этом до тех пор, пока не запустите программу.
  \item В языках с динамической типизацией ответом на эти проблемы является модульное тестирование. Проверьте, что для всего, что может пойти не так, вы не забили написать тест. Но как, я полагаю, вы уже знаете, это не очень согласуется с подходом, принятом в Yesod. Мы предпочитаем использовать преимущества статической типизации языка Haskell для нашей собственной защиты, насколько это возможно, и хранение данных не является исключением.
\end{itemize}

Итак, вопрос остается открытым: как мы можем использовать систему типов языка Haskell, чтобы исправить положение?

\section{Типы} % Types

Как и в случае с маршрутами, нет ничего невероятно сложного в типобезопасном доступе к данным. Он всего лишь требует написания монотонного, подверженного ошибкам избыточного шаблонного кода. Как обычно, это означает, что мы можем использовать систему типов для того, чтобы избежать лишних ошибок. А чтобы не заниматься нудной работой, мы вооружимся Template Haskell.

\begin{remark}
В ранних версиях Persistent очень активно использовался Template Haskell. Начиная с версии 0.6 используется новая архитектура, позаимстованная из пакета groundhog. Благодаря новому подходу существенная часть нагрузки была переложена на фантомные типы.
\end{remark}

PersistValue является основным строительным блоком в Persistent. Этот тип представляет данные, посылаемые базе данных или получаемые от нее. Вот его определение:

\begin{lstlisting}
data PersistValue = PersistText Text
                  | PersistByteString ByteString
                  | PersistInt64 Int64
                  | PersistDouble Double
                  | PersistBool Bool
                  | PersistDay Day
                  | PersistTimeOfDay TimeOfDay
                  | PersistUTCTime UTCTime
                  | PersistNull
                  | PersistList [PersistValue]
                  | PersistMap [(T.Text, PersistValue)]
                  | PersistForeignKey ByteString -- ^ предназначен прежде всего для MongoDB
\end{lstlisting}

Каждый из бэкэндов Persistent должен знать, как переводить соответствующие значения во что-то понятное базе данных. Однако было бы неудобно выражать все данные через эти базовые типы. Следующим слоем является класс типов PersistField, определяющий, как произвольный тип может быть преобразован в тип PersistValue или обратно. PersistField соответствует столбцами в SQL базах данных. В приведенном ранее примере с людьми name и age будут нашими PersistField'ами.

Чтобы связать пользовательский код, нам понадобится последний класс типов --- PersistEntity. Экземпляр класса типов PersistEntity соответствует таблице в SQL базе данных. Этот класс типов определеяет несколько функций и связанные с ними типы. Таким образом, имеет место следующее соответствие между Persistent и SQL:

\begin{center}
\begin{tabular}{ | l | l |}
\hline
SQL	& Persistent \\ \hline
Тип (VARCHAR, INTEGER и тд)	& PersistValue \\ \hline
Столбец & PersistField \\ \hline
Таблица	& PersistEntity \\ \hline
\end{tabular}
\end{center}

\section{Генерация кода} % Code Generation

Дабы убедиться, что экземпляры класса PersistEntity корректно соответствуют вашим типам данных, Persistent берет на себя ответственность и за тех, и за других. Это хорошо и с точки зрения принципа DRY (Не повторяйтесь, Don't Repeat Yourslef): от вас требуется объявить сущности только один раз. Рассмотрим следующий пример:

\begin{lstlisting}
{-# LANGUAGE QuasiQuotes, TypeFamilies, GeneralizedNewtypeDeriving, TemplateHaskell, OverloadedStrings, GADTs #-}

import Database.Persist
import Database.Persist.TH
import Database.Persist.Sqlite
import Control.Monad.IO.Class (liftIO)

mkPersist sqlSettings [persist|
Person
    name String
    age Int
    deriving Show
|]
main = return ()
\end{lstlisting}

Здесь мы используем комбинацию из Template Haskell и квазицитирования (как при определении маршрутов): persist является обработчиком квазицитирования, который преобразует чувствительный к пробелам синтаксис в список определений сущностей. (Также вы можете вынести определение сущностей в отдельный файл и воспользоваться persistFile.) mkPersist принимает список этих сущностей и определяет:

\begin{itemize}
  \item По одному типу данных языка Haskell на сущность;
  \item Экземпляр класса PersistEntity для каждого определенного типа данных;
\end{itemize}

Приведенный выше пример генерирует код, который выглядит примерно следующим образом:

\begin{lstlisting}
{-# LANGUAGE TypeFamilies, GeneralizedNewtypeDeriving, OverloadedStrings, GADTs #-}

import Database.Persist
import Database.Persist.Store
import Database.Persist.Sqlite
import Database.Persist.EntityDef
import Control.Monad.IO.Class (liftIO)
import Control.Applicative

data Person = Person
    { personName :: String
    , personAge :: Int
    }
  deriving (Show, Read, Eq)

type PersonId = Key SqlPersist Person

instance PersistEntity Person where
    -- Обобщенный алгебраический тип данных.
    -- Это дает нам типобезопасный подход к сопоставлению
    -- полей с их типами данных
    data EntityField Person typ where
        PersonId   :: EntityField Person PersonId
        PersonName :: EntityField Person String
        PersonAge  :: EntityField Person Int

    type PersistEntityBackend Person = SqlPersist

    toPersistFields (Person name age) =
        [ SomePersistField name
        , SomePersistField age
        ]

    fromPersistValues [nameValue, ageValue] = Person
        <$> fromPersistValue nameValue
        <*> fromPersistValue ageValue
    fromPersistValues _ = Left "Invalid fromPersistValues input"

    -- Информация о каждом поле для внутреннего использования при генерации SQL выражений
    persistFieldDef PersonId = FieldDef
        (HaskellName "Id")
        (DBName "id")
        (FTTypeCon Nothing "PersonId")
        []
    persistFieldDef PersonName = FieldDef
        (HaskellName "name")
        (DBName "name")
        (FTTypeCon Nothing "String")
        []
    persistFieldDef PersonAge = FieldDef
        (HaskellName "age")
        (DBName "age")
        (FTTypeCon Nothing "Int")
        []
    data Unique Person typ = IgnoreThis
    entityDef = undefined
    halfDefined = undefined
    persistUniqueToFieldNames = undefined
    persistUniqueToValues = undefined
    persistUniqueKeys = undefined
    persistIdField = undefined
main :: IO ()
main = return ()
\end{lstlisting}%$

Как и следовало ожидать, определение типа данных Person очень близко к определению, данному в оригинальной версии кода, где использовался Template Haskell. Мы также имеем обощенный алгебраический тип данный (ОАТД), предоставляющий отдельный конструктор для каждого поля. Этот ОАТД кодирует как тип сущности, так и тип поля. Мы используем его конструкторы через модуль Persistent, например, чтобы убедиться, что когда мы применяем фильтр, типы фильтруемого значения и поля совпадают.

Мы можем использовать сгенерированный тип Person как и любой другой тип языка Haskell, а затем передать его в одну из функций модуля Persistent.

\begin{lstlisting}
main = withSqliteConn ":memory:" $ runSqlConn $ do
    michaelId <- insert $ Person "Michael" 26
    michael <- get michaelId
    liftIO $ print michael
\end{lstlisting}%$

Мы начнем со стандартного кода, работающего с базой данных. В данном случае мы использовали функции для работы с одним соединением. Модуль Persistent также предоставляет функции для работы с пулом соединений, которые использовать в боевом окружении обычно предпочтительнее.

В приведенном примере мы видим две функции. Функция insert создает новую запись в базе данных и возвращает ее ID. Как и все остальное в модуле Persistent, ID являются типобезопасными. Более подробно о том, как работают эти ID, мы узнаем позже. Итак, код \lstinline'insert \$ Person "Michael" 25', возвращает значение типа PersonId.

Следующая функция, которую мы видим --- это get. Она пытается загрузить из базы данных значение, используя заданный ID. При использовании Persistent вам никогда не придется беспокоиться, что вы, возможно, используете ключ не от той таблицы. Код, который пытается получить другую сущность (например, House), используя PersonId, никогда не будет скомпилирован.

\section{PersistStore}

Последний момент, который остался без объяснения в предыдущем примере: что делают функции PersistStore и runSqlConn? И что это за монада, в которой выполняются все наши действия с базой данных?

Все действия с базой данных должны выполняться в экземпляре PersistStore. Как следует из его названия, каждое хранилище (PostgreSQL, SQLite, MongoDB) имеет свой экземпляр PersistStore. Именно с его помощью происходят генерация SQL-запросов, преобразования из PersistValue в значения, специфичные для конкретной СУБД и так далее.

\begin{remark}
Как вы, вероятно, догадываетесь, несмотря на то, что PersistStore предоставляет безопасный, хорошо типизированный интерфейс, во время взаимодействия с базой данных многое может пойти не так, как ожидалось. Однако тестируя код автоматически и тщательно в каждом отдельном месте, мы может централизовать склонный к ошибкам код и убедиться, что он настолько свободен от ошибок, насколько это вообще возможно.
\end{remark}

Функция withSqliteConn создает отдельное соединение с базой данных, используя предоставленную строку. Для тестов мы воспользуемся строкой <<:memory:>>, которая означает использовать базу данных, расположенную в памяти. Функция runSqlConn использует это соединение для выполнения действий над базой данных. SQLite и PostgreSQL используют один и тот же экземпляр PersistStore: SqlPersist.

\begin{remark}
В действительности существует еще несколько классов типов --- это PersistUpdate и PersistQuery. Различные классы типов предоставляют различную функциональность, что позволяет нам писать бэкенды, использующие более простые хранилища (например, Redis) несмотря на то, что они не обладают всей высокоуровневой функциональностью, предоставляемой Persistent. 
\end{remark}

Важный момент, который следует отметить, заключается в том, что каждый отдельный вызов runSqlConn выполняется в отдельной транзакции. Отсюда два следствия:

\begin{itemize}
  \item Для многих СУБД выполнение коммита может быть дорогой операцией. Помещая множество запросов в одну транзакцию, вы можете существенно ускорить выполнение кода.
  \item Если где-либо внутри вызова runSqlConn бросается исключение, все выполненные действия будут откачены (конечно, если используемый бэкенд поддерживает транзакции).
\end{itemize}

\section{Миграции} % Migrations

Мне очень жаль, но все это время я вам лгал: пример из предыдущего раздела на самом деле не работает. Если вы попытаетесь запутить его, то получите ошибку о несуществующей таблице.

При работе с реляционными СУБД, изменение схемы базы данных обычно является большой проблемой. Вместо того, чтобы возлагать эту проблему на плечи пользователя, Persistent делает шаг вперед и протягивает руку помощи. Только нужно его об этом попросить. Вот как примерно это выглядит:

\begin{lstlisting}
{-# LANGUAGE QuasiQuotes, TypeFamilies, GeneralizedNewtypeDeriving, TemplateHaskell, OverloadedStrings, GADTs, FlexibleContexts #-}

import Database.Persist
import Database.Persist.TH
import Database.Persist.Sqlite
import Control.Monad.IO.Class (liftIO)

share [mkPersist sqlSettings, mkSave "entityDefs"] [persist|
Person
    name String
    age Int
    deriving Show
|]

main = withSqliteConn ":memory:" $ runSqlConn $ do
    runMigration $ migrate entityDefs (undefined :: Person) -- добавлена эта строчка, и только!
    michaelId <- insert $ Person "Michael" 26
    michael <- get michaelId
    liftIO $ print michael
\end{lstlisting}%$

Благодаря этому небольшому изменению, Persistent будет автоматически создавать для вас таблицу Person. Разбиение между функциями runMigration и migrate позволяет производить миграции множества таблиц одновременно.

Это хорошо работает, когда речь идет о нескольких сущностях, но становится несколько утомительным при работе с десятками. Вместо того, чтобы повторяться, Persistent предлагает функцию mkMigrate:

\begin{lstlisting}
{-# LANGUAGE QuasiQuotes, TypeFamilies, GeneralizedNewtypeDeriving, TemplateHaskell, OverloadedStrings, GADTs, FlexibleContexts #-}

import Database.Persist
import Database.Persist.Sqlite
import Database.Persist.TH

share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persist|
Person
    name String
    age Int
    deriving Show
Car
    color String
    make String
    model String
    deriving Show
|]

main = withSqliteConn ":memory:" $ runSqlConn $ do
       runMigration migrateAll
\end{lstlisting}%$

mkMigrate --- это функция Template Haskell, которая создает новую функцию, что будет вызывать migrate для всех сущностей, объявленных в блоке persist. Функция share является небольшим хелпером, который передает информацию из блока persist каждой из функций Template Haskell, а затем объединяет результаты их выполнения.

В Persistent используются очень консервативные правила относительно того, что следует делать во время миграции. Сначала он загружает из базы данных всю информацию о таблицах, вместе со всеми объявленными типами данных SQL. Эту информацию он сравнивает с определениями сущностей, приведенными в коде. В следующих случаях схема базы данных будет изменена автоматически:

\begin{itemize}
	\item Изменился тип данных поля. Но СУБД может возражать против такого изменения, если данные не могут быть преобразованы.
	\item Было добавлено новое поле. Однако если поле не может быть пустым (null), не было предоставлено значение по-умолчанию (как это сделать, мы обсудим позже), и в таблице уже есть какие-то даные, СУБД не позволит добавить поле.
	\item Некоторе поле отныне может быть пустым. В обратном случае Persistent попытается выполнить преобразование, если СУБД позволит это сделать.
	\item Была добавлена совершенно новая сущность.
\end{itemize}

Однако есть и случаи, которые Persistent не в состоянии обработать:

\begin{itemize}
	\item Переименование сущностей или полей. У Persistent нет никакой возможности узнать, что поле <<name>> было переименовано в <<fullName>>. Все, что он видит --- это старое поле с именем <<name>> и новое поле с именем <<fullName>>.
	\item Удаление полей. Поскольку это может привести к потере данных, по-умолчанию Persistent отказывается выполнять такие приобразования. Вы можете настоять на этом, воспользовавшись функцией runMigrationUnsafe вместо runMigration, но это не рекомендуется.
\end{itemize}

Функция runMigration выводит выполняемые миграции в STDERR (если вам не нравится такое поведение, воспользуйтесь функцией runMigrationSilent). По возможности она использует запросы ALTER TABLE. Однако в SQLite ALTER TABLE имеет очень малые возможности, поэтому Persistent приходится прибегнуть к копированию данных из одной таблицы в другую.

Наконец, если вы хотите, чтобы вместо выполнения миграций Persistent дал вам подсказку по самостоятельному выполнению этих миграцией, воспользуйтесь функцией printMigration. Эта функция выводит действия, которые были бы выполнены функцией runMigration. Это может быть полезно в случае выполнения миграций, на который Persistent не способен, выполнения дополнительных SQL-запросов во время миграций, или же просто для логирования происходящих миграций.

\section{Уникальность} % Uniqueness

Помимо объявления полей у сущности мы также может объявлять ограничение уникальности. Типичный пример --- это требование уникальности имени пользователя:

\begin{lstlisting}
User
    username Text
    UniqueUsername username
\end{lstlisting}

В то время, как имя каждого поля должно начинаться с маленькой буквы, ограничение уникальности должно начинаться с большой буквы.

\begin{lstlisting}
{-# LANGUAGE QuasiQuotes, TypeFamilies, GeneralizedNewtypeDeriving, TemplateHaskell, OverloadedStrings, GADTs, FlexibleContexts #-}
import Database.Persist
import Database.Persist.Sqlite
import Database.Persist.TH
import Data.Time
import Control.Monad.IO.Class (liftIO)
import Control.Monad.Trans.Resource (runResourceT)

share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persist|
Person
    firstName String
    lastName String
    age Int
    UniqueName firstName lastName
    deriving Show
|]

main = runResourceT $ withSqliteConn ":memory:" $ runSqlConn $ do
    runMigration migrateAll
    insert $ Person "Michael" "Snoyman" 26
    michael <- getBy $ UniqueName "Michael" "Snoyman"
    liftIO $ print michael
\end{lstlisting}%$

Чтобы сообщить об уникальности комбинации нескольких полей, добавим одну дополнительную строку в наше определение. Persistent знает, что таким образом определяется уникальный конструктор, потому что строка начинается с заглавной буквы. Каждое последующее слово должно быть именем поля в сущности.

Главное ограничение, связанное с уникальностью, состоит в том, что она может использоваться только для непустых (non-null) полей. Причина заключается в том, что стандарт SQL неоднозначен относительно уникальности пустых полей (например, NULL=NULL является истиной или ложью?). К тому же, в большинстве СУБД реализованы правила, которые не соответствуют правилам для соответствующих типов данных в Haskell (например, в PostgreSQL NULL=NULL --- это ложь, а в Haskell Nothing = Nothing есть True).

В дополнение к предоставлению гарантий на уровне СУБД относительно согласованности даннных, ограничение уникальности также может быть использовано для выполнения некоторых специфических запросов из кода на Haskell, как, например, в случае с getBy, продемонстрированом выше. Здесь используется ассоциированный тип Unique. В конце приведенного выше примера используется следующий конструктор:

\begin{lstlisting}
UniqueName :: String -> String -> Unique Person
\end{lstlisting}

\begin{remark}
В случае использования MongoDB ограничение уникальности не может быть использовано --- вы должны создать уникальный индекс по полю.
\end{remark}

\section{Запросы} % Queries

В зависимости от вашей цели, могут быть использованы различные запросы к базе данных. В некоторых запросах используется численный ID, когда в других происходит фильтрация по значению поля. Запросы также различаются по количеству значений, которые они возвращают. Одни должны возвращать не более одного результата, другие же могут возвразать множество результатов.

В связи с этим Persistent предоставляет множетсво различных функций для выполнения запросов. Как обычно, мы стараемся закодировать с помощью типов столько инвариантов, сколько возможно. Например, если запрос может возвращать либо 0, либо 1 результат, используется обертка Maybe. Если же запрос может вернуть много результатов, возвращается список.

\section{Выборка по ID} % Fetching by ID

Простейший запрос, который может быть выполнен в Persistent --- это выборка, основанная на ID. Поскольку в этом случае значение может существовать или не существовать, возвращаемое значение оборачивается в Maybe.

Использование функции get:

\begin{lstlisting}
    personId <- insert $ Person "Michael" "Snoyman" 26
    maybePerson <- get personId
    case maybePerson of
        Nothing -> liftIO $ putStrLn "Ничего нет"
        Just person -> liftIO $ print person
\end{lstlisting}%$

Это может быть очень удобно на сайтах, предоставляющих URL типа /person/5. Однако в таких случаях мы обычно не беспокоимся о Maybe, а просто хотим получить значение или вернуть код 404, если оно не найдено. К счастью, есть функция get404, которая поможет нам в этом. Мы разберемся с этим вопросом более детально, когда дойдем до интеграции с Yesod. 

\section{Выборка по уникальному ключу} % Fetching by unique constraint

Функция getBy почти идентична get, только вместо ID она принимает значение Unique.

Использование функции getBy:

\begin{lstlisting}
    personId <- insert $ Person "Michael" "Snoyman" 26
    maybePerson <- getBy $ UniqueName "Michael" "Snoyman"
    case maybePerson of
        Nothing -> liftIO $ putStrLn "Ничего нет"
        Just person -> liftIO $ print person
\end{lstlisting}

Аналогично get404, также существует функция getBy404.

\section{Другие функции выборки} % Select functions

Скорее всего, вам хотелось бы выполнять более сложные запросы, например, найти всех людей определенного возраста, все свободные машины синего цвета, всех пользователей без указанного email и тд. Для этого вам понадобится одна из следующий функций выборки.

Все эти функции имеют похожий интерфейс и немного различающиеся возвращаемые значения: 

\begin{itemize}
\item {\bf selectSource}. Возвращает источник (source), содержащий все ID и значения из базы данных. Это позволяет писать поточный код.
\begin{remark}
Мы более подробно рассмотрим источники в приложении, посвященном кодуитам (conduits). Кроме того, есть и другая функция под названием selectSourceConn, которая предоставляет больше контроля над выделением соединений. Мы рассмотрим ее в главе, посвященной работае со Sphinx.
\end{remark}
\item {\bf selectList}. Возвращает список, содержащий все ID и значения из базы данных. Все записи будут помещены в память.
\item {\bf selectFirst}. Просто возвращает первый ID и первое значение из базы данных, если они есть.
\item {\bf selectKeys}. Возвращает только ключи, без значений, в качесте источника.
\end{itemize}

Чаще всего используется функция selectList, так что мы рассмотрим ее отдельно. После этого понять остальные функции будет проще простого.

Функция selectList принимает два аргумента: список Filter'ов и список SelectOpt'ов. Первый из них определяет ограничения, накладываемые на свойства сущностей, и позволяет использовать предикаты <<равно>>, <<меньше чем>>, <<принадлежит множеству>> и тп. SelectOpt'ы предоставляют три различных возможности --- сортировку, ограничение количества возвращаемых строк и смещение возвращаемого значения на заданное количество строк.

\begin{remark}
Комбинация из ограничения и смещения очень важна, она позволяет реализовать эффективное разбиение на страницы в вашем веб-приложении.
\end{remark}

Сразу перейдем к примеру с фильтрацией, а затем проанализируем его:

\begin{lstlisting}
    people <- selectList [PersonAge >. 25, PersonAge <=. 30] []
    liftIO $ print people
\end{lstlisting}%$

Несмотря на простоту примера, необходимо отметить три момента:

\begin{enumerate}
\item PersonAge является конструктором ассоциативного фантомного типа. Звучит ужасающе, однако действительно важно лишь то, что он однозначно определяет столбец <<age>> таблицы <<person>>, а также знает, что возраст является Int'ом. (В этом и состоит фантомность.)
\item Мы имеем дело с группой фильтрующих операторов пакета Persistent. Они довольно прямолинейны и делают в точности то, что вы от них ожидаете. Однако тут есть три тонких момента, которые я объясню ниже.
\item Список фильтров объядиняется логическим И, то есть, ограничение следует читать, как <<возраст больше 25-и И возраст меньше или равен 30-и>>. Использование логического ИЛИ мы рассмотрим позже.
\end{enumerate}

Также имеется оператор с удивительным названием <<не равно>>. Мы используем обозначение \lstinline'!=.', поскольку \lstinline'/=.' используется при UPDATE-запросах (ради <<разделяй-и-устанавливай>>, о котором я расскажу позже). Не беспокойтесь, если вы воспользуетесь неверным оператором, компилятор предупредит вас. Еще два удивительных оператора --- это <<принадлежит множеству>> и <<не пренадлежит множеству>>. Они обозначаются, соответственно, \lstinline'<-.' и \lstinline'/<-.' (оба с точкой на конце).

Что же касается логического ИЛИ, для него есть оператор \lstinline'||.'. Например:

\begin{lstlisting}
    people <- selectList
        (       [PersonAge >. 25, PersonAge <=. 30]
            ||. [PersonFirstName /<-. ["Adam", "Bonny"]]
            ||. ([PersonAge ==. 50] ||. [PersonAge ==. 60])
        )
        []
    liftIO $ print people
\end{lstlisting}%$

Этот (совершенно нелепый) пример означает <<найти людей, чей возраст составляет от 26-и до 30-и лет включительно ИЛИ чье имя не Адам и не Бонни ИЛИ чей возраст --- 50 или 60 лет>>.

\section{SelectOpt}

Все наши вызовы selectList имели пустой список в качестве второго аргумента. Это не задает никаких параметров и означает <<сортируй на усмотрение СУБД, возвращай все результаты, не пропускай никаких результатов>>. SelectOpt имеем четыре конструктора, которые могут быть использованы для изменения этого поведения:

\begin{itemize}
\item {\bf Asc}. Сортировать по заданному столбцу в неубывающем порядке. Тут используется такой же фантомный тип, как и при фильтрации, например PersonAge.
\item {\bf Desc}. Аналогично Asc, только в невозрастающем порядке.
\item {\bf LimitTo}. Принимает аргумент типа Int. Вернуть не более указанного количества результатов.
\item {\bf OffsetBy}. Также принимает аргумент типа Int. Пропустить указанное количество результатов.
\end{itemize}

В следующем отрывке кода определяется функция, которая разбивает результат на страницы. Она возвращает всех людей старше 18-и лет, отсортированных по возрасту (более старшие идут первыми). Люди с одинаковым возрастом сортируются по фамилиям, а затем по именам.

\begin{lstlisting}
resultsForPage pageNumber = do
    let resultsPerPage = 10
    selectList
        [ PersonAge >=. 18
        ]
        [ Desc PersonAge
        , Asc PersonLastName
        , Asc PersonFirstName
        , LimitTo resultsPerPage
        , OffsetBy $ (pageNumber - 1) * resultsPerPage
        ]

main = withSqliteConn ":memory:" $ runSqlConn $ do
    runMigrationSilent migrateAll
    personId <- insert $ Person "Michael" "Snoyman" 26
    resultsForPage 1 >>= liftIO . print
\end{lstlisting}%$

\section{Другие действия с данными} % Manipulation

Извлечение данных --- это только полдела. Нам также необходимо иметь возможность добавлять данные и модифицировать данные, находящиеся в базе.

\section{Вставка} % Insert 

Иметь возможность работать с данными из базы --- это здорово и замечательно, но как эти данные туда попадают? Для этого есть функция insert. Вы просто передаете ей значение, а она возвращает ID.

В связи с этим имеет смысл немного пояснить философию Persistent. Во многих ORM типы, используемые для работы с данными, непрозрачны. Вам приходится продираться через определяемый ими интерфейс, чтобы получить, а затем изменить данные. Однако в Persistent все иначе --- для всего используются старые добрые алгебраические типы данных. Таким образом, вы по-прежнему можете иметь огромный выигрышь от использования сопастовления с образцом, каррирования и всего остального, к чему вы привыкли.

Однако есть вещи, которые мы не можем делать. Например, нет способа автоматически одновлять данные в базе данных при каждом их изменении в Haskell. Конечно, учитывая позицию языка Haskell в отношении чистоты и неизменяемости, от этого все равно было бы мало проку, так что не будем лить слезы.

Тем не менее, есть момент, который часто беспокоит новичков. Почему ID и значения совершенно разделены? Казалось бы, куда логичнее было бы включить ID в само значение. Другими словами, вместо:

\begin{lstlisting}
data Person = Person { name :: String }
\end{lstlisting}

... мы бы имели:

\begin{lstlisting}
data Person = Person { personId :: PersonId, name :: String }
\end{lstlisting}

Одна из проблем сразу бросается в глаза. Как прикажете производить вставку? Если Person требуется ID, а ID возвращается функцией insert, которой в свою очередь требуется Person, мы получаем проблему курицы и яйца. Мы могли бы решить эту проблему, используя неопределенный ID, однако это верный способ нарваться на неприятности.

Вы скажете, хорошо, давайте попробуем что-то более безопасное:

\begin{lstlisting}
data Person = Person { personId :: Maybe PersonId, name :: String }
\end{lstlisting}

Намного предочтительнее писать \lstinline'insert \$ Person Nothing "Michael"' вместо \lstinline'insert \$ Person undefined "Michael"'. И теперь наши типы стали намного проще, не так ли? Например, selectList теперь может возвращать просто \lstinline'[Person]' вместо уродливого \lstinline'[Entity SqlPersist Person]'.

\begin{remark}
Entity представляет собой тип данных, который связывает ID и значение сущности воедино. Поскольку ID могут быть разными в зависимости от бэкенда, необходимо также предоставить используемый бэкенд пакета Persistent. Тип данных \lstinline'Entity SqlPersist Person' следует читать как <<ID и значение некого человека, хранящееся в SQL базе данных>>.
\end{remark}

Проблема заключается в том, что <<уродство>> оказывается невероятно полезным. Запись \lstinline'Entity SqlPersist Person' делает очевидным тот факт, что мы работаем со значением, которое существует в базе данных. Допустим, мы хотим создать ссылку, в которой пресутствует PersonId (не такой уж редкий случай, как мы скоро выясним). \lstinline'Entity SqlPersist Person' недвусмысленно предоставляет доступ к требуемой информации. Тем временем использование обертки Maybe приводит к потребности в дополнительных проверках во время выполнения, вместо того, чтобы убедиться в корректности программы еще на этапе компиляции.

Наконец, в случае присоединения ID к значению имеет место семантическое несоответствие. Person --- это значение. Два человека являются идентичными (с точки зрения базы данных), если все их поля одинаковы. Присоединяя ID к значению, мы начинаем говорить не о человеке, а о строке в базе данных. Равенство перестает быть равентсвом, оно превращается в идентичность: <<это тот же самый человек>> вместо <<это такой же человек>>.

Другими словами, есть нечто раздражающее в отделении ID от значения, но в конце концов, это правильный подход, который в великой схеме вещей ведет к более хорошему, менее дырявому коду.

\section{Обновление} % Update

Теперь подумаем об обновлении в контексте нашего обсуждения. Вот простейший способ сделать обновление:

\begin{lstlisting}
let michael = Person "Michael" 26
    michaelAfterBirthday = michael { personAge = 27 }
\end{lstlisting}

Однако в действительности этот код ничего не обновляет. Он просто создает новое значение типа Person, основанное на старом значении. Когда мы говорим об обновлении, мы имеем ввиду не модификацию значений в Haskell. (И вправду, не стоило бы делать это, поскольку данные в Haskell неизменяемы.) % в оригинале "since Haskell data types are immutable", мне кажется, это опечатка: https://github.com/yesodweb/yesodweb.com-content/pull/27

На самом деле, мы ищем способ изменить строки в таблице. И проще всего сделать это с помощью функции update:

\begin{lstlisting}
    personId <- insert $ Person "Michael" "Snoyman" 26
    update personId [PersonAge =. 27]
    resultsForPage 1 >>= liftIO . print
\end{lstlisting}%$

Функция update принимает два аргумента: ID и список Update'ов. Простейший способ обновления поля заключается в присвоении ему нового значения, однако этот способ не лучший. Что, если вы хотите увеличить чей-то возраст на единицу, но текущий возраст вам не известен? В Persistent предусмотрено и это:

\begin{lstlisting}
haveBirthday personId = update personId [PersonAge +=. 1]

main = withSqliteConn ":memory:" $ runSqlConn $ do
    runMigrationSilent migrateAll
    personId <- insert $ Person "Michael" "Snoyman" 26
    update personId [PersonAge =. 27]
    haveBirthday personId
    resultsForPage 1 >>= liftIO . print
\end{lstlisting}%$

Как и следовало ожидать, в нашем распоряжении есть все базовые математические операторы: \lstinline'+=.', \lstinline'-=.', \lstinline'*=.' и \lstinline'/=.'. Они не только удобны для обновления единичной записи, но и необходимы для соблюдения гарантий ACID. Представьте, что бы мы делали без этих операторов. Нам приходилось бы извлекать из базы Person, увеличивать возраст, а затем обновлять значение в базе данных на новое. Как только у вас появляется два процесса или потока, одновременно работающих с базой данных, вы попадаете в мир боли (подсказка: состоняие гонки).

Иногда вы хотите обновить несколько строк одновременно (повысить зарплату на 5\% всем вашим работникам, например). Функция updateWhere принимает два аргумента: список фильтров и список одновлений, которые следует применить. % в оригинале "Sometimes you'll want to update many fields", мне кажется, это опечатка: https://github.com/yesodweb/yesodweb.com-content/pull/28

\begin{lstlisting}
    updateWhere [PersonFirstName ==. "Michael"] [PersonAge *=. 2] -- это был длинный день
\end{lstlisting}

Иногда хочется просто заменить одно значение в базе данных на другое. Для этого (сюрприз!) воспользуйтесь функцией replace:

\begin{lstlisting}
    personId <- insert $ Person "Michael" "Snoyman" 26
    replace personId $ Person "John" "Doe" 20
    update personId [PersonAge =. 27]
    haveBirthday personId
    updateWhere [PersonFirstName ==. "Michael"] [PersonAge *=. 2] -- это был длинный день
    resultsForPage 1 >>= liftIO . print
\end{lstlisting}%$

\section{Удаление} % Delete

Как ни печально, иногда мы вынуждены расстаться с нашими данными. Для этого у нас есть аж три функции:

\begin{center}
\begin{tabular}{ | l | l |}
\hline
delete & Удалить по ID \\ \hline
deleteBy & Удалить по уникальному ключу \\ \hline
deleteWhere & Удалить по множеству фильтров \\ \hline
\end{tabular}
\end{center}

\begin{lstlisting}
    personId <- insert $ Person "Michael" "Snoyman" 26
    delete personId
    deleteBy $ UniqueName "Michael" "Snoyman"
    deleteWhere [PersonFirstName ==. "Michael"]
\end{lstlisting}%$

С помощью deleteWhere мы можем удалить вообще все данные из таблицы. Нужно только подсказать GHC, какая таблица нас интересует:

\begin{lstlisting}
    deleteWhere ([] :: [Filter Person])
\end{lstlisting}

\section{Атрибуты} % Attributes

До сих пор мы видели базовый синтаксис для наших persist-блоков --- строка с именем сущности, за которой для кажлого поля идет по одной строке с отступами, состоящей из двух слов, имени поля и типа данных поля. Persistent поддерживает не только это. После двух слов в строке вы можете указать произвольный список атрибутов.

Допустим, вы хотите, чтобы сущность Person имела необязательный возраст, а также время добавления его или ее в систему. Для сущностей, уже находящихся в базе данных, в качестве этого времени мы хотим использовать текущее время.

\begin{lstlisting}
{-# LANGUAGE QuasiQuotes, TypeFamilies, GeneralizedNewtypeDeriving, TemplateHaskell, OverloadedStrings, GADTs, FlexibleContexts #-}

import Database.Persist
import Database.Persist.Sqlite
import Database.Persist.TH
import Data.Time
import Control.Monad.IO.Class

share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persist|
Person
    name String
    age Int Maybe
    created UTCTime default=now()
    deriving Show
|]

main = withSqliteConn ":memory:" $ runSqlConn $ do
    time <- liftIO getCurrentTime
    runMigration migrateAll
    insert $ Person "Michael" (Just 26) time
    insert $ Person "Greg" Nothing time
\end{lstlisting}%$

Maybe является встроенным атрибутом из одного слова. Он делает поле необязательным. Это означает, что в Haskell данное поле будет обернуто в Maybe, а в SQL оно может иметь значение NULL.

Атрибут default зависит от используемого бэкенда и может использовать любой синтаксис, лишь бы он был понятен СУБД. В приведенном примере используется встроенная функция СУБД now(). Допустим, теперь мы хотим добавить в сущность Person поле с любимым языком программирования:

\begin{lstlisting}
{-# LANGUAGE QuasiQuotes, TypeFamilies, GeneralizedNewtypeDeriving, TemplateHaskell, OverloadedStrings, GADTs, FlexibleContexts #-}

import Database.Persist
import Database.Persist.Sqlite
import Database.Persist.TH
import Data.Time

share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persist|
Person
    name String
    age Int Maybe
    created UTCTime default=now()
    language String default='Haskell'
    deriving Show
|]

main = withSqliteConn ":memory:" $ runSqlConn $ do
    runMigration migrateAll
\end{lstlisting}%$

\begin{remark}
Атрибут default абсолютно никак не затрагивает код на Haskell, то есть, вам по прежнему придется заполнять все значения. Атрибут влияет только на схему базы данных и автоматические миграции.
\end{remark}

Мы должны окружить строку в одинарные кавычки, чтобы СУБД могла правильно интерпретировать ее. Также Persistent позволяет использовать двойные кавычки для строк, содержащих пробелы. Например, если мы хотим сделать страной по-умолчанию Российскую Федерацию, то должны написать:

\begin{lstlisting}
{-# LANGUAGE QuasiQuotes, TypeFamilies, GeneralizedNewtypeDeriving, TemplateHaskell, OverloadedStrings, GADTs, FlexibleContexts #-}

import Database.Persist
import Database.Persist.Sqlite
import Database.Persist.TH
import Data.Time

share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persist|
Person
    name String
    age Int Maybe
    created UTCTime default=now()
    language String default='Haskell'
    country String "default='Российская Федерация'"
    deriving Show
|]

main = withSqliteConn ":memory:" $ runSqlConn $ do
    runMigration migrateAll
\end{lstlisting}%$

Последний трюк, который вы можете проделать с атрибутами --- это указать имена таблиц и столбцов, используемые в SQL. Это может пригодиться при взаимодействии с существующими базами данных.

\begin{lstlisting}
share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persist|
Person sql=the-person-table
    firstName String sql=first_name
    lastName String sql=fldLastName
    age Int Gt Desc "sql=The Age of the Person"
    UniqueName firstName lastName
    deriving Show
|]

resultsForPage pageNumber = do
    let resultsPerPage = 10
    selectList
        [ PersonAge >=. 18
        ]
        [ Desc PersonAge
        , Asc PersonLastName
        , Asc PersonFirstName
        , LimitTo resultsPerPage
        , OffsetBy $ (pageNumber - 1) * resultsPerPage
        ]

main = withSqliteConn ":memory:" $ runSqlConn $ do
    runMigration migrateAll
    personId <- insert $ Person "Michael" "Snoyman" 26
    resultsForPage 1 >>= liftIO . print
\end{lstlisting}%$

\section{Отношения} % Relations

Persistent allows references between your data types in a manner that is consistent with supporting non-SQL databases. We do this by embedding an ID in the related entity. So if a person has many cars:

\begin{lstlisting}
{-# LANGUAGE QuasiQuotes, TypeFamilies, GeneralizedNewtypeDeriving, TemplateHaskell, OverloadedStrings, GADTs, FlexibleContexts #-}

import Database.Persist
import Database.Persist.Sqlite
import Database.Persist.TH
import Control.Monad.IO.Class (liftIO)
import Data.Time

share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persist|
Person
    name String
    deriving Show
Car
    ownerId PersonId Eq
    name String
    deriving Show
|]

main = withSqliteConn ":memory:" $ runSqlConn $ do
    runMigration migrateAll
    bruce <- insert $ Person "Bruce Wayne"
    insert $ Car bruce "Bat Mobile"
    insert $ Car bruce "Porsche"
    -- this could go on a while
    cars <- selectList [CarOwnerId ==. bruce] []
    liftIO $ print cars
\end{lstlisting}%$
 
Using this technique, you can define one-to-many relationships. To define many-to-many relationships, we need a join entity, which has a one-to-many relationship with each of the original tables. It is also a good idea to use uniqueness constraints on these. For example, to model a situation where we want to track which people have shopped in which stores:

\begin{lstlisting}
{-# LANGUAGE QuasiQuotes, TypeFamilies, GeneralizedNewtypeDeriving, TemplateHaskell, OverloadedStrings, GADTs, FlexibleContexts #-}

import Database.Persist
import Database.Persist.Sqlite
import Database.Persist.TH
import Data.Time

share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persist|
Person
    name String
Store
    name String
PersonStore
    personId PersonId
    storeId StoreId
    UniquePersonStore personId storeId
|]

main = withSqliteConn ":memory:" $ runSqlConn $ do
    runMigration migrateAll

    bruce <- insert $ Person "Bruce Wayne"
    michael <- insert $ Person "Michael"

    target <- insert $ Store "Target"
    gucci <- insert $ Store "Gucci"
    sevenEleven <- insert $ Store "7-11"

    insert $ PersonStore bruce gucci
    insert $ PersonStore bruce sevenEleven

    insert $ PersonStore michael target
    insert $ PersonStore michael sevenEleven
\end{lstlisting}%$

\begin{remark}
Since the Id suffix on a type is used to indicate a foreign key relationship to Persistent, you currently cannot use non-key types that end in Id. A simple workaround is to define a type synonym with a different suffix, e.g.:

\begin{lstlisting}
data MyExistingTypeEndingInId = ...
type IdIsNotTheSuffix = MyExistingTypeEndingInId
[persist|
Person
    someField IdIsNotTheSuffix
\end{lstlisting}%$
\end{remark}

\section{Подробнее о типах} % Closer look at types

So far, we've spoken about Person and PersonId without really explaining what they are. In the simplest sense, for a SQL-only system, the PersonId could just be type PersonId = Int64. However, that means there is nothing binding a PersonId at the type level to the Person entity. As a result, you could accidently use a PersonId and get a Car. In order to model this relationship, we use phantom types. So, our next naive step would be:

\begin{lstlisting}
newtype Key entity = Key Int64
type PersonId = Key Person
\end{lstlisting}

\begin{remark}
Prior to Persistent 0.6, we used associated types instead of phantom types. You could solve the problem in that direction as well, but phantoms worked out better.
\end{remark}

And that works out really well, until you get to a backend that doesn't use Int64 for its IDs. And that's not just a theoretical question; MongoDB uses ByteStrings instead. So what we need is a key value that can contain an Int and a ByteString. Seems like a great time for a sum type:

\begin{lstlisting}
data Key entity = KeyInt Int64 | KeyByteString ByteString
\end{lstlisting}

But that's just asking for trouble. Next we'll have a backend that uses timestamps, so we'll need to add another constructor to Key. This could go on for a while. Fortunately, we already have a sum type intended for representing arbitrary data: PersistValue:

\begin{lstlisting}
newtype Key entity = Key PersistValue
\end{lstlisting}

But this has another problem. Let's say we have a web application that takes an ID as a parameter from the user. It will need to receive that parameter as Text and then try to convert it to a Key. Well, that's simple: write a function to convert a Text to a PersistValue, and then wrap the result in the Key constructor, right?

Wrong. We tried this, and there's a big problem. We end up getting Keys that could never be. For example, if we're dealing with SQL, a key must be an integer. But the approach described above would allow arbitrary textual data in. The result was a bunch of 500 server errors as the database choked on comparing an integer column to text.

So what we need is a way to convert text to a Key, but have it dependent on the rules of the backend in question. And once phrased that way, the answer is simple: just add another phantom. The real, actual definition of Key in Persistent is:

\begin{lstlisting}
newtype Key backend entity = Key { unKey :: PersistValue }
\end{lstlisting}

This works great: we can have a Text -> Key MongoDB entity function and a Text -> Key SqlPersist entity function, and everything runs smoothly. But now we have a new problem: relations. Let's say we want to represent blogs and blog posts. We would use the entity definition:

\begin{lstlisting}
Blog
    title Text
Post
    title Text
    blogId BlogId
\end{lstlisting}

But what would that look like in terms of our Key datatype?

\begin{lstlisting}
data Blog = Blog { blogTitle :: Text }
data Post = Post { postTitle :: Text, postBlogId :: Key <what goes here?> Blog }
\end{lstlisting}

We need something to fill in as the backend. In theory, we could hardcode this to SqlPersist, or Mongo, but then our datatypes will only work for a single backend. For an individual application, that might be acceptable, but what about libraries defining datatypes to be used by multiple applications, using multiple backends?

So things got a little more complicated. Our types are actually:

\begin{lstlisting}
data BlogGeneric backend = Blog { blogTitle :: Text }
data PostGeneric backend = Post { postTitle :: Text, postBlogId :: Key backend (BlogGeneric backend) }
\end{lstlisting}

Notice that we still keep the short names for the constructors and the records. Finally, to give a simple interface for normal code, we define some type synonyms:

\begin{lstlisting}
type Blog = BlogGeneric SqlPersist
type BlogId = Key SqlPersist Blog
type Post = PostGeneric SqlPersist
type PostId = Key SqlPersist Post
\end{lstlisting}

And no, SqlPersist isn't hard-coded into Persistent anywhere. That sqlSettings parameter you've been passing to mkPersist is what tells us to use SqlPersist. Mongo code will use mongoSettings instead.

This might be quite complicated under the surface, but user code hardly ever touches this. Look back through this whole chapter: not once did we need to deal with the Key or Generic stuff directly. The most common place for it to pop up is in compiler error messages. So it's important to be aware that this exists, but it shouldn't affect you on a day-to-day basis.

\section{Произвольные поля} % Custom Fields

Occassionally, you will want to define a custom field to be used in your datastore. The most common case is an enumeration, such as employment status. For this, Persistent provides a helper Template Haskell function:

\begin{lstlisting}
{-# LANGUAGE QuasiQuotes, TypeFamilies, GeneralizedNewtypeDeriving, TemplateHaskell, OverloadedStrings, GADTs, FlexibleContexts #-}

import Database.Persist
import Database.Persist.Sqlite
import Database.Persist.TH

data Employment = Employed | Unemployed | Retired
    deriving (Show, Read, Eq)
derivePersistField "Employment"

share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persist|
Person
    name String
    employment Employment
|]

main = withSqliteConn ":memory:" $ runSqlConn $ do
    runMigration migrateAll

    insert $ Person "Bruce Wayne" Retired
    insert $ Person "Peter Parker" Unemployed
    insert $ Person "Michael" Employed
\end{lstlisting}%$

derivePersistField stores the data in the database using a string field, and performs marshaling using the Show and Read instances of the datatype. This may not be as efficient as storing via an integer, but it is much more future proof: even if you add extra constructors in the future, your data will still be valid.

\section{Persistent: сырой SQL} % Persistent: Raw SQL

The Persistent package provides a type safe interface to data stores. It tries to be backend-agnostic, such as not relying on relational features of SQL. My experience has been you can easily perform 95\% of what you need to do with the high-level interface. (In fact, most of my web apps use the high level interface exclusively.)

But occassionally you'll want to use a feature that's specific to a backend. One feature I've used in the past is full text search. In this case, we'll use the SQL "LIKE" operator, which is not modeled in Persistent. We'll get all people with the last name "Snoyman" and print the records out.

\begin{remark}
Actually, you can express a LIKE operator directly in the normal syntax due to a feature added in Persistent 0.6, which allows backend-specific operators. But this is still a good example, so let's roll with it.
\end{remark}

\begin{lstlisting}
{-# LANGUAGE OverloadedStrings, TemplateHaskell, QuasiQuotes, TypeFamilies #-}
{-# LANGUAGE GeneralizedNewtypeDeriving, GADTs, FlexibleContexts #-}

import Database.Persist.Sqlite (withSqliteConn)
import Database.Persist.TH (mkPersist, persist, share, mkMigrate, sqlSettings)
import Database.Persist.GenericSql (runSqlConn, runMigration, SqlPersist)
import Database.Persist.GenericSql.Raw (withStmt)
import Data.Text (Text)
import Database.Persist
import Database.Persist.Store (PersistValue)
import Control.Monad.IO.Class (liftIO)
import qualified Data.Conduit as C
import qualified Data.Conduit.List as CL

share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persist|
Person
    name Text
|]

main :: IO ()
main = withSqliteConn ":memory:" $ runSqlConn $ do
    runMigration migrateAll
    insert $ Person "Michael Snoyman"
    insert $ Person "Miriam Snoyman"
    insert $ Person "Eliezer Snoyman"
    insert $ Person "Gavriella Snoyman"
    insert $ Person "Greg Weber"
    insert $ Person "Rick Richardson"

    -- Persistent does not provide the LIKE keyword, but we'd like to get the
    -- whole Snoyman family...
    let sql = "SELECT name FROM Person WHERE name LIKE '%Snoyman'"
    C.runResourceT $ withStmt sql []
                C.$$ CL.mapM_ $ liftIO . print
\end{lstlisting}%$

There is also higher-level support that allows for automated data marshaling. Please see the Haddock API docs for more details.

\section{Интеграция с Yesod} % Integration with Yesod

So you've been convinced of the power of Persistent. How do you integrate it with your Yesod application? If you use the scaffolding, most of the work is done for you already. But as we normally do, we'll build up everything manually here to point out how it works under the surface.

The yesod-persistent package provides the meeting point between Persistent and Yesod. It provides the YesodPersist typeclass, which standardizes access to the database via the runDB method. Let's see this in action.

\begin{lstlisting}
{-# LANGUAGE QuasiQuotes, TypeFamilies, GeneralizedNewtypeDeriving, FlexibleContexts #-}
{-# LANGUAGE TemplateHaskell, OverloadedStrings, GADTs, MultiParamTypeClasses #-}

import Yesod
import Database.Persist.Sqlite

-- Define our entities as usual
share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persist|
Person
    firstName String
    lastName String
    age Int Gt Desc
    deriving Show
|]

-- We keep our connection pool in the foundation. At program initialization, we
-- create our initial pool, and each time we need to perform an action we check
-- out a single connection from the pool.
data PersistTest = PersistTest ConnectionPool

-- We'll create a single route, to access a person. It's a very common
-- occurrence to use an Id type in routes.
mkYesod "PersistTest" [parseRoutes|
/person/#PersonId PersonR GET
|]

-- Nothing special here
instance Yesod PersistTest

-- Now we need to define a YesodPersist instance, which will keep track of
-- which backend we're using and how to run an action.
instance YesodPersist PersistTest where
    type YesodPersistBackend PersistTest = SqlPersist

    runDB action = do
        PersistTest pool <- getYesod
        runSqlPool action pool

-- We'll just return the show value of a person, or a 404 if the Person doesn't
-- exist.
getPersonR :: PersonId -> Handler RepPlain
getPersonR personId = do
    person <- runDB $ get404 personId
    return $ RepPlain $ toContent $ show person

openConnectionCount :: Int
openConnectionCount = 10

main :: IO ()
main = withSqlitePool "test.db3" openConnectionCount $ \pool -> do
    runSqlPool (runMigration migrateAll) pool
    runSqlPool (insert $ Person "Michael" "Snoyman" 26) pool
    warpDebug 3000 $ PersistTest pool
\end{lstlisting}%$

There are two important pieces here for general use. runDB is used to run a DB action from within a Handler. Within the runDB, you can use any of the functions we've spoken about so far, such as insert and selectList.

\begin{remark}
The type of runDB is runDB :: YesodDB sub master a -> GHandler sub master a. YesodDB is defined as:

\begin{lstlisting}
type YesodDB sub master = YesodPersistBackend master (GHandler sub master)
\end{lstlisting}

Since it is built on top of the YesodPersistBackend associated type, it uses the appropriate database backend based on the current site.
\end{remark}

The other new feature is get404. It works just like get, but instead of returning a Nothing when a result can't be found, it returns a 404 message page. The getPersonR function is a very common approach used in real-world Yesod applications: get404 a value and then return a response based on it.

\section{Заключение} % Summary

Persistent brings the type safety of Haskell to your data access layer. Instead of writing error-prone, untyped data access, or manually writing boilerplate marshal code, you can rely on Persistent to automate the process for you.

The goal is to provide everything you need, most of the time. For the times when you need something a bit more powerful, Persistent gives you direct access to the underlying data store, so you can write whatever 5-way joins you want.

Persistent integrates directly into the general Yesod workflow. Not only do helper packages like yesod-persistent provide a nice layer, but packages like yesod-form and yesod-auth also leverage Persistent's features as well.
