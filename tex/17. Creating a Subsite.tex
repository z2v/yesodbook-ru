Создание дочернего сайта

Сколько сайтов требуют систему аутентификации? Или функции управления данными (CRUD)? Или блог? Или вики?

Идея в том, что многие веб-сайты включают общие компоненты, которые можно использовать для нескольких сайтов. Однако, часто бывает довольно трудно получить модульный код, который действительно был бы plug-and-play: такая компонента потребует включения в систему маршрутизации, как правило, нескольких маршрутов, а также ей будет необходимо каким-то образом использовать совместный стиль с главным сайтом.

Решением в Yesod являются дочерние сайты. Дочерний сайт представляет собой набор маршрутов и их обработчиков, которые могут быть легко включены в главный сайт. Используя классы типов, легко убедиться, что мастер сайт предоставляет определенные возможности и доступ к стандартной разметке сайта. А с помощью типизированных URL, легко ссылаться с главного сайта на дочерние.

Hello World

Создание дочерних сайтов достаточно мудрёный процесс, вовлекающий ряд различных типов. Давайте начнем с простого Hello World:

\begin{lstlisting}
{-# LANGUAGE QuasiQuotes, TypeFamilies, MultiParamTypeClasses #-}
{-# LANGUAGE TemplateHaskell, FlexibleInstances, OverloadedStrings #-}
import Yesod

-- У дочерних сайтов, также как и у главных, есть фундаментальные типы.
data HelloSub = HelloSub

-- Тут аналог знакомого нам mkYesod, с одним дополнительным параметром.
-- Мы обсудим это позже.
mkYesodSub "HelloSub" [] [parseRoutes|
/ SubRootR GET
|]

-- Опишем сигнатуру типа для обработчика.
getSubRootR :: Yesod master => GHandler HelloSub master RepHtml
getSubRootR = defaultLayout [whamlet|Welcome to the subsite!|]

-- Давайте создадим главный сайт который будет его вызывать.
data Master = Master
    { getHelloSub :: HelloSub
    }

mkYesod "Master" [parseRoutes|
/ RootR GET
/subsite SubsiteR HelloSub getHelloSub
|]

instance Yesod Master

-- Опять опишем сигнатуру типа.
getRootR :: GHandler sub Master RepHtml -- could also replace sub with Master
getRootR = defaultLayout [whamlet|
<h1>Welcome to the homepage
<p>
    Feel free to visit the #
    <a href=@{SubsiteR SubRootR}>subsite
    \ as well.
|]

main = warpDebug 3000 $ Master HelloSub
\end{lstlisting}

Этот очень простой пример на самом деле демонстрирует большинство сложностей связанных с созданием дочернего сайта. Как и в обычном приложении Yesod, в дочернем всё сосредоточено вокруг фундаментального типа, в нашем случае HelloSub. Затем мы используем mkYesodSub, во многом так же, как мы используем mkYesod, чтобы создать тип данных маршрута и функции деспетчеризации и рендеринга. (Мы еще вернемся к дополнительному параметру через секунду).

Что интересно, так это сигнатура типа getSubRootR. До сих пор мы старались не обращать внимания на тип GHandler, или делать вид, что первые два аргумента типа всегда одинаковы. Теперь мы должны, наконец, узнать правду об этом странном типе.

У функции обработчика всегда есть два фундаментальных типа, связанных с ней: дочерний и главный сайт. Когда вы пишете обычное приложение, эти два типа данных одинаковы. Однако, если вы работаете с дочерним сайтом, они обязательно будут отличаться. Таким образом, сигнатура типа для getSubRootR использует HelloSub для первого аргумента и master для второго.

Функция DefaultLayout принадлежит классу типов Yesod. Таким образом, для того, чтобы её вызывать, аргумент типа master должен быть экземпляром Yesod. Преимуществом такого подхода является то, что любые изменения в методе defaultLayout главного сайта будут автоматически отражены в дочерних сайтах.

Когда мы включаем дочерний сайт в определение маршрутов нашего главного сайта, мы должны определить четыре части информации: маршрут, используемый дочерним сайтом в качестве базового (в данном случае /subsite), конструктор для маршрутов дочернего сайта (SubsiteR), фундаментальный тип данных (HelloSub) для дочернего сайта и функцию, которая принимает фундаментальное значение главного сайта и возвращает фундаментальное значение значение дочернего сайта (getHelloSub).

В определении getRootR, мы можем увидеть, как используется конструктор маршрута. В некотором смысле, SubsiteR переводит любой маршрут дочернего сайта в маршрут главного сайт, что позволяет безопасно ссылаться на него из любого шаблона главного сайта.
