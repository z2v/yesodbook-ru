\chapter{Создание подсайта}\label{chap:subsite}

Сколько сайтов требуют систему аутентификации? Или функции управления данными
(CRUD)? Или блог? Или вики?

Идея в том, что многие веб-сайты включают общие компоненты, которые можно
использовать для нескольких сайтов. Однако часто бывает довольно трудно
получить модульный код, который действительно был бы plug-and-play: такой
компонент, вероятно потребует включения в систему маршрутизации нескольких
маршрутов, а также от него потребуется соответствовать стилю основного сайта.

Решением в Yesod являются подсайты. Подсайт представляет собой набор маршрутов
и их обработчиков, которые могут быть легко включены в основной сайт. Используя
классы типов, легко убедиться, что основной сайт предоставляет определённые
возможности. Также с их помощью несложно получить доступ к стандартной разметке
сайта. В свою очередь типобезопасные URL позволяют с лёгкостью ссылаться с
основного сайта на подсайты.

\section{Привет, мир!}
Возможно, главная сложность в создании подсайтов~--- это первоначальное
знакомство. Поэтому давайте сразу начнём с простого приложения <<Привет,
мир!>>. Нам потребуется сделать один модуль для данных подсайта, другой~--- для
кода диспетчеризации, и затем ещё один модуль для приложения, которое
использует наш подсайт.

\begin{remark}
    Причина разделения на данные и код диспетчеризации~--- нечто, называемое
    <<ограничением стадий GHC>> (GHC stage restriction). Это требование делает
    маленькие демо программки многословнее, но на практике, разделение на
    множество модулей~--- хорошая практика для следования.
\end{remark}

\includecode{17/HelloSub/Data.hs}

\includecode{17/HelloSub.hs}

Этот очень простой пример на самом деле демонстрирует большинство сложностей,
связанных с созданием подсайта. Как и в обычном приложении Yesod, в подсайте
всё сосредоточено вокруг основного типа данных, в нашем случае
\lstinline!HelloSub!. Затем мы используем \lstinline!mkYesodSubData!, чтобы
создать тип данных маршрута и связанные функции диспетчеризации/рендеринга.

Что касается диспетчеризации, мы начинаем с определения функции-обработчика для
маршрута~\lstinline'SubHomeR'. Обратите особое внимание на сигнатуру типа этой
функции:
\begin{lstlisting}
getSubHomeR :: Yesod master
            => HandlerT HelloSub (HandlerT master IO) Html
\end{lstlisting}

Это суть всего, относящегося к подсайтам. Все наши действия находятся в этой
многоуровневой монаде, в которой мы оборачиваем наш подсайт вокруг основного
сайта. Наличие уровней естественным образом приводит к использованию
функции~\lstinline'lift'. В нашем случае, подсайт использует
функцию~\lstinline'defaultLayout' основного сайта для отображения виджета.

Функция \lstinline!defaultLayout! принадлежит классу типов Yesod. Таким
образом, для того, чтобы её вызывать, аргумент типа \lstinline!master! должен
быть экземпляром \lstinline!Yesod!.  Преимуществом такого подхода заключается в
том, что любые изменения в методе \lstinline!defaultLayout! основного сайта
будут автоматически отражены в подсайтах.

Когда мы включаем подсайт в определение маршрутов нашего основного сайта, мы
должны определить четыре вещи: маршрут, используемый подсайтом в качестве
базового (в данном случае \lstinline!/subsite!), конструктор для маршрутов
подсайта (\lstinline!SubsiteR!), основной тип данных (\lstinline!HelloSub!) для
подсайта и функцию, которая принимает основное значение основного сайта и
возвращает основное значение подсайта (\lstinline!getHelloSub!).

В определении getRootR мы можем видеть, как используется конструктор маршрута.
В некотором смысле, \lstinline!SubsiteR! переводит любой маршрут подсайта в
маршрут основного сайта, что позволяет безопасно ссылаться на него из любого
шаблона основного сайта.
