\chapter{Создание дочернего сайта}\label{chap:subsite}

Сколько сайтов требуют систему аутентификации? Или функции управления данными (CRUD)? Или блог? Или вики?

Идея в том, что многие веб-сайты включают общие компоненты, которые можно использовать для нескольких сайтов. Однако часто бывает довольно трудно получить модульный код, который действительно был бы plug-and-play: такой компонент, вероятно потребует включения в систему маршрутизации нескольких маршрутов, а также от него потребуется соответствовать стилю основного сайта.

Решением в Yesod являются подсайты. Подсайт представляет собой набор маршрутов и их обработчиков, которые могут быть легко включены в основной сайт. Используя классы типов, легко убедиться, что основной сайт предоставляет определённые возможности. Также с их помощью несложно получить доступ к стандартной разметке сайта. В свою очередь типобезопасные URL позволяют с лёгкостью ссылаться с основного сайта на подсайты.

\section{Привет, мир!}

Создание подсайтов достаточно мудрёный процесс, который затрагивает целый ряд различных типов. Давайте начнём с простого приложения <<Привет, мир!>>:
\includecode{17/hellosub.hs}

Этот очень простой пример на самом деле демонстрирует большинство сложностей, связанных с созданием подсайта. Как и в обычном приложении Yesod, в подсайте всё сосредоточено вокруг основного типа данных, в нашем случае \lstinline!HelloSub!. Затем мы используем \lstinline!mkYesodSub!, во многом так же, как мы используем \lstinline!mkYesod!: чтобы создать тип данных маршрута и функции деспетчеризации/рендеринга. (Мы ещё вернёмся к дополнительному параметру через секунду).

Что интересно, так это сигнатура типа \lstinline!getSubRootR!. До сих пор мы старались не обращать внимания на тип данных \lstinline!GHandler!, или, в случае необходимости, делать вид, что первые два аргумента типа всегда одинаковы. Теперь мы должны, наконец, узнать правду об этом странном типе данных.

У функции обработчика всегда есть два основных типа, связанных с ней: подсайт и основной сайт. Когда вы пишете обычное приложение, эти \emph{два типа данных одинаковы}.  Однако, если вы работаете с подсайтом, они обязательно будут отличаться. Таким образом, сигнатура типа для \lstinline!getSubRootR! использует \lstinline!HelloSub! для первого аргумента и master для второго.

Функция \lstinline!defaultLayout! принадлежит классу типов Yesod. Таким образом, для того, чтобы её вызывать, аргумент типа \lstinline!master! должен быть экземпляром \lstinline!Yesod!.  Преимуществом такого подхода заключается в том, что любые изменения в методе \lstinline!defaultLayout! основного сайта будут автоматически отражены в подсайтах.

Когда мы включаем подсайт в определение маршрутов нашего основного сайта, мы должны определить четыре вещи: маршрут, используемый подсайтом в качестве базового (в данном случае \lstinline!/subsite!), конструктор для маршрутов подсайта (\lstinline!SubsiteR!), основной тип данных (\lstinline!HelloSub!) для подсайта и функцию, которая принимает основное значение основного сайта и возвращает основное значение подсайта (\lstinline!getHelloSub!).

В определении getRootR мы можем видеть, как используется конструктор маршрута. В некотором смысле, \lstinline!SubsiteR! переводит любой маршрут подсайта в маршрут основного сайта, что позволяет безопасно ссылаться на него из любого шаблона основного сайта.
