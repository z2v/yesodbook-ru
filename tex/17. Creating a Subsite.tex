\chapter{Создание дочернего сайта}

Сколько сайтов требуют систему аутентификации? Или функции управления данными (CRUD)? Или блог? Или вики?

Идея в том, что многие веб-сайты включают общие компоненты, которые можно использовать для нескольких сайтов. Однако часто бывает довольно трудно получить модульный код, который действительно был бы plug-and-play: такая компонента, вероятноЮ потребует включения в систему маршрутизации нескольких маршрутов, а также от нее потребуется соответствовать стилю главного сайта.

Решением в Yesod являются дочерние сайты. Дочерний сайт представляет собой набор маршрутов и их обработчиков, которые могут быть легко включены в главный сайт. Используя классы типов, легко убедиться, что главный сайт предоставляет определенные возможности. Также с их помощью несложно получить доступ к стандартной разметке сайта. В свою очередь типобезопасные URL позволяют с легкостью ссылаться с главного сайта на дочерние.

\section{Привет, мир!}

Создание дочерних сайтов достаточно мудрёный процесс, вовлекающий ряд различных типов. Давайте начнем с простого приложения <<Привет, мир!>>:

\begin{lstlisting}
{-# LANGUAGE QuasiQuotes, TypeFamilies, MultiParamTypeClasses #-}
{-# LANGUAGE TemplateHaskell, FlexibleInstances, OverloadedStrings #-}
import Yesod

-- У дочерних сайтов, также как и у главных, есть основной тип данных.
data HelloSub = HelloSub

-- Тут аналог знакомого нам mkYesod, с одним дополнительным параметром.
-- Мы обсудим это позже.
mkYesodSub "HelloSub" [] [parseRoutes|
/ SubRootR GET
|]

-- Опишем сигнатуру типа для обработчика.
getSubRootR :: Yesod master => GHandler HelloSub master RepHtml
getSubRootR = defaultLayout [whamlet|Welcome to the subsite!|]

-- Давайте создадим главный сайт который будет его вызывать.
data Master = Master
    { getHelloSub :: HelloSub
    }

mkYesod "Master" [parseRoutes|
/ RootR GET
/subsite SubsiteR HelloSub getHelloSub
|]

instance Yesod Master

-- Опять опишем сигнатуру типа.
getRootR :: GHandler sub Master RepHtml -- так же могли бы заметь sub на Master
getRootR = defaultLayout [whamlet|
<h1>Добро пожаловать на главную страницу
<p>
    Обратите внимание, что вы также можете посетить #
    <a href=@{SubsiteR SubRootR}>дочерний сайт
    \ .
|]

main = warpDebug 3000 $ Master HelloSub
\end{lstlisting}

Этот очень простой пример на самом деле демонстрирует большинство сложностей, связанных с созданием дочернего сайта. Как и в обычном приложении Yesod, в дочернем сайте всё сосредоточено вокруг основного типа данных, в нашем случае HelloSub. Затем мы используем mkYesodSub, во многом так же, как мы используем mkYesod, чтобы создать тип данных маршрута и функции деспетчеризации/рендеринга. (Мы еще вернемся к дополнительному параметру через секунду).

Что интересно, так это сигнатура типа getSubRootR. До сих пор мы старались не обращать внимания на тип данных GHandler, или, в случае необходимости, делать вид, что первые два аргумента типа всегда одинаковы. Теперь мы должны, наконец, узнать правду об этом странном типе данных.

У функции обработчика всегда есть два основных типа, связанных с ней: дочерний и главный сайт. Когда вы пишете обычное приложение, эти два типа данных одинаковы. Однако, если вы работаете с дочерним сайтом, они обязательно будут отличаться. Таким образом, сигнатура типа для getSubRootR использует HelloSub для первого аргумента и master для второго.

Функция DefaultLayout принадлежит классу типов Yesod. Таким образом, для того, чтобы её вызывать, аргумент типа master должен быть экземпляром Yesod. Преимуществом такого подхода заключается в том, что любые изменения в методе defaultLayout главного сайта будут автоматически отражены в дочерних сайтах.

Когда мы включаем дочерний сайт в определение маршрутов нашего главного сайта, мы должны определить четыре вещи: маршрут, используемый дочерним сайтом в качестве базового (в данном случае /subsite), конструктор для маршрутов дочернего сайта (SubsiteR), основной тип данных (HelloSub) для дочернего сайта и функцию, которая принимает основное значение главного сайта и возвращает основное значение дочернего сайта (getHelloSub).

В определении getRootR, мы можем видеть, как используется конструктор маршрута. В некотором смысле, SubsiteR переводит любой маршрут дочернего сайта в маршрут главного сайт, что позволяет безопасно ссылаться на него из любого шаблона главного сайта.
