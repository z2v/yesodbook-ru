\chapter{Интерфейс веб-приложений}\label{chap:web_application_interface}

\begin{remark}
    Глава описывает версию 3.0 WAI, которая имеет ряд отличий от предыдущих
    версий.
\end{remark}

Практически всякий язык, используемый для веб-разработки, сталкивается с
проблемой низкоуровневого интерфейса между веб-сервером и приложением. Самым
ранним примером решения этой проблемы является почтенный и потёртый в боях
Common Gateway Interface (CGI), который предоставляет не зависящий от языка
интерфейс на основе стандартных потоков ввода/вывода и переменных среды
окружения.

Но уже в те времена, когда Perl только становился языком веб-программирования
де-факто, стал очевиден основной недостаток CGI~--- для каждого запроса должен
быть запущен новый процесс. При работе с интерпретируемым языком и
приложениями, требующими подключения к базе данных, эти издержки стали
чрезмерны. FastCGI (и позднее SCGI) возник как преемник CGI, но, похоже,
основная часть мира программирования направилась в другом направлении.

Каждый язык начал создавать свой собственный стандарт для взаимодействия с
сервером.  mod\_perl. mod\_python. mod\_php. mod\_ruby. Для одного и того же
языка появлялись различные интерфейсы. В некоторых случаях получались даже
интерфейсы поверх интерфейсов.  Всё это привело к ещё большему дублированию
усилий: приложение на Python, созданное для работы с FastCGI, не работало с
mod\_python, а mod\_python существовал только для определённых веб-серверов. И
подобные модули расширения веб-сервера должны были быть реализованы для каждого
языка.

У Haskell своя история. Сначала у нас был пакет cgi, который предоставлял
монадный интерфейс. Позднее появился пакет fastcgi с таким же интерфейсом.  Тем
временем, казалось, большая часть веб-разработки на Haskell сфокусировалась на
написании отдельных серверов.  Проблема в том, что у каждого сервера свой
собственный интерфейс, а это означает, что вы вынуждены при разработке
ориентироваться на конкретный сервер. Что, в свою очередь, означает
невозможность использовать общий функционал наподобие GZIP кодирования, сервера
разработки или фреймворка для тестирования.

WAI пробует решить эту проблему, обеспечивая обобщённый и эффективный интерфейс
между веб-серверами и приложениями. Любой \textbf{обработчик}, поддерживающий
этот интерфейс может обслуживать любое приложение WAI, в то же время любое
приложение, использующее этот интерфейс, может быть запущено любым
обработчиком.

На момент написания этой книги существует несколько веб-серверов, реализующих
WAI, такие как Warp, FastCGI и сервер разработки. Существуют и другие
реализации, известные лишь посвящённым, например, wai-handler-webkit,
используемый для создания настольных приложений. Пакет wai-extra предоставляет
много обычных компонент промежуточного уровня, к примеру, реализующих поддержку
GZIP, JSON-P и виртуального хостинга. Библиотека wai-test облегчает написание
модульных тестов, а wai-handler-devel позволяет разрабатывать приложения, не
отвлекаясь на остановку сервера для компиляции.  Yesod уже ориентирован на
использование WAI, также как такие веб-фрейморки для Haskell, как Scotty
и~MFlow. Этот интерфейс также используется некоторыми приложениями, которые
вообще не используют фреймворки, включая Hoogle.

\begin{remark}
    Yesod предоставляет альтернативный подход для сервера разработки, известный
    как \texttt{yesod devel}. Отличие от \texttt{wai-handler-devel} состоит в
    том, что \texttt{yesod devel} компилирует ваш код каждый раз, учитывая все
    настройки в вашем cabal-файле.  Этот подход рекомендуется при разработке на
    Yesod.
\end{remark}

\section {Интерфейс}
Интерфейс сам по себе довольно незатейлив: приложение принимает запрос и
возвращает ответ. Ответом является статус HTTP, список заголовков и тело
ответа.  Запрос содержит различную информацию: запрашиваемый путь, строку
запроса, тело запроса, версию HTTP и т.д.

Чтобы выполнять управление ресурсами безопасным способом, мы используем стиль
передачи продолжения (continuation passing style) для возврата ответа,
наподобие того, как работает функция~\lstinline'bracket'. В результате
определение нашего приложения принимает вид:
\begin{lstlisting}
type Application =
    Request ->
    (Response -> IO ResponseReceived) ->
    IO ResponseReceived
\end{lstlisting}

Первый аргумент~--- это \lstinline'Request'\footnote{Тип данных для
    запроса.~--- Прим. перев.}, что не должно удивлять. Второй аргумент~---
это, собственно, продолжение, т.е. то, что мы должны \textbf{сделать}
c~\lstinline'Response'. Вообще говоря, он просто будет отправлен клиенту. Мы
используем специальный тип~\lstinline'ResponseReceived', чтобы убедиться, что
приложение на самом деле вызывает продолжение.

Всё это может показаться немного странным, но использование в целом очевидно,
как мы покажем ниже.

\subsection {Тело ответа}
В Haskell есть тип данных известный как ленивая строка байтов. Используя
ленивость, вы можете создавать большие значения, не переполняя память.
Например, используя ленивый ввод/вывод, вы можете иметь значение, которое
представляет всё содержимое файла и в то же время занимает небольшой участок
памяти. В теории, ленивая строка байтов является единственным необходимым
представлением тела ответа.

На практике же, в то время как ленивые строки байтов замечательно подходят для
<<чистых>> значений, ленивый ввод/вывод, необходимый для чтения файлов, вносит
некоторый недетерминизм в нашу программу. При обработке тысяч небольших файлов
в секунду, ограничивающим фактором является не память, а число дескрипторов
файлов. При использовании ленивого ввода/вывода файловые дескрипторы не могут
быть освобождены мгновенно, что приводит к исчерпанию ресурсов. Для решения
этой проблемы WAI предоставляет свой собственный потоковый интерфейс для данных.

Ядро этого потокового интерфейса~--- тип~\lstinline'Builder'.
\lstinline'Builder' представляет действие, которое заполняет буфер байтами
данных. Это эффективнее, чем просто передавать \lstinline'ByteString', так как
позволяет избежать многочисленных копий данных. В большинстве случаев,
приложению требуется только предоставить единственное
знаечение~\lstinline'Builder'. И для этого простого случая у нас есть отдельный
конструктор~\lstinline'ResponseBuilder'.

Однако, бывают случаи, когда \lstinline'Application' потребуется чередовать
\lstinline'IO' действия с генерацией данных для клиента. Для этого случая у нас
есть~\lstinline'ResponseStream'. С \lstinline'ResponseStream', вы
предоставляете \textbf{функцию}. Эта функция в свою очередь выполняет два
действия: <<создать ещё данных>> и <<сбросить буфер>>. Это позволяет вам
подготовить данные, выполнить \lstinline'IO' действия, сбросить буфер, столько
раз, сколько требуется, с любым желаемым чередованием.

Есть ещё одна оптимизация: многие системы предоставляют системный
вызов~\texttt{sendfile}, который отправляет файл напрямую в сокет, минуя
неизбежные копирования в памяти, которые присущи более общим системным вызовам
ввода/вывода. Для этого случая у нас есть~\lstinline'ResponseFile'.

И, наконец, есть случаи, когда требуется полностью выйти из режима HTTP. Два
примера: WebSockets, когда нам требуется перейти с полудуплексного соединения
HTTP на дуплексное соединение, и проксирование HTTPS, которое требует от нашего
прокси-сервера установить соединение и стать простым пересыльщиком данных. Для
этих случаев у нас есть конструктор~\lstinline'ResponseRaw'. Обратите внимание,
что не все обработчики WAI могут на самом деле поддерживать
\lstinline'ResponseRaw', хотя наиболее используемый обработчик, Warp, такую
поддержку имеет.

\subsection {Тело запроса}
Как и для тела ответов, мы могли бы теоретически использовать ленивую строку
байтов для тел запросов, но на практике мы хотим избежать ленивого
ввода/вывода. Вместо этого тело запроса представлено в виде
действия~\lstinline'IO ByteString' (используется \textbf{строгий} вариант
\lstinline'ByteString'). Обратите внимание, что это действие \textbf{не}
возвращает полное тело запроса, а только следующий блок данных. Как только вы
считали всё тело запроса, дальнейшие вызовы будут возвращать пустую строку
байтов.

Заметьте также, что в отличие от тел ответов, нам нет нужды использовать
\lstinline'Builder' на стороне запроса, так нашей целью является просто чтение
данных.

Теоретически тело запроса может содержать любой тип данных, но наиболее частыми
являются данные, закодированные URL-кодировкой, и составные данные форм.
Пакет~wai-extra включает встроенную поддержку для разбора данных форматов
эффективно использующим память способом.

\section{Hello world}
Чтобы продемонстрировать простоту WAI, давайте взглянем на простейший пример.
В этом примере мы используем расширение языка OverloadedStrings, чтобы избежать
явной упаковки строковых значений в строки байт.

\includecode{24/hello-world.hs}

В строках со 2-й по 4-ю выполняется импорт необходимых модулей. Warp
предоставляется пакетом~warp и является исторически первым веб-сервером,
реализующим WAI. Также WAI использует пакет~http-types, который предоставляет
некоторые типы данных и вспомогательные значения,
включая~\lstinline!status200!.

Сперва мы определяем наше приложение. Так как нам безразличны конкретные
параметры запроса, то мы игнорируем первый аргумент нашей функции, который
содержит значение запроса. Второй аргумент~--- это наша функция "отправить
ответ", который мы тут пользуемся. Значение ответа, которое мы отправляем,
строится из ленивой строки байтов (поэтому \lstinline'responseLBS'), кода
статуса 200 (<<OK>>), типом содержимого text/plain и телом, содержащим слова
<<Hello World>>. Довольно просто.

\section{Распределение ресурсов}
Давайте сделаем наш пример поинтереснее, и попробуем выделить ресурсы для
нашего ответа. Мы создадим значение~\lstinline'MVar' в нашей
функции~\lstinline'main' для отслеживания количества запросов и будем
захватывать это значение при отправке каждого ответа.

\includecode{24/alloc.hs}

Вот где наш интерфейс с продолжением показывает себя во всей красе. Мы можем
использовать стандартную функцию~\lstinline'modifyMVar' для захвата блокировки
для \lstinline'MVar' и отправлять наш ответ. Обратите внимание, как мы
протягиваем значение~\lstinline'responseReceived', хотя по факту нигде его не
используем для чего-либо. Оно просто отмечает тот факт, что мы действительно
отправили ответ.

Заметьте также, как мы пользуемся преимуществами \lstinline'Builder' при
построении нашего значения~\lstinline'msg'. Вместо склеивания двух байтовых
строк напрямую, мы моноидально складываем два различных
значения~\lstinline'ByteString'. Преимущество в том, что результат будет
напрямую скопирован в итоговый выходной буфер, вместо промежуточного
копирования во временную байтовую строку с последующим копированием в итоговый
буфер.

\section{Потоковый ответ}
Давайте ещё протестируем наш потоковый интерфейс:

\includecode{24/stream.hs}

Мы используем \lstinline'responseStream' и наш третий аргумент~--- это функция,
которая принимает наши функции <<отправить строителя>> и <<сбросить буфер>>.
Заметьте, как мы сбрасываем буфер после первого блока данных, чтобы
удостовериться, что клиент незамедлительно видит данные. Однако, нет
необходимости сбрасывать буфер в конце ответа. WAI требует, чтобы обработчик
автоматически сбрасывал буфер после завершения потока.

\section {Middleware~--- компоненты промежуточного уровня}

В добавление к возможности запуска наших приложений без изменения кода на
различных серверах реализующих WAI, WAI имеет ещё и другое преимущество~---
возможность создавать и использовать компоненты промежуточного уровня. Они
являются по сути преобразователями приложения, получая на вход одно приложение
и возвращая другое.

Компоненты промежуточного уровня могут использоваться для различных нужд:
исправления URL, аутентификации, кеширования, обработки запросов JSON-P. Но,
возможно, наиболее полезным и наиболее интуитивно понятным является компонент
реализующий gzip-сжатие. Этот компонент работает довольно просто: он разбирает
заголовки запроса для определения, поддерживает ли клиент сжатие, и, если
клиент поддерживает, то выполняет сжатие тела ответа, добавляя соответствующий
заголовок ответа.

Самое замечательное в компонентах промежуточного уровня заключается в том, что
они ненавязчивы. Давайте посмотрим, как применить gzip к нашему примеру.

\includecode{24/hello-world-gzip.hs}

Мы добавили строку импорта, чтобы получить доступ к компоненте, и затем просто
применили \lstinline!gzip!  к нашему приложению. Вы также можете
\emph{выстраивать в цепочку} несколько компонент: к примеру, строка
\lstinline'gzip False $ jsonp $ othermiddleware $ myapplication' вполне
корректна. Но следует заметить, что порядок применения компонент может быть
важен. К примеру, для \lstinline!jsonp! нужны несжатые данные. Если вы его
примените после применения \lstinline!gzip!, то получите проблемы.
