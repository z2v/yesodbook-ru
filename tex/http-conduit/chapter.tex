\chapter{http-conduit}
Большая часть Yesod относится к предоставлению контента по протоколу HTTP. Но
это лишь часть картины: кто-то должен получать этот контент. И даже если вы
пишете веб-приложение, иногда этим <<кто-то>> можете быть вы сами. Если вы
хотите получать контент от других сервисов или взаимодействовать с RESTful API,
вам потребуется писать клиентский код, и рекомендуемый подход для этого~---
\footnotehref{http://hackage.haskell.org/package/http-conduit}{http--conduit}.

Эта глава напрямую с Yesod не связана, и будет, вообще говоря, полезной для
всех, кто хочет выполнять HTTP запросы.

\section{Конспект}
\includecode{26/synopsis.hs}

\section{Основные положения}
Самый простой способ выполнения запроса в http--conduit~--- использовать
функцию~\lstinline!simpleHttp!. Эта функция принимает строку (типа
\lstinline!String!), представляющую URL, и возвращает значение
типа~\lstinline!ByteString! с содержимым этого URL. Её реализация состоит из
нескольких шагов:
\begin{itemize}
    \item Создаётся новый менеджер соединения~\lstinline!Manager!.

    \item URL преобразуется в \lstinline!Request!. Если URL некорректный, то
        выбрасывается исключение.

    \item Выполняется HTTP запрос, следующий по всем перенаправлениям с
        сервера.

    \item Если код статуса ответа находится вне диапазона 200-х значений,
        выбрасывается исключение.

    \item Тело запроса считывается в память и возвращается.

    \item Вызывается \lstinline!runResourceT!, которая освобождает все ресурсы
        (например, открытый сокет к серверу).
\end{itemize}

Если вы хотите больше контроля над тем, что происходит, вы можете настроить
любой из описанных шагов (плюс ещё несколько), явно создавая
значение~\lstinline!Request!, вручную размещая \lstinline!Manager! и используя
функции \lstinline!http! и \lstinline!httpLbs!.

\section{Request}
Самый лёгкий путь создания \lstinline!Request!~--- с помощью
функции~\lstinline!parseUrl!. Эта функция вернёт значение в любой монаде,
являющейся экземпляром класса~\lstinline!Failure!, например, \lstinline!Maybe!
или~\lstinline!IO!. Последняя используется чаще всего и приводит к исключению
во время выполнения, если функции передан некорректный URL. Однако, вы можете
использовать другую монаду, если, например, хотите проверять пользовательский
ввод.

\includecode{26/response-body.hs}

Тип~\lstinline!Request! абстрактный, так что http--conduit может добавлять
новые настройки в будущем, не нарушая API (см.
приложение~\nameref{chap:settings_types} для более подробной информации). Чтобы
изменить значения отдельных полей, используйте record-нотацию\footnote{Запись
    вида \lstinline'req \{ method = "HEAD" \}'}. К примеру, модификация нашей
программы, которая отправляет \texttt{HEAD} запросы и печатает заголовки
ответа, могла бы выглядеть так:

\includecode{26/response-head.hs}

API предоставляет целый ряд различных настроек. Вот те, на которые стоит
обратить внимание:
\begin{description}
    \item[proxy] \hfill \\
    Позволяет отправлять запросы через указанный прокси--сервер.

    \item[redirectCount] \hfill \\
    Указывает количество переадресаций, по которым следовать. По умолчанию~---
    10.

    \item[checkStatus] \hfill \\
    Проверка кода статуса ответа. По умолчанию, бросает исключение для любого
    кода вне диапазона 200-х значений.

    \item[requestBody] \hfill \\
    Тело запроса для отправки. Удостоверьтесь, что так же обновили
    значение~\lstinline!method!. Для общего случая кодирования данных в URL
    можно использовать функцию~\lstinline!urlEncodedBody!.
\end{description}

\section{Manager}
Менеджер соединений позволяет повторно использовать сетевые соединения. При
выполнении многочисленных запросов к единственному серверу (например, обращаясь
к Amazon S3), это может быть критично для создания эффективного кода. Менеджер
будет отслеживать множественные соединения к указанному серверу (в том числе
учитывая номер порта и SSL), автоматически собирая неиспользуемые соединения
при необходимости. Когда вы делаете запрос, http-conduit сначала пытается
проверить наличие существующего соединения. Когда работа с соединением
завершена (в случае если сервер позволяет поддерживать открытое соединение
(keep-alive)), оно возвращается менеджеру. Если что-нибудь пошло не так,
соединение закрывается.

Чтобы предохранить наш код от исключений, мы используем трансформатор монады
\lstinline!ResourceT!. Для вас это означает, что ваш код должен быть завёрнут
внутрь вызова \lstinline!runResourceT!, явно или неявно, и код внутри этого
блока должен использовать \lstinline!liftIO! для выполнения обычных действий
ввода/вывода (IO).

Есть два способа получить значение типа \lstinline!Manager!.
\lstinline!newManager! возвращает нового менеджера, который не будет закрыт
автоматически (вы можете использовать \lstinline!closeManager! для ручного
закрытия), тогда как \lstinline!withManager! откроет новый блок
\lstinline!ResourceT!, даст возможность использовать менеджера и затем
автоматически закроет \lstinline!ResourceT!, когда вы закончите. Если вы хотите
использовать \lstinline!ResourceT! для всего приложения, и нет необходимости
его закрывать, вам, вероятнее всего, следует использовать
\lstinline!newManager!.

Обратите внимание: очевидно, что не следует создавать нового менеджера
соединений для каждого запроса; это полностью противоречило бы его назначению.
Вместо этого \lstinline!Manager! следует создавать как можно раньше и затем
переиспользовать.

\section{Response}
Тип данных~\lstinline!Response! состоит из трёх информационных блоков: кода
статуса, заголовка ответа и тела ответа. Первые два понятны, давайте обсудим
тело.

У типа данных~\lstinline!Response! есть т\'иповая переменная, чтобы тело
запроса могло иметь любой тип. Если вы хотите использовать потоковый интерфейс
http-conduit, вам нужен тип~\lstinline!Source!. Для простого интерфейса это
будет ленивая~\lstinline!ByteString!. Обращаю внимание, что, хотя мы и
используем ленивую~\lstinline!ByteString!, \emph{весь ответ хранится в памяти}.
Другими словами, мы не используем ленивый ввод/вывод в этом пакете.

\begin{remark}
    Пакет \texttt{conduit} предоставляет ленивую реализацию модуля, которая
    позволит вам прочитать это значение лениво, но, как и любой ленивый
    ввод/вывод, это не совсем безопасно и, несомненно, недетерминировано.
    Однако если надо, вы можете его использовать.
\end{remark}

\section{http и httpLbs}
Давайте соберём всё вместе. Функция~\lstinline!http! даёт вам доступ к
потоковому интерфейсу (т.е., она возвращает \lstinline!Response!, использующий
\lstinline!BufferedSource!), тогда как \lstinline!httpLbs! возвращает
ленивую~\lstinline!ByteString!. В обоих случаях возвращаемые значения находятся
в трансформаторе~\lstinline!ResourceT!, так что они получают доступ к
\lstinline!Manager! и корректную работу с соединениями в случае возникновения
исключений.

\begin{remark}
    Если вы хотите проигнорировать остаток большого тела запроса, этого можно
    добиться соединившись со стоком~\lstinline!sinkNull!. Используемое сетевое
    соединение будет автоматически закрыто, что позволит избежать чтения
    большого тела запроса по сети.
\end{remark}
