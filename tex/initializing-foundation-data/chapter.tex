\chapter{Инициализация данных в типе-основании}

Цель этого примера~--- продемонстрировать относительно простую концепцию:
выполнение инициализации данных, которые должны храниться в типе-основании.
Есть ряд различных причин для такого подхода, вот две самые важные из них:
\begin{itemize}
    \item Эффективность: инициализируя данные только один раз, при старте
        процесса, вы можете избежать необходимости вычисления одного и того же
        значения при каждом запросе.

    \item Сохранность: мы хотим хранить некоторую информацию в изменяемом
        месте, которая будет сохраняться между отдельными запросами. Часто это
        требование реализуется с помощью внешней базы данных, но может быть
        сделано и с использованием изменяемой переменной, находящейся в памяти.
\end{itemize}

\begin{remark}
    Хотя изменяемые переменные могут быть удобным механизмом хранения, помните,
    что у них есть и недостатки. Если ваш процесс прервётся, вы потеряете ваши
    данные. Также, при горизонтальном масштабировании на несколько процессов,
    вам потребуется механизм для синхронизации данных между процессами. Мы
    проигнорируем обе проблемы в рамках нашего примера, но обе они вполне
    реальны. Это одна из причин, почему Yesod столь сильно акцентирован на
    использовании внешних баз данных для сохранности данных.
\end{remark}

Для демонстрации мы реализуем очень простой сайт. Он будет включать
единственный путь и предоставлять контент, сохранённый в файле Markdown. Кроме
того, он будет отображать счётчик посетителей сайта.

\section{Шаг 1: определяем тип-основание}
Мы указали два объекта, которые требуется инициализировать: содержимое
Markdown, которое должно быть отображено, и изменяемая переменная, хранящая
количество посещений. Напоминаю, что наша задача~--- выполнить как можно больше
работы на стадии инициализации и таким образом избежать той же самой работы
непосредственно в обработчиках. Следовательно, мы хотим предварительно
преобразовывать Markdown в HTML. Что касается счётчика, простой
\lstinline'IORef' должно быть достаточно. В итоге наш тип-основание принимает
вид:
\begin{lstlisting}
data App = App
    { homepageContent :: Html
    , visitorCount    :: IORef Int
    }
\end{lstlisting}

\section{Шаг 2: используем тип-основание}
В нашем тривиальном примере есть только один путь: домашняя страница. Всё, что
нам требуется:
\begin{itemize}
    \item Увеличить значение счётчика посетителей.
    \item Получить новое значение счётчика.
    \item Отобразить содержимое Markdown со счётчиком посетителей.
\end{itemize}

Чтобы сделать код немного короче, воспользуемся фокусом с синтаксисом
подстановки записи (record wildcard syntax): \lstinline'App {..}'. Это удобно,
когда мы хотим работать с набором различных полей типа данных.
\begin{lstlisting}
getHomeR :: Handler Html
getHomeR = do
    App {..} <- getYesod
    currentCount <- liftIO $ atomicModifyIORef visitorCount
        $ \i -> (i + 1, i + 1)
    defaultLayout $ do
        setTitle "Homepage"
        [whamlet|
            <article>#{homepageContent}
            <p>Вы посетитель № #{currentCount}.
        |]
\end{lstlisting}

\section{Шаг 3: создаём значение типа-основания}
Когда мы будем инициализировать наше приложение, нам потребуется предоставить
значения для полей, описанных выше. Это обычный код \lstinline'IO', и он может
выполнять любые произвольные необходимые действия. В нашем случае требуется:
\begin{itemize}
    \item Прочитать Markdown из файла.
    \item Преобразовать Markdown в HTML.
    \item Создать переменную для счётчика посетителей.
\end{itemize}

Код просто воспроизводит то, что мы написали:
\begin{lstlisting}
go :: IO ()
go = do
    rawMarkdown <- TLIO.readFile "homepage.md"
    countRef <- newIORef 0
    warp 3000 App
        { homepageContent = markdown def rawMarkdown
        , visitorCount    = countRef
        }
\end{lstlisting}

\section{Выводы}
Ничего заумного в этом примере нет, просто очень прямолинейное
программирование. Цель этой главы~--- продемонстрировать широко используемые
лучшие практики для достижения часто требуемых стремлений. В ваших собственных
приложениях шаги инициализации могут быть гораздо сложнее: настройка пула
соединений к базе данных, запуск фоновых заданий для пакетной обработки больших
массивов данных и т.д. После прочтения этой главы, у вас должно сложиться
понимание о том, где лучше всего разместить инициализирующий код для вашего
приложения.

Ниже полный код для примера, описанного выше:
\includecode{17c/source.hs}
