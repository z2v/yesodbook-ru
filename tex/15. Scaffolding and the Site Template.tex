\chapter{Создание каркаса сайта}

Вы уже устали запускать маленькие примеры и готовы написать настоящий сайт?
Тогда вы читаете нужную главу. Даже при наличии библиотеки Yesod \marginpar{at your fingertips},
остаётся ещё много шагов, которые нужно пройти, чтобы получить production-quolity 
конфигурацию сайта:

\begin{itemize}
  \item разбор файлов конфигурации
  \item поддержка сигналов (*nix)
  \item более эффективная поддержка статических файлов
  \item хорошее расположение файлов \marginpar{layout}
\end{itemize}

Каркас сайта является комбинацией лучших техник собранных вместе в готовый к 
использованию сайт. И он (highly) очень рекомендуется для всех сайтов.
Эта глава описывает структуру каркаса, как использовать его, и некоторые 
неочевидные возможности.

Основная часть данной главы не содержит примеров кода. Рекомендуется 
просматривать собранный каркас. \marginpar{переписать предложение}

\begin{remark}
 Т.к. nature of каркаса сайта, это наиболее изменяемый компонент Yesod, и 
 он может изменяться от версии к версии. Поэтому информация в этой главе
 может быть немного устаревшей.
\end{remark}

\section{Как создавать каркас}

Пакет Yesod содержит  себе библиотеку и исполняемый файл (conveniently 
названый \lstinline!yesod!). Этот файл предоставляет небольшой набор 
команд (запустите \lstinline!yesod! чтобы увидеть весь список). Команда
\lstinline!yesod init! генерировать каркас сайта. Она запустит процесс
вопрос-ответ в котором вы должны будете указать минимальную информацию
(ваше имя, название проекта, и т.д.). После ответов на вопросы создастся 
шаблон проекта в подкаталоге с названием проекта.\marginpar{не точный перевод}

Наиболее важный вопрос о backend базы данных. У вас будет четыре варианта 
выбора: \texttt{SQLite}, \texttt{PostgreSQL}, \texttt{MongoDB}, и tiny. 
Tiny это не движок базы данных, это указание, что вы не хотите использовать
какую-либо базу данных. Этот выбор так же отключит некоторые дополнительные
зависимости и вы получите, leaner overall site. Далее в этой главе мы предполагаем,
что выбран один из движков баз данных. В случае с отсутсвующим движком 
существуют минимальные отличия.

После создания файлов, scrappfolder напишет команды для запуска сайта.
Существует два набора опций команд: одни для использования \texttt{cabal},
другие для использования \texttt{cabal-dev}. \texttt{cabal-dev} это обёртка
вокруг \texttt{cabal}, собирающая все зависимости в песочнице. Использование
его good way, чтобы убедиться, что установка других пакетов, не сломает сайт.
Его использование рекомендуется. Если у вас нет \texttt{cabal-dev}, то вы можете
установить его командой \lstinline!cabal install cabal-dev!.

Заметьте, что вам нужно использовать команду \lstinline!cabal install --only-dependencies! 
или \lstinline!cabal-dev install --only-dependencies!. Вероятно, что у вас не 
установлены все зависимости требуемые для сайта. Например, ни одного backend
базы данных, ни минификатора Javascript (\footnotehref{http://hackage.haskell.org/package/hjsmin}{hjsmin})
обычно не при установке пакета \texttt{yesod}.

И наконец, для того, чтобы запустить разработческий сайт, вам нужно использовать
\lstinline!yesod devel! (или \lstinline!yesod --dev devel!). Сайт автоматически
пересоберётся и будет перезагружаться при всех изменениях кода.

\section{Структура файлов}

Каркас сайта является полностью "кабализированным" приложением. В дополнение
к исходным файлам, конфигурационным файлам, шаблонам так же создаются статические файлы.

\subsection{Кабал файл}

Независимо от того используете ли вы cabal или yesod devel, сборка вашего кода всегда 
использует cabal файл. Если вы откроете файл, то увидите что там есть два блока для
библиотеки и для исполняемого файла. При построении используется только одна, в зависимости
от того, утановлен ли флаг library-only. Если флаг library-only включен, то собирается только
библиотека, это скособ которым yesod devel запускает приложение. Иначе собирается исполняемый файл

Флаг library-only должен использоваться только yesod devel; вы никогда не должны передавать его в 
cabal явно. Так же есть дополнительный флаг dev, который позволяет cabal-у собирать исполняемый файл,
но включает некоторые возможности library-only флага, т.е. отключение оптимизаций перезапуск
верский Shakespearean шаблонов

В общем случае вы будете использовать следующую сборку:
\begin{itemize}
    \item при разработке использовать только yesod devel
    \item при боевой сборке вызывайте \lstinline!cabal clean && cabal configure && cabal build!. И вы
        создадите оптимизованный исполняемый файл в директории \texttt{dist}. Раньше использовался флаг
        \lstinline!-fproduction!, поэтому если вы создали каркас сайта ранее вы должны использовать этот
        флаг для боевой сборки.
\end{itemize}

Вы также заметите, что мы указали все расширения языка в кабал файле. Расширения указаны дважды:
один раз для исполняемого файла, и другой для библиотеки. Если вы будете добавлять расширения, то
добавляйте их в оба блока.

Вы можете быть удивлены увидев расширение \textt{NoImplicitPredude}. Мы его включили поскольку сайт 
включет свой специальный модуль \lstinline!Import!, с некоторыми изменениями в Prelude, это позволяет
сделать работу с Yesod более convenient.

И напоследок, следует отметить список экспортируемых модулей. Если вы добавите какой-либо модуль в 
ваше приложение, то вы должны обновить список для корректной работы yesod devel. К сожалению,
ни Cabal, ни GHC не выдадут предупреждение о том, что вы забыли сделать это обновление, и вместо этого
вы получите жутко выглядющую ошибку от yesod devel. Одно из планируемых улучшений это позволять yesod
devel проверять наличие неуказанных модулей.

\section{Маршруты и entities}

Множество раз на протяжении книги вы видели комментарии вида ,,Мы определяем пути/entities квазицитированием для простоты. 
На рабочем сайте, вам следует использовать внешний файл``. Каркас сайта, как раз и использует внешние файлы.
Маршруты определяются в файле \texttt{config/routes}, а entities в \texttt{config/models} соотвественно. Эти файлы
имеют в точности такой же синтаксис как и квазицитирование, которое вы видели на протяжении книги, и yesod devel 
автоматически пересобирает соотвествующие модули при изменении этих файлов.

The models files is referenced by \tettt{Model.hs}. В этом файле вы можете определять все, что угодно,
вот некоторые guidelines:
\begin{itemize}
    \item все типы данных использующиеся в entities должны быть импортированы, декларированы в \texttt{Model.hs}, 
        перед вызовом \lstinline!persistFile!.
    \item вспомогательные утилиты должны быть определены в \texttt{Import.hs} или, если они относятся к модели,
        то в фале в каталоге \texttt{Model} и импортированы в \texttt{Import.hs}.
\end{itemize}

\section{Основание и модули приложения}

Функция \lstinline!mkYesod! которую мы использовали на протяжении книги определяют несколько вещей:

\begin{itemize}
  \item тип маршрута
  \item функцию отображения
  \item функцию диспетчечризации
\end{itemize}

Функиця диспетчеризации refers ко всем остальным функциям обработки, поэтому все они должны быть 
или определены в том же файле, что и функция диспетчеризации или импортированы этой функцией (?). %TODO wtf?
Междутем, функция обработчих практически обязательно будет refer на маршрутный тип. Поэтому,
они должны быть или в одном файле, где определен тип маршрута или импротировать это файл.
Если you follow the logic here, то всё приложение должно обязательно находиться в одном файле!

Очевидно, что это не то, что мы хотим. Поэтому вместо использования \lstinline!mkYesod!, каркас 
сайта использует разделенные (decomposed) версии этой функции. Основание вызывает \lstinline!mkYesodData!,
который определяет маршрутный тип и функцию обработки. Так как он не определят функцию диспетчеризации,
функции обработчики не должны быть в той же области видимости. \texttt{Import.hs} импортирует
\texttt{Foundation.hs}, и все модули обработчики импортируют \texttt{Import.hs}.

В \texttt{Application.hs} мы вызываем \lstinline!mkYesodDispatch!, который создаёт функцию диспетчеризации.
Чтобы это заработало, все функции обрабочики должны быть в той же области видимости, так что убедитесь, в 
том, чтобы добавить импортирование всех модулей обработчиков, которые вы создаёте.

В остальном \texttt{Application.hs} достаточно прост. Он предоставляет две функции:
\lstinline!withDevelAppPort! используемую \lstinline!yesod devel! для запуска приложения
и \lstinline!getApplication! используемую исполняемым файлом для запуска.

\texttt{Foundation.hs} гораздо более интересен. Он:
\begin{itemize}
      \item определяет тип основание;
      \item определяет instance, такие как \lstinline!Yesod!, \lstinline!YesodAuth! и \lstinline!YesodPersist!;
      \item импортирует файлы сообщений
\end{itemize}

Если вы взгляните на строку запускающую \lstinline!mkMessage!, вы увидите, что она определяет директорию 
в которой находятся сообщения (\lstinline!messages!) и язык по умолчанию (\lstinline!en! для английского).
Это правильный файл для добавления дополнительных instances для приложени, таких как \lstinline!YesodAuthEmail! 
или \lstinline!YesodBreadcrumbs!. Мы будем ещё обратимся к этому файлу позже, когда будем ,
as we discussed some of the special implementations of Yesod typeclass methods.

\section{Import.hs}

Модуль \texttt{Import} появился из нескольких часто используемых шаблонов
Я хотел определить несколько вспомогательных функций (может быть оператор \lstinline!<> = mappend!) 
для того, чтобы использовать их во всех обработчиках. Я всегда добавляют один и те же мять
импортов  (\lstinline!Data.Text!, \lstinline!Control.Applicative!, прочие) в каждый модуль обработчик.
Мне бы хотелось гарантировать, что я никогда не использую некоторые (evil) функции (\lstinline!head!,
\lstinline!readFile!,\ldots) из \lstinline!Prelude!. Да evil это преувеличение. Если вам интересно,
почему я причислил эти функции к плохим: \lstinline!head! partial, и выбрасывает исключение на пустом
списке, а \lstinline!readFile! использует ленивый ввод-вывод, что приводит к тому, что хэндлер файла,
не закрывается достаточно быстро. Также, \lstinline!readFile! использует \lstinline!String! вместо
\lstinline!Text!. Решение заключается в том, чтобы включить расширение \texttt{NoImplicitPrelude} и
ре-экспортировать интересующие нас части \lstinline!Prelude!, и всё остальное, то нам нужно, так же
определить наши функции и инпортировать этот файл во все обработчики.

\section{Модули обработчиков}

Модули обработчиков должны находиться в директории \texttt{Handler}. Шаблон сайта включает один
модуль: \texttt{Handler/Home.hs}. Как разделять функции обрабочиков на модули зависит от вас, но
хорошее правило thumb:
\begin{itemize}
    \item методы относящиеся к одному маршруту должны находиться в одном файле, напр. \lstinline!getBlogR!
          и \lstinline!postBlogR!;
    \item связанные маршруты обычно находятся в одном файле, напр \lstinline!getPeopleR! и \lstinline!getPersonR!.
\end{itemize}

Естественно, решение зависит только от вас. Когда вы добавляете новый файл обработчик, убедитесь,
что вы сделали следующее:
\begin{enumerate}
  \item добавили файл в систему контроля версий (вы ведь используете систему контроля версий?);
  \item добавили модуль в cabal файл;
  \item добавили его в файл \texttt{Application.hs};
  \item добавили \lstinline!module! statement вначале файла, и \lstinline!import Import! на следующей строке.
\end{itemize}

Одним из планируемых улучшений Yesod является автоматизация этих четырёх шагов.

\section{widgetFile}

Достаточно часто хочется включать CSS и Javascript специфичный для страницы (!).
И вам не надо помнить, что нужно подклюить Lucius и Julius файлы вручную каждый раз,
когда ы обращаетесь к Hamlet файлу. Для этого шаблон сайта предоставляет 
функцию \lstinline!widgetFile!.

Если у вас есть функция обработчик:
\begin{lstlisting}
getHomeR = defaultLayout $(widgetFile "homepage")
\end{lstlisting}
, Yesod обратиться к следующим файлам:
\begin{lstlisting}
templates/homepage.hamlet
templates/homepage.lucius
templates/homepage.cassius
templates/homepage.julius
\end{lstlisting}

Если какой-то из них существует, то он будет автоматически включен в вывод.

В связи с nature особенностями работы, если вы запустите приложение через
yesod evel, и затем создадите новый файл (e.g. \texttt{templates/homepage.julius}),
его содержимое не будет подключено до тех пор пока widgetFile не будет переособран.
В этом случае, вы можете force a save of that file для того, чтобы yesod devel
пересобрал проект.

\section{defaultLayout}

Одна из первых вещей, которую вы захотике настрокить это то, как выглядит ваш сайт.
Раскладка на самом деле разделена на два файл:
\begin{enumerate}
  \item \texttt{templates/default-layout-wrapper.hamlet} содержит базовый скелет
      страницы. Этот файл интерпретируется как простой Hamlet, а не Widget, и поэтому
      не может обращаться к другим виджетам, вложенным i18n строкам или дополнительному CSS/JS.
  \item \texttt{templates/default-layout.hamlet} то, куда вы будете класть нполнение (bulk) 
      вашей страницы. Вы должны не забыть вложить widget value в страницу, это будет содержание
      каждой страницы. Этот файл интерпретируется как виджет.
\end{enumerate}

Также, поскольку default-layout влючен с помощью функции widgetFile, то любой Lucius, 
Cassius или Julius файл названный default-layout.* будет автоматически включен.

\section{Статические файлы}

Шаблон стайта, автоматически включает подсайт со статическими файлами, оптимизироанный пож просмотр 
файлов, которые не изменяются на протяжении текущей сборки. Что это значит, так то что:
при генерации идентификаторов статических файлов (например, static/mylogo.png превращается  mylogo\_png), 
в парметр запроса, который добавляется к нему !!! добавляется хэш файла. И всё это происходит
во время компиляции.
При отдаче статических файло сервер устанавливает заголовок expiration в далекое будущее
и включает etag основанный на хэше контента.
Пока вы используете ссылку на mylogo\_png, обработчик включает query-string параметр. Если
вы изменяете логотип, пересобираете и запускаете ваше новое приложение, строка запроса
изменится, засталяя пользоателя игнорироать сохранённую копию и скачивать новую версию файла.

В дополнение, вы можете установить specific static root в файле Settings.hs, для того, чтобы
отдавать файлы  с другого доменного имени. Это позволяет получить advantage от отсутсвия 
передачи cookie файлов для статических файло и также позволяет вам выложить файлы на 
CDN хостинг или на сервисы наподобие Amazon S3. Смотрите комментарии для уточнения (?!)

Другая оптимизация заключается в том, что CSS и Javascript загружаемый в виджетах не будет
включен нутрь HTML кода. Наоборот их содержимое будет записано во внешние файлы и дана ссылка.
Имена этих файлов так же основаны на хэше содержимого, что значит что кэширование работает 
правильно.

Есод позволяет избежать частой записи на диск CSS/Javascript файло, если файл с требуемым 
именем уже существует.

И наконец, все яаскрипт файлы автоматичесски минимифицируются через hjsmin.

\section{Заключение}

The purpose of this chapter was not to explain every line that exists in the scaffolded site, but instead to give a general overview to how it works. The best way to become more familiar with it is to jump right in and start writing a Yesod site with it.


