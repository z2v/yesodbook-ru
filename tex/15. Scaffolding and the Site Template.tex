\chapter{Создание каркаса сайта}\label{chap:scaffolding}
Вы уже устали запускать маленькие примеры и готовы написать настоящий сайт?
Тогда вы читаете нужную главу. Даже при наличии библиотеки Yesod
остаётся ещё много шагов, которые нужно пройти, чтобы получить сайт
промышленного качества:
\begin{itemize}
  \item разбор файлов конфигурации
  \item поддержка сигналов (для *nix)
  \item более эффективная поддержка статических файлов
  \item удобное расположение файлов
\end{itemize}

Каркас сайта является комбинацией множества лучших техник, практикуемых пользователями Yesod и собранных вместе в готовый к
использованию <<скелет>> сайта. Он настоятельно рекомендуется для всех сайтов.
Эта глава описывает структуру каркаса, как его использовать, а также некоторые
не совсем очевидные его возможности.

Глава практически не содержит примеров кода. Рекомендуется
просматривать актуальный каркас по мере чтения главы.

\begin{remark}
  По самой природе каркаса сайта, он является наиболее изменяемым компонентом Yesod и
  может изменяться от версии к версии. Поэтому информация в этой главе может оказаться немного устаревшей.
\end{remark}

\section{Как создавать каркас}
Пакет \footnotehref{http://hackage.haskell.org/package/yesod-bin}{yesod-bin}
устанавливает исполняемый файл (для удобства
также названный \texttt{yesod}). Этот файл предоставляет несколько
команд (запустите \texttt{yesod}, чтобы увидеть весь список). Команда
\texttt{yesod init} создаёт каркас сайта. Она задаёт ряд вопросов, в ответах на которые
вам потребуется предоставить необходимую базовую информацию
После ответа на вопросы в подкаталоге с
названием проекта создаётся шаблон проекта.

Самый важный из задаваемых вопрос~--- используемый бэкэнд базы данных. У вас есть выбор из
нескольких вариантов, включая SQL и MongoDB бэкэнды, и опция <<simple>>, отключающая
поддержку базы данных. Эта опция так же отключает некоторые дополнительные
зависимости, и сайт получится более компактным. Далее в этой главе мы предполагаем,
что выбран один из бэкэндов баз данных. Для варианта с бэкэндом simple
будут небольшие отличия.

После создания файлов утилита выводит сообщение о том, как приступить к работе.
Предлагаемая команда запускает \texttt{cabal sandbox init}. Это гарантирует,
что все пакеты устанавливаются только в директорию с проектом для избежания конфликтов
с другими проектами. Обратите внимание, что на самом деле вам нужно использовать
команду~\texttt{cabal install -{}-only-dependencies}. Скорее всего, у вас не будут
установлены все зависимости необходимые для сайта. Например, ни бэкэнды
баз данных, ни минификатор Javascript (\footnotehref{http://hackage.haskell.org/package/hjsmin}{hjsmin})
не устанавливаются при установке пакета~\texttt{yesod}.

И, наконец, чтобы запустить сайт в режиме разработки, вам нужно использовать
\texttt{yesod devel}. В этом режиме сайт будет автоматически
пересобираться и перезагружаться при каждом изменении кода.

\section{Файловая структура}
Каркас сайта создаётся как полноценный пакет Haskell,
использующий~\texttt{cabal} для сборки. В дополнение к исходным файлам также
создаются конфигурационные файлы, шаблоны и статические файлы.

\subsection{Файл Cabal}
Используете ли вы напрямую \texttt{cabal} или косвенно через~\texttt{yesod
    devel}, сборка вашего кода всегда проходит через cabal-файл. Если вы
откроете этот файл, то увидите, что там есть и блок для сборки библиотеки, и
блок для сборки исполняемого файла. Если флаг~\texttt{library-only} установлен,
то исполняемый файл не собирается. И именно так \texttt{yesod devel} запускает
приложение.  В противном случае собирается исполняемый файл.

Флаг \texttt{library-only} должен использоваться только \texttt{yesod devel};
вы никогда не должны явно передавать его~\texttt{cabal}. Есть ещё
дополнительный флаг~\texttt{dev}, который указывает \texttt{cabal} собрать
исполняемый файл, но с включением части тех же особенностей, что и сборка с
флагом~\texttt{library-only}: без оптимизации и с использованием версий с
перезагрузкой функций, работающих с Шекспировскими шаблонами.

В общем, собирайте приложение так:
\begin{itemize}
  \item В процессе разработки используйте только \texttt{yesod devel}.
  \item Для сборки боевой версии запускайте \texttt{cabal clean \&\& cabal configure \&\& cabal build}.
    В результате будет создан оптимизированный исполняемый файл в каталоге~\texttt{dist}.
\end{itemize}

Вы, возможно, удивитесь, увидев расширение~\lstinline!NoImplicitPredude!. Мы
его включили, поскольку сайт включает свой собственный модуль
\lstinline!Import! с некоторыми изменениями в~\lstinline!Prelude!, которые
позволяют сделать работу с Yesod более удобной.

И, напоследок, следует отметить список экспортируемых модулей. Если вы
добавляете какой-либо модуль в ваше приложение, то вы \textbf{должны} обновить
этот список для корректной работы \texttt{yesod devel}. К сожалению, ни Cabal,
ни GHC не выдадут предупреждение о том, что вы забыли сделать такое обновление,
и, вместо предупреждения, вы получите жутко выглядящую ошибку от~\texttt{yesod
    devel}.

\subsection{Маршруты и сущности}
Неоднократно на протяжении книги вы встречали подобные комментарии: <<Мы
определяем пути/сущности квазицитированием для простоты. Для рабочего сайта вам
следует использовать внешний файл>>.  Каркас сайта использует такие внешние
файлы.

Маршруты определяются в файле \texttt{config/routes}, а сущности~---
в~\texttt{config/models}.  Эти файлы имеют в точности такой же синтаксис, что и
квазицитирование, которое повсеместно используется в книге, а \texttt{yesod
devel} автоматически пересобирает соответствующие модули при изменении этих
файлов.

Файл сущностей обрабатывается в \texttt{Model.hs}. В этом файле вы вольны
объявлять что угодно, но есть несколько рекомендаций:
\begin{itemize}
    \item Все типы данных, использующиеся в сущностях, \textbf{должны} быть
        импортированы/определены в \texttt{Model.hs} выше вызова
        \lstinline!persistFile!.
    \item Вспомогательные утилиты следует определять или в \texttt{Import.hs},
        или, если они относятся только к сущностям, в файле каталога
        \texttt{Model}, и импортировать в \texttt{Import.hs}.
\end{itemize}

\subsection{Модули Foundation и Application}
Функция \lstinline!mkYesod!, которую мы использовали на протяжении книги,
объявляет следующее:
\begin{itemize}
  \item Тип маршрута;
  \item Функцию отображения маршрута;
  \item Функцию диспетчеризации.
\end{itemize}

Функция диспетчеризации ссылается на все остальные функции-обработчики, поэтому
все они должны быть или определены в том же файле, что и функция
диспетчеризации, или импортированы модулем, в котором определена функция
диспетчеризации.

Между тем, функции-обработчики практически обязательно будут ссылаться на тип
маршрута. Поэтому и \emph{они} должны или находиться в том же файле, где
определён тип маршрута, или импортировать этот файл.  Если следовать логике, то
получается, что всё приложение, фактически, должно находиться в одном файле!

Очевидно, это не то, что мы хотим. Поэтому вместо использования
\lstinline!mkYesod! каркас сайта использует <<расщеплённую>> версию этой
функции. Модуль~\lstinline!Foundation! вызывает функцию~\lstinline!mkYesodData!,
которая определяет тип маршрута и функцию отображения. Так как модуль не
определяет функцию диспетчеризации, функции-обработчики не должны быть в той же
области видимости. \texttt{Import.hs} импортирует \texttt{Foundation.hs}, а все
модули обработчиков импортируют \texttt{Import.hs}.

В \texttt{Application.hs} мы вызываем \lstinline!mkYesodDispatch!, которая
создаёт функцию диспетчеризации.  Чтобы это заработало, все функции-обработчики
должны быть в той же области видимости, так что не забывайте добавлять импорт
всех вновь создаваемых модулей обработчиков.

В остальном модуль \texttt{Application.hs} достаточно прост. Он предоставляет
две первостепенные функции: \lstinline!getApplicationDev!, которую использует \texttt{yesod devel} для
запуска приложения, и \lstinline!makeApplication!, которая используется в исполняемом
файле.

Модуль \texttt{Foundation.hs} гораздо более интересен. Он:
\begin{itemize}
  \item Определяет тип-основание;
  \item Определяет экземпляры ряда классов типов таких как \lstinline!Yesod!,
      \lstinline!YesodAuth! и \lstinline!YesodPersist!;
  \item Импортирует файлы сообщений. Если вы поищете строку, начинающуюся с
      \lstinline!mkMessage!, то увидите, что она определяет каталог, в котором
      находятся сообщения (\lstinline!messages!), и язык по умолчанию
      (\lstinline!en!, для английского).
\end{itemize}

В этот же файл следует добавлять дополнительные экземпляры классов типов для
типа-основания, такие как \lstinline!YesodAuthEmail!
или~\lstinline!YesodBreadcrumbs!.

Мы ещё вернёмся к этому файлу ниже, когда будем обсуждать ряд особых реализаций
методов класса типов~\lstinline!Yesod!.

\subsection{Import}
Модуль \lstinline!Import! появился из нескольких часто повторяемых приёмов:
\begin{itemize}
  \item Я хочу определять несколько вспомогательных функций (возможно,
      оператор~\lstinline!<> = mappend!), чтобы использовать их во всех
      обработчиках.
  \item Я всегда добавляю одни и те же пять инструкций импорта
      (\lstinline!Data.Text!, \lstinline!Control.Applicative! и др.) в каждый
      модуль-обработчик.
  \item Я хочу быть уверен, что никогда не использую некоторые <<плохие>> (evil)
      функции (\lstinline!head!, \lstinline!readFile!, \ldots) из модуля
      \lstinline!Prelude!.

    \begin{remark}
      Да, <<плохие>>~--- это преувеличение. Если вам интересно, почему я
      причислил эти функции к плохим: \lstinline!head! является частичной
      функцией и выбрасывает исключение для пустого списка, а
      \lstinline!readFile! использует ленивый ввод-вывод, который недостаточно
      быстро высвобождает дескрипторы файлов. Кроме того, \lstinline!readFile!
      использует \lstinline!String! вместо~\lstinline!Text!.
    \end{remark}
\end{itemize}

Решение следующее: использовать расширение~\lstinline!NoImplicitPrelude!,
реэкспортировать необходимые нам части \lstinline!Prelude!, добавить всё
остальное, нам необходимое, определить наши собственные функции и затем
импортировать полученный файл во всех обработчиках.

\subsection{Модули-обработчики}
Модули-обработчики следует помещать внутрь каталога~\lstinline!Handler!. Шаблон
сайта включает один модуль: \texttt{Handler/Root.hs}. Вам решать, как разделять
функции обработчиков на модули, но вот хорошее проверенное правило:
\begin{itemize}
  \item различные методы, относящиеся к одному маршруту, следует собирать в
      одном файле, например: \lstinline!getBlogR! и~\lstinline!postBlogR!;
  \item связанные маршруты также обычно можно поместить в одном файле, например:
      \lstinline!getPeopleR! и~\lstinline!getPersonR!.
\end{itemize}

Естественно, решение зависит только от вас. Когда вы добавляете новый файл
обработчика, убедитесь, что вы сделали следующее:
\begin{enumerate}
  \item Добавили файл в систему контроля версий (вы ведь \emph{используете}
      систему контроля версий?).
  \item Добавили модуль в файл cabal.
  \item Добавили его в файл \texttt{Application.hs}.
  \item Разместили объявление модуля в начале файла и \lstinline!import Import!
      на следующей строке.
\end{enumerate}

Вы можете воспользоваться командой \texttt{yesod add-handler} для автоматизации
последних трёх шагов.

\section{widgetFile}
Достаточно часто требуется добавить на страницу специфичный код CSS и
Javascript.  Вы не хотите помнить о необходимости ручного подключения файлов
Lucius и Julius каждый раз, когда ссылаетесь на файл Hamlet. Для этого шаблон
сайта предоставляет функцию~\lstinline!widgetFile!.

Если у вас есть функция-обработчик:
\begin{lstlisting}
getRootR = defaultLayout $(widgetFile "homepage")
\end{lstlisting}%$
Yesod будет искать следующие файлы:
\begin{lstlisting}
templates/homepage.hamlet
templates/homepage.lucius
templates/homepage.cassius
templates/homepage.julius
\end{lstlisting}

Если какой-либо из них существует, то он будет автоматически включён в вывод.

\begin{remark}
В связи с особенностями работы описанного механизма, если вы запустите приложение
через \texttt{yesod devel}, и затем создадите новый файл (например,
\texttt{templates/homepage.julius}), его содержимое \emph{не} будет подключено,
пока файл, вызывающий \lstinline!widgetFile!, не будет перекомпилирован.  В
подобном случае, вам, возможно, потребуется принудительно сохранить вызывающий файл,
чтобы \texttt{yesod devel} его перекомпилировал.
\end{remark}

\section{defaultLayout}
Одно из первых, что вы, наверное, захотите настроить,~--- это внешний вид вашего
сайта. Разметка, фактически, разделена на два файла:
\begin{itemize}
  \item \texttt{templates/default-layout-wrapper.hamlet} содержит базовый скелет
      страницы. Этот файл интерпретируется как простой файл Hamlet, а не как
      виджет, и поэтому не может обращаться к другим виджетам, встраивать
      интернационализированные строки или добавлять дополнительный код CSS/JS.
  \item \texttt{templates/default-layout.hamlet}~--- это файл, где вы будете
      размещать основную часть вашей страницы. Вы \textbf{должны} помнить о
      включении значения~\lstinline!widget! на страницу, т.к. оно представляет
      собой непосредственное содержание каждой страницы. Этот файл
      интерпретируется как виджет.
\end{itemize}

Также, поскольку файл \texttt{default-layout} включён с помощью
функции~\lstinline!widgetFile!, то любой файл Lucius, Cassius или Julius с
именем вида \texttt{default-layout.*} будет также автоматически включён.

\section{Статические файлы}
Шаблон сайта автоматически включает подсайт для статических файлов,
оптимизированный для обслуживания файлов, которые не изменяются за время жизни
текущей сборки приложения. Это означает следующее:
\begin{itemize}
  \item В процессе генерации идентификаторов статических файлов (например,
      \texttt{static/mylogo.png} становится \lstinline!mylogo_png!) к ним
      добавляется параметр строки запроса с хэшем содержимого файла. Всё
      это происходит во время компиляции.
  \item Когда \lstinline!yesod-static! отдаёт ваши статические файлы, он устанавливает
      заголовки истечения срока действия (expiration headers) на даты в далёком
      будущем и добавляет заголовок etag на основе хэша содержимого файла.
  \item Всякий раз, когда вы вставляете ссылку на \lstinline!mylogo_png!, при
      рендеринге маршрута к ней добавляется параметр строки запроса. Если вы
      поменяете логотип и запустите после перекомпиляции ваше новое приложение,
      строка запроса изменится, что вынудит пользователей скачать новую версию
      логотипа, игнорируя кэшированную копию.
\end{itemize}

Кроме того, вы можете задать специфический корневой каталог для статических
файлов в файле~\texttt{Settings.hs}, чтобы отдавать файлы с другого доменного
имени. Преимущество такого подхода~--- отсутствие необходимости передачи файлов
куки для запросов статических файлов, а также возможность переложить нагрузку по
отдаче статических файлов на CDN\footnote{Content Delivery Network - сеть
    доставки (и дистрибуции) контента} или сервис наподобие Amazon~S3.
Смотрите комментарии в файле для более подробной информации.

Другая оптимизация заключается в том, что CSS и Javascript, включённые в ваши
виджеты, не будут вставлены в код HTML. Вместо этого их содержимое будет записано
во внешний файл и дана ссылка на него.  Имя этого файла так же основано на
хэше содержимого, что означает следующее:
\begin{enumerate}
  \item Кэширование будет работать корректно.
  \item Yesod может избежать дорогостоящей записи на диск CSS/Javascript файла,
      если уже существует файл с таким же хэшем.
\end{enumerate}

И, наконец, весь код Javascript автоматически минимизируется, используя \footnotehref{http://hackage.haskell.org/package/hjsmin}{hjsmin}.

\section{Выводы}
Целью этой главы было не объяснить каждую строчку кода в каркасе сайта, а
дать общее представление о том, как он работает.  Самый лучший способ
узнать подробности~--- это взять и начать писать свой сайт на Yesod,
используя каркас.
