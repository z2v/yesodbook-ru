\chapter{Создание каркаса сайта}\label{chap:scaffolding}
Вы уже устали запускать маленькие примеры и готовы написать настоящий сайт?
Тогда вы читаете нужную главу. Даже при наличии библиотеки Yesod
остаётся ещё много шагов, которые нужно пройти, чтобы получить сайт
промышленного качества:
\begin{itemize}
  \item разбор файлов конфигурации
  \item поддержка сигналов (для *nix)
  \item более эффективная поддержка статических файлов
  \item удобное расположение файлов
\end{itemize}

Каркас сайта является комбинацией множества лучших техник, практикуемых пользователями Yesod и собранных вместе в готовый к
использованию <<скелет>> сайта. Он настоятельно рекомендуется для всех сайтов.
Эта глава описывает структуру каркаса, как его использовать, а также некоторые
не совсем очевидные его возможности.

Глава практически не содержит примеров кода. Рекомендуется
просматривать актуальный каркас по мере чтения главы.

\begin{remark}
  По самой природе каркаса сайта, он является наиболее изменяемым компонентом Yesod и
  может изменяться от версии к версии. Поэтому информация в этой главе может оказаться немного устаревшей.
\end{remark}

\section{Как создавать каркас}
Пакет \footnotehref{http://hackage.haskell.org/package/yesod}{yesod}
включает в себя и библиотеку, и исполняемый файл (для удобства
также названный \texttt{yesod}). Этот файл предоставляет несколько
команд (запустите \texttt{yesod}, чтобы увидеть весь список). Команда
\texttt{yesod init} создаёт каркас сайта. Она задаёт ряд вопросов, в ответах на которые
вам потребуется предоставить необходимую базовую информацию
(ваше имя, название проекта и~т.д.). После ответа на вопросы в подкаталоге с
названием проекта создаётся шаблон проекта.

Самый важный из задаваемых вопрос~--- используемый бэкэнд базы данных. У вас будет четыре варианта
для выбора: SQLite, PostgreSQL, MongoDB и tiny.
Tiny~--- это не бэкэнд базы данных, а указание, что вы не хотите использовать
какую-либо базу данных. Этот выбор так же отключит некоторые дополнительные
зависимости, и сайт получится более компактным. Далее в этой главе мы предполагаем,
что выбран один из бэкэндов баз данных. Для варианта с бэкэндом tiny
будут небольшие отличия.

После создания файлов утилита выводит сообщение с командами для запуска сайта.
Существует два варианта команд: один для использования \texttt{cabal},
другой для использования \texttt{cabal-dev}. \texttt{cabal-dev}~--- это обёртка
вокруг \texttt{cabal}, собирающая все зависимости в <<песочнице>>. Его
использование~--- хороший способ избежать поломки вашего сайта в результате установки других пакетов.
И поэтому настойчиво рекомендуется.
Если \texttt{cabal-dev} не установлен, установить его можно, выполнив команду
\texttt{cabal install cabal-dev}.

Обратите внимание, что на самом деле вам нужно использовать команду~\texttt{cabal install -{}-only-dependencies}
(или \texttt{cabal-dev install -{}-only-dependencies}). Скорее всего, у вас не будут
установлены все зависимости необходимые для сайта. Например, ни бэкэнды
баз данных, ни минификатор Javascript (\footnotehref{http://hackage.haskell.org/package/hjsmin}{hjsmin})
не устанавливаются при установке пакета~\texttt{yesod}.

И, наконец, чтобы запустить сайт в режиме разработки, вам нужно использовать
\texttt{yesod devel} (или \texttt{yesod -{}-dev devel}). В этом режиме сайт будет автоматически
пересобираться и перезагружаться при каждом изменении кода.

\section{Файловая структура}
Каркас сайта создаётся как полноценный пакет Haskell,
использующий~\texttt{cabal} для сборки. В дополнение к исходным файлам также
создаются конфигурационные файлы, шаблоны и статические файлы.

\subsection{Файл Cabal}
Используете ли вы напрямую \texttt{cabal} или косвенно через~\texttt{yesod
    devel}, сборка вашего кода всегда проходит через cabal-файл. Если вы
откроете этот файл, то увидите, что там есть и блок для сборки библиотеки, и
блок для сборки исполняемого файла. При сборке используется только один, в
зависимости от значения флага~\texttt{library-only}. Если
флаг~\texttt{library-only} установлен, то собирается библиотека. И именно так
\texttt{yesod devel} запускает приложение.  В противоположном случае собирается
исполняемый файл.

Флаг \texttt{library-only} должен использоваться только \texttt{yesod devel};
вы никогда не должны явно передавать его~\texttt{cabal}. Есть ещё
дополнительный флаг~\texttt{dev}, который указывает \texttt{cabal} собрать
исполняемый файл, но с включением части тех же особенностей, что и сборка с
флагом~\texttt{library-only}: без оптимизации и с использованием версий с
перезагрузкой функций, работающих с Шекспировскими шаблонами.

В общем, собирайте приложение так:
\begin{itemize}
  \item В процессе разработки используйте только \texttt{yesod devel}.
  \item Для сборки боевой версии запускайте \texttt{cabal clean \&\& cabal configure \&\& cabal build}.
    В результате будет создан оптимизированный исполняемый файл в каталоге~\texttt{dist}.

    \begin{remark}
      Раньше использовался флаг~\texttt{-fproduction}. Поэтому, если вы создали
      каркас сайта с ранней версией~\texttt{yesod}, вам, возможно, потребуется
      использовать этот флаг для сборки боевой версии.
    \end{remark}

\end{itemize}

Вы также заметите, что мы указали все расширения языка в cabal-файле.
Расширения указаны \emph{дважды}: один раз для исполняемого файла, и второй раз
для библиотеки. Если вы будете добавлять расширения, то добавляйте их в оба
блока.

Вы, возможно, удивитесь, увидев расширение~\lstinline!NoImplicitPredude!. Мы
его включили, поскольку сайт включает свой собственный модуль
\lstinline!Import! с некоторыми изменениями в~\lstinline!Prelude!, которые
позволяют сделать работу с Yesod более удобной.

И, напоследок, следует отметить список экспортируемых модулей. Если вы
добавляете какой-либо модуль в ваше приложение, то вы \textbf{должны} обновить
этот список для корректной работы \texttt{yesod devel}. К сожалению, ни Cabal,
ни GHC не выдадут предупреждение о том, что вы забыли сделать такое обновление,
и, вместо предупреждения, вы получите жутко выглядящую ошибку от~\texttt{yesod
    devel}.

\begin{remark}
  Одним из планируемых улучшений \texttt{yesod devel} является проверка наличия
  неуказанных модулей.
\end{remark}

\subsection{Маршруты и сущности}
Неоднократно на протяжении книги вы встречали подобные комментарии: <<Мы
определяем пути/сущности квазицитированием для простоты. Для рабочего сайта вам
следует использовать внешний файл>>.  Каркас сайта использует такие внешние
файлы.

Маршруты определяются в файле \texttt{config/routes}, а сущности~---
в~\texttt{config/models}.  Эти файлы имеют в точности такой же синтаксис, что и
квазицитирование, которое повсеместно используется в книге, а \texttt{yesod
devel} автоматически пересобирает соответствующие модули при изменении этих
файлов.

Файл сущностей обрабатывается в \texttt{Model.hs}. В этом файле вы вольны
объявлять что угодно, но есть несколько рекомендаций:
\begin{itemize}
    \item Все типы данных, использующиеся в сущностях, \textbf{должны} быть
        импортированы/определены в \texttt{Model.hs} выше вызова
        \lstinline!persistFile!.
    \item Вспомогательные утилиты следует определять или в \texttt{Import.hs},
        или, если они относятся только к сущностям, в файле каталога
        \texttt{Model}, и импортировать в \texttt{Import.hs}.
\end{itemize}

\subsection{Модули Foundation и Application}
Функция \lstinline!mkYesod!, которую мы использовали на протяжении книги,
объявляет следующее:
\begin{itemize}
  \item Тип маршрута;
  \item Функцию отображения маршрута;
  \item Функцию диспетчеризации.
\end{itemize}

Функция диспетчеризации ссылается на все остальные функции-обработчики, поэтому
все они должны быть или определены в том же файле, что и функция
диспетчеризации, или импортированы модулем, в котором определена функция
диспетчеризации.

Между тем, функции-обработчики практически обязательно будут ссылаться на тип
маршрута. Поэтому и \emph{они} должны или находиться в том же файле, где
определён тип маршрута, или импортировать этот файл.  Если следовать логике, то
получается, что всё приложение, фактически, должно находиться в одном файле!

Очевидно, это не то, что мы хотим. Поэтому вместо использования
\lstinline!mkYesod! каркас сайта использует <<расщеплённую>> версию этой
функции. Модуль~\lstinline!Foundation! вызывает функцию~\lstinline!mkYesodData!,
которая определяет тип маршрута и функцию отображения. Так как модуль не
определяет функцию диспетчеризации, функции-обработчики не должны быть в той же
области видимости. \texttt{Import.hs} импортирует \texttt{Foundation.hs}, а все
модули обработчиков импортируют \texttt{Import.hs}.

В \texttt{Application.hs} мы вызываем \lstinline!mkYesodDispatch!, которая
создаёт функцию диспетчеризации.  Чтобы это заработало, все функции-обработчики
должны быть в той же области видимости, так что не забывайте добавлять импорт
всех вновь создаваемых модулей обработчиков.

В остальном модуль \texttt{Application.hs} достаточно прост. Он предоставляет
две функции: \lstinline!withDevelAppPort!, используемую \texttt{yesod devel} для
запуска приложения, и \lstinline!getApplication!, используемую исполняемым
файлом для запуска.

Модуль \texttt{Foundation.hs} гораздо более интересен. Он:
\begin{itemize}
  \item Определяет тип-основание;
  \item Определяет экземпляры ряда классов типов таких как \lstinline!Yesod!,
      \lstinline!YesodAuth! и \lstinline!YesodPersist!;
  \item Импортирует файлы сообщений. Если вы поищете строку, начинающуюся с
      \lstinline!mkMessage!, то увидите, что она определяет каталог, в котором
      находятся сообщения (\lstinline!messages!), и язык по умолчанию
      (\lstinline!en!, для английского).
\end{itemize}

В этот же файл следует добавлять дополнительные экземпляры классов типов для
типа-основания, такие как \lstinline!YesodAuthEmail!
или~\lstinline!YesodBreadcrumbs!.

Мы ещё вернёмся к этому файлу ниже, когда будем обсуждать ряд особых реализаций
методов класса типов~\lstinline!Yesod!.

\subsection{Import}
Модуль \lstinline!Import! появился из нескольких часто повторяемых приёмов:
\begin{itemize}
  \item Я хочу определять несколько вспомогательных функций (возможно,
      оператор~\lstinline!<> = mappend!), чтобы использовать их во всех
      обработчиках.
  \item Я всегда добавляю одни и те же пять инструкций импорта
      (\lstinline!Data.Text!, \lstinline!Control.Applicative! и др.) в каждый
      модуль-обработчик.
  \item Я хочу быть уверен, что никогда не использую некоторые <<плохие>> (evil)
      функции (\lstinline!head!, \lstinline!readFile!, \ldots) из модуля
      \lstinline!Prelude!.

    \begin{remark}
      Да, <<плохие>>~--- это преувеличение. Если вам интересно, почему я
      причислил эти функции к плохим: \lstinline!head! является частичной
      функцией и выбрасывает исключение для пустого списка, а
      \lstinline!readFile! использует ленивый ввод-вывод, который недостаточно
      быстро высвобождает дескрипторы файлов. Кроме того, \lstinline!readFile!
      использует \lstinline!String! вместо~\lstinline!Text!.
    \end{remark}
\end{itemize}

Решение следующее: использовать расширение~\lstinline!NoImplicitPrelude!,
реэкспортировать необходимые нам части \lstinline!Prelude!, добавить всё
остальное, нам необходимое, определить наши собственные функции и затем
импортировать полученный файл во всех обработчиках.

\subsection{Модули-обработчики}
Модули-обработчики следует помещать внутрь каталога~\lstinline!Handler!. Шаблон
сайта включает один модуль: \texttt{Handler/Home.hs}. Вам решать, как разделять
функции обработчиков на модули, но вот хорошее проверенное правило:
\begin{itemize}
  \item различные методы, относящиеся к одному маршруту, следует собирать в
      одном файле, например: \lstinline!getBlogR! и~\lstinline!postBlogR!;
  \item связанные маршруты также обычно можно поместить в одном файле, например:
      \lstinline!getPeopleR! и~\lstinline!getPersonR!.
\end{itemize}

Естественно, решение зависит только от вас. Когда вы добавляете новый файл
обработчика, убедитесь, что вы сделали следующее:
\begin{enumerate}
  \item Добавили файл в систему контроля версий (вы ведь \emph{используете}
      систему контроля версий?).
  \item Добавили модуль в файл cabal.
  \item Добавили его в файл \texttt{Application.hs}.
  \item Разместили объявление модуля в начале файла и \lstinline!import Import!
      на следующей строке.
\end{enumerate}

\begin{remark}
  Одно из планируемых улучшений Yesod~--- автоматизация этих четырёх шагов.
\end{remark}

\section{widgetFile}
Достаточно часто требуется добавить на страницу специфичный код CSS и
Javascript.  Вы не хотите помнить о необходимости ручного подключения файлов
Lucius и Julius каждый раз, когда ссылаетесь на файл Hamlet. Для этого шаблон
сайта предоставляет функцию~\lstinline!widgetFile!.

Если у вас есть функция-обработчик:
\begin{lstlisting}
getHomeR = defaultLayout $(widgetFile "homepage")
\end{lstlisting}%$
Yesod будет искать следующие файлы:
\begin{lstlisting}
templates/homepage.hamlet
templates/homepage.lucius
templates/homepage.cassius
templates/homepage.julius
\end{lstlisting}

Если какой-либо из них существует, то он будет автоматически включён в вывод.

\begin{remark}
В связи с особенностями работы описанного механизма, если вы запустите приложение
через \texttt{yesod devel}, и затем создадите новый файл (например,
\texttt{templates/homepage.julius}), его содержимое \emph{не} будет подключено,
пока файл, вызывающий \lstinline!widgetFile!, не будет перекомпилирован.  В
подобном случае, вам, возможно, потребуется принудительно сохранить вызывающий файл,
чтобы \texttt{yesod devel} его перекомпилировал.
\end{remark}

\section{defaultLayout}

Одна из первых вещей, которую вы захотите настрокить, это то, как будет выглядеть ваш сайт.
Разметка на самом деле разделена на два файла:
\begin{itemize}
  \item \lstinline!templates/default-layout-wrapper.hamlet! содержит базовый скелет
    страницы. Этот файл интерпретируется просто как Hamlet, а не как виджет, и поэтому
    не может обращаться к другим виджетам, вложенным i18n строкам или добавлять CSS/JS.
  \item \lstinline!templates/default-layout.hamlet! - тот файл, куда где выбудете располагать
    нполнение вашей страницы. Вы \emph{должны} не забыть включить значение \lstinline!widget!
    в текст страницы, т.к. оно являет собой содержание каждой страницы. Этот файл
    интерпретируется как виджет.
\end{itemize}

Также, поскольку default-layout влючен с помощью функции \lstinline!widgetFile!, то любой
файл Lucius, Cassius или Julius с именем вида default-layout.* будет также автоматически включен.

\section{Статические файлы}

Шаблон стайта, автоматически включает подсайт со статическими файлами, оптимизироанный для просмотра
файлов, которые не изменяются на время работы текущей сборки приложения. Это значит следующее:

\begin{itemize}
  \item при генерации идентификаторов статических файлов (например, static/mylogo.png
    превращается  \lstinline!mylogo\_png!), к ним добавляется параметр запроса, который содержит
    хэш содержимого файла. Происходит это во время компиляции.
  \item При отдаче статических файлов \lstinline!yesod-static! устанавливает заголовок expiration
    на дату в далеком будущем и включает etag на основе хэша содержимого файла.
  \item В любом из случаев, когда вы вставляете  ссылку на \lstinline!mylogo\_png!, отображение
    маршрута даёт строку с параметром запроса. Если вы изменяете логотип, перекомпилируете и
    запустите ваше новое приложение, строка запроса изменится, что заставит пользоателя игнорироать
    кэшированную копию и скачать новую версию файла.
\end{itemize}

Кроме того, вы можете установить свой корень запросов для статики в файле Settings.hs, для того, чтобы
отдавать файлы  с другого доменного имени. У этого подхода есть преимущество в том, что остсутствует
необходимость передачи cookie-файлов для запросов статических файлов, а также позволяет переложить
нагрузку по отдаче статических файлов на CDN\footnote{Content Delivery Network - сеть доставки (и
дестрибуции) контента} или на сервисы наподобие Amazon S3. Смотрите комментарии в указанном файле
по поводу дальнейших деталей.

Другая оптимизация заключается в том, что CSS и Javascript, подключаемые в виджетах, не будут
включены в HTML код. Вместо этого их содержимое будет записано во внешние файлы и дана ссылка на них.
Имена этих файлов так же основаны на хэше содержимого, что значит:
\begin{enumerate}
  \item кэширование будет работать корректно
  \item Yesod может избежать дорогостоящей записи на диск CSS/Javascript файла, если уже существует
    файл с таким именем.
\end{enumerate}

И, наконец, весь код Javascript автоматичесски минимизируется через \footnotehref{http://hackage.haskell.org/package/hjsmin}{hjsmin}.

\section{Заключение}

Объяснение каждой строки сгенерированного каркаса сайта не являлось целью этой главы, а заключалась эта цель в том, чтобы дать обзор того, как он работает. Самый лучший способ познакомиться с ним - это взять и начать писать сайт на Yesod при помощи этого каркаса.
