\chapter{Создание каркаса сайта}

Вы уже устали запускать маленькие примеры и готовы написать настоящий сайт?
Тогда вы читаете нужную главу. Даже при наличии библиотеки Yesod \marginpar{at your fingertips},
остаётся ещё много шагов, которые нужно пройти, чтобы получить сайт
промышленного качаства:

\begin{itemize}
  \item разбор файлов конфигурации
  \item поддержка сигналов (для *nix)
  \item более эффективная поддержка статических файлов
  \item хорошее расположение файлов \marginpar{layout}
\end{itemize}

Каркас сайта является комбинацией лучших техник собранных вместе в готовый к 
использованию ``скелет'' сайта. Он настоятельно рекомендуется для всех сайтов.
Эта глава описывает структуру каркаса, как его использовать, а также некоторые 
не совсем очевидные возможности.

Основная часть данной главы не содержит примеров кода. Рекомендуется 
просматривать собранный вами каркас по мере изучения главы.

\begin{remark}
 Благодаря самой природе каркаса сайта, он является наиболее изменяемым компонентом Yesod, и 
 может изменяться от версии к версии. Поэтому информация в этой главе может быть немного устаревшей.
\end{remark}

\section{Как создавать каркас}

Пакет \footnotehref{http://hackage.haskell.org/package/yesod}{yesod}
содержит в себе библиотеку и исполняемый файл (для удобства 
назаемый также \lstinline!yesod!). Этот файл предоставляет некоторый набор 
команд (запустите \lstinline!yesod! чтобы увидеть весь список). Команда
\lstinline!yesod init! создаёт каркас сайта. Она запускает процесс
``вопросов и ответов'' в котором вы должны будете указать основную информацию
(ваше имя, название проекта, и т.д.). После ответа на вопросы создастся 
шаблон проекта в подкаталоге с названием проекта.

Наиболее важный вопрос о бэкэнде базы данных. У вас будет четыре варианта 
выбора: \texttt{SQLite}, \texttt{PostgreSQL}, \texttt{MongoDB}, и tiny. 
Tiny это не бэкэнд базы данных, а указание, что вы не хотите использовать
какую-либо базу данных. Этот выбор так же отключит некоторые дополнительные
зависимости и сайт получится более компактным. Далее в этой главе мы предполагаем,
что выбран один из бэкэндов баз данных. Для варианта с отсутсвующим бэкэндом
будут небольшие отличия.

После создания файлов, утилита для создания каркаса напишет команды для запуска сайта.
Существует два варианта команд: один для использования \texttt{cabal},
другой для использования \texttt{cabal-dev}. \texttt{cabal-dev} - это обёртка
вокруг \texttt{cabal}, собирающая все зависимости в ``песочнице''. Использование
его является хорошим способом для того, чтобы быть уверенным в том, что установка
других пакетов, не сломает сайт. Его использование настойчиво рекомендуется.
Если у вас не установлен \texttt{cabal-dev}, то вы можете сустановить его командой
\lstinline!cabal install cabal-dev!.

Заметьте, что вам нужно использовать команду \lstinline!cabal install --only-dependencies! 
или \lstinline!cabal-dev install --only-dependencies!. Скорее всего у вас не 
установлены все зависимости требуемые для сайта. К примеру, ни один из бэкэндов
баз данных, или минификатор Javascript (\footnotehref{http://hackage.haskell.org/package/hjsmin}{hjsmin})
не устанавливаются при установке пакета \lstinline!yesod!.

И, наконец, для того, чтобы запустить сайт для разработки, вам нужно использовать
\lstinline!yesod devel! (или \lstinline!yesod --dev devel!). Сайт автоматически
пересоберётся и будет перезагружаться при всех изменениях кода.

\section{Структура файлов}

Каркас сайта является полностью "кабализированным" приложением. В дополнение
к исходным файлам создаются конфигурационные файлы, шаблоны, а так же статические файлы.

\subsection{Cabal-файл}

Независимо от того используете ли вы cabal или yesod devel, сборка вашего кода всегда 
использует cabal-файл. Если вы откроете этот файл, то увидите, что там есть два блока: для
библиотеки и для исполняемого файла. При сборке используется только один, в зависимости
от того, утановлен ли флаг \lstinline!library-only!. Если флаг \lstinline!library-only! включен,
то собирается только библиотека, при помощи этого способа yesod devel запускает приложение.
В противоположном случае собирается исполняемый файл

Флаг \lstinline!library-only! должен использоваться только yesod devel; вы никогда не должны
передавать его в cabal явно. Также есть дополнительный флаг \lstinline!dev!, который позволяет
cabal-у собирать исполняемый файл, но включает некоторые возможности флага library-only:
отключает оптимизации и задействует перезагрузку версий Shakespeare шаблонов.

В общем случае вы будете использовать сборку следующим образом:
\begin{itemize}
    \item при разработке используйте только yesod devel
    \item при боевой сборке вызывайте \lstinline!cabal clean && cabal configure && cabal build!. Такой вызов
        создаст оптимизованный исполняемый файл в каталоге \lstinline!dist!.
        \begin{remark}
        Раньше использовался флаг \lstinline!-fproduction!, поэтому, если вы создали каркас сайта в более ранней
        версии yesod, вы должны использовать этот флаг для боевой сборки.
        \end{remark}
\end{itemize}

Вы также заметите, что мы указали все расширения языка в cabal-файле. Расширения указаны дважды:
один раз для исполняемого файла, и второй раз для библиотеки. Если вы будете добавлять расширения, то
добавляйте их в оба блока.

Вы можете быть удивлены увидев расширение \lstinline!NoImplicitPredude!. Мы его включили поскольку сайт 
включает свой специальный модуль \lstinline!Import!, с некоторыми изменениями в \lstinline!Prelude!, которые
позволяют сделать работу с Yesod более удобной.

И напоследок, следует отметить список экспортируемых модулей. Если вы добавите какой-либо модуль в 
ваше приложение, то вы \emph{должны} обновить этот список для корректной работы yesod devel. К сожалению,
ни Cabal, ни GHC не выдадут предупреждение о том, что вы забыли сделать это обновление, и, вместо этого,
вы получите жутко выглядющую ошибку от yesod devel.
\begin{remark}
Одим из планируемых улучшений yesod devel является проврка наличия неуказанных модулей.
\end{remark}

\section{Маршруты и сущности}

Множество раз на протяжении книги вы видели комментарии вида ,,Мы определяем пути/сущности
квазицитированием для простоты. На рабочем сайте, вам следует использовать внешний файл``.
Каркас сайта, как раз и использует внешние файлы.
Маршруты определяются в файле \lstinline!config/routes!, а сущности в \lstinline!config/models!
соотвественно. Эти файлы имеют в точности такой же синтаксис как и квазицитирование, которое вы
видели в книге, и yesod devel автоматически пересобирает соотвествующие модули при изменении этих файлов.

Файлы моделей используются \lstinline!Model.hs!. В этом файле вы можете определять все, что угодно, но
вот некоторые рекоммендации:
\begin{itemize}
    \item все типы данных, использующиеся в сущностях \emph{должны} быть импортированы/определены
      в \lstinline!Model.hs!, выше вызова \lstinline!persistFile!.
    \item вспомогательные утилиты должны быть определены в \lstinline!Import.hs!, или, если они
      относятся к модели, то в файле в каталоге \lstinline!Model! и импортированы в \lstinline!Import.hs!.
\end{itemize}

\section{Модули Foundation и Application}

Функция \lstinline!mkYesod!, которую мы использовали на протяжении книги, объявляет несколько вещей:

\begin{itemize}
  \item тип маршрута
  \item функцию отображения маршрута
  \item функцию диспетчечризации
\end{itemize}

Функция диспетчеризации ссылается на все остальные функции-обработчики, поэтому все они должны быть, 
или определены в том же файле, что и функция диспетчеризации, или импортированы модулем,
в котором определена функция диспетчеризации.
Между тем, функции-обработчики практически обязательно будут ссылаться на тип маршрута. Поэтому,
\emph{они} должны быть или в том же файле, где определен тип маршрута, или импротировать этот файл.
Если вы проследите за логикой, то всё приложение должно обязательно находиться в одном файле!

Очевидно, что это не то, что мы хотим. Поэтому вместо использования \lstinline!mkYesod!, каркас 
сайта использует ``расщеплённую'' версию этой функции. \lstinline!Foundation! вызывает \lstinline!mkYesodData!,
которая определяет тип маршрута и функцию отображения маршрута. Так как он не определят функцию диспетчеризации,
функции-обработчики не должны быть в той же области видимости. \lstinline!Import.hs! импортирует
\lstinline!Foundation.hs!, и все модули обработчиков импортируют \lstinline!Import.hs!.

В \lstinline!Application.hs! мы вызываем \lstinline!mkYesodDispatch!, которая создаёт функцию диспетчеризации.
Чтобы это заработало, все функции-обрабочики должны быть в той же области видимости, так что убедитесь, в 
том, что добавите импорт для всех модулей обработчиков, которые вы создадите.

В остальном \lstinline!Application.hs! достаточно прост. Он предоставляет две функции:
\lstinline!withDevelAppPort!, используемую \lstinline!yesod devel! для запуска приложения,
и \lstinline!getApplication! используемую исполняемым файлом для запуска.

\lstinline!Foundation.hs! гораздо более интересен. Он:
\begin{itemize}
      \item определяет тип основание;
      \item определяет экземпляры ряда классов типов, таких как \lstinline!Yesod!, \lstinline!YesodAuth! и \lstinline!YesodPersist!;
      \item импортирует файлы сообщений. Если вы взгляните на строку начинающуюся с \lstinline!mkMessage!,
        то вы увидите, что она определяет каталог, в котором находятся сообщения (\lstinline!messages!),
        и язык по умолчанию (\lstinline!en! для английского).
\end{itemize}

Это подходящий файл для добавления дополнительных экземпляров классов типов для приложения,
таких как \lstinline!YesodAuthEmail! или \lstinline!YesodBreadcrumbs!.

Мы будем ещё вспомним этот файл позже, когда будем обсуждать ряд особых реализаций
методов класса типов \lstinline!Yesod!.

\section{Import}

Модуль \lstinline!Import! появился из нескольких часто повторяемых приёмов:

\begin{itemize}
  \item Я хочу определять некотоыре вспомогательные функцие (возможно, оператор \lstinline!<> = mappend!) 
для того, чтобы использовать их во всех обработчиках.
  \item Я всегда добавляю одни и те же пять инструкций импорта  (\lstinline!Data.Text!, \lstinline!Control.Applicative! и др.) в каждый модуль-обработчик.
  \item Мне хочу гарантировать, что я никогда не использую некоторые ``плохие''(evil) функции (\lstinline!head!,
\lstinline!readFile!,\ldots) из модуля \lstinline!Prelude!.
    \begin{remark}
      Да evil это преувеличение. Если вам интересно, почему я причислил эти функции к плохим:
      \lstinline!head! является частичной функцией, и выбрасывает исключение для пустого списка,
      а \lstinline!readFile! использует ленивый ввод-вывод, который не достаточно быстро
      высвобождает дескрипторы файлов. Также, \lstinline!readFile! использует \lstinline!String! вместо
      \lstinline!Text!.
    \end{remark}
\end{itemize}

Решение заключается в том, чтобы использовать расширение \texttt{NoImplicitPrelude} и
ре-экспортировать необходимые нам части \lstinline!Prelude!, и всё остальное, то нам нужно, так же
определить наши собственные функции и инпортировать этот файл во всех обработчиках.

\section{Модули-обработчики}

Модули-обработчики должны находиться в директории \lstinline!Handler!. Шаблон сайта включает один
модуль: \lstinline!Handler/Home.hs!. Как разделять функции обрабочиков на модули зависит от вас, но
проверенным методом будет следующее:
\begin{itemize}
    \item методы относящиеся к одному маршруту должны находиться в одном файле, например: \lstinline!getBlogR!
          и \lstinline!postBlogR!;
    \item взаимосвязанные маршруты обычно находятся в одном файле, например: \lstinline!getPeopleR! и \lstinline!getPersonR!.
\end{itemize}

Естественно, решение зависит только от вас. Когда вы добавляете новый файл обработчика, убедитесь,
что вы сделали следующее:
\begin{enumerate}
  \item добавили файл в систему контроля версий (вы ведь \emph{используете} систему контроля версий?);
  \item добавили модуль в cabal файл;
  \item добавили его в файл \texttt{Application.hs};
  \item добавили строку \lstinline!module! в начало файла, и \lstinline!import Import! на следующей строке.
\end{enumerate}

\begin{remark}
  Одним из планируемых улучшений Yesod является автоматизация этих четырёх шагов.
\end{remark}

\section{widgetFile}

Достаточно часто требуется включать код CSS и Javascript специфичный для какой-нибудь страницы.
И вы не хотите помнить, что нужно подклюить Lucius и Julius файлы вручную каждый раз,
когда вы обращаетесь к Hamlet файлу. Для этого шаблон сайта предоставляет 
функцию \lstinline!widgetFile!.

Если у вас есть функция-обработчик:

\begin{lstlisting}
getHomeR = defaultLayout $(widgetFile "homepage")
\end{lstlisting}%$

, Yesod обратится к следующим файлам:

\begin{lstlisting}
templates/homepage.hamlet
templates/homepage.lucius
templates/homepage.cassius
templates/homepage.julius
\end{lstlisting}

Если какой-либо из них существует, то он будет автоматически включен в вывод.

\begin{remark}
  В связи с особенностями работы этого механизма, если вы запустите приложение через
  yesod evel, и затем создадите новый файл (e.g. \lstinline!templates/homepage.julius!),
  его содержимое \emph{не} будет подключено до тех пор, пока вызываемый \lstinline!widgetFile!
  не будет перекомпилирован.  В подобном случае, вы можете принудительно сохранить
  этот файл для того, чтобы yesod devel его перекомпилировал.
\end{remark}

\section{defaultLayout}

Одна из первых вещей, которую вы захотите настрокить, это то, как будет выглядеть ваш сайт.
Разметка на самом деле разделена на два файла:
\begin{itemize}
  \item \lstinline!templates/default-layout-wrapper.hamlet! содержит базовый скелет
    страницы. Этот файл интерпретируется просто как Hamlet, а не как виджет, и поэтому
    не может обращаться к другим виджетам, вложенным i18n строкам или добавлять CSS/JS.
  \item \lstinline!templates/default-layout.hamlet! - тот файл, куда где выбудете располагать
    нполнение вашей страницы. Вы \emph{должны} не забыть включить значение \lstinline!widget!
    в текст страницы, т.к. оно являет собой содержание каждой страницы. Этот файл
    интерпретируется как виджет.
\end{itemize}

Также, поскольку default-layout влючен с помощью функции \lstinline!widgetFile!, то любой
файл Lucius, Cassius или Julius с именем вида default-layout.* будет также автоматически включен.

\section{Статические файлы}
%TOCONTINUE
Шаблон стайта, автоматически включает подсайт со статическими файлами, оптимизироанный для просмотра
файлов, которые не изменяются на время работы текущей сборки приложения. Это значит следующее:

\begin{itemize}
  \item при генерации идентификаторов статических файлов (например, static/mylogo.png
    превращается  \lstinline!mylogo\_png!), к ним добавляется параметр запроса, который содержит
    хэш содержимого файла. Происходит это во время компиляции.
  \item При отдаче статических файлов \lstinline!yesod-static! устанавливает заголовок expiration
    на дату в далеком будущем и включает etag на основе хэша содержимого файла.
  \item В любом из случаев, когда вы вставляете  ссылку на \lstinline!mylogo\_png!, отображение
    маршрута даёт строку с параметром запроса. Если вы изменяете логотип, перекомпилируете и
    запустите ваше новое приложение, строка запроса изменится, что заставит пользоателя игнорироать
    кэшированную копию и скачать новую версию файла.
\end{itemize}

Кроме того, вы можете установить свой корень запросов для статики в файле Settings.hs, для того, чтобы
отдавать файлы  с другого доменного имени. У этого подхода есть преимущество в том, что остсутствует
необходимость передачи cookie-файлов для запросов статических файло, а также позволяет переложить
нагрузку по отдаче статических файлов на CDN\footnote{Content Delivery Network - сеть доставки (и
дестрибуции) контента} или на сервисы наподобие Amazon S3. Смотрите комментарии в указанном файле
по поводу дальнейших деталей.

Другая оптимизация заключается в том, что CSS и Javascript, подключаемые в виджетах, не будут
включены в HTML код. Вместо этого их содержимое будет записано во внешние файлы и дана ссылка на них.
Имена этих файлов так же основаны на хэше содержимого, что значит:
\begin{enumerate}
  \item кэширование будет работать корректно
  \item Yesod может избежать дорогостоящей записи на диск CSS/Javascript файла, если уже существует
    файл с таким именем.
\end{enumerate}

И, наконец, весь код Javascript автоматичесски минимизируется через \footnotehref{http://hackage.haskell.org/package/hjsmin}{hjsmin}.

\section{Заключение}

Объяснение каждой строки сгенерированного каркаса сайта не являлось целью этой главы, она состояла в том, чтобы датьобзор того, как он работает. Самый лучший способ познакомиться с ним - это взять и начать писать сайт на Yesod при помощи этого каркаса.


