\chapter{Публикатор-подписчик в одном процессе}

Предыдущий пример был, в общем-то, довольно простой. Давайте на его основе
сделаем что-нибудь более интересное. Предположим, что на нашем сайте
реализован такой рабочий процесс:
\begin{itemize}
    \item Вводится некая информация на странице X и отправляется.

    \item Отправка запускает фоновый процесс, а пользователь перенаправляется
        на страницу для отслеживания статуса процесса.

    \item Эта вторая страница подписывается на обновления от фонового
        процесса и отображает их пользователю.
\end{itemize}

Основной принцип~--- возможность предоставления одному потоку публиковать
обновления, а другому потому~--- получать эти обновления. Этот шаблон
общеизвестен как публикатор/подписчик (pub/sub или pubsub), и, к счастью, очень
легко реализуется в Haskell с использованием~STM.

Как и в предыдущей главе, позвольте мне начать с предостережения: описываемая
техника корректно работает только, если ваше веб-приложение работает в
единственном экземпляре. Если у вас два различных сервера и балансировщик
нагрузки, вам потребуются <<липкие>> сессии или какое-нибудь другое
решение, обеспечивающее, что запросы одного и того же пользователя направляются
на одну и ту же машину. Также в подобной ситуации вы можете воспользоваться
сторонним решением pubsub, например, Redis.

Предупреждение сделано, приступаем.

\section{Основной тип данных}

Нам потребуются две разных изменяемых ссылки в типе нашего приложения. Первая
будет хранить следующий идентификатор фонового процесса, который мы будем
запускать. Каждый из фоновых процессов будет представлен уникальным
идентификатором, который мы будем использовать в наших URL. Вторая ссылка будет
представлять собой отображение идентификатора процесса в широковещательный
канал, используемый для публикации обновлений. Вот код:

\begin{lstlisting}
data App = App
    { jobs    :: TVar (IntMap (TChan (Maybe Text)))
    , nextJob :: TVar Int
    }
\end{lstlisting}

Обратите внимание, что наш канал типа~\lstinline'TChan' содержит значения
типа~\lstinline'Maybe Text'. Использую обёртку~\lstinline'Maybe', мы сможем
сообщить о завершении работы, отправив значение~\lstinline'Nothing'.

\section{Размещение фонового процесса}
Чтобы разместить новый процесс, нам потребуется:
\begin{itemize}
    \item Получить идентификатор процесса.

    \item Создать новый широковещательный канал.

    \item Добавить канал в отображение каналов.
\end{itemize}

\begin{lstlisting}
(jobId, chan) <- liftIO $ atomically $ do
    jobId <- readTVar nextJob
    writeTVar nextJob $! jobId + 1
    chan <- newBroadcastTChan
    m <- readTVar jobs
    writeTVar jobs $ IntMap.insert jobId chan m
    return (jobId, chan)
\end{lstlisting}

\section{Запуск фонового процесса}

Есть много различных способов для запуска процессов, и они зависят от того, что
наш процесс будет делать. Вот минимальный пример фонового процесса, который
выводит несколько сообщений с интервалом в одну секунду. Обратите внимание, как
после последнего сообщения, мы публикуем значение~\lstinline'Nothing' и удаляем
наш канал из отображения.

\begin{lstlisting}
liftIO $ forkIO $ do
    threadDelay 1000000
    atomically $ writeTChan chan $ Just "Did something\n"
    threadDelay 1000000
    atomically $ writeTChan chan $ Just "Did something else\n"
    threadDelay 1000000
    atomically $ do
        writeTChan chan $ Just "All done\n"
        writeTChan chan Nothing
        m <- readTVar jobs
        writeTVar jobs $ IntMap.delete jobId m
\end{lstlisting}

\section{Показ прогресса}

Для демонстрации я выбрал очень простой способ показа прогресса: обычная
текстовая страница с потоковым ответом. Есть ещё несколько возможных вариантов:
страница HTML с авто-обновлением каждые X секунд или использование eventsource
или~websockets. Я советую вам их попробовать, но здесь простейшая реализация,
какую я смог придумать:
\begin{lstlisting}
getViewProgressR jobId = do
    App {..} <- getYesod
    mchan <- liftIO $ atomically $ do
        m <- readTVar jobs
        case IntMap.lookup jobId m of
            Nothing -> return Nothing
            Just chan -> fmap Just $ dupTChan chan
    case mchan of
        Nothing -> notFound
        Just chan -> respondSource typePlain $ do
            let loop = do
                    mtext <- liftIO $ atomically $ readTChan chan
                    case mtext of
                        Nothing -> return ()
                        Just text -> do
                            sendChunkText text
                            sendFlush
                            loop
            loop
\end{lstlisting}

Мы начинаем с поиска канала в отображении. Если не можем найти, то это
означает, что процесс либо вовсе не существовал, либо уже закончился. В любом
случае, мы возвращаем 404. (Возможное улучшение: хранить некоторую информацию о
всех завершившихся процессах и дать пользователю возможность узнать, что
процесс завершён.)

Предполагая, что канал существует, мы используем
функцию~\lstinline'respondSource' для запуска потокового ответа. Затем мы
циклически вызываем функцию~\lstinline'readTChan', пока не получим в ответ
значение~\lstinline'Nothing' и тогда выходим (используя~\lstinline'return ()').
Обратите внимание, что на каждой итерации мы вызываем и
\lstinline'sendChunkText', и~\lstinline'sendFlush'. Без вызова второй функции
пользователь не получит никаких обновлений, пока буфер не заполнится, а это
совсем не то, что мы хотим для системы с обновлениями в режиме реального
времени.

\section{Полный код приложения}

Для полноты ниже приведён код всего приложения из примера:

\sourcecode{single-process-pubsub}{single-process-pubsub.hs}
