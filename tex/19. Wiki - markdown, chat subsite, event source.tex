
\chapter{Wiki: разметка, подсайт чата, источник событий}
\label{}

Этот пример свяжет воедино несколько различных идей. Мы начнем с подсайта чата, позволяющего внедрить виджет чата в любую страницу. Для организации отправки событий клиенту с сервера будем использовать API источника событий HTML 5.

\begin{lstlisting}
-- @Chat.hs
{-# LANGUAGE OverloadedStrings, TypeFamilies, QuasiQuotes,
             TemplateHaskell, FlexibleInstances, MultiParamTypeClasses,
             FlexibleContexts
  #-}
-- | Этот модуль определяет подсайт, который позволяет вам вставлять
-- элемент управления с чатом на любую страницу вашего сайта. Он использует
-- eventsource для отправки сообщений браузеру с сервера.
module Chat where

import Yesod
import Control.Concurrent.Chan (Chan, dupChan, writeChan)
import Data.Text (Text)
import Network.Wai.EventSource (ServerEvent (..), eventSourceAppChan)
import Language.Haskell.TH.Syntax (Type (VarT), Pred (ClassP), mkName)
import Blaze.ByteString.Builder.Char.Utf8 (fromText)
import Data.Monoid (mappend)

-- | Тип-основание нашего подсайта. Мы поддерживаем канал событий,
-- который будет разделяться между всеми подключениями.
data Chat = Chat (Chan ServerEvent)

-- | Нам нужно иметь возможность проверять, что пользователь выполнил вход,
-- и получать его имя (для вывода сообщений).
class (Yesod master, RenderMessage master FormMessage)
        => YesodChat master where
    getUserName :: GHandler sub master Text
    isLoggedIn :: GHandler sub master Bool

-- Теперь создадим наш подсайт. Первый аргумент - это подсайт, что
-- очень напоминает то, как мы раньше использовали mkYesod. Второй аргумент
-- характерен для создания подсайта. В данном случае он означает "главный сайт
-- должен быть экземпляром YesodChat".
--
-- Мы определяем два маршрута: маршрут отправки сообщений от клиента серверу
-- и маршрут открытия потока событий для приема сообщений от сервера.
mkYesodSub "Chat"
    [ ClassP ''YesodChat [VarT $ mkName "master"]
    ] [parseRoutes|
/send SendR POST
/recv ReceiveR GET
|]

-- | Получить сообщение от пользователя и отправить его всем слушателям.
postSendR :: YesodChat master => GHandler Chat master ()
postSendR = do
    from <- getUserName

    -- Обратите внимание, что мы используем параметры GET для упрощения
    -- кода Ajax. Можно легко переключиться на POST. Тем не менее, общий 
    -- наш подход все же является RESTful, так как доступ к этому маршруту
    -- можно получить только через POST-запрос.
    body <- runInputGet $ ireq textField "message"

    -- Получить канал
    Chat chan <- getYesodSub

    -- Отправить событие с именем пользователя и сообщением всем слушателям.
    liftIO $ writeChan chan $ ServerEvent Nothing Nothing $ return $
        fromText from `mappend` fromText ": " `mappend` fromText body

-- | Отправить eventstream-ответ, в который включены все сообщения.
getReceiveR :: GHandler Chat master ()
getReceiveR = do
    -- Сначала получаем главный канал
    Chat chan0 <- getYesodSub

    -- Мы сделали копию канала, что позволяет нам создавать широковещательные каналы.
    chan <- liftIO $ dupChan chan0

    -- Теперь воспользуемся API источника событий. eventSourceAppChan
    -- принимает два параметра: канал событий, из которого выполнять чтение,
    -- и запрос WAI. Он возвращает отклик WAI, который мы можем возвратить
    -- с помощью sendWaiResponse.
    req <- waiRequest
    res <- lift $ eventSourceAppChan chan req
    sendWaiResponse res

-- | Предоставим виджет, который главный сайт сможет внедрить в любую страницу.
chatWidget :: YesodChat master
           => (Route Chat -> Route master)
           -> GWidget sub master ()
-- Аргумент toMaster говорит нам, как преобразовывать Route Chat в маршрут
-- главного сайта. Вы можете счесть эту информация избыточной, но использование
-- такого подхода дает нам возможность иметь несколько подсайтов с чатом в пределах
-- одного сайта.
chatWidget toMaster = do
    -- Получим некоторые уникальные идентификаторы, помогающие в создании
    -- наших HTML/CSS. Вспомним, что у нас нет представления о том, как
    -- выглядит HTML главного сайта. Поэтому мы не можем предполагать, что способны
    -- придумать идентификаторы, которые не будут использоваться повторно.
    -- Кроме того, несколько chatWidget могут быть внедрены в одну и ту же страницу.
    chat <- lift newIdent   -- обрамляющий div
    output <- lift newIdent -- элемент, где отображаются сообщения
    input <- lift newIdent  -- поле пользовательского ввода

    ili <- lift isLoggedIn  -- проверить, выполнили ли мы вход
    if ili
        then do
            -- Вход выполнен: показать виджет
            [whamlet|
<div ##{chat}>
    <h2>Chat
    <div ##{output}>
    <input ##{input} type=text placeholder="Введите сообщение">
|]
            -- Немного CSS
            toWidget [lucius|
##{chat} {
    position: absolute;
    top: 2em;
    right: 2em;
}
##{output} {
    width: 200px;
    height: 300px;
    border: 1px solid #999;
    overflow: auto;
}
|]
            -- И теперь вот такой JavaScript
            toWidgetBody [julius|
// Настроим принимающую сторону
var output = document.getElementById("#{output}");
var src = new EventSource("@{toMaster ReceiveR}");
src.onmessage = function(msg) {
    // Эта функция будет вызвана для каждого нового сообщения
    var p = document.createElement("p");
    p.appendChild(document.createTextNode(msg.data));
    output.appendChild(p);

    // А теперь прокрутим вниз в обрамляющем div так, чтобы было видно
    // последнее сообщение.
    output.scrollTop = output.scrollHeight;
};

// Настроим отправляющую сторону: отправлять сообщение через Ajax всякий раз,
// когда пользователь нажимает Enter.
var input = document.getElementById("#{input}");
input.onkeyup = function(event) {
    var keycode = (event.keyCode ? event.keyCode : event.which);
    if (keycode == '13') {
        var xhr = new XMLHttpRequest();
        var val = input.value;
        input.value = "";
        var params = "?message=" + encodeURI(val);
        xhr.open("POST", "@{toMaster SendR}" + params);
        xhr.send(null);
    }
}
|]
        else do
            -- Пользователь не выполнил вход, выдать об этом сообщение.
            master <- lift getYesod
            [whamlet|
<p>
    Вы должны #
    $maybe ar <- authRoute master
        <a href=@{ar}>выполнить вход
    $nothing
        выполнить вход
    \ чтобы воспользоваться чатом.
|]

Этот модуль является независимым и может использоваться в любом приложении. Далее мы создадим такое приложение-драйвер~--- wiki. У нашей wiki будет жестко заданная домашняя страница, а затем и wiki-раздел сайта. Мы будем использовать множество динамических фрагментов, позволяющих строить произвольную иерархию страниц в рамках Wiki.

В качестве способа хранения мы просто используем изменяемую ссылку на Map. Для реального приложения нужно заменить ее на подходящуюю базу данных. Содержимое будет храниться и предоставляться как Markdown. Плагин-пустышка yesod-auth предоставит нам способ выполнять (фальшивую) аутентификацию.

{-# LANGUAGE OverloadedStrings, TypeFamilies, QuasiQuotes,
             TemplateHaskell, FlexibleInstances, MultiParamTypeClasses,
             FlexibleContexts
  #-}
import Yesod
import Yesod.Auth
import Yesod.Auth.Dummy (authDummy)
import Chat
import Control.Concurrent.Chan (Chan, newChan)
import Network.Wai.Handler.Warp (run)
import Data.Text (Text)
import qualified Data.Text.Lazy as TL
import qualified Data.IORef as I
import qualified Data.Map as Map

-- Этот пакет пока отсутствует на Hackage.
-- Вы можете скачать его исходный код с https://github.com/snoyberg/markdown
import Text.Markdown (markdown, def)

-- | Наш тип-основание включает и подсайт чата, и изменяемую ссылку на карту
-- содержимого wiki. Обратите внимание, что ключом в этой карте является список из Text,
-- так как wiki может иметь произвольную иерархию.
--
-- В реальном приложении мы бы хотели хранить эту информацию в какой-нибудь базе данных.
data Wiki = Wiki
    { getChat :: Chat
    , wikiContent :: I.IORef (Map.Map [Text] Text)
    }

-- Настраиваем наши маршруты, как обычно.
mkYesod "Wiki" [parseRoutes|
/ RootR GET                 -- домашняя страница
FIXME
-- обратите внимание на multipiece для иерархии wiki
/wiki/*Texts WikiR GET POST -- note the multipiece for the wiki hierarchy
/chat ChatR Chat getChat    -- the chat subsite
/auth AuthR Auth getAuth    -- the auth subsite
|]

instance Yesod Wiki where
    -- получим работающую ссылку на вход
    authRoute _ = Just $ AuthR LoginR -- get a working login link

    -- Our custom defaultLayout will add the chat widget to every page.
    -- We'll also add login and logout links to the top.
    -- Наш особый defaultLayout добавит виджет чата на каждую страницу.
    -- Он также добавит ссылки на вход и на выход вверху страниц.
    defaultLayout widget = do
        pc <- widgetToPageContent $ widget >> chatWidget ChatR
        mmsg <- getMessage
        hamletToRepHtml [hamlet|
$doctype 5
<html>
    <head>
        <title>#{pageTitle pc}
        ^{pageHead pc}
    <body>
        $maybe msg <- mmsg
            <div .message>#{msg}
        <nav>
            <a href=@{AuthR LoginR}>Login
            \ | #
            <a href=@{AuthR LogoutR}>Logout
        ^{pageBody pc}
|]

-- Fairly standard YesodAuth instance. We'll use the dummy plugin so that you
-- can create any name you want, and store the login name as the AuthId.
-- Довольно стандартный экземпляр YesodAuth. Мы будем использовать плагин-пустышку, чтобы вы могли создать любое имя, какое пожелаете, и хранить имя пользователя как AuthId.
instance YesodAuth Wiki where
    type AuthId Wiki = Text
    authPlugins _ = [authDummy]
    loginDest _ = RootR
    logoutDest _ = RootR
    getAuthId = return . Just . credsIdent
    -- не используется в authDummy
    authHttpManager = error "authHttpManager" -- not used by authDummy

-- Just implement authentication based on our yesod-auth usage.
-- Просто реализуем аутентификацию на основе использования нашего yesod-auth.
instance YesodChat Wiki where
    getUserName = requireAuthId
    isLoggedIn = do
        ma <- maybeAuthId
        return $ maybe False (const True) ma

instance RenderMessage Wiki FormMessage where
    renderMessage _ _ = defaultFormMessage

-- Nothing special here, just giving a link to the root of the wiki.
-- Здесь ничего особенного, просто даем ссылку на корень wiki.
getRootR :: Handler RepHtml
getRootR = defaultLayout [whamlet|
<p>Добро пожаловать в Wiki!
<p>
    <a href=@{wikiRoot}>Корень wiki
|]
  where
    wikiRoot = WikiR []

-- A form for getting wiki content
-- Форма для получения wiki-содержимого
wikiForm mtext = renderDivs $ areq textareaField "Содержимое страницы" mtext

-- Show a wiki page and an edit form
-- Отобразить страницу wiki и форму для редактирования
getWikiR :: [Text] -> Handler RepHtml
getWikiR page = do
    -- Get the reference to the contents map
    -- Получим ссылку на карту содержимого
    icontent <- fmap wikiContent getYesod

    -- And read the map from inside the reference
    -- И прочтем карту изнутри ссылки
    content <- liftIO $ I.readIORef icontent

    -- Lookup the contents of the current page, if available
    -- Найдем содержимое текущей страницы, если оно доступно
    let mtext = Map.lookup page content

    -- Generate a form with the current contents as the default value.
    -- Note that we use the Textarea wrapper to get a <textarea>.
    -- Сгенерируем форму с текущим содержимым в качестве значения по умолчанию.
    -- Обратите внимание, что мы используем обертку Textarea, чтобы получить <textarea>.
    (form, _) <- generateFormPost $ wikiForm $ fmap Textarea mtext
    defaultLayout $ do
        case mtext of
            -- We're treating the input as markdown. The markdown package
            -- automatically handles XSS protection for us.
            -- Трактуем ввод как разметку. Пакет markdown автоматически выполняет для нас защиту от XSS.
            Just text -> toWidget $ markdown def $ TL.fromStrict text
            Nothing -> [whamlet|<p>Страница не существует|]
        [whamlet|
<h2>Редактировать страницу
<form method=post>
    ^{form}
    <div>
        <input type=submit>
|]

-- Get a submitted wiki page and updated the contents.
-- Получим отправленную wiki-страницу и обновим содержимое.
postWikiR :: [Text] -> Handler RepHtml
postWikiR page = do
    icontent <- fmap wikiContent getYesod
    content <- liftIO $ I.readIORef icontent
    let mtext = Map.lookup page content
    ((res, form), _) <- runFormPost $ wikiForm $ fmap Textarea mtext
    case res of
        FormSuccess (Textarea t) -> do
            liftIO $ I.atomicModifyIORef icontent $
                \m -> (Map.insert page t m, ())
            setMessage "Страница обновлена"
            redirect $ WikiR page
        _ -> defaultLayout [whamlet|
<form method=post>
    ^{form}
    <div>
        <input type=submit>
|]

main :: IO ()
main = do
    -- Create our server event channel
    -- Создадим канал событий нашего сервера
    chan <- newChan

    -- Initially have a blank database of wiki pages
    -- Изначально будем иметь пустую базу данных wiki-страниц.
    icontent <- I.newIORef Map.empty

    -- Run our app
    -- Запустим наше приложение
    warpDebug 3000 $ Wiki (Chat chan) icontent
\end{lstlisting}