
\chapter{Wiki: разметка, подсайт чата, источник событий}
\label{}

Этот пример свяжет воедино несколько различных идей. Мы начнем с подсайта чата, позволяющего внедрить виджет чата в любую страницу. Для организации отправки событий клиенту с сервера будем использовать API источника событий (event source) HTML 5.

\begin{lstlisting}
-- @Chat.hs
{-# LANGUAGE OverloadedStrings, TypeFamilies, QuasiQuotes,
             TemplateHaskell, FlexibleInstances, MultiParamTypeClasses,
             FlexibleContexts
  #-}
-- | Этот модуль определяет подсайт, который позволяет вам вставлять
-- элемент управления с чатом в любую страницу вашего сайта. Он использует
-- eventsource для отправки сообщений браузеру с сервера.
module Chat where

import Yesod
import Control.Concurrent.Chan (Chan, dupChan, writeChan)
import Data.Text (Text)
import Network.Wai.EventSource (ServerEvent (..), eventSourceAppChan)
import Language.Haskell.TH.Syntax (Type (VarT), Pred (ClassP), mkName)
import Blaze.ByteString.Builder.Char.Utf8 (fromText)
import Data.Monoid (mappend)

-- | Тип-основание нашего подсайта. Мы поддерживаем канал событий,
-- который будет разделяться между всеми подключениями.
data Chat = Chat (Chan ServerEvent)

-- | Нам нужно иметь возможность проверять, что пользователь выполнил вход,
-- и получать его имя (для вывода сообщений).
class (Yesod master, RenderMessage master FormMessage)
        => YesodChat master where
    getUserName :: GHandler sub master Text
    isLoggedIn :: GHandler sub master Bool

-- Теперь создадим наш подсайт. Первый аргумент - это подсайт, что
-- очень напоминает то, как мы раньше использовали mkYesod. Второй аргумент
-- характерен для создания подсайта. В данном случае он означает "главный сайт
-- должен быть экземпляром YesodChat".
--
-- Мы определяем два маршрута: маршрут отправки сообщений от клиента серверу
-- и маршрут открытия потока событий для приёма сообщений от сервера.
mkYesodSub "Chat"
    [ ClassP ''YesodChat [VarT $ mkName "master"]
    ] [parseRoutes|
/send SendR POST
/recv ReceiveR GET
|]

-- | Получить сообщение от пользователя и отправить его всем слушателям.
postSendR :: YesodChat master => GHandler Chat master ()
postSendR = do
    from <- getUserName

    -- Обратите внимание, что мы используем параметры GET для упрощения
    -- кода Ajax. Можно легко переключиться на POST. Тем не менее, общий 
    -- наш подход все же является RESTful, так как доступ к этому маршруту
    -- можно получить только через POST-запрос.
    body <- runInputGet $ ireq textField "message"

    -- Получить канал
    Chat chan <- getYesodSub

    -- Отправить событие с именем пользователя и сообщением всем слушателям.
    liftIO $ writeChan chan $ ServerEvent Nothing Nothing $ return $
        fromText from `mappend` fromText ": " `mappend` fromText body

-- | Отправить eventstream-ответ, в который включены все сообщения.
getReceiveR :: GHandler Chat master ()
getReceiveR = do
    -- Сначала получаем главный канал
    Chat chan0 <- getYesodSub

    -- Мы сделали копию канала, что позволяет нам создавать широковещательные каналы.
    chan <- liftIO $ dupChan chan0

    -- Теперь воспользуемся API источника событий. eventSourceAppChan
    -- принимает два параметра: канал событий, из которого выполнять чтение,
    -- и запрос WAI. Он возвращает отклик WAI, который мы можем возвратить
    -- с помощью sendWaiResponse.
    req <- waiRequest
    res <- lift $ eventSourceAppChan chan req
    sendWaiResponse res

-- | Предоставим виджет, который главный сайт сможет внедрить в любую страницу.
chatWidget :: YesodChat master
           => (Route Chat -> Route master)
           -> GWidget sub master ()
-- Аргумент toMaster говорит нам, как преобразовывать Route Chat в маршрут
-- главного сайта. Вы можете счесть эту информация избыточной, но использование
-- такого подхода дает нам возможность иметь несколько подсайтов с чатом в пределах
-- одного сайта.
chatWidget toMaster = do
    -- Получим некоторые уникальные идентификаторы, помогающие в создании
    -- наших HTML/CSS. Вспомним, что у нас нет представления о том, как
    -- выглядит HTML главного сайта. Поэтому мы не можем предполагать, что способны
    -- придумать идентификаторы, которые не будут использоваться повторно.
    -- Кроме того, несколько chatWidget могут быть внедрены в одну и ту же страницу.
    chat <- lift newIdent   -- обрамляющий div
    output <- lift newIdent -- элемент, где отображаются сообщения
    input <- lift newIdent  -- поле пользовательского ввода

    ili <- lift isLoggedIn  -- проверить, выполнили ли мы вход
    if ili
        then do
            -- Вход выполнен: показать виджет
            [whamlet|
<div ##{chat}>
    <h2>Chat
    <div ##{output}>
    <input ##{input} type=text placeholder="Введите сообщение">
|]
            -- Немного CSS
            toWidget [lucius|
##{chat} {
    position: absolute;
    top: 2em;
    right: 2em;
}
##{output} {
    width: 200px;
    height: 300px;
    border: 1px solid #999;
    overflow: auto;
}
|]
            -- И теперь вот такой JavaScript
            toWidgetBody [julius|
// Настроим принимающую сторону
var output = document.getElementById("#{output}");
var src = new EventSource("@{toMaster ReceiveR}");
src.onmessage = function(msg) {
    // Эта функция будет вызвана для каждого нового сообщения
    var p = document.createElement("p");
    p.appendChild(document.createTextNode(msg.data));
    output.appendChild(p);

    // А теперь прокрутим вниз в обрамляющем div так, чтобы было видно
    // последнее сообщение.
    output.scrollTop = output.scrollHeight;
};

// Настроим отправляющую сторону: отправлять сообщение через Ajax всякий раз,
// когда пользователь нажимает Enter.
var input = document.getElementById("#{input}");
input.onkeyup = function(event) {
    var keycode = (event.keyCode ? event.keyCode : event.which);
    if (keycode == '13') {
        var xhr = new XMLHttpRequest();
        var val = input.value;
        input.value = "";
        var params = "?message=" + encodeURI(val);
        xhr.open("POST", "@{toMaster SendR}" + params);
        xhr.send(null);
    }
}
|]
        else do
            -- Пользователь не выполнил вход, выдать об этом сообщение.
            master <- lift getYesod
            [whamlet|
<p>
    Вы должны #
    $maybe ar <- authRoute master
        <a href=@{ar}>выполнить вход
    $nothing
        выполнить вход
    \ чтобы воспользоваться чатом.
|]

Этот модуль является независимым и может использоваться в любом приложении. Ниже мы создадим такое приложение-драйвер~--- wiki. Наша wiki получит жестко заданную домашнюю страницу, а затем и wiki-раздел сайта. Мы будем использовать множество динамических фрагментов, позволяющих строить произвольную иерархию страниц в рамках Wiki.

В качестве способа хранения мы просто используем изменяемую ссылку на Map. Для реального приложения нужно заменить её на подходящуюю базу данных. Содержимое будет храниться и предоставляться как Markdown. Плагин-пустышка yesod-auth предоставит нам способ выполнять (фальшивую) аутентификацию.

{-# LANGUAGE OverloadedStrings, TypeFamilies, QuasiQuotes,
             TemplateHaskell, FlexibleInstances, MultiParamTypeClasses,
             FlexibleContexts
  #-}
import Yesod
import Yesod.Auth
import Yesod.Auth.Dummy (authDummy)
import Chat
import Control.Concurrent.Chan (Chan, newChan)
import Network.Wai.Handler.Warp (run)
import Data.Text (Text)
import qualified Data.Text.Lazy as TL
import qualified Data.IORef as I
import qualified Data.Map as Map

-- Этот пакет пока отсутствует на Hackage.
-- Вы можете скачать его исходный код с https://github.com/snoyberg/markdown
import Text.Markdown (markdown, def)

-- | Наш тип-основание включает и подсайт чата, и изменяемую ссылку на словарь
-- содержимого wiki. Обратите внимание, что ключом в этом словаре является список
-- из Text, так как wiki может иметь произвольную иерархию.
--
-- В реальном приложении мы бы предпочли хранить эту информацию в какой-нибудь
-- базе данных.
data Wiki = Wiki
    { getChat :: Chat
    , wikiContent :: I.IORef (Map.Map [Text] Text)
    }

-- Настраиваем наши маршруты, как обычно.
mkYesod "Wiki" [parseRoutes|
/ RootR GET                 -- домашняя страница
FIXME
/wiki/*Texts WikiR GET POST -- обратите внимание на многокомпонентный путь,
                            -- необходимый для иерархии wiki
/chat ChatR Chat getChat    -- подсайт чата
/auth AuthR Auth getAuth    -- подсайт аутентификации
|]

instance Yesod Wiki where
    -- получим работающую ссылку на вход
    authRoute _ = Just $ AuthR LoginR -- get a working login link

    -- Наш особый defaultLayout добавит виджет чата на каждую страницу.
    -- Он также добавит ссылки на вход и на выход вверху страниц.
    defaultLayout widget = do
        pc <- widgetToPageContent $ widget >> chatWidget ChatR
        mmsg <- getMessage
        hamletToRepHtml [hamlet|
$doctype 5
<html>
    <head>
        <title>#{pageTitle pc}
        ^{pageHead pc}
    <body>
        $maybe msg <- mmsg
            <div .message>#{msg}
        <nav>
            <a href=@{AuthR LoginR}>Войти
            \ | #
            <a href=@{AuthR LogoutR}>Выйти
        ^{pageBody pc}
|]

-- Довольно стандартный экземпляр YesodAuth. Мы будем использовать плагин-пустышку,
-- чтобы вы могли создать любое имя, какое пожелаете, и хранить имя вошедшего
-- пользователя как AuthId.
instance YesodAuth Wiki where
    type AuthId Wiki = Text
    authPlugins _ = [authDummy]
    loginDest _ = RootR
    logoutDest _ = RootR
    getAuthId = return . Just . credsIdent
    authHttpManager = error "authHttpManager" -- authDummy это не использует

-- Просто реализуем аутентификацию на основе нашего yesod-auth.
instance YesodChat Wiki where
    getUserName = requireAuthId
    isLoggedIn = do
        ma <- maybeAuthId
        return $ maybe False (const True) ma

instance RenderMessage Wiki FormMessage where
    renderMessage _ _ = defaultFormMessage

-- Здесь ничего особенного, просто даём ссылку на корень wiki.
getRootR :: Handler RepHtml
getRootR = defaultLayout [whamlet|
<p>Добро пожаловать в Wiki!
<p>
    <a href=@{wikiRoot}>Корень wiki
|]
  where
    wikiRoot = WikiR []

-- Форма для получения wiki-содержимого
wikiForm mtext = renderDivs $ areq textareaField "Содержимое страницы" mtext

-- Отобразить страницу wiki и форму для редактирования
getWikiR :: [Text] -> Handler RepHtml
getWikiR page = do
    -- Получим ссылку на словарь содержимого
    icontent <- fmap wikiContent getYesod

    -- И прочтем словарь из ссылки
    content <- liftIO $ I.readIORef icontent

    -- Получим содержимое текущей страницы, если оно доступно
    let mtext = Map.lookup page content

    -- Сгенерируем форму с текущим содержимым в качестве значения по умолчанию.
    -- Обратите внимание, что мы используем обёртку Textarea для получения <textarea>.
    (form, _) <- generateFormPost $ wikiForm $ fmap Textarea mtext
    defaultLayout $ do
        case mtext of
            -- Трактуем ввод как markdown. Пакет markdown автоматически
            -- выполняет для нас защиту от XSS.
            Just text -> toWidget $ markdown def $ TL.fromStrict text
            Nothing -> [whamlet|<p>Страница не существует|]
        [whamlet|
<h2>Редактировать страницу
<form method=post>
    ^{form}
    <div>
        <input type=submit>
|]

-- Получим отправленную wiki-страницу и обновим содержимое.
postWikiR :: [Text] -> Handler RepHtml
postWikiR page = do
    icontent <- fmap wikiContent getYesod
    content <- liftIO $ I.readIORef icontent
    let mtext = Map.lookup page content
    ((res, form), _) <- runFormPost $ wikiForm $ fmap Textarea mtext
    case res of
        FormSuccess (Textarea t) -> do
            liftIO $ I.atomicModifyIORef icontent $
                \m -> (Map.insert page t m, ())
            setMessage "Страница обновлена"
            redirect $ WikiR page
        _ -> defaultLayout [whamlet|
<form method=post>
    ^{form}
    <div>
        <input type=submit>
|]

main :: IO ()
main = do
    -- Создадим наш канал серверных событий
    chan <- newChan

    -- Изначально у нас пустая база данных wiki-страниц
    icontent <- I.newIORef Map.empty

    -- Запустим наше приложение
    warpDebug 3000 $ Wiki (Chat chan) icontent
\end{lstlisting}