\chapter{RESTful содержимое}
%FIXME RESTful Content

Одна из историй ранних дней развития Интернета --- как поисковые системы уничтожали целые web-сайты. Когда динамические сайты были еще новой концепцией, разработчики не принимали во внимание различий между GET и POST запросами. В результате, они создавали страницы, удаляющие содержимое, с доступом через GET-метод. Когда поисковики начинали сканировать эти сайты, они могли удалить все содержимое.

Если бы эти разработчики точнее следовали спецификации HTTP, этого бы не случилось. GET-запрос подразумевает отсутствие побочных эффектов (вроде стирания сайта, к примеру). Не так давно, в веб-разработке произошло движение к правильному пониманию “Передачи репрезентативного состояния” (Representational State Transfer), известного также как REST. Эта глава описывает особенности Yesod, связаные с поддержкой REST, и как они могут быть использованы для создания более надежных web-приложений.

\section{Методы HTTP-запросов}

Во многих веб-фреймворках, вы пишете для ресурса одну функцию-обработчик (handler). В Yesod, по умолчанию, предполагается отдельная функция-обработчик для каждого метода запроса. Два самых частых метода, с которыми вы будете иметь дело при создании веб-сайтов - это методы GET и POST. Эти методы лучше всего поддерживаются в HTML, поскольку только они используются в web-формах. Однако, при создании RESTful-API, другие методы также очень полезны.

Технически, вы можете создать какие угодно методы, но настоятельно рекомендуется придерживаться методов, описанных в спецификации HTTP. Наиболее часто встречаются методы:
\begin{itemize}
 \item GET. Запрос на чтение. Предполагается, что, при вызове GET, не произойдет никаких изменений на сервере. При многократном вызове GET-метода, сервер должен выдавать тот же ответ, если исключить такие вещи как “текущее время” или случайно полученные результаты. 
 \item POST. Обычный запрос на изменение. POST-запрос никогда не должен посылаться пользователем дважды. Обычно, в качестве примера POST-запроса, приводят перевод денежных средств с одного банковского счета на другой.
 \item PUT. Создание нового ресурса на сервере или изменение существующего. Этот метод может быть выполнен многократно с одинаковым эффектом.
 \item DELETE. В точности соответствует названию. Удаляет ресурс с сервера. Повторные вызовы не должны приводить к проблемам.
\end{itemize}

В определенной степени, это соответствует философии Haskell: GET-запрос подобен чистой функции, без побочных эффектов. На практике, ваши GET-функции вероятно будут производить IO-операции --- чтение информации из базы данных, логирование пользовательских действий и так далее.

Смотрите часть “Маршрутизация URL и обработчики” для более полной информации по синтаксису определения функций-обработчиков для каждого метода HTTP-запроса.

\section{Представления}

Пусть мы определили тип данных и значение:

\begin{lstlisting}
data Person = Person { name :: String, age :: Int }
michael = Person "Michael" 25
\end{lstlisting}

Мы можем представить эти данные в HTML:
\begin{lstlisting}[language=HTML]
 <table>
    <tr>
        <th>Name</th>
        <td>Michael</td>
    </tr>
    <tr>
        <th>Age</th>
        <td>25</td>
    </tr>
</table>
\end{lstlisting}

или в JSON:

\begin{verbatim}
{"name":"Michael","age":25}
\end{verbatim}
%FIXME как выделять код JSON?

или в XML:
\begin{lstlisting}[language=XML]
<person>
    <name>Michael</name>
    <age>25</age>
</person>
\end{lstlisting}

Зачастую веб-приложения используют различные URL для получения этих представлений: возможно \lstinline'/person/michael.html, /person/michael.json', и т.п. Yesod, следуя принципам RESTful, использует один URL для каждого ресурса. Поэтому в Yesod все представления будут доступны через \lstinline'/person/michael'.

Возникает вопрос, как мы определим, какое представление требуется. Ответ в Accept-заголовке запроса: он получает приоритезированный список типов содержимого, ожидаемого клиентом. Основываясь на этом заголовке, Yesod будет автоматически определять, какое представление требуется.

Немного конкретизируем последнее предложение следующим кодом:

\begin{lstlisting}
type ChooseRep = [ContentType] -> IO (ContentType, Content)
class HasReps a where
    chooseRep :: a -> ChooseRep
\end{lstlisting}

Функция \lstinline`chooseRep` получает два аргумента: значение, для которого мы получаем представления и список типов содержимого, которые клиент будет получать. Список определяется чтением из заголовка Accept-запроса. \lstinline`chooseRep` возвращает пару, включающую тип содержимого ответа и непосредственно содержимое.

Этот класс типов - основа RESTful-подхода, принятого в Yesod для представлений. Каждая функция-обработчик должна возвращать экземпляр \lstinline`HasReps`. Когда Yesod генерирует функцию-диспетчер, он автоматически применяет \lstinline'chooseRep' к каждому обработчику, по существу давая всем функциям тип \lstinline'Handler ChooseRep'. После  запуска \lstinline'Handler' и получения результата \lstinline'ChooseRep',  он применяет список типов содержимого, полученный из Accept-заголовка.

В Yesod определены многочисленные экземпляры класса HasReps. Например, когда мы используем \lstinline`defaultLayout`, возвращается тип \lstinline'RepHtml', который выглядит так:

\begin{lstlisting}
newtype RepHtml = RepHtml Content
instance HasReps RepHtml where
    chooseRep (RepHtml content) _ = return ("text/html", content)
\end{lstlisting}

Заметьте, что мы полностью игнорируем список ожидаемых типов содержимого. Многочисленные встроенные представления (\lstinline'RepHtml, RepPlain, RepJson, RepXml'), в действительности, поддерживают только единственное представление и, следовательно, то, что содержится в Accept-заголовке клиентского запроса, является несущественным.

\section{\lstinline'RepHtmlJson'}

Противоположный пример --- \lstinline'RepHtmlJson', который создает либо HTML либо JSON представление. Этот экземпляр класса особенно полезен в программировании AJAX приложений. Вот пример, возвращающий либо HTML либо JSON данные, в зависимости от того, что хочет клиент. 

\begin{lstlisting}
{-# LANGUAGE QuasiQuotes, TypeFamilies, OverloadedStrings #-}
{-# LANGUAGE MultiParamTypeClasses, TemplateHaskell #-}
import Yesod
data R = R
mkYesod "R" [parseRoutes|
/ RootR GET
/#String NameR GET
|]
instance Yesod R

getRootR = defaultLayout $ do
    setTitle "Homepage"
    addScriptRemote "http://ajax.googleapis.com/ajax/libs/jquery/1.4/jquery.min.js"
    toWidget [julius|
$(function(){
    $("#ajax a").click(function(){
        jQuery.getJSON($(this).attr("href"), function(o){
            $("div").text(o.name);
        });
        return false;
    });
});
|]
    let names = words "Larry Moe Curly"
    [whamlet|
<h2>AJAX Version
<div #results>
    AJAX results will be placed here when you click #
    the names below.
<ul #ajax>
    $forall name <- names
        <li>
            <a href=@{NameR name}>#{name}

<h2>HTML Version
<p>
    Clicking the names below will redirect the page #
    to an HTML version.
<ul #html>
    $forall name <- names
        <li>
            <a href=@{NameR name}>#{name}

|]

getNameR name = do
    let widget = do
            setTitle $ toHtml name
            [whamlet|Looks like you have Javascript off. Name: #{name}|]
    let json = object ["name" .= name]
    defaultLayoutJson widget json

main = warpDebug 4000 R

\end{lstlisting}

Наш обработчик \lstinline'getRootR' создает страницу c тремя ссылками и Javascript-кодом, который перехватывает нажатия на ссылки и производит асинхронные запросы. Если у пользователя разрешен Javascript, то нажатие на ссылку приводит к запросу, отсылаемому с Accept-заголовком application/json. В этом случае, \lstinline'getNameR' будет возвращать JSON-представление.

Если пользователь запрещает Javascript, то нажатие на ссылку будет отсылать пользователя к соответствующему URL. Браузер укажет приоритет HTML-представления данных и, следовательно, будет возвращена страница, определенная виджетом.

Мы конечно можем расширить это поведение для работы с XML, Atom-лентами, или даже двоичным представлением данных. Для развлечения можно было бы написать веб-приложение, которое готовит данные, просто используя для типов данных стандартные экземпляры класса \lstinline'Show'. И затем написать веб-клиента, который разбирает результаты, используя стандартные экземпляры класса Read.

Возможно вас беспокоит эффективность этого подхода. Разве это не означает, что мы должны генерировать и HTML и JSON ответы для каждого запроса? Благодаря ленивости этого не происходит. В функции \lstinline'getNameR' ни \lstinline'widget' ни \lstinline'json' не будет вычислен, пока не будет выбран соответствующий тип ответа, и, следовательно, всегда будет выполняться только один из них.

\section{Новостные ленты}

Отличный практический пример множественных представлений дает пакет yesod-newsfeed. В вебе существуют два главных формата новостных лент: RSS и Atom. Они содержат почти в точности схожую информацию, но по-разному упакованную.

В пакете yesod-newsfeed определен тип данных \lstinline'Feed', который содержит такую информацию как название, описание, время последнего изменения. Далее определено два набора функций для отображения данных: одна для RSS, другая для Atom. Для каждого набора определен собственный тип данных представления:

\begin{lstlisting}
newtype RepAtom = RepAtom Content
instance HasReps RepAtom where
    chooseRep (RepAtom c) _ = return (typeAtom, c)
newtype RepRss = RepRss Content
instance HasReps RepRss where
    chooseRep (RepRss c) _ = return (typeRss, c)
\end{lstlisting}

В третьем модуле определен другой тип данных:

\begin{lstlisting}
data RepAtomRss = RepAtomRss RepAtom RepRss
instance HasReps RepAtomRss where
    chooseRep (RepAtomRss (RepAtom a) (RepRss r)) = chooseRep
        [ (typeAtom, a)
        , (typeRss, r)
        ]
\end{lstlisting}

Этот тип данных автоматически определяет представление, предпочтительное для клиента (по умолчанию выбирается Atom). Если клиентские соединения понимают только RSS, полагая, что они обеспечивают правильные HTTP-заголовки, Yesod выдаст RSS представление.

\section{Другие заголовки запроса}

Существует большое количество других заголовков запроса. Некоторые из них влияют только на передачу данных между сервером и клиентом, и не должны влиять на приложение в целом. Например, Accept-Encoding сообщает серверу о том, какие схемы сжатия понимает клиент, а Host информирует сервер, какие виртуальные хосты обслуживаются.

Другие заголовки влияют на приложение, и автоматически считываются в Yesod. Например, заголовок Accept-Language определяет, какой язык предпочитает клиент (Английский, Испанский, Немецкий и т.п.). В части про i18n детально описывается, как используется этот заголовок.

\section{Отсутстие состояния}

Я оставил этот раздел напоследок, не оттого, что он менее важен, но скорее потому, что здесь нет особенностей в Yesod, обеспечивающих соответствующую поддержку.

Протокол HTTP не поддерживает состояния (stateless): каждый запрос рассматривается как начало общения. Это означает, к примеру, что серверу не важно то, что вы уже запрашивали пять страниц, --- он будет обрабатывать ваш шестой запрос так, как если бы он был самым первым.

С другой стороны, некоторая функциональность сайта не будет работать без хранения состояния. Например, как реализовать корзину покупок, если не хранить информацию о покупках между запросами?

Решением являются куки-файлы (cookies) и, построенные на их основе, сессии. У нас есть целый раздел, посвященный сессиям в Yesod. Однако, я не могу не подчеркнуть, что их следует использовать с осторожностью.

Позвольте привести пример. Существует популярная система отслеживания ошибок, с которой я работал ежедневно и которая слишком много использовала сессии. Там есть маленький выпадающий список на каждой странице для выбора текущего проекта. Кажется безвредно, да? Все, что этот список делает - устанавливает текущий проект для вашей сессии.

В результате, щелчок на ссылке <<просмотреть инциденты>> внутренне зависит от того, какой проект вы выбирали последним. Из-за этого нет способа сделать закладку на ваши Yesod-инциденты и отдельную ссылку на ваши Hamlet-инциденты.

Правильный RESTful подход состоит в том, чтобы иметь один ресурс для всех Yesod-инцидентов и другой для всех Hamlet-инцидентов. В Yesod это легко делается с примерно таким определением маршрута:

\begin{lstlisting}
/ ProjectsR GET
/projects/#ProjectID ProjectIssuesR GET
/issues/#IssueID IssueR GET
\end{lstlisting}

Будьте внимательны к своим пользователям: правильная архитектура без использования состояний означает, что такие базовые вещи, как закладки, хранимые ссылки и кнопки <<Вперед>>, <<Назад>> будут всегда работать.

\section{Выводы}

Yesod придерживается следующих принципов REST:
\begin{itemize}
 \item Использует правильные методы запроса
 \item Каждый ресурс должен иметь в точности один URL
 \item Разрешает множественные представления данных для одного URL
 \item Проверяет заголовки запросов для определения дополнительной информации о том, что ждет клиент
\end{itemize}

Это упрощает использование Yesod не только для построения веб-сайтов, но также для построения программных интерфейсов (API). В действительности, используя технику, подобную RepHtmlJson, с одного URL вы можете обслужить одновременно "дружелюбную к пользователю" HTML-страницу и "дружелюбную к машине" JSON-страницу.







 



