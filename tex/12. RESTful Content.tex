RESTful содержимое

Одна из историй ранних дней развития Интернета - как поисковые системы уничтожали целые web-сайты. Когда динамические сайты были еще новой концепцией, разработчики не принимали во внимание различий между GET и POST запросами. В результате, они создавали страницы, удаляющие содержимое, с доступомчерез GET-метод. Когда поисковики начинали сканировать эти сайты, они могли удалить все содержимое.

Если бы эти разработчики точнее следовали спецификации HTTP, этого бы не случилось. GET-запрос подразумевает отсутствие побочных эффектов (вроде стирания сайта, к примеру). Не так давно, в веб-разработке произошло движение к правильному охвату “Передачи репрезентативного состояния” (Representational State Transfer), известного также как REST. Эта часть описывает особенности Yesod, связаные с поддержкой REST, и как они могут быть использованы для создания более надежных web-приложений.

Методы HTTP-запросов

Во многих веб-фреймворках, вы пишете для ресурса одну функцию-обработчик (handler). В Yesod, по умолчанию, предполагается отдельная функция-обработчик для каждого метода запроса. Два самых частых метода, с которыми вы будете иметь дело при создании веб-сайтов - это методы GET и POST. Эти методы лучше всего поддерживаются в HTML, поскольку только они поддерживаются web-формами. Однако, при создании REST-API, другие методы также очень полезны.

Технически, вы можете создать какие угодно методы, но настоятельно рекомендуется придерживаться методов, описанных в спецификации HTTP. Наиболее часто встречаются методы:

• GET
Запрос на чтение. Предполагается, что, при вызове GET, не произойдет никаких изменений на сервере. При многократном вызове GET-метода, сервер должен выдавать тот же ответ, если исключить такие вещи как “текущее время” или случайно полученные результаты.

• POST
Обычный запрос на изменение. POST-запрос никогда не должен посылаться пользователем дважды. Обычно, в качестве примера POST-запроса приводят перевод денежных средств с одного банковского счета на другой.

• PUT
Создание нового ресурса на сервере или изменение существующего. Этот метод может быть выполнен многократно с одинаковым эффектом.

• DELETE
В точности соответствует названию. Удаляет ресурс с сервера. Повторные вызовы не должны приводить к проблемам.

В определенной степени, это соответствует философии Haskell: GET-запрос подобен чистой функции, без побочных эффектов. На практике, ваши GET-функции вероятно будут производить IO-операции - чтение информации из базы данных, логирование пользовательских действий и так далее.

Смотрите часть “Routing and Handlers” для более полной информации по синтаксису определения функций-обработчиков для каждого метода HTTP-запроса.

Представления

Пусть мы определили тип данных и значение:

\begin{lstlisting}
data Person = Person { name :: String, age :: Int }
michael = Person "Michael" 25
\end{lstlisting}

Мы можем представить эти данные в HTML:
\begin{lstlisting}[language=HTML]
 <table>
    <tr>
        <th>Name</th>
        <td>Michael</td>
    </tr>
    <tr>
        <th>Age</th>
        <td>25</td>
    </tr>
</table>
\end{lstlisting}

или в JSON:

\begin{lstlisting}[language=Java]
{"name":"Michael","age":25}
\end{lstlisting}

или в XML:
\begin{lstlisting}[language=XML]
<person>
    <name>Michael</name>
    <age>25</age>
</person>
\end{lstlisting}

Зачастую, веб-приложения используют различные URL для получения этих представлений: возможно \lstinline '/person/michael.html', \lstinline '/person/michael.json', и т.п. Yesod, следуя принципам REST, использует один URL для каждого ресурса. Поэтому в Yesod все представления будут доступны через \lstinline '/person/michael'.

Возникает вопрос, как мы определим, какое представление требуется. Ответ в заголовке HTTP Accept: он получает приоритезированный список типов содержимого, ожидаемого клиентом. Yesod будет автоматически опраделять какое представление требуется, основываясь на этом заголовке.

Немного конкретизируем последнее предложение следующим кодом:

\begin{lstlisting}
type ChooseRep = [ContentType] -> IO (ContentType, Content)
class HasReps a where
    chooseRep :: a -> ChooseRep
\end{lstlisting}

Функция \lstinline `chooseRep` получает два аргумента: значение, для которого мы получаем представления и список типов содержимого, которые клиент будет получать. Список определяется чтением из заголовка Accept-запроса. \lstinline `chooseRep` возвращает пару, включающую тип содержимого ответа и непосредственно содержимое.

Этот класс типов - основа REST-подхода, принятого в Yesod для представлений. Каждая функция-обработчик должна возвращать экземпляр \lstinline `HasReps`. Когда Yesod генерирует функцию-диспетчер, он автоматически применяет \lstinline 'chooseRep' к каждому обработчику, по существу давая всем функциям тип \lstinline 'Handler \lstinline ChooseRep'. После  запуска \lstinline 'Handler' и получения результата \lstinline 'ChooseRep',  он применяет список типов содержимого, полученный из Accept-заголовка.




