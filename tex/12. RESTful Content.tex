\section{RESTful содержимое}
%FIXME RESTful Content

Одна из историй ранних дней развития Интернета - как поисковые системы уничтожали целые web-сайты. Когда динамические сайты были еще новой концепцией, разработчики не принимали во внимание различий между GET и POST запросами. В результате, они создавали страницы, удаляющие содержимое, с доступомчерез GET-метод. Когда поисковики начинали сканировать эти сайты, они могли удалить все содержимое.

Если бы эти разработчики точнее следовали спецификации HTTP, этого бы не случилось. GET-запрос подразумевает отсутствие побочных эффектов (вроде стирания сайта, к примеру). Не так давно, в веб-разработке произошло движение к правильному охвату “Передачи репрезентативного состояния” (Representational State Transfer), известного также как REST. Эта часть описывает особенности Yesod, связаные с поддержкой REST, и как они могут быть использованы для создания более надежных web-приложений.

\subsection{Методы HTTP-запросов}

Во многих веб-фреймворках, вы пишете для ресурса одну функцию-обработчик (handler). В Yesod, по умолчанию, предполагается отдельная функция-обработчик для каждого метода запроса. Два самых частых метода, с которыми вы будете иметь дело при создании веб-сайтов - это методы GET и POST. Эти методы лучше всего поддерживаются в HTML, поскольку только они поддерживаются web-формами. Однако, при создании REST-API, другие методы также очень полезны.

Технически, вы можете создать какие угодно методы, но настоятельно рекомендуется придерживаться методов, описанных в спецификации HTTP. Наиболее часто встречаются методы:

• GET
Запрос на чтение. Предполагается, что, при вызове GET, не произойдет никаких изменений на сервере. При многократном вызове GET-метода, сервер должен выдавать тот же ответ, если исключить такие вещи как “текущее время” или случайно полученные результаты.

• POST
Обычный запрос на изменение. POST-запрос никогда не должен посылаться пользователем дважды. Обычно, в качестве примера POST-запроса приводят перевод денежных средств с одного банковского счета на другой.

• PUT
Создание нового ресурса на сервере или изменение существующего. Этот метод может быть выполнен многократно с одинаковым эффектом.

• DELETE
В точности соответствует названию. Удаляет ресурс с сервера. Повторные вызовы не должны приводить к проблемам.

В определенной степени, это соответствует философии Haskell: GET-запрос подобен чистой функции, без побочных эффектов. На практике, ваши GET-функции вероятно будут производить IO-операции - чтение информации из базы данных, логирование пользовательских действий и так далее.

Смотрите часть “Routing and Handlers” для более полной информации по синтаксису определения функций-обработчиков для каждого метода HTTP-запроса.

\subsection{Представления}

Пусть мы определили тип данных и значение:

\begin{lstlisting}
data Person = Person { name :: String, age :: Int }
michael = Person "Michael" 25
\end{lstlisting}

Мы можем представить эти данные в HTML:
\begin{lstlisting}[language=HTML]
 <table>
    <tr>
        <th>Name</th>
        <td>Michael</td>
    </tr>
    <tr>
        <th>Age</th>
        <td>25</td>
    </tr>
</table>
\end{lstlisting}

или в JSON:

\begin{lstlisting}[language=Java]
{"name":"Michael","age":25}
\end{lstlisting}

или в XML:
\begin{lstlisting}[language=XML]
<person>
    <name>Michael</name>
    <age>25</age>
</person>
\end{lstlisting}

Зачастую, веб-приложения используют различные URL для получения этих представлений: возможно \lstinline '/person/michael.html', \lstinline '/person/michael.json', и т.п. Yesod, следуя принципам REST, использует один URL для каждого ресурса. Поэтому в Yesod все представления будут доступны через \lstinline '/person/michael'.

Возникает вопрос, как мы определим, какое представление требуется. Ответ в заголовке HTTP Accept: он получает приоритезированный список типов содержимого, ожидаемого клиентом. Yesod будет автоматически опраделять какое представление требуется, основываясь на этом заголовке.
%FIXME Accept request header

Немного конкретизируем последнее предложение следующим кодом:

\begin{lstlisting}
type ChooseRep = [ContentType] -> IO (ContentType, Content)
class HasReps a where
    chooseRep :: a -> ChooseRep
\end{lstlisting}

Функция \lstinline `chooseRep` получает два аргумента: значение, для которого мы получаем представления и список типов содержимого, которые клиент будет получать. Список определяется чтением из заголовка Accept-запроса. \lstinline `chooseRep` возвращает пару, включающую тип содержимого ответа и непосредственно содержимое.

Этот класс типов - основа REST-подхода, принятого в Yesod для представлений. Каждая функция-обработчик должна возвращать экземпляр \lstinline `HasReps`. Когда Yesod генерирует функцию-диспетчер, он автоматически применяет \lstinline 'chooseRep' к каждому обработчику, по существу давая всем функциям тип \lstinline 'Handler \lstinline ChooseRep'. После  запуска \lstinline 'Handler' и получения результата \lstinline 'ChooseRep',  он применяет список типов содержимого, полученный из Accept-заголовка.

В Yesod определены многочисленные экземпляры класса HasReps. Например, когда мы используем \lstinline `defaultLayout`, возвращается тип \lstinline 'RepHtml', который выглядит так:

\begin{lstlisting}
newtype RepHtml = RepHtml Content
instance HasReps RepHtml where
    chooseRep (RepHtml content) _ = return ("text/html", content)
\end{lstlisting}

Заметьте, что мы полностью игнорируем список ожидаемых типов содержимого. Многочисленные встроенные представления (\lstinline 'RepHtml', \lstinline 'RepPlain', \lstinline 'RepJson', \lstinline 'RepXml'), в действительности, поддерживают только единственное представление и, следовательно, то, что содержится в Accept-заголовке клиентского запроса, является несущественным.

\subsection{\lstinline 'RepHtmlJson'}

Противоположный пример - \lstinline 'RepHtmlJson', который создает либо HTML либо JSON представление. Этот экземпляр класса особенно полезен в программировании AJAX приложений. Вот пример, возвращающий либо HTML либо JSON данные, в зависимости от того, что хочет клиент. 
%FIXME перевел "This instance helps greatly in programming AJAX applications that degrade nicely" как "Этот экземпляр класса особенно полезен в программировании AJAX приложений". Как перевести "that degrade nicely" (что ухудшает красиво) не придумал и просто опустил.

\begin{lstlisting}
{-# LANGUAGE QuasiQuotes, TypeFamilies, OverloadedStrings #-}
{-# LANGUAGE MultiParamTypeClasses, TemplateHaskell #-}
import Yesod
data R = R
mkYesod "R" [parseRoutes|
/ RootR GET
/#String NameR GET
|]
instance Yesod R

getRootR = defaultLayout $ do
    setTitle "Homepage"
    addScriptRemote "http://ajax.googleapis.com/ajax/libs/jquery/1.4/jquery.min.js"
    toWidget [julius|
$(function(){
    $("#ajax a").click(function(){
        jQuery.getJSON($(this).attr("href"), function(o){
            $("div").text(o.name);
        });
        return false;
    });
});
|]
    let names = words "Larry Moe Curly"
    [whamlet|
<h2>AJAX Version
<div #results>
    AJAX results will be placed here when you click #
    the names below.
<ul #ajax>
    $forall name <- names
        <li>
            <a href=@{NameR name}>#{name}

<h2>HTML Version
<p>
    Clicking the names below will redirect the page #
    to an HTML version.
<ul #html>
    $forall name <- names
        <li>
            <a href=@{NameR name}>#{name}

|]

getNameR name = do
    let widget = do
            setTitle $ toHtml name
            [whamlet|Looks like you have Javascript off. Name: #{name}|]
    let json = object ["name" .= name]
    defaultLayoutJson widget json

main = warpDebug 4000 R

\end{lstlisting}

Наш \lstinline обработчик 'getRootR' создает страницу c тремя ссылками и Javascript-кодом, который перехватывает нажатия на ссылки и производит асинхронные запросы. Если у пользователя разрешен Javascript, то нажатие на ссылку приводит к запросу, отсылаемому с Accept-заголовком application/json. В этом случае, \lstinline 'getNameR' будет возвращать JSON-представление.

Если пользователь запрещает Javascript, то нажатие на ссылку будет отсылать пользователя к соответствующему URL. Браузер укажет приоритет HTML-представления данных и, следовательно, будет возвращена страница, определенная виджетом.

Мы конечно можем расширить это поведение для работы с XML, Atom feeds, или даже двоичным представлением данных. Для развлечения можно было бы написать веб-приложение, которое готовит данные просто используя экземпляры по умолчанию класса \lstinline 'Show' типов данных. И затем написать веб-клиента, который разбирает результаты, используя экземпляры по умолчанию класса Read.
%FIXME Atom feeds

Возможно, вас беспокоит эффективность этого подхода. Разве это не означает, что мы должны генерировать и HTML и JSON ответы для каждого запроса? Благодаря ленивости этого не происходит. В функции \lstinline 'getNameR' ни \lstinline 'widget' ни \lstinline 'json' не будет вычислен, пока не будет выбран соответствующий тип ответа, и, следовательно, всегда будет выполняться только один из них.

\subsection{Новостные ленты (News Feeds)}
%FIXME News Feed

Отличный, практический пример множественных представлений дает пакет yesod-newsfeed. В вебе существует два главных формата новостных лент: RSS и Atom. Они содержат почти в точности схожую информацию, но по-разному упакованную.

В пакете yesod-newsfeed определе тип данных \lstinline 'Feed', который содержит такую информацию как название, описание, время последнего изменения. Далее определено два набора функций для отображения данных: одна для RSS, другая для Atom. Для каждого набора определен собственный тип данных представления:

\begin{lstlisting}
newtype RepAtom = RepAtom Content
instance HasReps RepAtom where
    chooseRep (RepAtom c) _ = return (typeAtom, c)
newtype RepRss = RepRss Content
instance HasReps RepRss where
    chooseRep (RepRss c) _ = return (typeRss, c)
\end{lstlisting}

В третьем модуле определен другой тип данных:

\begin{lstlisting}
data RepAtomRss = RepAtomRss RepAtom RepRss
instance HasReps RepAtomRss where
    chooseRep (RepAtomRss (RepAtom a) (RepRss r)) = chooseRep
        [ (typeAtom, a)
        , (typeRss, r)
        ]
\end{lstlisting}

Этот тип данных автоматически определяет представление, предпочтительное для клиента (по умолчанию выбирается Atom). Если клиентские соединения понимают только RSS, полагая, что они обеспечивают правильные HTTP-заголовки, Yesod выдаст RSS представление.

\subsection{Другие заголовки запроса}

Существует большое количество других заголовков запроса. Некоторые из них влияют только на передачу данных между сервером и клиентом, и не должны влиять на приложение в целом. Например, Accept-Encoding информирует сервер о том, какие схемы сжатия понимает клиент, а Host информирует сервер, какие виртуальные хосты для обслуживания.
%FIXME For example, Accept-Encoding informs the server which compression schemes the client understands, and Host informs the server which virtual host to serve up.

Другие заголовки влияют на приложение, и автоматически считываются в Yesod. Например, заголовок Accept-Language определяет, какой язык предпочитает клиент (Английский, Испанский, Немецкий и т.п.). В части про i18n детально описывается, как используется этот заголовок.

\subsection{Отсутстие состояния}

Я оставил этот раздел напоследок, не от того, что он менее важен, но скорее потому, что здесь нет особенностей в Yesod, обеспечивающих соответствующую поддержку.

Протокол HTTP не поддерживает состояния (stateless): каждый запрос рассматривается как начало общения. Это означает, к примеру, что серверу не важно то, что вы уже запрашивали пять страниц, - он будет обрабатывать ваш шестой запрос так, как если бы он был самым первым.

С другой стороны, некоторая функциональность сайта не будет работать без хранения состояния. Например, как реализовать корзину покупок, если не хранить информацию о покупках между запросами?

Решением являются куки-файлы (cookies) и, построенные на их основе, сессии. У нас есть целый раздел, посвященный сессиям в Yesod. Однако, ...
%FIXME I cannot stress enough that this should be used sparingly.

Позвольте привести пример. Существует популярная система баг трекинга, с котороя я работал ежедневно и которая слишком много использовала сессии. Там есть маленький drop-down элемент на каждой странице для выбора текущего проекта. Кажется безвредно, да? Все, что этот dropdown делает - устанавливает текущий проект для вашей сессии.
%FIXME  bug tracking system

В результате, щелчок на ссылке "view issues" внутренне зависит от того, какой проект вы выбирали последним. Из-за этого нет способа сделать закладку на ваши "Yesod" issues и отдельную ссылку на ваши "Hamlet" issues.
%FIXME issues

Правильный REST подход состоит в том, чтобы иметь один ресурс для всех Yesod issues и другой для всех Hamlet issues. В Yesod это легко делается с примерно таким определением маршрута:

\begin{lstlisting}
/ ProjectsR GET
/projects/#ProjectID ProjectIssuesR GET
/issues/#IssueID IssueR GET
\end{lstlisting}

Будьте внимательны к своим пользователям: правильная архитектура без использования состояний означает, что такие базовые вещи, как закладки, хранимые ссылки и кнопки "Вперед", "Назад" будут всегда работать.

\subsection{Выводы}

Yesod adheres to the following tenets of REST:
%FIXME Yesod adheres to the following tenets of REST:
\item{Использует правильные методы запроса}
\item{Каждый ресурс должен иметь в точности один URL}
\item{Разрешает множественные представления данных для одного URL}
\item{Проверяет заголовки запросов для определения дополнительной информации о том, что ждет клиент}

Это упрощает использование Yesod не только для построения веб-сайтов, но также для построения программных интерфейсов (API). В действительности, используя технику, подобную RepHtmlJson, с одного URL вы можете обслужить одновременно "дружелюбную к пользователю" HTML-страницу и "дружелюбную к машине" JSON-страницу.







 



