\chapter{Виджеты}

Одна из проблем в веб разработке~--- нам приходится координировать три различные клиентские технологии: HTML, CSS и Javascript. Хуже того, мы должны размещать эти компоненты в различных местах на странице: CSS в теге style в заголовке, Javascript в теге script в заголовке, a HTML в теле. И это не говоря уже о случае, когда вы хотите разместить свои CSS и Javascript в отдельных файлах!

На деле, это работает довольно хорошо при создании одиночной страницы, потому что мы можем разделить нашу структуру (HTML), стили (CSS) и логику (Javascript). Но когда мы хотим строить код из модулей, которые можно будет легко компоновать, раздельная координация всех трёх частей может стать головной болью. Виджеты~--- решение Yesod для этой задачи. Они также помогают с проблемой однократного подключения библиотек наподобие jQuery.

Наши четыре языка шаблонов~--- Hamlet, Cassius, Lucius и Julius~--- предоставляют исходные инструменты для конструирования вашего вывода. Виджеты обеспечивают клей, который позволяет работать им вместе как единое целое.

\section{Краткий обзор}

\begin{lstlisting}
getRootR = defaultLayout $ do
    setTitle "Название моей страницы"
    toWidget [lucius| h1 { color: green; } |]
    addScriptRemote "https://ajax.googleapis.com/ajax/libs/jquery/1.6.2/jquery.min.js"
    toWidget [julius|
$(function() {
    $("h1").click(function(){ alert("Вы кликнули на заголовок!"); });
});
|]
    toWidgetHead [hamlet| <meta name=keywords content="некоторые ключевые слова примера">|]
    toWidget [hamlet| <h1> Это один способ вставки контента |]
    [whamlet| <h2> А это другой |]
    toWidgetBody [julius| alert("Это вставлено в само тело"); |]

main = warpDebug 3000 W
\end{lstlisting}

Этот код порождает следующий HTML (отступы добавлены):

\begin{lstlisting}[language=HTML]
<!DOCTYPE html>
<html>
    <head>
        <title>Название моей страницы</title>
        <style>h1 { color : green }</style>
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.6.2/jquery.min.js"></script>
        <script>
$(function() {
    $("h1").click(function(){ alert("Вы кликнули на заголовок!"); });
});
</script>
        <meta name="keywords" content="некоторые ключевые слова примера">
    </head>
    <body>
        <h1> Это один способ вставки контента </h1>
        <h2> А это другой </h2>
        <script> alert("Это вставлено в само тело"); </script>
    </body>
</html>
\end{lstlisting}

\section{Что в Виджете?}
На самом поверхностном уровне, HTML документ~--- это просто набор вложенных тегов. Такой подход выбирают большинство генерирующих HTML инструментов: вы просто определяете иерархию тегов и всё. Но давайте представим, что я хочу написать компонент страницы для отображения навигационной панели. Я хочу, чтобы он был <<plug and play>>: я просто вызываю функцию в нужное время, и панель вставляется в соответствующее место в иерархии.

Тут наш поверхностный подход к генерации HTML даёт сбой. Наша навигационная панель вероятно содержит какой-нибудь CSS и Javascript в дополнение к HTML. К тому времени, когда мы вызываем функцию навигационной панели, мы уже сформировали тег <head>, так что уже поздно добавлять новый тег <style> для наших CSS объявлений. В рамках обычных стратегий, нам нужно было бы разбить нашу функцию навигационной панели на три части: HTML, CSS и JavaScript, и убедиться, что мы всегда вызываем все три части.

Виджеты используют другой подход. Вместо рассмотрения HTML документа как монолитного дерева тегов, виджеты видят на странице набор различных компонентов. В частности:
\begin{itemize}
  \item Название страницы
  \item Внешние стили
  \item Внешний Javascript
  \item Объявления CSS
  \item Код Javascript
  \item Произвольный контент в <head>
  \item Произвольный контент в <body>
\end{itemize}

Различные компоненты имеют различный смысл. К примеру, может быть только одно название, но может быть множество внешних скриптов и стилей. Однако, эти внешние скрипты и стили должны быть добавлены только раз. Произвольный контент в заголовке и теле, с другой стороны, не имеет ограничений (кто-то, возможно, захочет пять блоков lorem ipsum, в конце концов).

Работа виджета~--- держаться за эти несопоставимые компоненты и применять правильную логику для комбинирования виджетов вместе. Логика эта включает такие действия, как фиксация первого установленного названия и игнорирование остальных, фильтрация дубликатов из списка внешних скриптов и стилей, объединение содержимого заголовка и тела.

\section{Конструирование Виджетов}
Для использования виджетов, вам, очевидно, необходима возможность их создания. Наиболее распространённый способ сделать это~--- через класс типов \lstinline'ToWidget' и его метод \lstinline'toWidget'. Метод предоставляет вам возможность конвертировать ваши Shakespearean шаблоны прямо в \lstinline'Widget': код Hamlet появится в теле, скрипты Julius~--- в теге <script> в заголовке, а Cassius и Lucius~--- в теге <style> заголовка.
\begin{remark}
На самом деле, вы можете переопределить стандартное поведение и получить скрипт и код стилей в отдельных файлах. Сгенерированный начальный каркас сайта делает это для вас автоматически. Кроме того, в главе <<\nameref{ch:yesod-typeclass}>> мы увидим, как включить асинхронную загрузку скриптов, которая поместит содержимое ваших скриптов в конец тела страницы.
\end{remark}

Но что, если вы захотите добавить какие-нибудь теги <meta>, которые должны появиться в заголовке? Или если вы захотите, чтобы некоторый Javascipt появился в теле, а не в заголовке? Для этих целей, Yesod предоставляет два дополнительных класса типов: \lstinline'ToWidgetHead' и \lstinline'ToWidgetBody'. Они работают именно так, как вы от них ожидаете.

Кроме того, есть ряд других функций для создания специфических видов Виджетов:
\begin{description}
\item[setTitle] \hfill \\
Преобразует некоторый HTML в название страницы.
\item[addCassiusMedia, addLuciusMedia] \hfill \\
Работают также как \lstinline'toWidget', но принимают дополнительный параметр для обозначения, к какому типу медиа контента применяется. Полезно для создания стилей печати, например.
\item[addStylesheet] \hfill \\
Добавляет ссылку, используя тег <link>, на внешнюю таблицу стилей. Принимает типобезопасный URL.
\item[addStylesheetRemote] \hfill \\
Аналогична \lstinline'addStylesheet', но принимает обычный URL. Полезна для ссылок на файлы, хранящиеся на CDN, подобно таблицам стилей CSS для jQuery UI, предоставляемым Google.
\item[addScript] \hfill \\
Добавляет ссылку, используя тег <script>, на внешний скрипт. Принимает типобезопасный URL.
\item[addScriptRemote] \hfill \\
Аналогична \lstinline'addScript', но принимает обычный URL. Полезна для ссылок на файлы, хранящиеся на CDN, подобно jQuery от Google .
\end{description}

\section{Комбинирование Виджетов}

В целом идея виджетов это повышение компонуемости. Вы можете взять отдельные части HTML, CSS и Javascript, комбинировать их вместе в нечто более сложное, и затем комбинировать эти большие сущности в полную страницу. Это все работает естественно через экземпляр класса Monad виджетов, а значит вы можете использовать do-нотацию для комбинирования частей вместе.
\begin{lstlisting}[title={Комбинирование Виджетов}]
myWidget1 = do
    toWidget [hamlet|<h1>My Title|]
    toWidget [lucius|h1 { color: green } |]

myWidget2 = do
    setTitle "My Page Title"
    addScriptRemote "http://www.example.com/script.js"

myWidget = do
    myWidget1
    myWidget2

-- или, если захотите
myWidget' = myWidget1 >> myWidget2
\end{lstlisting}
\begin{remark}
Еслы вы к тому же склоны, есть также экземпляр класса Monoid Виджета, а значит вы можете использовать \lstinline'mconcat' или монаду Writer для построения сущностей. В моих экспериментах, самое легкое и самое естественное, просто использовать do-нотацию.
\end{remark}

\section{Генерирование идентификаторов}

Если мы здесь по настоящему хотим переиспользовать код, мы со временем получим конфликт имен. Скажем, что есть две вспомогательные библиотеки, обе используют имя класса \textquotedblleft foo\textquotedblright, чтобы повлиять на стилистику. Мы хотим избежать такой возможности. Вследствие этого, мы имеет \lstinline'newIdent' функцию.  Эта функция автоматически генерирует слово, такое что оно уникально для этого обработчика.

Использование newIdent

\begin{lstlisting}
getRootR = defaultLayout $ do
    headerClass <- lift newIdent
    toWidget [hamlet|<h1 .#{headerClass}>My Header|]
    toWidget [lucius| .#{headerClass} { color: green; } |]

main = warpDebug 3000 W
\end{lstlisting}

Вам может быть интересно: что означает \lstinline'lift'? Виджет это трансформер монад, сидящий cверху Обработчика. \lstinline'newIdent' это функция обработчика, так мы нуждаемся в \textquotedblleft втягивании\textquotedblright функции из слоя обработчика в слой виджета, чтобы использовать её. Мы можем на самом деле использовать этот похожий подход для выполнения сложных действий, подобно запросы базы данных, из в виджет. Мы покроем это когда мы обсудим монады Yesod.

\section{whamlet}

Cкажем вы получили довольно стандартный шаблон Hamlet, который встрааивает другой шаблон Hamlet для отображения footer:

\begin{lstlisting}
page = [hamlet|
<p>Это моя страница. Я надеюсь вы наслаждаетесь ею.
^{footer}
|]

footer = [hamlet|
<footer>
    <p>Это все, люди!
|]
\end{lstlisting}

Это работает хорошо, если footer это обычный старый HTML, но что если мы хотим добавить некторый стиль? Хорошо, мы можем легко приправить footer, преобразуя его в виджет:

\begin{lstlisting}
footer = do
    toWidget [lucius| footer { font-weight: bold; text-align: center } |]
    toWidget [hamlet|
<footer>
    <p>Это все, люди!
|]
\end{lstlisting}

Но сейчас мы получили проблему: шаблон Hamlet может только встраивать другой шаблон Hamlet; он ничего не знает о Виджете. Тут к нам приходит whamlet. Он принимает точно такой же синтаксис, как обычный Hamlet, и не изменяет его. Но встраивание (\lstinline!^{...}!) принимает Виджет, и финальный результат тоже Виджет. Для его использования, мы можем просто сделать так:

\begin{lstlisting}
page = [whamlet|
<p>Это моя страница. Я надеюсь вы наслаждаетесь ею.
^{footer}
|]
\end{lstlisting}


Есть также \lstinline'whamletFile', если вы предпрочитаете держать ваш шаблон в отдельном файле.

Сгенерированный каркасный сайт имеет даже больше удобных функций, \lstinline'widgetFile', которая также встраивает ваши Lucius, Cassius, и Julius файлы автоматически. Мы увидели это в главе генерирование каркасного сайта. %FIXME название главы зависит от того как его перевел другой переводчик

\subsection{Типы}

Возможно, вы уже заметили, я избегал сигнатуры типов до сих пор. На самом простом уровне, все что вам нужно знать, это то есть синонимы типов названные Виджетом, которые вы будете постоянно использовать. Технические подробности позже, но не беспокойтесь, если немножко не ясно.

На самом деле нету типа Widget определенного в библиотеках Yesod, так как точное значение их меняется между сайтами. Взамен, мы имеем более обощенный тип \lstinline'GWidget sub master a'. Первые два параметра sub и master дают основные типы, соответсвенно. Последний параметр это контейнерное значение, просто как в любой Монаде.

Так в чем дело с этими sub/master штуковинами? Хорошо, когда вы пишете некоторый переиспользуемый код, такой как CRUD приложение, вы можете писать это как подсайт, который может быть встроен в любое другое приложение Yesod. В данном случае, мы нуждаемся в отслеживании информации для обоих, sub и master сайтов. Самый простой пример для типов -типобезопасные URL: Yesod нуждается в знании как взять путь для CRUD подсайта и преобразовать его в путь для master сайта, так что он мог бы правильно быть отображен.

Однако, эти sub/master различия только более значимы, когда вы взаимодействуете с подсайтами. Когда вы пишете ваш стандартный ответный код, вы обращаетесь с только вашим приложением, и так sub и master сайты будут похожими. Поскольку это самый общий случай, сгенерированный каркасный сайт объявляет тип синоним, чтобы помочь вам. Скажем ваш основной тип это MyCoolApp, он будет определен \lstinline'define type Widget = GWidget MyCoolApp MyCoolApp ()'. В следствии этого, мы можем получить некоторую очень дружелюбную к пользователю сигнатуру типа в наших виджатах:

\begin{lstlisting}
footer :: Widget
footer = do
    toWidget [lucius| footer { font-weight: bold; text-align: center } |]
    toWidget [hamlet|
<footer>
    <p>Это все, люди!
|]

page :: Widget
page = [whamlet|
<p>Это моя страница. Я надеюсь вы наслаждаетесь ею.
^{footer}
|]
\end{lstlisting}

Если вы обратили пристальное внимание, вы может быть были сбитыми с толку. Мы использовали \lstinline'lift' на Виджете в примере Генерировании идентификаторов выше, но GWidget на самом деле не трансформер монад. Что здесь происходит? Что ж, в ранних версиях Yesod, он был трансформером вокруг типа Обработчика. К несчастью, это привело к сложностям с обработкой сообщений об ошибках. Как результат, GWidget это сейчас обертка newtype, которая прячет свою сущность монады трансформера. Но мы продолжаем хотеть, быть в состоянии втянуть функцию из внутреннего Обработчика монады.

Чтобы решить это, Yesod предоставляет альтернативу, более общую \lstinline'lift' функцию, которая работает для обоих стандартных экземпляров класса MonadTrans, и специальной обертки newtype подобной GWidget. Как результат, вы можете делать вид как будто GWidget это стандартный трансформер, в то же время получая ваше приятное сообщение об ошибке.

Одна последняя проблема: только как мы имеем разрыв между Widget и GWidget, мы имеем похожий разрыв между Handler и GHandler.

\section{Использование Виджетов}

Это все хорошо и приятно, что мы имеем эти красивые типы Виджета, но как именно нам превратить их во что-то, с чем пользователь мог взаимодействовать? Самая общая использованная функция это \lstinline'defaultLayout', которая по существу имеет сигнатуру типа \lstinline'Widget -> Handler RepHtml'. (Я говорю \textquotedblleft по существу\textquotedblright, потому что это целая проблема GHandler.) RepHtml это тип данных содержащий некоторый необработанный HTML вывод, готовый к отправке по проводам.

\lstinline'defaultLayout' в действительности метод класса типов, который может быть переопределен для каждого приложения. Так приложения Yesod рождаются. Поэтому мы остаемся с вопросом: когда мы внутри \lstinline'defaultLayout', как нам развернуть Widget? Ответ это \lstinline'widgetToPageContent'. Давайте посмотрим на некоторые (упрощенные) типы:

\begin{lstlisting}
widgetToPageContent :: Widget -> Handler (PageContent url)
data PageContent url = PageContent
    { pageTitle :: Html
    , pageHead :: HtmlUrl url
    , pageBody :: HtmlUrl url
    }
\end{lstlisting}

Это ближе к тому, что наМ нужно. Мы сейчас имеем прямой доступ к HTML, создавая head и body, так же хорошо как title. В этот момент, мы можем использовать Hamlet для комбинирования их всех вместе в одиночный документ, наряду с нашим макетом сайта, и мы используем \lstinline'hamletToRepHtml' для отображения результата Hamlet в настоящий HTML, готовый к показу пользователю. Следующая илюстрация демонстрирует этот процесс.

Использование widgetToPageContent

\begin{lstlisting}
myLayout :: GWidget s MyApp () -> GHandler s MyApp RepHtml
myLayout widget = do
    pc <- widgetToPageContent widget
    hamletToRepHtml [hamlet|
$doctype 5
<html>
    <head>
        <title>#{pageTitle pc}
        <meta charset=utf-8>
        <style>body { font-family: verdana }
        ^{pageHead pc}
    <body>
        <article>
            ^{pageBody pc}
|]

instance Yesod MyApp where
    defaultLayout = myLayout

main = warpDebug 3000 MyApp
\end{lstlisting}

Вы могли заметить, что мы использовали GWidget и GHandler взамен Widget и Handler. Это потому что \lstinline'defaultLayout' метод, который может быть вызван подсайтами для удостоверения, что они получат такие же стили, как master сайт. Отсюда, мы нуждаемся поддержании гибкости наших типов здесь.

Это все хорошо и приятно, но есть одна вещь, которая беспокоит меня: style тег. Есть несколько проблем с ним:
\begin{itemize}
\item В отличие от Lucius или Cassius, он не проверяется на корректность во время компиляции.
\item Разумеющимся, что текущий пример очень простой, но в чем-то более сложном мы получим проблему экранирования символов.
\item Мы теперь имеем 2 style тега взамен одного: один из myLayout, и один генерируется в pageHead основанный на стилях установленных в виджете.
\end{itemize}

У нас есть еще один трюк в нашем мешке для решения этого: мы применим некоторую последнюю корректировку к самому виджету до вызова \lstinline'widgetToPageContent'. На самом деле это очень легко cделать: нам только надо использовать do-нотацию снова, как в Последняя корректировка виджета.

Последняя корректировка виджета

\begin{lstlisting}
myLayout :: GWidget s MyApp () -> GHandler s MyApp RepHtml
myLayout widget = do
    pc <- widgetToPageContent $ do
        widget
        toWidget [lucius| body { font-family: verdana } |]
    hamletToRepHtml [hamlet|
$doctype 5
<html>
    <head>
        <title>#{pageTitle pc}
        <meta charset=utf-8>
        ^{pageHead pc}
    <body>
        <article>
            ^{pageBody pc}
|]

instance Yesod MyApp where
    defaultLayout = myLayout

main = warpDebug 3000 MyApp
\end{lstlisting}

\section{Выводы}

Простые строительные блоки для страницы это виджет. Идвидуальные куски HTML, CSS, и Javascript могут быть преобразованны в виджет через полиморфную функцию \lstinline'toWidget'. Используя do-нотацию, вы можете комбинировать эти индивидуальные виджеты в большие виджеты, временами содержащие весь контент вашей страницы.

Развертывая эти виджеты обычно выполняются с функцией \lstinline'defaultLayout', которая может быть использованна для применения единого стилистики ко всем вашим страницам.