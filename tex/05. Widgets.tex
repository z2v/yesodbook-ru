Виджеты

Одна из задач в веб разработке — мы должны координировать 3 различные клиентские технологии: HTML, CSS и Javascript. Хуже того, мы должны размещать эти компоненты в различных местах на странице: CSS в style теге в head, Javascript в script теге в head, и HTML в body. И не говоря уже о том, если вы захотите добавить свои CSS и Javascript в отдельные файлы! 

На деле, это работает довольно хорошо когда строим одиночную страницу, потому что мы можем разделить нашу структуру (HTML), стили (CSS) и логику (Javascript). Но когда мы хотим построить части кода модульно, так что можно было легко их компоновать, это может быть головной болью, координировать всеми тремя частями раздельно. Виджеты это решение проблемы от Yesod. Они также помогают с проблемой вкладывания библиотек, таких как jQuery, единожды.

Наши четыре языка шаблонов- Hamlet, Cassius, Lucius and Julius- предоставляют грубые инструменты для конструирования вашего результата. Виджеты обеспечивают клей, который позволяет работать им вместе, без швов.

Краткий обзор

\begin{lstlisting}
getRootR = defaultLayout $ do
    setTitle "Название моей страницы"
    toWidget [lucius| h1 { color: green; } |]
    addScriptRemote "https://ajax.googleapis.com/ajax/libs/jquery/1.6.2/jquery.min.js"
    toWidget [julius|
$(function() {
    $("h1").click(function(){ alert("Вы кликнули на заголовок!"); });
});
|]
    toWidgetHead [hamlet| <meta name=keywords content="некоторый пример ключевых слов">|]
    toWidget [hamlet| <h1>Это один способ вложения контента |]
    [whamlet| <h2>А это другой |]
    toWidgetBody [julius| alert("Это вложено в сам body"); |]

main = warpDebug 3000 W
\end{lstlisting}

Этот код порождает следующий HTML (отступы добавлены):

\begin{lstlisting}[language=HTML]
<!DOCTYPE html> 
<html>
    <head>
        <title>Название моей страницы</title>
        <style>h1 { color : green }</style>
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.6.2/jquery.min.js"></script>
        <script>
$(function() {
    $("h1").click(function(){ alert("Вы кликнули на заголовок!"); });
});
</script>
        <meta name="keywords" content="некоторый пример ключевых слов">
    </head>
    <body>
        <h1>Это один способ вложения контента </h1>
        <h2>А это другой </h2>
        <script> alert("Это вложено в сам body"); </script>
    </body>
</html>
\end{lstlisting}

Что в Виджете?

На самом верхнем уровне, HTML документ это просто группа вложенных тегов. Этот подход выбирают большинство HTML порождающие инструменты: вы просто определяете иерархию тегов и заканчиваете на этом. Но давайте предствим, что я хочу написать компонент страницы для отображения навигационной панели. Я хочу, чтобы она была \textquotedblleft plug and play\textquotedblright: я просто вызываю функцию в нужное время, и она вставляется в нужное место в иерархию.

Тут наша поверхностная HTML генерация разрывается. Наша навигацонная панель вероятно содержит какой-нибудь CSS и Javascript в дополнении к HTML. К тому времени мы вызываем функцию навигационной панели, мы уже отрендерели <head> тег, так что уже поздно добавлять новый <style> тег для наших CSS объявлений. При нормальной стратегии, нам нужно разбить нашу функцию навигационной панели на три части: HTML, CSS и JavaScript, и убедиться что мы всегда вызываем все три части.  

Виджеты берут другой подход. Вместо рассматривания HTML документа как монолитное дерево тегов, виджеты видят номера различных компонентов на странице. В частности:

\begin{itemize}
  \item Название
  \item Внешние стили
  \item Внешний Javascript
  \item CSS объявления
  \item Javascript код
  \item Произвольный <head> контент
  \item Произвольный <body> контент
\end{itemize}

Различные компоненты имеют различное назначение. К примеру, может быть только одно название, но може быть множество внешних скриптов и стилей. Однако, эти внешние скрипты и стили должны быть добавленны только раз. Произвольный head и body контент, с другой стороны, без огрничений (кто-то, возможно, захочет 5 lorem ipsum блоков в конце концов).

Работа виджета это проводить в эти несопостовимые компоненты и применять правильную логику для комбинирования виджетов вместе. Это содержит вещи подобно взять первое название и игнорировать другие, фильтровать дубликаты из списка внешних скриптов и стилей, и конкатенировать head и body контент.

Конструирование Виджетов

Для использования виджетов, вам очевидно понадобиться быть в состоянии протянуть руки к ним. Наиболее распространенный путь будет через ToWidget typeclass, и его \lstinline'toWidget' метод. Это позволит вам конвертировать вашы Shakespearean шаблоны прямо в виджет: код Hamlet появится в body, скрипты Julius в <script> теге в head, и Cassius и Lucius в <style> теге.

Вы можете на самом деле переопределить стандартное поведение и получить скрипт и код стилей в отдельных файлах. Scaffolded сайт предоставляет это автоматически. В дополнениии, мы увидем в главе Yesod typeclass как включить асинхронную загрузку скриптов, которая установит ваши скрипты в конец body.

Но, что если мы захотим добавить некоторые <meta> теги, которые должны появиться в head? Или если мы захотим, чтобы некоторый Javascipt появился в body взамен head? Для этих целей, Yesod предоставляется два дополнительных type класса: ToWidgetHead и ToWidgetBody. Они работают именно так, как они, кажется, они должны. # bug!

В дополнении, есть ряд других функций для создания специфичных типов Виджетов:

\lstinline'setTitle'

Преобразует некоторый HTML в название страницы.

\lstinline'addCassiusMedia, addLuciusMedia'

Работает также как toWidget, но берет дополнительный параметр для обозначения какому типу медиа применяется. Полезно для создания стилей для печати, например.

\lstinline'addStylesheet'

Добавляет ссылки, такие как <link> тег, к внешнему стилю. Берет типобезопасный URL.

\lstinline'addStylesheetRemote'

Такой же как addStylesheet, но берет нормальный URL. полезно для ссылки к файлам, хранящимся на CDN, подобно Google's jQuery UI CSS файлы.

\lstinline'addScript'

Добавляется ссылки, такие как <script> тег, к внешнему скрипту. Берет типобезопасный URL. 

\lstinline'addScriptRemote'

Такой же как addScript, но берет нормальный URL. Полезно для ссылки к файлам, хранящимся на CDN, подобно Google's jQuery.

Комбинирование Виджетов

В целом идея виджетов это повышение компонуемости. Вы можете взять эти индивидуальные части HTML, CSS и Javascript, комбинировать их вместе в нечто более сложное, и затем комбинировать эти большие сущности в полную страницу. Это все работает естественно через экземпляр класса Monad виджетов, значит вы можете использовать do-нотацию для комбинирования частей вместе.

Комбинирование Виджетов

\begin{lstlisting}
myWidget1 = do
    toWidget [hamlet|<h1>My Title|]
    toWidget [lucius|h1 { color: green } |]

myWidget2 = do
    setTitle "My Page Title"
    addScriptRemote "http://www.example.com/script.js"

myWidget = do
    myWidget1
    myWidget2

-- или, если захотите
myWidget' = myWidget1 >> myWidget2
\end{lstlisting}

Еслы вы так склоны, есть также экземпляр класса Monoid Виджет, значит вы можете использовать mconcat или монаду Writer для построения сущностей. В моих экспериментах, самое легкое и самое естественное просто использовать do-нотацию.

Генерирование идентификаторов

Если мы здесь по настоящему хотим переиспользовать код, мы со временем получим конфликт имен. Давайте скажем что есть две вспомогательные библиотеки, обе используют имя класса "foo" чтобы повлиять на стилистику. Мы хотим избежать такой возможности. Вследствие этого, мы имеет newIdent функцию.  Эта функция автоматически генерирует слово, такое что оно уникально для этого обработчика.

Использование newIdent

\begin{lstlisting}
getRootR = defaultLayout $ do
    headerClass <- lift newIdent
    toWidget [hamlet|<h1 .#{headerClass}>My Header|]
    toWidget [lucius| .#{headerClass} { color: green; } |]

main = warpDebug 3000 W
\end{lstlisting}

Вам может быть интересно: что означает \lstinline'lift'? Виджет это трансформер монад, сидящий на верху Обработчика. \lstinline'newIdent' это функция обработчика, так мы нуждаемся "поднять" функцию из слоя обработчика в слой виджета, чтобы использовать её. Мы можем на самом деле использовать этот похожий подход для выполнения сложных действий, подобно запросы базы данных, из в виджет. Мы покроем это когда мы обсудим монады Yesod.

whamlet

Давайте скажем вы получили довольно стандартный шаблон Hamlet, который встрааивает другой шаблон Hamlet для отображения footer:

\begin{lstlisting}
page = [hamlet|
<p>This is my page. I hope you enjoyed it.
^{footer}
|]

footer = [hamlet|
<footer>
    <p>That's all folks!
|]
\end{lstlisting}

Это работает хорошо, если footer это обычный старый HTML, но что если мы хотим добавить некторый стиль? Хорошо, мы можем легко приправить footer, преобразуя его в виджет:

\begin{lstlisting}
footer = do
    toWidget [lucius| footer { font-weight: bold; text-align: center } |]
    toWidget [hamlet|
<footer>
    <p>That's all folks!
|]
\end{lstlisting}

Но сейчас мы получили проблему: шаблон Hamlet может только встраивать другой шаблон Hamlet; он ничего не знает о Виджете. Тут к нам приходит whamlet. Он берет точно синтаксис как обычный Hamlet, и не изменяет. Но встраивание (^{...}) берет Виджет, и финальный результат Виджет. Для его использования, мы можем просто сделать:

\begin{lstlisting}
page = [whamlet|
<p>This is my page. I hope you enjoyed it.
^{footer}
|]
\end{lstlisting}


Есть также \lstinline'whamletFile', если вы предпрочитаете держать шаблоны в отдельном файле.

Временный сайт имеет даже больше удобных функций, widgetFile, которая также встраивает ваши Lucius, Cassius, и Julius файлы автоматически. Мы покрыли это в главе scaffolding.

Типы

Вы может заметили это, я избегаю сигнатуры типов до сих пор. На самом простом уровене, все что вам нужно знать это то есть синонимы типов названные Виджетом, которые выбудете постоянно использовать. Технические подробности позже, но не беспокойтесь, если немножко туманно.

На самом деле нету типа Виджет определенного в библиотеках Yesod, так как точное значение их меняется между сайтами. Взамен, мы имеем более обощенный тип GWidget sub master a. Первые два параметра sub и master дают основные типы, соответсвенно. Последний параметр это контейнерное значение, просто как любая Монада имеет.

Так в чем дело с этими sub/master штуковинами? Хорошо, когда вы пишете некоторый переиспользуемый код, такой как CRUD приложение, вы можете писать это как подсайт, который может быть встроен в любое другое приложение Yesod. В данном случае, мы нуждаемся в отслеживании информации для обоих, sub и master сайтов. Самый простой пример для типов -типобезопасные URL: Yesod нуждается в знании как взять путь для CRUD подсайта и повернуть его в путь для master сайта, так что он мог бы правильно отображен.

Однако, те sub/master различия только больше значат, когда вы взаимодействуете с подсайтами. Когда вы пишете ваш стандартный ответный код, вы обращаетесь с только вашим приложением, и так sub и master сайты будут похожими. Поскольку это самый общий случай, временный сайт объявляет тип синоним, чтобы помочь вам. Давайте скажем ваш основной тип это MyCoolApp, он будет определен define type Widget = GWidget MyCoolApp MyCoolApp (). В следствии этого, мы можем получить некоторуй очень дружелюбнуй к пользователю сигнатуру типа на наших виджатах:

\begin{lstlisting}
footer :: Widget
footer = do
    toWidget [lucius| footer { font-weight: bold; text-align: center } |]
    toWidget [hamlet|
<footer>
    <p>That's all folks!
|]

page :: Widget
page = [whamlet|
<p>This is my page. I hope you enjoyed it.
^{footer}
|]
\end{lstlisting}

Если вы обратили пристальное внимание, вы может быть были сбитыми с толку. Мы использовали lift на Виджете в примере Генерировании идентификаторов выше, но GWidget на самом деле не трансформер монад. Что здесь происходит? Что ж, в ранних версиях Yesod, он был трансформером вокруг типа Обработчика. К несчастью, это привело к сложностям с обработкой сообщений об ошибках. Как результат, GWidget это сейчас обертка newtype, которая прячет свою сущность монады трансформера. Но мы продолжаем хотеть быть в состоянии поднять функции из внутреннего Обработчика монады.

Чтобы решить это, Yesod предоставляет альтернативу, более общую lift функцию, которая работает для обоих стандартных экземпляров класса MonadTrans, и специальной обертки newtype подобной GWidget. Как результат, вы можете делать вид как будто GWidget это стандартный трансформер, в то же время получая ваше приятное сообщение об ошибке.

Последняя точка: только как мы имеем разрыв между Widget и GWidget, мы имеем похожий разрыв между Handler и GHandler.

Использование Виджетов

Это все хорошо и приятно, что мы имеем эти красивые типы Виджета, но как именно нам превратить их в что-то, с чем пользователь мог взаимодействовать? Самая общая использованная функция это defaultLayout, которая по существу имеет сигнатуру типа Widget -> Handler RepHtml. (Я говорю "по существу" потому что это целая проблема GHandler.) RepHtml это тип данных содержащий некоторый необработанный HTML вывод, готовый к отправке по проводам.

defaultLayout в действительности метод класса типов, который может быть переопределен для каждого приложения. Так приложения Yesod рождаются. Поэтому мы остаемся с вопросом: когда мы внутри defaultLayout, как нам развернуть Виджет? Ответ это widgetToPageContent. Давайте посмотрим на некоторые (упрощенные) типы: 

\begin{lstlisting}
widgetToPageContent :: Widget -> Handler (PageContent url)
data PageContent url = PageContent
    { pageTitle :: Html
    , pageHead :: HtmlUrl url
    , pageBody :: HtmlUrl url
    }
\end{lstlisting} 

Это ближе к тому, что на нужно. Мы сейчас имеем прямой доступ к HTML, создавая head и body, так же хорошо как title. В этот момент, мы можем использовать Hamlet для комбинирования их всех вместе в одиночный документ, наряду с нашим макетом сайта, и мы используем hamletToRepHtml для отображения результата Hamlet в настоящий HTML готовый к показу пользователю. Следующая илюстрация демонстрирует этот процесс.

Использование widgetToPageContent

\begin{lstlisting}
myLayout :: GWidget s MyApp () -> GHandler s MyApp RepHtml
myLayout widget = do
    pc <- widgetToPageContent widget
    hamletToRepHtml [hamlet|
$doctype 5
<html>
    <head>
        <title>#{pageTitle pc}
        <meta charset=utf-8>
        <style>body { font-family: verdana }
        ^{pageHead pc}
    <body>
        <article>
            ^{pageBody pc}
|]

instance Yesod MyApp where
    defaultLayout = myLayout

main = warpDebug 3000 MyApp
\end{lstlisting}

Вы могли заметить, что мы использовали GWidget и GHandler взамен Widget и Handler. Это потому что defaultLayout метод, который может быть вызван подсайтами для удостоверения, что они получат такие же стили, как master сайт. Отсюда, мы нуждаемся поддержании гибкости наших типов здесь.

Это все хорошо и приятно, но есть одна вещь, которая беспокоит меня: style тег. Есть несколько проблем с ним:

* В отличие от Lucius или Cassius, он не проверяется на корректность во время компиляции.
* Разумеющимся, что текущий пример очень простой, но в чем-то более сложном мы получим проблему экранирования символов.
* Мы теперь имеем 2 style тега взамен одного: один из myLayout, и один генерируется в pageHead основанный на стилях установленных в виджете.

У нас есть еще один трюк в нашем мешке для решения этого: мы применим некоторую последнюю корректеровку к виджету самому до вызова widgetToPageContent. На самом деле это очень легко зделать: нам только надо использовать do-нотацию снова, как в Последняя корректировка виджета.

Последняя корректировка виджета

\begin{lstlisting}
myLayout :: GWidget s MyApp () -> GHandler s MyApp RepHtml
myLayout widget = do
    pc <- widgetToPageContent $ do
        widget
        toWidget [lucius| body { font-family: verdana } |]
    hamletToRepHtml [hamlet|
$doctype 5
<html>
    <head>
        <title>#{pageTitle pc}
        <meta charset=utf-8>
        ^{pageHead pc}
    <body>
        <article>
            ^{pageBody pc}
|]

instance Yesod MyApp where
    defaultLayout = myLayout

main = warpDebug 3000 MyApp
\end{lstlisting}

Вывод

Простые строительные блоки для страницы это виджет. Идвидуальные куски HTML, CSS, и Javascript могут быть преобразованны в виджет через полиморфную функцию toWidget. Используя do-нотацию, вы можете комбинировать эти индивидуальные виджеты в большие виджеты, временами содержащие весь контент вашей страницы.

Развертывая эти виджеты обычно выполняются с функцией defaultLayout, которая может быть использованна для применения единого look-and-feel ко всем вашим страницам.