\chapter{Виджеты}\label{chap:widgets}
Одна из проблем в веб-разработке~--- нам приходится координировать три
различные клиентские технологии: HTML, CSS и Javascript. Хуже того, мы должны
размещать эти компоненты в различных местах на странице: CSS в теге style в
заголовке, Javascript в теге script в заголовке, a HTML в теле. И это не говоря
уже о случае, когда вы хотите разместить свои CSS и Javascript в отдельных
файлах!

На деле, это работает довольно хорошо при создании одиночной страницы, потому
что мы можем разделить нашу структуру (HTML), стили (CSS) и логику
(Javascript). Но когда мы хотим строить код из модулей, которые можно будет
легко компоновать, раздельная координация всех трёх частей может стать головной
болью. Виджеты~--- решение Yesod для этой задачи. Они также помогают с
проблемой однократного подключения библиотек наподобие jQuery.

Наши четыре языка шаблонов~--- Hamlet, Cassius, Lucius и Julius~---
предоставляют исходные инструменты для конструирования вашего вывода. Виджеты
обеспечивают клей, который позволяет работать им вместе как единое целое.

\section{Краткий обзор}
\includecode{05/synopsis.hs}
Этот код порождает следующий HTML (отступы добавлены):
\begin{lstlisting}[language=HTML]
<!DOCTYPE html>
<html>
    <head>
        <title>My Page Title</title>
        <meta name="keywords" content="некоторые ключевые слова примера">
        <style>h1{color:green}</style>
    </head>
    <body>
        <h1> Это один способ вставки контента</h1>
        <h2>А это другой </h2>
        <script>
            alert("Это вставляется в само тело");
        </script>
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.6.2/jquery.min.js"></script>
        <script>
            $(function() {
                $("h1").click(function(){
                    alert("Вы кликнули на заголовок!");
                });
            });
        </script>
    </body>
</html>
\end{lstlisting}

\section{Что в Виджете?}
На самом поверхностном уровне, HTML документ~--- это просто набор вложенных
тегов. Такой подход выбирают большинство генерирующих HTML инструментов: вы
определяете иерархию тегов и всё. Но давайте представим, что я хочу
написать компонент страницы для отображения навигационной панели. Я хочу, чтобы
он был <<plug and play>>: я вызываю функцию в нужное время, и панель
вставляется в соответствующее место в иерархии.

Тут наш поверхностный подход к генерации HTML даёт сбой. Наша навигационная
панель вероятно содержит какой-нибудь CSS и Javascript в дополнение к HTML. К
тому времени, когда мы вызываем функцию навигационной панели, мы уже
сформировали тег <head>, так что уже поздно добавлять новый тег <style> для
наших CSS объявлений. В рамках обычных стратегий, нам нужно было бы разбить
нашу функцию навигационной панели на три части: HTML, CSS и JavaScript, и
убедиться, что мы всегда вызываем все три части.

Виджеты используют другой подход. Вместо рассмотрения HTML документа как
монолитного дерева тегов, виджеты видят на странице набор различных
компонентов. В частности:
\begin{itemize}
    \item Название страницы
    \item Внешние стили
    \item Внешний Javascript
    \item Объявления CSS
    \item Код Javascript
    \item Произвольный контент в <head>
    \item Произвольный контент в <body>
\end{itemize}

Различные компоненты имеют различный смысл. К примеру, может быть только одно
название, но может быть множество внешних скриптов и стилей. Однако, эти
внешние скрипты и стили должны быть добавлены только раз. Произвольный контент
в заголовке и теле, с другой стороны, не имеет ограничений (кто-то, возможно,
захочет пять блоков lorem ipsum, в конце концов).

Работа виджета~--- держаться за эти несопоставимые компоненты и применять
правильную логику для комбинирования виджетов вместе. Логика эта включает такие
действия, как фиксация последнего установленного названия и игнорирование
остальных, фильтрация дубликатов из списка внешних скриптов и стилей,
объединение содержимого заголовка и тела.

\section{Конструирование Виджетов}
Для использования виджетов, вам, очевидно, необходима возможность их создания.
Наиболее распространённый способ сделать это~--- через класс типов
\lstinline'ToWidget' и его метод \lstinline'toWidget'. Метод предоставляет вам
возможность конвертировать ваши Shakespearean шаблоны прямо в
\lstinline'Widget': код Hamlet появится в теле, скрипты Julius~--- в теге
<script>, а Cassius и Lucius~--- в теге <style>.

\begin{remark}
    На самом деле, вы можете переопределить стандартное поведение и получить
    скрипт и код стилей в отдельных файлах. Каркас сайта делает это для вас
    автоматически.
\end{remark}

Но что, если вы захотите добавить какие-нибудь теги <meta>, которые должны
появиться в заголовке? Или если вы захотите, чтобы некоторый Javascipt появился
в теле, а не в заголовке? Для этих целей, Yesod предоставляет два
дополнительных класса типов: \lstinline'ToWidgetHead' и
\lstinline'ToWidgetBody'. Они работают именно так, как вы от них ожидаете.

Кроме того, есть ряд других функций для создания специфических видов виджетов:
\begin{description}
    \item[setTitle] \hfill \\
        Преобразует некоторый HTML в название страницы.

    \item[toWidgetMedia] \hfill \\
        Работает также как \lstinline'toWidget', но принимает дополнительный
        параметр для обозначения, к какому типу медиа контента применяется.
        Полезно для создания стилей печати, например.

    \item[addStylesheet] \hfill \\
        Добавляет ссылку, используя тег <link>, на внешнюю таблицу стилей.
        Принимает типобезопасный URL.

    \item[addStylesheetRemote] \hfill \\
        Аналогична \lstinline'addStylesheet', но принимает обычный URL. Полезна
        для ссылок на файлы, хранящиеся на CDN, подобно таблицам стилей CSS для
        jQuery UI, предоставляемым Google.

    \item[addScript] \hfill \\
        Добавляет ссылку, используя тег <script>, на внешний скрипт. Принимает
        типобезопасный URL.

    \item[addScriptRemote] \hfill \\
        Аналогична \lstinline'addScript', но принимает обычный URL. Полезна для
        ссылок на файлы, хранящиеся на CDN, подобно jQuery от Google.
\end{description}

\section{Комбинирование Виджетов}
Вся идея виджетов~--- это повышение компонуемости. Вы можете взять отдельные
части HTML, CSS и Javascript, скомбинировать их вместе в нечто более сложное, и
затем скомпоновать эти большие сущности в законченную страницу. Это всё
работает, естественно, через экземпляр класса \lstinline'Monad' для
\lstinline'Widget', и значит вы можете использовать do-нотацию для
комбинирования частей вместе.
\begin{lstlisting}
myWidget1 = do
    toWidget [hamlet|<h1>My Title|]
    toWidget [lucius|h1 { color: green } |]

myWidget2 = do
    setTitle "My Page Title"
    addScriptRemote "http://www.example.com/script.js"

myWidget = do
    myWidget1
    myWidget2

-- или, если захотите
myWidget' = myWidget1 >> myWidget2
\end{lstlisting}

\begin{remark}
    Если для вас это принципиально, для \lstinline'Widget' есть также экземпляр
    класса \lstinline'Monoid', поэтому вы можете использовать
    \lstinline'mconcat' или монаду \lstinline'Writer' для построения сущностей.
    По моему опыту, самое лёгкое и самое естественное просто использовать
    do-нотацию.
\end{remark}

\section{Генерирование идентификаторов}
Если мы на самом деле выбираем настоящее повторное использование кода, мы со
временем получим конфликт имён. Скажем, есть две вспомогательные библиотеки, и
обе используют класс с именем <<\lstinline'foo'>> для изменения стилевого
оформления. Мы хотим избежать такой возможности. И для этого у нас есть функция
\lstinline'newIdent'. Эта функция автоматически генерирует слово, которое
уникально для текущего обработчика.
\begin{lstlisting}
getRootR = defaultLayout $ do
    headerClass <- newIdent
    toWidget [hamlet|<h1 .#{headerClass}>My Header|]
    toWidget [lucius| .#{headerClass} { color: green; } |]
\end{lstlisting}

\section{whamlet}
Предположим, у вас есть довольно стандартный шаблон Hamlet, который встраивает
другой шаблон Hamlet для отображения подвала страницы (footer):
\begin{lstlisting}
page =
    [hamlet|
        <p>Это моя страница. Надеюсь, она вам нравится.
        ^{footer}
    |]

footer =
    [hamlet|
        <footer>
        <p>Это всё, люди!
    |]
\end{lstlisting}

Это работает хорошо, если в \lstinline'footer' обычный старый HTML, но что если
мы хотим добавить какое-нибудь стилевое оформление? Хорошо, мы можем легко
приправить \lstinline'footer', преобразовав его в виджет:
\begin{lstlisting}
footer = do
    toWidget
        [lucius|
            footer {
                font-weight: bold;
                text-align: center
            }
        |]
    toWidget
        [hamlet|
            <footer>
                <p>Это всё, люди!
        |]
\end{lstlisting}

Но теперь у нас проблема: шаблон Hamlet может встраивать только другой шаблон
Hamlet; он ничего не знает о \lstinline'Widget'. И вот тут на сцену выходит
\lstinline'whamlet'. Он принимает точно такой же синтаксис, как обычный Hamlet,
и не меняет интерполяцию переменных (\lstinline'#{...}')  и URL
(\lstinline'@{...}'). Но встраивание (\lstinline'^{...}') принимает
\lstinline'Widget', и финальный результат тоже \lstinline'Widget'. Для его
использования, мы можем просто сделать так:
\begin{lstlisting}
page =
    [whamlet|
        <p>Это моя страница. Надеюсь, она вам нравится.
        ^{footer}
    |]
\end{lstlisting}

Есть также \lstinline'whamletFile', если вы предпочитаете держать ваш шаблон в
отдельном файле.

\begin{remark}
    В каркасе сайте есть ещё более удобная функция, \lstinline'widgetFile',
    которая также автоматически включает ваши Lucius, Cassius и Julius файлы.
    Мы рассмотрим это в главе~\nameref{chap:scaffolding}.
\end{remark}

\subsection{Типы}
Возможно, вы уже заметили, что я избегал сигнатуры типов до сих пор. Простой
ответ: каждый виджет~--- это значение типа~\lstinline'Widget'. Но если вы
пробежитесь по библиотекам Yesod, вы не найдёте определение
типа~\lstinline'Widget'. Откуда же он берётся?

Yesod определяет очень похожий тип: \lstinline'data WidgetT site m a'. Этот тип
данных~--- \textbf{трансформатор монад}. Последние два аргумента~--- это
базовая монада и монадическое значение, соответственно. Аргумент
\lstinline'site'~--- это конкретный тип-основания вашего конкретного
приложения. Так как этот тип отличается для каждого сайта, невозможно в
библиотеках определить единственный тип данных~\lstinline'Widget', который будет
работать для всех приложений.

Вместо этого, функция Template Haskell \lstinline'mkYesod' создаёт такой
синоним типа для вас. Предполагая, что ваш тип-основание называется
\lstinline'MyApp', ваш синоним типа~\lstinline'Widget', определяется следующим
образом:
\begin{lstlisting}
type Widget = WidgetT MyApp IO ()
\end{lstlisting}

Мы устанавливаем монадическое значение равным \lstinline'()', так как значение
виджета будет безусловно отброшено. \lstinline'IO'~--- это стандартная базовая
монада, и будет использоваться в большинстве случаев. Единственное
исключение~--- создание \textbf{подсайта}. Подсайты~--- более продвинутая тема,
которая будет рассмотрена ниже в отдельной главе..

Раз теперь мы знаем о синониме типа~\lstinline'Widget', легко добавить
сигнатуры типа к нашему предыдущем примерам:
\begin{lstlisting}
footer :: Widget
footer = do
    toWidget
        [lucius|
            footer {
                font-weight: bold;
                text-align: center
            }
        |]
    toWidget
        [hamlet|
            <footer>
                <p>Это всё, люди!
        |]

page :: Widget
page =
    [whamlet|
        <p>Это моя страница. Надеюсь, она вам нравится.
        ^{footer}
    |]
\end{lstlisting}

Когда мы глубже копнём функции-обработчики, мы обнаружим аналогичную
ситуацию с типами~\lstinline'HanderT' и~\lstinline'Handler'.

\section{Использование виджетов}
Это, конечно, замечательно, что у нас есть эти красивые типы данных для виджетов,
но как именно нам превратить их во что-то, с чем пользователь может
взаимодействовать? Самая часто используемая функция~--- это
\lstinline'defaultLayout', которая по существу имеет сигнатуру типа
\lstinline'Widget -> Handler Html'.

На самом деле, \lstinline'defaultLayout'~--- метод класса типов, который может
быть переопределён для каждого приложения. Так для приложений Yesod задаются
темы\footnote{Имеются в виду темы для визуального оформления.~--- \emph{Прим.
перев.}}. Но мы всё ещё остаёмся с вопросом: когда мы внутри
\lstinline'defaultLayout', как нам развернуть \lstinline'Widget'? Ответ~---
\lstinline'widgetToPageContent'. Давайте посмотрим на некоторые (упрощённые)
типы:
\begin{lstlisting}
widgetToPageContent :: Widget -> Handler (PageContent url)
data PageContent url = PageContent
    { pageTitle :: Html
    , pageHead :: HtmlUrl url
    , pageBody :: HtmlUrl url
    }
\end{lstlisting}

Это уже ближе к тому, что нам нужно. Теперь у нас есть прямой доступ к HTML,
формирующему заголовок и тело страницы, а так же к заголовку. В этот момент, мы
можем использовать Hamlet для комбинирования их всех вместе в единый документ,
наряду с нашим макетом сайта, и мы используем \lstinline'giveUrlRenderer' для
преобразования Hamlet в настоящий HTML, готовый к показу пользователю.
Следующий листинг демонстрирует этот процесс.
\includecode{05/example.hs}

Это всё очень хорошо, но есть один момент, который беспокоит меня: тег style.
Есть несколько проблем с ним:
\begin{itemize}
    \item В отличие от Lucius или Cassius, он не проверяется на корректность во
        время компиляции.

    \item Конечно, рассматриваемый пример очень простой, но в чём-то более
        сложном мы можем получить проблемы с экранированием символов.

    \item У нас теперь 2 тега style взамен одного: один из
        \lstinline'myLayout', а другой генерируется \lstinline'pageHead',
        основанный на стилях, установленных в виджете.
\end{itemize}

Для решения этой проблемы у нас есть ещё один трюк в запасе: мы в последний
момент перед вызовом \lstinline'widgetToPageContent' скорректируем сам виджет.
На самом деле, это очень легко сделать: мы просто опять используем do-нотацию.
\includecode{05/style.hs}

\section{Использование функций-обработчиков}
Мы пока ещё особо не рассматривали функциональность обработчиков, но когда
начнём, возникнет вопрос: как мы можем использовать эти функции в виджете?
Например, что, если в виджете требуется найти параметр строки запроса,
используя функцию~\lstinline'lookupGetParam'?

Первый ответ~--- функция~\lstinline'handlerToWidget', которая преобразует
действие \lstinline'Handler' в значение \lstinline'Widget'. Однако, во многих
случаях, этого не требуется. Посмотрим на сигнатуру типа
функции~\lstinline'lookupGetParam':
\begin{lstlisting}
lookupGetParam :: MonadHandler m => Text -> m (Maybe Text)
\end{lstlisting}

Эта функция сработает в \textbf{любом} экземпляре \lstinline'MonadHandler'. И
для удобства, \lstinline'Widget' предоставляет экземпляр для
\lstinline'MonadHandler'. Это означает, что большая часть кода может быть
выполнена как в \lstinline'Handler', так и в~\lstinline'Widget'. А если вам
требуется явное преобразование из \lstinline'Handler' в \lstinline'Widget', вы
всегда можете использовать функцию~\lstinline'handlerToWidget'.

\begin{remark}
    Это заметное отличие от версии Yesod 1.1 и более ранних. Ранее не было
    класса типов~\lstinline'MonadHandler', и все функции требовалось явно
    преобразовывать, используя фукнцию~\lstinline'lift', а не
    \lstinline'handlerToWidget'. Новую реализацию не только проще использовать,
    но она также не требует разных странных фокусов с трансформаторами монад,
    использованных в предыдущих версиях.
\end{remark}

\section{Выводы}
Базовый строительный блок каждой страницы~---это виджет. Отдельные фрагменты
HTML, CSS, и Javascript могут быть преобразованы в виджет с помощью полиморфной
функции \lstinline'toWidget'. Используя do-нотацию, вы можете комбинировать эти
отдельные виджеты в виджеты большего размера, в конечном счёте содержащие всё
наполнение вашей страницы.

Разворачивание полученных виджетов обычно выполняется функцией
\lstinline'defaultLayout', которая может быть использована для применения
единого стиля оформления для всех ваших страниц.
