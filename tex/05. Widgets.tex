\chapter{Виджеты}

Одна из проблем в веб разработке~--- нам приходится координировать три различные клиентские технологии: HTML, CSS и Javascript. Хуже того, мы должны размещать эти компоненты в различных местах на странице: CSS в теге style в заголовке, Javascript в теге script в заголовке, a HTML в теле. И это не говоря уже о случае, когда вы хотите разместить свои CSS и Javascript в отдельных файлах!

На деле, это работает довольно хорошо при создании одиночной страницы, потому что мы можем разделить нашу структуру (HTML), стили (CSS) и логику (Javascript). Но когда мы хотим строить код из модулей, которые можно будет легко компоновать, раздельная координация всех трёх частей может стать головной болью. Виджеты~--- решение Yesod для этой задачи. Они также помогают с проблемой однократного подключения библиотек наподобие jQuery.

Наши четыре языка шаблонов~--- Hamlet, Cassius, Lucius и Julius~--- предоставляют исходные инструменты для конструирования вашего вывода. Виджеты обеспечивают клей, который позволяет работать им вместе как единое целое.

\section{Краткий обзор}

\begin{lstlisting}
getRootR = defaultLayout $ do
    setTitle "Название моей страницы"
    toWidget [lucius| h1 { color: green; } |]
    addScriptRemote "https://ajax.googleapis.com/ajax/libs/jquery/1.6.2/jquery.min.js"
    toWidget [julius|
$(function() {
    $("h1").click(function(){ alert("Вы кликнули на заголовок!"); });
});
|]
    toWidgetHead [hamlet| <meta name=keywords content="некоторые ключевые слова примера">|]
    toWidget [hamlet| <h1> Это один способ вставки контента |]
    [whamlet| <h2> А это другой |]
    toWidgetBody [julius| alert("Это вставлено в само тело"); |]

main = warpDebug 3000 W
\end{lstlisting}

Этот код порождает следующий HTML (отступы добавлены):

\begin{lstlisting}[language=HTML]
<!DOCTYPE html>
<html>
    <head>
        <title>Название моей страницы</title>
        <style>h1 { color : green }</style>
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.6.2/jquery.min.js"></script>
        <script>
$(function() {
    $("h1").click(function(){ alert("Вы кликнули на заголовок!"); });
});
</script>
        <meta name="keywords" content="некоторые ключевые слова примера">
    </head>
    <body>
        <h1> Это один способ вставки контента </h1>
        <h2> А это другой </h2>
        <script> alert("Это вставлено в само тело"); </script>
    </body>
</html>
\end{lstlisting}

\section{Что в Виджете?}
На самом поверхностном уровне, HTML документ~--- это просто набор вложенных тегов. Такой подход выбирают большинство генерирующих HTML инструментов: вы просто определяете иерархию тегов и всё. Но давайте представим, что я хочу написать компонент страницы для отображения навигационной панели. Я хочу, чтобы он был <<plug and play>>: я просто вызываю функцию в нужное время, и панель вставляется в соответствующее место в иерархии.

Тут наш поверхностный подход к генерации HTML даёт сбой. Наша навигационная панель вероятно содержит какой-нибудь CSS и Javascript в дополнение к HTML. К тому времени, когда мы вызываем функцию навигационной панели, мы уже сформировали тег <head>, так что уже поздно добавлять новый тег <style> для наших CSS объявлений. В рамках обычных стратегий, нам нужно было бы разбить нашу функцию навигационной панели на три части: HTML, CSS и JavaScript, и убедиться, что мы всегда вызываем все три части.

Виджеты используют другой подход. Вместо рассмотрения HTML документа как монолитного дерева тегов, виджеты видят на странице набор различных компонентов. В частности:
\begin{itemize}
  \item Название страницы
  \item Внешние стили
  \item Внешний Javascript
  \item Объявления CSS
  \item Код Javascript
  \item Произвольный контент в <head>
  \item Произвольный контент в <body>
\end{itemize}

Различные компоненты имеют различный смысл. К примеру, может быть только одно название, но может быть множество внешних скриптов и стилей. Однако, эти внешние скрипты и стили должны быть добавлены только раз. Произвольный контент в заголовке и теле, с другой стороны, не имеет ограничений (кто-то, возможно, захочет пять блоков lorem ipsum, в конце концов).

Работа виджета~--- держаться за эти несопоставимые компоненты и применять правильную логику для комбинирования виджетов вместе. Логика эта включает такие действия, как фиксация первого установленного названия и игнорирование остальных, фильтрация дубликатов из списка внешних скриптов и стилей, объединение содержимого заголовка и тела.

\section{Конструирование Виджетов}
Для использования виджетов, вам, очевидно, необходима возможность их создания. Наиболее распространённый способ сделать это~--- через класс типов \lstinline'ToWidget' и его метод \lstinline'toWidget'. Метод предоставляет вам возможность конвертировать ваши Shakespearean шаблоны прямо в \lstinline'Widget': код Hamlet появится в теле, скрипты Julius~--- в теге <script> в заголовке, а Cassius и Lucius~--- в теге <style> заголовка.
\begin{remark}
На самом деле, вы можете переопределить стандартное поведение и получить скрипт и код стилей в отдельных файлах. Сгенерированный начальный каркас сайта делает это для вас автоматически. Кроме того, в главе <<\nameref{ch:yesod-typeclass}>> мы увидим, как включить асинхронную загрузку скриптов, которая поместит содержимое ваших скриптов в конец тела страницы.
\end{remark}

Но что, если вы захотите добавить какие-нибудь теги <meta>, которые должны появиться в заголовке? Или если вы захотите, чтобы некоторый Javascipt появился в теле, а не в заголовке? Для этих целей, Yesod предоставляет два дополнительных класса типов: \lstinline'ToWidgetHead' и \lstinline'ToWidgetBody'. Они работают именно так, как вы от них ожидаете.

Кроме того, есть ряд других функций для создания специфических видов Виджетов:
\begin{description}
\item[setTitle] \hfill \\
Преобразует некоторый HTML в название страницы.
\item[addCassiusMedia, addLuciusMedia] \hfill \\
Работают также как \lstinline'toWidget', но принимают дополнительный параметр для обозначения, к какому типу медиа контента применяется. Полезно для создания стилей печати, например.
\item[addStylesheet] \hfill \\
Добавляет ссылку, используя тег <link>, на внешнюю таблицу стилей. Принимает типобезопасный URL.
\item[addStylesheetRemote] \hfill \\
Аналогична \lstinline'addStylesheet', но принимает обычный URL. Полезна для ссылок на файлы, хранящиеся на CDN, подобно таблицам стилей CSS для jQuery UI, предоставляемым Google.
\item[addScript] \hfill \\
Добавляет ссылку, используя тег <script>, на внешний скрипт. Принимает типобезопасный URL.
\item[addScriptRemote] \hfill \\
Аналогична \lstinline'addScript', но принимает обычный URL. Полезна для ссылок на файлы, хранящиеся на CDN, подобно jQuery от Google .
\end{description}

\section{Комбинирование Виджетов}
Вся идея виджетов~--- это повышение компонуемости. Вы можете взять отдельные части HTML, CSS и Javascript, скомбинировать их вместе в нечто более сложное, и затем скомпоновать эти большие сущности в законченную страницу. Это всё работает, естественно, через экземпляр класса \lstinline'Monad' для \lstinline'Widget', и значит вы можете использовать do-нотацию для комбинирования частей вместе.
\begin{lstlisting}[caption={Комбинирование Виджетов}]
myWidget1 = do
    toWidget [hamlet|<h1>My Title|]
    toWidget [lucius|h1 { color: green } |]

myWidget2 = do
    setTitle "My Page Title"
    addScriptRemote "http://www.example.com/script.js"

myWidget = do
    myWidget1
    myWidget2

-- или, если захотите
myWidget' = myWidget1 >> myWidget2
\end{lstlisting}
\begin{remark}
Если для вас это принципиально, для \lstinline'Widget' есть также экземпляр класса \lstinline'Monoid', поэтому вы можете использовать \lstinline'mconcat' или монаду \lstinline'Writer' для построения сущностей. По моему опыту, самое лёгкое и самое естественное просто использовать do-нотацию.
\end{remark}

\section{Генерирование идентификаторов}
Если мы на самом деле выбираем настоящее повторное использование кода, мы со временем получим конфликт имён. Скажем, есть две вспомогательные библиотеки, и обе используют класс с именем <<\lstinline'foo'>> для изменения стилевого оформления. Мы хотим избежать такой возможности. И для этого у нас есть функция \lstinline'newIdent'. Эта функция автоматически генерирует слово, которое уникально для текущего обработчика.

\begin{lstlisting}[caption={Использование \lstinline'newIdent'}]
getRootR = defaultLayout $ do
    headerClass <- lift newIdent
    toWidget [hamlet|<h1 .#{headerClass}>My Header|]
    toWidget [lucius| .#{headerClass} { color: green; } |]

main = warpDebug 3000 W
\end{lstlisting}

\begin{remark}
Вам, наверное, интересно: что означает \lstinline'lift'? \lstinline'Widget'~--- это трансформатор монад, базирующийся на \lstinline'Handler'. \lstinline'newIdent'~--- это функция \lstinline'Handler', поэтому нам необходимо <<втянуть>> (lift) её с уровня \lstinline'Handler' на уровень \lstinline'Widget', чтобы использовать. На самом деле, мы можем использовать точно такой же подход для выполнения сложных действий, наподобие запросов к базе данных, из виджета. Мы подробно рассмотрим этот вопрос при обсуждении монад в Yesod в главе~\ref{ch:yesod_monads}.
\end{remark}

\section{whamlet}

Предположим, у вас есть довольно стандартный шаблон Hamlet, который встраивает другой шаблон Hamlet для отображения подвала страницы (footer):

\begin{lstlisting}
page = [hamlet|
<p>Это моя страница. Я надеюсь, вы наслаждаетесь ею.
^{footer}
|]

footer = [hamlet|
<footer>
    <p>Это всё, люди!
|]
\end{lstlisting}

Это работает хорошо, если в \lstinline'footer' обычный старый HTML, но что если мы хотим добавить какое-нибудь стилевое оформление? Хорошо, мы можем легко приправить \lstinline'footer', преобразовав его в виджет:

\begin{lstlisting}
footer = do
    toWidget [lucius| footer { font-weight: bold; text-align: center } |]
    toWidget [hamlet|
<footer>
    <p>Это все, люди!
|]
\end{lstlisting}

Но теперь у нас проблема: шаблон Hamlet может встраивать только другой шаблон Hamlet; он ничего не знает о \lstinline'Widget'. И вот тут на сцену выходит \lstinline'whamlet'. Он принимает точно такой же синтаксис, как обычный Hamlet, и не меняет интерполяцию переменных (\lstinline'#{...}')  и URL (\lstinline'@{...}'). Но встраивание (\lstinline'^{...}') принимает \lstinline'Widget', и финальный результат тоже \lstinline'Widget'. Для его использования, мы можем просто сделать так:

\begin{lstlisting}
page = [whamlet|
<p>Это моя страница. Я надеюсь вы наслаждаетесь ею.
^{footer}
|]
\end{lstlisting}


Есть также \lstinline'whamletFile', если вы предпочитаете держать ваш шаблон в отдельном файле.

\begin{remark}
В каркасном сайте есть ещё более удобная функция, \lstinline'widgetFile', которая также автоматически включает ваши Lucius, Cassius и Julius файлы. Мы рассмотрим это в главе~\nameref{ch:scaffolding}.
\end{remark}

\subsection{Типы}

Возможно, вы уже заметили, что я избегал сигнатуры типов до сих пор. Это потому, что в них заключена некоторая сложность. На самом простом уровне, всё, что вам нужно знать,~--- это что есть синоним типов с именем \lstinline'Widget', который вы почти всегда и будете использовать. Дальше идут технические подробности, но не беспокойтесь, если они окажутся немного туманными.

На самом деле, нет типа \lstinline'Widget', определённого в библиотеках Yesod, так как его точный смысл меняется от сайта к сайту. Взамен, у нас есть более общий тип \lstinline'GWidget sub master a'. Первые два параметра~--- это основные типы подсайта и главного сайта, соответственно. Последний параметр~--- это контейнерное значение, как в любом экземпляре~\lstinline'Monad'.

Так в чём дело с этими sub/master штуковинами? Когда вы пишете некий повторно используемый код, такой как CRUD приложение, вы можете сделать его как подсайт, который может быть встроен в любое другое приложение Yesod. В таком случае, нам нужно отслеживать информацию для обоих сайтов: подсайта и основного. Самый простой пример~--- типобезопасные URL: Yesod должен знать, как получить путь для CRUD подсайта и преобразовать его в путь для основного сайта, чтобы корректно его отобразить.

Однако, эти различия подсайт/основной сайт имеют значение только тогда, когда вы имеете дело с подсайтами. Когда же вы пишете код вашего стандартного ответа, вы работаете только со своим приложением, и в этом случае подсайт и основной сайт~--- это одно и то же. Поскольку это самый распространённый случай, каркасный сайт объявляет синоним типа, чтобы помочь вам. Скажем, ваш основной тип это \lstinline'MyCoolApp', тогда будет определён \lstinline'type Widget = GWidget MyCoolApp MyCoolApp ()'. И как следствие, мы можем получить очень даже дружелюбные к пользователю сигнатуры типа для наших виджетов:

\begin{lstlisting}
footer :: Widget
footer = do
    toWidget [lucius| footer { font-weight: bold; text-align: center } |]
    toWidget [hamlet|
<footer>
    <p>Это все, люди!
|]

page :: Widget
page = [whamlet|
<p>Это моя страница. Я надеюсь, вы наслаждаетесь ею.
^{footer}
|]
\end{lstlisting}

Если вы пристально следили за изложением, вы, должно быть, сбиты с толку. Выше, в примере с генерированием идентификаторов, мы использовали \lstinline'lift' для \lstinline'Widget', но \lstinline'GWidget' на самом деле не является трансформатором монад. Что же здесь происходит? Что ж, в ранних версиях Yesod, он и был трансформатором вокруг типа~\lstinline'Handler'. К несчастью, это привело к сложным для анализа сообщениям об ошибках. Как результат, \lstinline'GWidget' теперь обёртка \lstinline'newtype', которая прячет свою сущность трансформатора монад. Но мы по-прежнему хотим иметь возможность втягивать (lift) функции из внутренней монады~\lstinline'Handler'.

В качестве решения Yesod предоставляет альтернативную, более общую функцию \lstinline'lift', которая работает для обоих стандартных экземпляров класса~\lstinline'MonadTrans', и специальные обёртки \lstinline'newtype' наподобие \lstinline'GWidget'.  В результате, вы можете считать, что \lstinline'GWidget'~--- это стандартный трансформатор, в то же время сохраняя ваше понятное сообщение об ошибке.

Одно последнее замечание: как у нас есть разделение между \lstinline'Widget' и \lstinline'GWidget', у нас точно такое же разделение между \lstinline'Handler' и \lstinline'GHandler'.

\section{Использование Виджетов}

Это всё хорошо и приятно, что у нас есть эти красивые типы данных для виджетов, но как именно нам превратить их во что-то, с чем пользователь может взаимодействовать? Самая часто используемая функция это~--- \lstinline'defaultLayout', которая по существу имеет сигнатуру типа \lstinline'Widget -> Handler RepHtml'. (Я говорю <<по существу>> из-за целой проблемы с \lstinline'GHandler'.) \lstinline'RepHtml'~--- это тип данных, содержащий некоторый сырой HTML вывод, готовый к отправке в сеть.

На самом деле, \lstinline'defaultLayout'~--- метод класса типов, который может быть переопределён для каждого приложения. Так для приложений Yesod задаются темы\footnote{Имеются в виду темы для визуального оформления.~--- \emph{Прим. перев.}}. Но мы все ещё остаёмся с вопросом: когда мы внутри \lstinline'defaultLayout', как нам развернуть \lstinline'Widget'? Ответ~--- \lstinline'widgetToPageContent'. Давайте посмотрим на некоторые (упрощённые) типы:

\begin{lstlisting}
widgetToPageContent :: Widget -> Handler (PageContent url)
data PageContent url = PageContent
    { pageTitle :: Html
    , pageHead :: HtmlUrl url
    , pageBody :: HtmlUrl url
    }
\end{lstlisting}

Это уже ближе к тому, что нам нужно. Теперь у нас есть прямой доступ к HTML, формирующему заголовок и тело страницы, а так же к заголовку. В этот момент, мы можем использовать Hamlet для комбинирования их всех вместе в единый документ, наряду с нашим макетом сайта, и мы используем \lstinline'hamletToRepHtml' для отображения результата Hamlet в настоящий HTML, готовый к показу пользователю. Следующий листинг демонстрирует этот процесс.

\begin{lstlisting}[caption={Использование \lstinline'widgetToPageContent'}]
myLayout :: GWidget s MyApp () -> GHandler s MyApp RepHtml
myLayout widget = do
    pc <- widgetToPageContent widget
    hamletToRepHtml [hamlet|
$doctype 5
<html>
    <head>
        <title>#{pageTitle pc}
        <meta charset=utf-8>
        <style>body { font-family: verdana }
        ^{pageHead pc}
    <body>
        <article>
            ^{pageBody pc}
|]

instance Yesod MyApp where
    defaultLayout = myLayout

main = warpDebug 3000 MyApp
\end{lstlisting}
\begin{remark}
Вы могли заметить, что мы использовали \lstinline'GWidget' и \lstinline'GHandler' взамен \lstinline'Widget' и \lstinline'Handler'. Это потому, что метод~\lstinline'defaultLayout' может быть вызван подсайтами для гарантии, что они получат такие же стили, как и главный сайт. Поэтому здесь нам необходимо поддерживать гибкость наших типов.
\end{remark}

Это всё очень хорошо, но есть один момент, который беспокоит меня: тег style. Есть несколько проблем с ним:
\begin{itemize}
\item В отличие от Lucius или Cassius, он не проверяется на корректность во время компиляции.
\item Конечно, рассматриваемый пример очень простой, но в чём-то более сложном мы можем получить проблемы с экранированием символов.
\item У нас теперь 2 тега style взамен одного: один из \lstinline'myLayout', а другой генерируется \lstinline'pageHead', основанный на стилях, установленных в виджете.
\end{itemize}

Для решения этой проблемы у нас есть ещё один трюк в запасе: мы в последний момент перед вызовом \lstinline'widgetToPageContent' скорректируем сам виджет. На самом деле, это очень легко сделать: мы просто опять используем do-нотацию, как в листинге~\ref{lst:last-minute-adjustment}.

\begin{lstlisting}[caption={Корректировка виджета <<в последний момент>>},label={lst:last-minute-adjustment}]
myLayout :: GWidget s MyApp () -> GHandler s MyApp RepHtml
myLayout widget = do
    pc <- widgetToPageContent $ do
        widget
        toWidget [lucius| body { font-family: verdana } |]
    hamletToRepHtml [hamlet|
$doctype 5
<html>
    <head>
        <title>#{pageTitle pc}
        <meta charset=utf-8>
        ^{pageHead pc}
    <body>
        <article>
            ^{pageBody pc}
|]

instance Yesod MyApp where
    defaultLayout = myLayout

main = warpDebug 3000 MyApp
\end{lstlisting}

\section{Выводы}

Простые строительные блоки для страницы это виджет. Идвидуальные куски HTML, CSS, и Javascript могут быть преобразованны в виджет через полиморфную функцию \lstinline'toWidget'. Используя do-нотацию, вы можете комбинировать эти индивидуальные виджеты в большие виджеты, временами содержащие весь контент вашей страницы.

Развертывая эти виджеты обычно выполняются с функцией \lstinline'defaultLayout', которая может быть использованна для применения единого стилистики ко всем вашим страницам.
