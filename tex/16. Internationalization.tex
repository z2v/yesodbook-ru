\chapter{Интернационализация} % Internationalization

Пользователи ожидают от наших программ, что они будут разговаривать с ними на одном языке. К несчастью для нас, для этого скорее всего потребуется поддержка более, чем одного языка. В то время, как простая замена строк не представляет собой большой проблемы, корректное формирование фраз в соответствии со всеми правилами грамматики может оказаться нетривиальной задачей. В конце концов, кому из нас приятно видеть в выводе программы <<Список 1 файл(ов)>>?

Но от настоящей интернационализации (i18n, от англ. internationalization - прим. пер.) требуется не только возможность формировать корректный вывод. Также требуется сделать этот процесс простым как для программиста, так и для переводчика, а также оставить относительно простой проверку на ошибки. Решение, реализованное в Yesod, позволяет вам:

\begin{itemize}
  \item Угадывать язык пользователя основываясь на информации, переданной HTTP запросе, с возможностью перезаписи.
  \item Простой синтаксис для формирования переводов, не требующий знания Haskell. (В конце концов, не всякий переводчик является еще и программистом.)
  \item Возможность при необходимости использовать всю мощь языка Haskell для нетривиальных грамматических проблем, а также выбор хелперов по умолчанию для покрытия большинства случаев.
  \item Полное отсутсвие проблем с порядком слов. % Absolutely no issues at all with word order
\end{itemize}

\section{Краткое содержание} % Synopsis

\begin{lstlisting}
-- @messages/en.msg
Hello: Hello
EnterItemCount: I would like to buy: 
Purchase: Purchase
ItemCount count@Int: You have purchased #{showInt count} #{plural count "item" "items"}.
SwitchLanguage: Switch language to: 
Switch: Switch

-- @messages/he.msg
Hello: Привет
EnterItemCount: Я хотел бы купить: 
Purchase: Покупка
ItemCount count: Вы приобрели #{showInt count} #{plural count "товар" "товаров"}. % FIXME: 1 товар, 2 товарА, 3,4,5... товаров
SwitchLanguage: Переключить язык на:
Switch: Переключить

-- @i18n-synopsis.hs
{-# LANGUAGE OverloadedStrings, QuasiQuotes, TemplateHaskell, TypeFamilies,
    MultiParamTypeClasses #-}
import Yesod

data I18N = I18N

mkMessage "I18N" "messages" "en"

plural :: Int -> String -> String -> String
plural 1 x _ = x
plural _ _ y = y

showInt :: Int -> String
showInt = show

instance Yesod I18N

instance RenderMessage I18N FormMessage where
    renderMessage _ _ = defaultFormMessage

mkYesod "I18N" [parseRoutes|
/ RootR GET
/buy BuyR GET
/lang LangR POST
|]

getRootR :: Handler RepHtml
getRootR = defaultLayout [whamlet|
<h1>_{MsgHello}
<form action=@{BuyR}>
    _{MsgEnterItemCount}
    <input type=text name=count>
    <input type=submit value=_{MsgPurchase}>
<form action=@{LangR} method=post>
    _{MsgSwitchLanguage}
    <select name=lang>
        <option value=en>English
        <option value=he>Hebrew
    <input type=submit value=_{MsgSwitch}>
|]

getBuyR :: Handler RepHtml
getBuyR = do
    count <- runInputGet $ ireq intField "count"
    defaultLayout [whamlet|
<p>_{MsgItemCount count}
|]

postLangR :: Handler ()
postLangR = do
    lang <- runInputPost $ ireq textField "lang"
    setLanguage lang
    redirect RootR

main :: IO ()
main = warpDebug 3000 I18N
\end{lstlisting}

\section{Обзор} % Overview

Большинство существующих решений, таких как gettext или пакеты сообщений Java, работают на принципе поиска строк. Для подстановки переменных в строки обычно используются функции, похожие на printf. Вместо этого в Yesod, как вы могли догадаться, мы полагаемся на типы. Это дает нам все обычные преимущества, такие как обнаружение ошибок на этапе компиляции.

Теперь рассмотрим конкретный пример. Допустим, есть две вещи, которые наше приложение хотело бы сообщать пользователю --- приветствовать его и называть количество пользователей, использующих систему в настоящий момент. Это можно смоделировать с помощью следующего типа:

\begin{lstlisting}
data MyMessage = MsgHello | MsgUsersLoggedIn Int
\end{lstlisting}

Мы без труда можем написать функцию, преобразующий приведенный тип в строку на английском языке:

\begin{lstlisting}
toEnglish :: MyMessage -> String
toEnglish MsgHello = "Hello there!"
toEnglish (MsgUsersLoggedIn 1) = "There is 1 user logged in."
toEnglish (MsgUsersLoggedIn i) = "There are " ++ show i ++ " users logged in."
\end{lstlisting}

Мы также можем написать похожие функции для других языков. Преимущество такого подхода заключается в возможности использовать всю мощь языка Haskell для решения нетривиальных грамматических проблем, особенно плюрализации. % for addressing tricky grammar issues, especially pluralization.

\fbox{\begin{minipage}[!h]{.9\linewidth}
Вам могло показаться, что плюрализация не так уж и сложна --- всего-то требуется один вариант для одного элемента и один для любого другого количества. Это может быть справедливо для английского языка, но для произвольного языка это не верно. В русском языке, к примеру, существует шесть различных падежей и вам придется использовать отдельный модуль с логикой, определяющей, какой падеж следует использовать.
\end{minipage}}

Обратная сторона медали заключается в необходимости писать все это на Haskell, что едва ли обрадует переводчика. Чтобы решить эту проблему, в Yesod введено понятие файлов сообщений. Чуть ниже этот вопрос будет освещен более подробно. % We'll cover that in a little bit.

Допустим, у нас уже есть полный набор функций перевода, но как мы собираемся их использовать? Что нам нужно, так это новая функция, оборачивающая их и вызывающая подходящую функцию перевода в зависимости от языка, выбранного пользователем. Как только мы получим ее, Yesod сможет автоматически выбирать наиболее подходящую функцию и вызывать ее со значениями, которые вы передадите.

Чтобы немного упростить нам жизнь, в Hamlet предусмотрен специальный синтаксис интерполяции, \lstinline'_{...}', который отвечает за все вызовы функций перевода. Чтобы связать функцию перевода с вашим приложением, используйте класс типов YesodMessage.

\section{Файлы сообщений} % Message files

Самый простой подход к созданию переводов заключается в использовании файлов сообщений. Идея простая --- имеется коталог, содержащий все файлы перевода, по одному файлу на язык. Каждый файл называется в соответсвии с кодом языка, например \lstinline'en.msg'. При этом каждая строка файла содержит одну фразу, которая соответсвует одному конструктору типа данных <<сообщение>>.

\fbox{\begin{minipage}[!h]{.9\linewidth}
Сайт, созданный с помощью генератора кода, содержит полностью настроенный каталог сообщений. % The scaffolded site already includes a fully configured message folder.
\end{minipage}}

Для начала поговорим о кодах для обозначения языков. На самом деле их существует два вида --- двубуквенные коды языков и коды вида <<язык-страна>>. Например, когда я загружаю страницу в веб-браузере, он передает два код: <<en-US>> и <<en>>. Это означает <<я бы предпочел американский английский, но если вы его не поддерживаете, сойдет и английский>>.

Так какой же формат следует использовать в своем приложении? Скорее всего это двухбуквенные коды, если только вы на самом деле не создаете отдельные переводы для разных стран. Это гарантирует, что если кто-то запросит канадский английский, он все равно получит английский. За сценой Yesod добавляет двубуквенные коды там, где это уместно. Допустим, пользователь имеет следующий список языков:

\begin{lstlisting}
pt-BR, es, he
\end{lstlisting}

Это означает <<я предпочел бы бразильский португальский, затем испанский, а затем иврит>>. Допустим, ваше приложение поддерживает языки pt (общий португальский) и английсикй, притом английский используется по умолчанию. Если строго следовать списку, предоставленному пользователем, будет выбран английский язык. Однако Yesod преобразует список в следующий:

\begin{lstlisting}
pt-BR, es, he, pt
\end{lstlisting}

Другими словами, если только вы не предоставляете отдельный перевод на диалекте языка, используемом в конкретной стране, используйте двубуквенные коды. % In other words: unless you're giving different translations based on locale, just stick to the two-letter language codes.

А что там на счет файлов сообщений? После работы с Hamlet и Persistent синтаксис должен показаться вам очень знакомым. Строка начинается с имени сообщения. Поскольку это конструктор данных, он должен начинаться с заглавной буквы. Далее можно указать параметры. Их следует набирать в нижнем регистре. Они будут использованы в качестве аргументов конструктора данных.

Список аргументов завершается двоеточием, за которым следует переведенная строка, в которой можно использовать традиционный синтаксис интерполяции \lstinline'#{myVar}'. Ссылаясь на параметры, заданные перед двоеточием, и используя хелперы для решения проблем вроде плюрализации, вы можете получить любые переводы, какие пожелаете.

\section{Определяя типы} % Specifying types

Since we will be creating a datatype out of our message specifications, each parameter to a data constructor must be given a data type. We use a @-syntax for this. For example, to create the datatype \lstinline'data MyMessage = MsgHello | MsgSayAge Int', we would write:

\begin{lstlisting}
Hello: Hi there!
SayAge age@Int: Your age is: #{show age}
\end{lstlisting}

But there are two problems with this:

\begin{enumerate}
  \item It's not very DRY (don't repeat yourself) to have to specify this datatype in every file.
  \item Translators will be confused having to specify these datatypes.
\end{enumerate}

So instead, the type specification is only required in the main language file. This is specified as the third argument in the mkMessage function. This also specifies what the backup language will be, to be used when none of the languages provided by your application match the user's language list.

\section{Класс типов RenderMessage} % RenderMessage typeclass

Your call to mkMessage creates an instance of the RenderMessage typeclass, which is the core of Yesod's i18n. It is defined as:
\begin{lstlisting}
class RenderMessage master message where
    renderMessage :: master
                  -> [Text] -- ^ languages
                  -> message
                  -> Text 
\end{lstlisting}

Notice that there are two parameters to the RenderMessage class: the master site and the message type. In theory, we could skip the master type here, but that would mean that every site would need to have the same set of translations for each message type. When it comes to shared libraries like forms, that would not be a workable solution.

The renderMessage function takes a parameter for each of the class's type parameters: master and message. The extra parameter is a list of languages the user will accept, in descending order of priority. The method then returns a user-ready Text that can be displayed.

A simple instance of RenderMessage may involve no actual translation of strings; instead, it will just display the same value for every language. For example:

\begin{lstlisting}
data MyMessage = Hello | Greet Text
instance RenderMessage MyApp MyMessage where
    renderMessage _ _ Hello = "Hello"
    renderMessage _ _ (Greet name) = "Welcome, " <> name <> "!"
\end{lstlisting}
    
Notice how we ignore the first two parameters to renderMessage. We can now extend this to support multiple languages:

\begin{lstlisting}
renderEn Hello = "Hello"
renderEn (Greet name) = "Welcome, " <> name <> "!"
renderHe Hello = "שלום"
renderHe (Greet name) = "ברוכים הבאים, " <> name <> "!"
instance RenderMessage MyApp MyMessage where
    renderMessage _ ("en":_) = renderEn
    renderMessage _ ("he":_) = renderHe
    renderMessage master (_:langs) = renderMessage master langs
    renderMessage _ [] = renderEn
\end{lstlisting}

The idea here is fairly straight-forward: we define helper functions to support each language. We then add a clause to catch each of those languages in the renderMessage definition. We then have two final cases: if no languages matched, continue checking with the next language in the user's priority list. If we've exhausted all languages the user specified, then use the default language (in our case, English).

But odds are that you will never need to worry about writing this stuff manually, as the message file interface does all this for you. But it's always a good idea to have an understanding of what's going on under the surface.

\section{Интерполяция} % Interpolation

One way to use your new RenderMessage instance would be to directly call the renderMessage function. This would work, but it's a bit tedious: you need to pass in the foundation value and the language list manually. Instead, Hamlet provides a specialized i18n interpolation, which looks like \lstinline'_{...}'.

\fbox{\begin{minipage}[!h]{.9\linewidth}
Why the underscore? Underscore is already a well-established character for i18n, as it is used in the gettext library.
\end{minipage}}

Hamlet will then automatically translate that to a call to renderMessage. Once Hamlet gets the output Text value, it uses the toHtml function to produce an Html value, meaning that any special characters (\lstinline'<, &, >') will be automatically escaped.

\section{Фразы, а не слова} % Phrases, not words

As a final note, I'd just like to give some general i18n advice. Let's say you have an application for selling turtles. You're going to use the word <<turtle>> in multiple places, like <<You have added 4 turtles to your cart>> and <<You have purchased 4 turtles, congratulations>>. As a programmer, you'll immediately notice the code reuse potential: we have the phrase <<4 turtles>> twice. So you might structure your message file as:

\begin{lstlisting}
AddStart: You have added
AddEnd: to your cart.
PurchaseStart: You have purchased
PurchaseEnd: , congratulations!
Turtles count@Int: #{show count} #{plural count "turtle" "turtles"}
\end{lstlisting}

STOP RIGHT THERE! This is all well and good from a programming perspective, but translations are not programming. There are a many things that could go wrong with this, such as:

\begin{itemize}
  \item Some languages might put "to your cart" before "You have added."
  \item Maybe "added" will be constructed differently depending whether you added 1 or more turtles.
  \item There are a bunch of whitespace issues as well.
\end{itemize}

So the general rule is: translate entire phrases, not just words.
