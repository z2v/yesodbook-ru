Пакет Enumerator

В связи с тем, что Yesod перешел на использование пакета conduits, эта глава больше не соответствует нынешнему Yesod. Она сохранена в качестве справки для тех, кто до сих пор используют enumerators.

Одной из развивающихся моделей в Haskell является enumerators. Они предназначены для решения проблем производства, изменения и потребления потоков данных. Enumerators считаются немного пугающиим, возможно, потому что:

* Существует несколько реализаций, все с несколько различными подходами.
* Некоторые из этих реализаций (на мой взгляд) используют сбивающюю с толку систему именования.
* Как правило, существующие руководства не нацелены непосредственно на конкретную реализацию, а больше работают на развитием интуиции, и не дают инструкции, как использовать библиотеку.

Инфраструктура Йесод использует enumerators за кулисами во многих местах: в WAI/Warp для работы с телами запроса и ответа, в Persistent для получения результатов запроса к базе данных, и в различных сторонних пакетах, таких как http-enumerator и xml-enumerator. Мы всегда используем пакет enumerators. Этот пакет является темой этой главы.

Эта глава состоит из трех основных разделов, каждый рассматривающий одно из основных понятий:

* Начнем с iteratees, которые являются потребителями (consumers). Им скармливаются данные и они что-то с ними делают.
* Далее мы рассмотрим enumerators, которые являются производителями (producers). Они скармливают данные iteratee.
* Наконец, мы рассмотрим enumeratees. Это трубы (pipes), которые получают данные от enumerators и в свою очередь передают их iteratee.

Вы можете быть удивлены, почему мы возиться с этим, когда большинство из этих проблем могут быть решены ленивым I/O. Основная проблема с ленивым I/O это его недетерминизм. Для получения дополнительной информации, то лучше пойти на оригинальный источник по этой теме: Олег.

Iteratees


Iteratee является потребителем данных. Это центральный тип пакета enumerator, на котором основаны другие типы.

Интуиция

Предположим, что мы хотим написать функцию, которая суммирует числа в списке. Пренебрёгши неинтересными деталями, такими как требованими к памяти, вполне хорошей реализацией будет:

\begin{lstlisting}
sum1 :: [Int] -> Int
sum1 [] = 0
sum1 (x:xs) = x + sum1 xs
\end{lstlisting}

Но давайте допустим, что у нас нету списка числа. Вместо этого, пользователь может вводить цифры в командной строке, и нажать "q", когда закончит. Другими словами, у нас есть такая функция:

\begin{lstlisting}
getNumber :: IO (Maybe Int)
getNumber = do
    x <- readLine
    if x == "q"
        then return Nothing
        else return $ Just $ read x
\end{lstlisting}

Мы можем написать новую функцию суммы так:

\begin{lstlisting}
sum2 :: IO Int
sum2 = do
    maybeNum <- getNumber
    case maybeNum of
        Nothing -> return 0
        Just num -> do
            rest <- sum2
            return $ num + rest
\end{lstlisting}

Это довольно неудобно быть винужденным писать две разные функции суммы только потому, что изменился наш источник данных. В идеале, мы бы хотели немного обобщить сущности. Начнем с того, что выделим сходство между этими двумя функциями: они обе возвращают значения только когда чисел больше нет. В случае sum1 мы проверяем пустой ли список, в sum2 мы проверяем на Nothing.

Тип данных Stream

Первый тип данных определеный в пакете enumerator:

\begin{lstlisting}
data Stream a = Chunks [a] | EOF
\end{lstlisting}

Конструктор EOF означает, что больше нет доступных данных. Конструктор Chunks просто позволяет нам поместить несколько частей данных вместе для повышения эффективности. Теперь мы можем переписать sum2 используя тип данных Stream:

\begin{lstlisting}
getNumber2 :: IO (Stream Int)
getNumber2 = do
    maybeNum <- getNumber -- using the original getNumber function
    case maybeNum of
        Nothing -> return EOF
        Just num -> return $ Chunks [num]

sum3 :: IO Int
sum3 = do
    stream <- getNumber2
    case stream of
        EOF -> return 0
        Chunks nums -> do
            let nums' = sum nums
            rest <- sum3
            return $ nums' + rest
\end{lstlisting}

Нельзя сказать, что это гораздо лучше, чем sum2, но по крайней мере это демонстрирует, как использовать тип данных Stream. Здесь проблема в том, что мы по-прежнему явно ссылаемся на функцию getNumber2, жёстко задавая источник данных.

Одним из возможных решений будет сделать источник данных аргументом функции суммы, а именно:

\begin{lstlisting}
sum4 :: IO (Stream Int) -> IO Int
sum4 getNum = do
    stream <- getNum
    case stream of
        EOF -> return 0
        Chunks nums -> do
            let nums' = sum nums
            rest <- sum4 getNum
            return $ nums' + rest
\end{lstlisting}

Это все хорошо, но давайте представим, что мы хотим иметь два источника данных для суммирования: значения которые пользователь вводит в командной строке, и,  допустим, числа которые мы читаем через соединение HTTP. Здесь перед нами проблема управления: sum4 управляет процессом вызывая getNum. Это модель вытягивания данных (pull data model). В enumerators используется модель инверсии управления, или же модель продавливания (inversion of control/push model), назначая ответсвенным за это enumerator. Это позволяет делать классные вещи, наподобии потребления данных из нескольких источников данных, а также становится проще писать enumerators, которые правильно работают с выделением (распределением) ресурсов.

Тип данных Step

Итак нам нужен новый тип данных, которые будут представлять состояние нашей операции суммирования. Мы позволим нашей операции находиться в одном из трех состояний:

* В ожидании новых данных.
* С уже подсчитаным результатом.
* Для удобства, мы также имеем состояние ошибки. Это не обязательно (например это состояние может быть смоделировано выбором монады вида EitherT), но это проще.

Как вы могли догадаться, эти состояния будут соответствовать трём конструкторам типа данных Step. Состояние ошибки моделируется с помощью Error SomeException, построеном на расширяемой системе исключений Haskell. Вот уже рассчитаный конструктор:

\begin{lstlisting}
Yield b (Stream a)
\end{lstlisting}

Здесь, a это вход для нашего iteratee, а b это выход. Этот конструктор позволяет одновременно произвести результат и сохранить "остатки" входных данных для другого iteratee, который может работать после нас. (Это не происходит в случае функции суммы, которая всегда потребляет все входные данные, но мы увидим и другие примеры, которые не потребляют все данные.)

Теперь вопрос заключается в том, как представлять состояние iteratee который ждёт дополнительных данных. Сперва вы можете захотеть объявить некоторый тип данных, чтобы представлять внутреннее состояние и передавать его каким-то образом. Но это не так, как оно сделано: вместо этого мы просто используем функцию (весьма в стиле Haskell, не так ли?):

\begin{lstlisting}
Continue (Stream a -> Iteratee a m b)
\end{lstlisting}

Эврика! Мы наконец увидели тип данных Iteratee! На самом деле, Iteratee очень скучный тип, который присутствует только для того, чтобы мы могли объявить крутые екземпляры (например, Monad) для наших функций. Iteratee определяется как:

\begin{lstlisting}
newtype Iteratee a m b = Iteratee (m (Step a m b))
\end{lstlisting}

А целиком тип данных Step выглядет так:

\begin{lstlisting}
data Step a m b = Error SomeException 
                | Yield b (Stream a) 
                | Continue (Stream a -> Iteratee a m b)
\end{lstlisting}

Это важно: Iteratee это просто newtype обертка вокруг Step завёрнутого в монаду. Просто имейте это в виду, когда будете смотреть на определения в пакете enumerator. Таким образом, зная это, мы можем представлять себе конструктор Continue как:

\begin{lstlisting}
Continue (Stream a -> m (Step a m b))
\end{lstlisting}

К этому определению гораздо легче подойти: эта функция берёт некоторое количество входных данных и возвращает новое состояние iteratee. Давайте посмотрим, как будет выглядеть наша функция суммы используя тип данных Step:

\begin{lstlisting}
sum5 :: Monad m => Step Int m Int -- вход Int, любая монада, выход Int
sum5 =
    Continue $ go 0 -- обычный подход, всегда начинайте с Continue
  where
    go :: Monad m => Int -> Stream Int -> Iteratee Int m Int
    -- Сложить новые входные данные с текущей суммой и создать новый Continue
    go runningSum (Chunks nums) = do
        let runningSum' = runningSum + sum nums
        -- Следующая строчка *страшная*, но хорошо, что есть 
        -- вспомогательные функции, что бы сделать это яснее.
        -- Больше про это ниже.
        Iteratee $ return $ Continue $ go runningSum'
    -- Произвести конечный результат
    go runningSum EOF = Iteratee $ return $ Yield runningSum EOF
\end{lstlisting}

Для того, чтобы запустить этот код, вы можете использовать run_ $ enumList 8 [1 .. 10] sum5. Но это использует чёрную магию Enumerator которую мы рассмотрим позже.

Первая действительная строка (Continue $ go 0) инициализирует наш iteratee в начальное состояние. Как и все другие функции суммирования мы должны явно заявить, что мы начинаем с 0. Настоящая рабочая лошадка это функция go. Обратите внимание, как мы передаём состояние iteratee в качестве первого аргумента go: это тоже очень распространенная подход в iteratees.

Мы должны обрабатывать два разных случая: когда получили EOF, функция go должна произвести значение Yield. (Она также может произвести Error, но определенно не может Continue.) В этом случае, мы просто возвращаем текущую сумму и говорим, что данных не осталось. Когда мы получаем некоторые входные данные с помощью Chunks, мы просто складываем их с текущей суммой и создаём новое Continue основаное на той же функции go.

Давайте теперь поработаем над тем, что бы сделать эту функцию немного красивее с помощью встроенных вспомогательных функций. Конструкция Iteratee . return достаточно обычна, чтобы оправдать вспомогательную функцию, а именно:

\begin{lstlisting}
returnI :: Monad m => Step a m b -> Iteratee a m b
returnI = Iteratee . return
\end{lstlisting}

Так к примеру,

\begin{lstlisting}
go runningSum EOF = Iteratee $ return $ Yield runningSum EOF
\end{lstlisting}

становится

\begin{lstlisting}
go runningSum EOF = returnI $ Yield runningSum EOF
\end{lstlisting}

Но даже это достаточно обычно, что бы захотеть вспомогательную функцию:

\begin{lstlisting}
yield :: Monad m => b -> Stream a -> Iteratee a m b
yield x chunk = returnI $ Yield x chunk
\end{lstlisting}

так наша строка становиться

\begin{lstlisting}
go runningSum EOF = yield runningSum EOF
\end{lstlisting}

Таким же образом,

\begin{lstlisting}
Iteratee $ return $ Continue $ go runningSum'
\end{lstlisting}

становиться

\begin{lstlisting}
continue $ go runningSum'
\end{lstlisting}

Екземпляр монады для Iteratee

Это все очень хорошо: теперь у нас есть iteratee, которому могут скармливаться числа из любой монады и он может их сложить. Он может даже брать входные данные из различных источников, и складывать их вместе. (Кстати, я на самом деле ещё не показал вам, как скармливать эти числа: об этом во второй части, про enumerators) Но давайте будем честными: sum5 является уродливой функцией. Разве нельзя написать как нибудь попроще?

На самом деле, можно. Помните, как я уже говорил, что Iteratee на самом деле существуют просто чтобы облегчить определение екземпляров классов типа? Это включает в себя и екземпляр монады. Вы можете посмотреть код, чтобы увидеть, как этот екземпляр определён, но здесь мы просто покажем, как это можно использовать:

\begin{lstlisting}
sum6 :: Monad m => Iteratee Int m Int
sum6 = do
    maybeNum <- head -- это не функция head из Prelude!
    case maybeNum of
        Nothing -> return 0
        Just i -> do
            rest <- sum6
            return $ i + rest
\end{lstlisting}

Эта функция head не из Prelude, она из модуля Data.Enumerator. Вот её сигнатура типа:

\begin{lstlisting}
head :: Monad m => Iteratee a m (Maybe a)
\end{lstlisting}

которая в общем означает, дай мне следующую часть входных данных, если они есть. Чуть позже мы рассмотрим эту функцию более подробно.

Сравните код sum6 и sum2: они удивительно похожи. Часто можно строить более сложные iteratees с помощью простых iteratees и экземпляра Monad для Iteratee.

Чередующийся(Вложенный) I/O

Хорошо, давайте рассмотрим совершенно другую проблему. Мы хотим, считывать строки с входных данных, и выводить их по одной на экран. Один из подходов заключается в использовании ленивого I/O:

\begin{lstlisting}
lazyIO :: IO ()
lazyIO = do
    s <- lines `fmap` getContents
    mapM_ putStrLn s
\end{lstlisting}

Но это решение имеет два недостатка:

* Оно привязано к одному источнику данных, стандартный ввод. Это ограничение можно обойти аргументом, указывающим источник данных.
* Но, допустим, в качестве источника данных используется некоторый ограниченный ресурс (представте себе дескрипторы файлов на очень загруженном веб-сервере). С ленивым I/O у нас нет никаких гарантий, когда эти дескрипторы файлов будут освобождены.

Давайте рассмотрим, как написать это в нашем новом высокоуровневом монадическом подходе iteratee:

\begin{lstlisting}
interleaved :: MonadIO m => Iteratee String m ()
interleaved = do
    maybeLine <- head
    case maybeLine of
        Nothing -> return ()
        Just line -> do
            liftIO $ putStrLn line
            interleaved
\end{lstlisting}

Функция liftIO из пакета трансформаторов, она просто продвигает действие в монаде IO в любое произвольное действие в MonadIO. Обратите внимание, что мы не отслеживаем состояние в этом iteratee: мы не заботимся о результате, только о побочных эффектах.

Реализация head

В качестве последнего примера, давайте попробуем реализовать функцию head.

\begin{lstlisting}
head' :: Monad m => Iteratee a m (Maybe a)
head' =
    continue go
  where
    go (Chunks []) = continue go
    go (Chunks (x:xs)) = yield (Just x) (Chunks xs)
    go EOF = yield Nothing EOF
\end{lstlisting}

Как и наша функция sum6, она тоже оборачивает внутреннюю функцию "go" используя continue. Однако, теперь у нас есть три условия для нашей функции go. Первый обрабатывает случай пустых блоков (Chunks []). Цитируя документацию enumerator:

(Chunks []) используется для обозначения того, что поток по-всё ещё активный, но в настоящее время нет данных. Iteratees должны игнорировать пустые блоки.

Второй вариант обрабатывает случай, когда нам даны некоторые данные. В этом случае мы возвращаем первый элемент списка, и остатки. Третий пункт обрабатывает конец ввода, возвращая Nothing.

Enumerators

В то время как Iteratee является потребителем (consumer), Enumerator является производителем (producer). На высоком уровне, Enumerator яаляется в действительности трансформатором Iteratee, переводя Iteratee из одного состояния в новое. Давайте посмотрим, как это работает.

Извлекая значение

Мы уже написали несколько iteratees, но мы до сих пор не знаем, как из них извлекать значения. Для начала, давайте вспомним, что Iteratee это просто newtype обертка вокруг Step:

\begin{lstlisting}
newtype Iteratee a m b = Iteratee { runIteratee :: m (Step a m b) }
\end{lstlisting}

Давайте развернём Iteratee, что бы иметь дело со значением Step внутри. Также вспомним, что для типа Step есть три конструктора: Continue, Yield и Error. Мы будем обрабатывать конструктор Error, возвращая наш результат в Either. Yield уже содержит данные, которые мы ищем.

Сложный случай с Continue: здесь, у нас есть iteratee, которй  ожидает больше данных. Здесь на помощь приходит конструктор EOF: это наш маленький способ сказать iteratee закончить то, что он делает, и продолжить нашу работу. Если вы помните, выше я сказал, что правильно реализованый (воспитаный) iteratee никогда не вернет Continue после получения EOF; сейчас мы увидим, почему:

\begin{lstlisting}
extract :: Monad m => Iteratee a m b -> m (Either SomeException b)
extract (Iteratee mstep) = do
    step <- mstep
    case step of
        Continue k -> do
            let Iteratee mstep' = k EOF
            step' <- mstep'
            case step' of
                Continue _ -> error "Misbehaving iteratee"
                Yield b _ -> return $ Right b
                Error e -> return $ Left e
        Yield b _ -> return $ Right b
        Error e -> return $ Left e
\end{lstlisting}

К счастью, вам не нужно переопределять это самостоятельно: enumerator содержит обе функции run и run_. Давайте пойдем дальше и воспользуемся этим в нашей sum6 функции:

\begin{lstlisting}
main = run_ sum6 >>= print
\end{lstlisting}

Если вы исполните это, то результат будет 0. Это подчеркивает один важный момент: iteratee не только то как для обрабатывать входные данные, это ещё и состояние обработки. В этом случае, мы не сделали ничего, чтобы изменить начальное состояние sum6, так что у нас еще начальное значение 0.

Чтобы дать аналогию: представте iteratee как такую машину. Когда вы вводите в неё данные, вы измененяете её внутреннее состояние, но вы не видите всех этих изменений снаружи. Когда же вы закончили ввод, вы нажимаете кнопку, и она выдаёт результат. Если вы не вводили никаких данных, ваш результат в начальном состоянии.

Добавление данных

Давайте предположим, что мы действительно хотим найти сумму некоторых чисел. Например, числа от 1 до 10. Мы должны каким-то образом скормить их нашему sum6 iteratee. Для того, чтобы как-то подойти к этому, нам опять нужно развернуть наш Iteratee и работать со значеним Step напрямую.

В нашем случае, мы точно знаем, что конструктор Step, который мы использовали это Continue, так что можно безопасно записать нашу функцию как:

\begin{lstlisting}
sum7 :: Monad m => Iteratee Int m Int
sum7 = Iteratee $ do
    Continue k <- runIteratee sum6
    runIteratee $ k $ Chunks [1..10]
\end{lstlisting}

Но в общем случае, мы не будем знать какой конструктор будет лежать в ожидании нас. Мы должны как положено обработать Continue, Yield и Error. Мы увидели, что делать с Continue: скормить ему данные. С Yield и Error, в общем правильным действием будет ничего не делать, поскольку мы уже прибыли в наш конечное состояние (или успешный Yield или Error). Таким образом, "правильный" способ записи функции выше:

\begin{lstlisting}
sum8 :: Monad m => Iteratee Int m Int
sum8 = Iteratee $ do
    step <- runIteratee sum6
    case step of
        Continue k -> runIteratee $ k $ Chunks [1..10]
        _ -> return step
\end{lstlisting}

Синоним типа Enumerator

То что мы сделали с sum7 и sum8 это выполнили преобразование Iteratee. Но мы сделали это в очень ограниченном виде: мы явно вписали использование орининальной функцию Iteratee (sum6). Мы могли бы сделать её аргументом функции:

\begin{lstlisting}
sum9 :: Monad m => Iteratee Int m Int -> Iteratee Int m Int
sum9 orig = Iteratee $ do
    step <- runIteratee orig
    case step of
        Continue k -> runIteratee $ k $ Chunks [1..10]
        _ -> return step
\end{lstlisting}

Но так как мы всегда просто хотим развернуть значение Iteratee, оказывается, что более естественно сделать аргумент типа Step, а именно:

\begin{lstlisting}
sum10 :: Monad m => Step Int m Int -> Iteratee Int m Int
sum10 (Continue k) = k $ Chunks [1..10]
sum10 step = returnI step
\end{lstlisting}

Эта сигнатура типа (взять Step, вернуть Iteratee) оказывается очень распространенна:

\begin{lstlisting}
type Enumerator a m b = Step a m b -> Iteratee a m b
\end{lstlisting}

Значит сигнатура типа sum10 может быть выражена следующим образом:

\begin{lstlisting}
sum10 :: Monad m => Enumerator Int m Int
\end{lstlisting}

Конечно, нам нужна некоторая вспомогательная функция для связи Enumerator и Iteratee:

\begin{lstlisting}
applyEnum :: Monad m => Enumerator a m b -> Iteratee a m b -> Iteratee a m b
applyEnum enum iter = Iteratee $ do
    step <- runIteratee iter
    runIteratee $ enum step
\end{lstlisting}

Позвольте мне повторить, наша интуиция здесь: Enumerator трпнсформирует Iteratee из его исходного состояния в новое состояние, скармливая ему данные. Для того, чтобы использовать эту функцию, мы можем написать:

\begin{lstlisting}
run_ (applyEnum sum10 sum6) >>= print
\end{lstlisting}

Здесь результат 55, точно тот, что мы ожидали. Но теперь мы видим одно из преимуществ enumerators: мы можем использовать несколько источников данных. Допустим, у нас есть еще один enumerator:

\begin{lstlisting}
sum11 :: Monad m => Enumerator Int m Int
sum11 (Continue k) = k $ Chunks [11..20]
sum11 step = returnI step
\end{lstlisting}

Тогда мы могли бы просто применить оба enumerators:

\begin{lstlisting}
run_ (applyEnum sum11 $ applyEnum sum10 sum6) >>= print
\end{lstlisting}

И мы получили бы результат 210. (Да, (1 + 20) * 10 = 210), но не волнуйтесь, вам не нужно писать функцию applyEnum самим: enumerator  предоставляет оператор $$, который делает то же самое. Его сигнатура типа немного страшнее, так как это обобщение applyEnum, но он работает так же, и даже делает код более читабельным:

\begin{lstlisting}
run_ (sum11 $$ sum10 $$ sum6) >>= print
\end{lstlisting}

$$ это синорим для ==<<, которая просто flip >>==. Я нахожу $$ наиболее читаемым, но для вас это может быть подругому.

Некоторые встроенные enumerators

Конечно, писать целую функцию только что бы передать несколько чисел нашей функции суммы кажется несколько утомительным. Мы могли бы легко сделать список аргументом функции:

\begin{lstlisting}
sum12 :: Monad m => [Int] -> Enumerator Int m Int
sum12 nums (Continue k) = k $ Chunks nums
sum12 _ step = returnI step
\end{lstlisting}

Но в нашей функции нет ничего Int специфичного. Мы могли бы легко её обобщить до:

\begin{lstlisting}
genericSum12 :: Monad m => [a] -> Enumerator a m b
genericSum12 nums (Continue k) = k $ Chunks nums
genericSum12 _ step = returnI step
\end{lstlisting}

И в самом деле, enumerator идёт со встроеной функцией enumList, которая это делает. enumList также принимает аргумент типа Integer, который указывает максимальное количество элементов в блоке. Например, мы можем написать:

\begin{lstlisting}
run_ (enumList 5 [1..30] $$ sum6) >>= print
\end{lstlisting}

(Это произведёт 465, если вы считаете.) Первый аргумент enumList никогда не должен влиять на результат, хотя он может иметь некоторое влияние на производительность.

Data.Enumerator включает в себя два других enumerators: enumEOF просто передает EOF в iteratee. concatEnums немного более интересный, он обьединяет несколько enumerators вместе. Например:

\begin{lstlisting}
run_ (concatEnums
        [ enumList 1 [1..10]
        , enumList 1 [11..20]
        , enumList 1 [21..30]
        ] $$ sum6) >>= print
\end{lstlisting}

Это тоже произведёт 465.

Некоторый не чистый вход

Enumerators гораздо интереснее, если они не просто имеют дело с чистыми значениями. В первой части этого руководства, мы привели пример ввода чисел пользователем в командной строке:

\begin{lstlisting}
getNumber :: IO (Maybe Int)
getNumber = do
    x <- getLine
    if x == "q"
        then return Nothing
        else return $ Just $ read x

sum2 :: IO Int
sum2 = do
    maybeNum <- getNumber
    case maybeNum of
        Nothing -> return 0
        Just num -> do
            rest <- sum2
            return $ num + rest
\end{lstlisting}

Мы говорили об этом как о модели вытягивания данных: sum2 вытаскивал каждое значению из getNumber. Давайте посмотрим, сможем ли мы переписать getNumber так, что бы она была в роли толкателя (pusher), а не пасивного источника (pullee).

\begin{lstlisting}
getNumberEnum :: MonadIO m => Enumerator Int m b
getNumberEnum (Continue k) = do
    x <- liftIO getLine
    if x == "q"
        then continue k
        else k (Chunks [read x]) >>== getNumberEnum
getNumberEnum step = returnI step
\end{lstlisting}

Во-первых, обратите внимание, что мы проверяем какой передали конструктор, и только в случае Continue осуществляем какие либо действия. Если это был Continue, мы получим строку ввода от пользователя. Если строка «q» (наше указание прекратить ввод значений), мы ничего не делаем. Вы, наверное, подумали, что мы должны передать EOF. Но если бы мы это сделали, мы бы предотвратили передачу других данных этой iteratee. Вместо этого, мы просто возвращаем исходное значение Step.

Если строка была не "q", мы превращаем её в Int через read, создаём значение Stream с типом данных Chunks, и передаём его k. (Если бы мы хотели, всё делать правильно, мы бы проверили, на самом ли деле x это Int и использовали конструктора Error; я оставляю это в качестве упражнения для читателя.) На данный момент, давайте посмотрим на сигнатуру типа:

\begin{lstlisting}
k (Chunks [read x]) :: Iteratee Int m b
\end{lstlisting}

Если мы просто отбросим остаток линии, наша программа прошла бы проверку соответствия типов. Однако, она читала бы только одно значение из командной строки; ==>> getNumberEnum заставляет наш enumerator зацикливаться.

И последнее, что следует отметить о нашей функции: обратите внимание на b в сигнатуре типа.

\begin{lstlisting}
getNumberEnum :: MonadIO m => Enumerator Int m b
\end{lstlisting}

Оно говорит, что наш Enumerator может скармливать Ints любому Iteratee принемающему Ints, и не имеет значения, какой тип будет у окончательного вывода. Это обычная манера работы enumerators. Это позволяет создавать совершенно разные iteratees, которые работают с одними и теми же enumerators:

\begin{lstlisting}
intsToStrings :: (Show a, Monad m) => Iteratee a m String
intsToStrings = (unlines . map show) `fmap` consume
\end{lstlisting}

И после этого обе следуюющие линии работают:

\begin{lstlisting}
run_ (getNumberEnum $$ sum6) >>= print
run_ (getNumberEnum $$ intsToStrings) >>= print
\end{lstlisting}

Enumeratees

Заключительной частью головоломки является Enumeratee. Это сочетание Iteratee (он потребляет некоторые данные) и Enumerator (передает свои данные). Его можно рассматривать как трансформатор потока, или, как конвеер соединяющий Enumerator и Iteratee.

Обобщяя getNumberEnum

Раньше мы создали функцию getNumberEnum с сигнатурой типа:

\begin{lstlisting}
getNumberEnum :: MonadIO m => Enumerator Int m b
\end{lstlisting}

Если вы не помните, то это означает, что getNumberEnum производит поток Int. В частности, наша функция getNumberEnum читает строки из стандартного ввода, преобразовывает их в Int и скармливает их в iteratee. Она перестёт читать строки, когда встречает "q". 

Но кажется, что эта функциональность, может быть полезна и вне области Int. Например, мы можем захотеть работать с оригинальными String, или Bool, или множеством других типов. Так мы можем легко определить более обобщенную функцию, которая просто не делает преобразования String в Int:

\begin{lstlisting}
lineEnum :: MonadIO m => Enumerator String m b
lineEnum (Continue k) = do
    x <- liftIO getLine
    if x == "q"
        then continue k
        else k (Chunks [x]) >>== lineEnum
lineEnum step = returnI step
\end{lstlisting}

Круто, давайте используем это с нашей функции sumIter (я переименовал функции sum6 из двух предыдущих частей):

lineEnum $$ sumIter

На самом деле, это проходит проверку типа: lineEnum производит String, а sumIter хочет Int. Нам нужно как-то изменить одну из них.

\begin{lstlisting}
sumIterString :: Monad m => Iteratee String m Int
sumIterString = Iteratee $ do
    innerStep <- runIteratee sumIter
    return $ go innerStep
  where
    go :: Monad m => Step Int m Int -> Step String m Int
    go (Yield res _) = Yield res EOF
    go (Error err) = Error err
    go (Continue k) = Continue $ \strings -> Iteratee $ do
        let ints = fmap read strings :: Stream Int
        step <- runIteratee $ k ints
        return $ go step
\end{lstlisting}

То что мы тут сделали, это обернули вокруг оригинального iteratee. Как обычно, нам в первую очередь необходимо развернуть конструктор Iteratee и монаду, чтобы добраться до сердца значения Step. Как только мы получим значение innerStep, мы передаем его функции go, которая просто преобразовывает значения в значении Stream, из String в Int.

Ещё общее

Конечно, было бы неплохо, если бы мы могли применить это преобразование к *любой* iteratee. Для начала, давайте просто передадим внутренний iteratee и отображающюю функции в качестве параметров.

\begin{lstlisting}
mapIter :: Monad m => (aOut -> aIn) -> Iteratee aIn m b -> Iteratee aOut m b
mapIter f innerIter = Iteratee $ do
    innerStep <- runIteratee innerIter
    return $ go innerStep
  where
    go (Yield res _) = Yield res EOF
    go (Error err) = Error err
    go (Continue k) = Continue $ \strings -> Iteratee $ do
        let ints = fmap f strings
        step <- runIteratee $ k ints
        return $ go step
\end{lstlisting}

Это можно вызывать так:

\begin{lstlisting}
run_ (lineEnum $$ mapIter read sumIter) >>= print
\end{lstlisting}

Здесь нет ничего особенного, это в общем-то идентично предыдущей версии. Что интересно, это то, что в пакете enumerator есть  функция map, чтобы как раз делать это, но у неё значительно отличается сигнатура типа:

\begin{lstlisting}
map :: Monad m => (ao -> ai) -> Enumeratee ao ai m b
\end{lstlisting}

так как:

\begin{lstlisting}
type Enumeratee aOut aIn m b = Step aIn m b -> Iteratee aOut m (Step aIn m b)
\end{lstlisting}

это еквивалентно:

\begin{lstlisting}
map :: Monad m => (aOut -> aIn) -> Step aIn m b -> Iteratee aOut m (Step aIn m b)
\end{lstlisting}

К чему все это дополнительное осложнение сигнатуры типа? Это не является необходимым для самой map, но это необходимо для целой кучи других подобных функций. Но давайте на секунду сосредоточимся на map, чтобы мы не заблудились: первый аргумент это та же старая отображающая функция, что была раньше. Вторым аргументом является значение Step. Это не так уж удивительно: в нашей mapIter, мы взяли Iteratee с теми же параметрами, и внутренне просто развернул его в Step.

Но что происходит с возвращаемым значением? Помня о значении всех этих типов данных, это Iteratee которому будет подаваться поток aOut и который будет возвращать Step (aka, новый iteratee, правда?). Этот вроде как имеет интуитивный смысл: мы ввели посредника, который принимает ввод от одного источника и преобразует Step в новое состояние.

А теперь, возможно, самая сложная часть всего этого: как мы можем использовать эту функцию map? Оказывается, что Enumeratee достаточно близок по сигнатуре типа к Enumerator, что мы можем просто сделать:

\begin{lstlisting}
map read $$ sumIter
\end{lstlisting}

Но сигнатура типа оказывается немного странной:

\begin{lstlisting}
Iteratee String m (Step Int m Int)
\end{lstlisting}

Помня, что Iteratee просто завернутый Step, мы имеем здесь iteratee, который принимает String и возвращает Iteratee, который, в свою очередь принимает Int и производит Int. Этот причудливый результат позволяет сделать один из наших великих трюков с iteratees: подключить данные из нескольких источников. Например, мы могли бы подключить несколько String к этой уродливой вещи, запустить её, получить новый iteratee который получает Int, скармливает эти Int и получает результат Int.

(Если это всё прошло мимо ваших ушей, не волнуйтесь. Я больше не буду говорить о таких вещах.)

Но зачастую, нам не нужна все эта мощь. Мы просто хотим прилепить наш enumeratee к нашему iteratee и получить новый iteratee. В нашем случае, мы хотим присоединить нашу map к sumIter для получения нового iteratee, которая принимает String и возвращает Int. Для того, чтобы это сделать, нам нужна функция подобная этой:

\begin{lstlisting}
unnest :: Monad m => Iteratee String m (Step Int m Int) -> Iteratee String m Int
unnest outer = do -- using the Monad instance of Iteratee
    inner <- outer -- inner :: Step Int m Int
    go inner
  where
    go (Error e) = throwError e
    go (Yield x _) = yield x EOF
    go (Continue k) = k EOF >>== go
\end{lstlisting}

Мы можем запустить наш полнейший беспорядок так:

\begin{lstlisting}
run_ (lineEnum $$ unnest $ map read $$ sumIter) >>= print
\end{lstlisting}

На самом деле функция unnest доступна в Data.Enumerator, и там она называется joinI. Таким образом, мы действительно должны писать:

\begin{lstlisting}
run_ (lineEnum $$ joinI $ map read $$ sumIter) >>= print
\end{lstlisting}

Пропуск значений

Давайте напишем чуть более интересный enumeratee: этот пропускает входные значения через одно.

\begin{lstlisting}
skip :: Monad m => Enumeratee a a m b
skip (Continue k) = do
    x <- head
    _ <- head -- это мы пропускаем
    case x of
        Nothing -> return $ Continue k
        Just y -> do
            newStep <- lift $ runIteratee $ k $ Chunks [y]
            skip newStep
skip step = return step
\end{lstlisting}

Что интересно в этом подходе, это то как он похож на Enumerator. Мы делаем много тех же вещей: проверяем, или значение Step это Continue; если это не так, то просто возвращаем его. Затем мы пользуемся тем, что Iteratee является экземпляром Monad, используя функцию head извлекаем два значения из потока. Если данных больше нет, мы возвращаем исходное значение Continue: как и с Enumerator, мы не возвращаем EOF, чтобы мы позже смогли скормить ещё данные в iteratee. Если есть данные, мы передаем их в iteratee, получаем наше новое значение Step, и затем зацикливаемся.

И то, что круто в enumeratees это то, что мы можем сцеплять все вместе:

\begin{lstlisting}
run_ (lineEnum $$ joinI $ skip $$ joinI $ map read $$ sumIter) >>= print
\end{lstlisting}

Здесь мы читаем строки, пропускаем каждую вторую, преобразуем String в Int и суммируем их.

Реальные примеры из жизни: пакет http-enumerator

Я начал работать на этим руководством, во время работы над пакетом http-enumerator. Я думаю, что использование enumeratees даёт отличное объяснение преимуществ, которые они могут предложить в реальной жизни. Существуют три различных способа разбить тело ответа:

* Блочное кодирование. В этом случае веб-сервер возвращает шестнадцатеричную строку, определяющую длину следующего блока, а затем этот блок. В конце концов, он отправляет 0, чтобы указать конец этого ответа.
* Длинна содержимого. Здесь, веб-сервер отправляет перед телом ответа заголовок, указывающий полную длину тела.
* Ничего не делать. В этом случае, тело ответа длится до конца файла.

Кроме того, тело может быть и не быть запаковано GZIP. В конечном итоге мы остаёмся со следующими enumeratees, каждый с сигнатурой типа Enumeratee ByteString ByteString m b: chunkedEncoding, contentLength и ungzip. Затем мы должны сжелать что-то похожее на:

\begin{lstlisting}
let parseBody x =
        if ("transfer-encoding", "chunked") `elem` responseHeaders
            then joinI $ chunkedEncoding $$ x
            else case mlen of
                    Just len -> joinI $ contentLength len $$ x
                    Nothing -> x -- вообще не применяем ни один enumeratee
let decompress x =
        if ("content-encoding", "gzip") `elem` responseHeaders
            then joinI $ ungzip $$ x
            else x
run_ $ socketEnumerator $$ parseBody $ decompress $ bodyIteratee
\end{lstlisting}

Мы создаем цепочку: данные с сервера поступает в функцию parseBody. В случае блочного кодирования, данные обрабатываются соответствующим образом, и затем заголовки отфильтровуються. Если мы имеем дело с длинной содержимого, то считываем только указанное количество байт. А в случае, ни одного из этих вариантов, parseBody является пустой операцией (no-op).

В любом случае, тело ответа затем скармливаеться decompress. Если тело запаковано GZIP, то ungzip распаковывает его, в противном случае decompress является пустой операцией. Наконец, разобранные и распакованые данные скармливаются в поставляемую пользователем функцию bodyIteratee. Пользователь остается в блаженном неведении о любых шагах которые потребовались, чтобы доставить данные для него.

Упражнения

1. Написать enumeratee который принимает шестнадцатеричные символы (например, "DEADBEEF"), и записывает их в Word8s. Его сигнатура типа должна быть Enumeratee Char Word8 m b.
2. Написать противоположный enumeratee, например Enumeratee Word8 Char m b.
3. Создать тест quickcheck, который проверяет, что эти две функции работают правильно.

Выводы

* Enumeratees являются конвеером связывающим enumerators с iteratees.
* Странная сигнатура типа Enumeratee скрывает множество мощных возможностей. Особенно обратите внимание, как схожа его сигнатура типа с Enumerators.
* Вы можете слить Enumeratee в Iteratee используя joinI $ enumeratee $$ iteratee.
* Не забывайте, что вы можете использовать экземпляр Monad для Iteratee при создании собственных enumeratees.
* Вы всегда можете составить несколько enumeratees вместе, как например в http-enumerator.
