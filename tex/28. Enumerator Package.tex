\chapter{Пакет Enumerator}\label{chap:enumerator}

\begin{remark}
В связи с тем, что Yesod перешел на использование пакета conduit, эта глава больше не соответствует текущему состоянию Yesod. Она приведена здесь в качестве справки для тех, кто до сих пор используют enumerator.
\end{remark}

Enumerator --- это одна из новых концепций в Haskell предназначенная для решения проблем производства, изменения и потребления потоков данных. Enumerator считается немного пугающей концепцией. Возможно, потому что:

\begin{itemize}
\item Существует несколько ее реализаций, все с несколько различными подходами;
\item Некоторые из этих реализаций (на мой взгляд) используют сбивающюю с толку систему именования;
\item Как правило, существующие руководства не нацелены непосредственно на конкретную реализацию, а больше работают над развитием интуитивного понимания, и не дают инструкций по использованию конкретной библиотеки.
\end{itemize}

Yesod использует enumerator во многих местах: в WAI/Warp для работы с телами запроса и ответа, в Persistent для получения результатов запроса к базе данных, а также в различных сторонних пакетах, таких как http-enumerator и xml-enumerator. Мы постоянно используем пакет enumerator. И этот пакет является темой данной главы.

Эта глава состоит из трех основных разделов, каждый из которых рассматривает одно из основных понятий:

\begin{itemize}
\item Начнем с перечисляемого (iteratee), которое является потребителем. Ему скармливаются данные с которыми он что-то делает.
\item Далее мы рассмотрим энумератор (enumerator), который является производителем. Он скармливает данные перечисляемому.
\item В конце мы рассмотрим повторяемое (enumeratee). Это конвеер, который получает данные от энумератора и в свою очередь передает их перечисляемому.
\end{itemize}

\begin{remark}
Вы можете быть удивлены, почему мы должны возиться с этим, ведь большинство из данных проблем решаются ленивым вводом/выводом. Но основная проблема с ленивым вводом/выводом --- это его недетерминизм. Для получения дополнительной информации лучше обратиться к оригинальному источнику по этой теме --- Олегу Киселеву\footnote{\href{http://okmij.org/ftp/Streams.html\#iteratee}{http://okmij.org/ftp/Streams.html\#iteratee}}.
\end{remark}

\section{Iteratee}

Перечисляемое является потребителем данных. Это центральный тип пакета enumerator, на котором основаны другие типы.

\section{Интуитивное понимание}

Предположим, что мы хотим написать функцию, которая суммирует числа в списке. Пренебрегши неинтересными деталями, такими как требованими к памяти, вполне хорошей реализацией будет:

\begin{lstlisting}
sum1 :: [Int] -> Int
sum1 [] = 0
sum1 (x:xs) = x + sum1 xs
\end{lstlisting}

Но допустим, что у нас нет списка чисел. Вместо этого, пользователь может вводить числа в командной строке, и <<q>> для окончания ввода. Иными словами, у нас есть такая функция:

\begin{lstlisting}
getNumber :: IO (Maybe Int)
getNumber = do
    x <- readLine
    if x == "q"
        then return Nothing
        else return $ Just $ read x
\end{lstlisting}%$

Мы можем написать новую функцию суммирования так:

\begin{lstlisting}
sum2 :: IO Int
sum2 = do
    maybeNum <- getNumber
    case maybeNum of
        Nothing -> return 0
        Just num -> do
            rest <- sum2
            return $ num + rest
\end{lstlisting}%$

Довольно неудобно писать две разные функции суммирования только потому, что изменился наш источник данных. В идеале, мы бы хотели немного обобщить сущности. Начнем с того, что выделим сходство между этими двумя функциями: они обе возвращают значения только тогда, когда чисел больше нет. В случае sum1 мы проверяем, пустой ли список, в sum2 проверяем на Nothing.

\section{Тип данных Stream}

Первый тип данных, определенный в пакете enumerator, это: 

\begin{lstlisting}
data Stream a = Chunks [a] | EOF
\end{lstlisting}

Конструктор EOF означает, что больше нет доступных данных. Конструктор Chunks просто позволяет нам обьеденять несколько частей данных вместе для повышения эффективности. Теперь мы можем переписать sum2, используя тип данных Stream:

\begin{lstlisting}
getNumber2 :: IO (Stream Int)
getNumber2 = do
    maybeNum <- getNumber -- используем оригинальную функцию getNumber
    case maybeNum of
        Nothing -> return EOF
        Just num -> return $ Chunks [num]

sum3 :: IO Int
sum3 = do
    stream <- getNumber2
    case stream of
        EOF -> return 0
        Chunks nums -> do
            let nums' = sum nums
            rest <- sum3
            return $ nums' + rest
\end{lstlisting}%$

Нельзя сказать, что этот способ гораздо лучше, чем sum2, но по крайней мере он демонстрирует использование типа данных Stream. Здесь проблема в том, что мы по-прежнему явно ссылаемся на функцию getNumber2, жестко задавая источник данных.

Одно из возможных решений --- сделать источник данных аргументом функции суммирования, а именно:

\begin{lstlisting}
sum4 :: IO (Stream Int) -> IO Int
sum4 getNum = do
    stream <- getNum
    case stream of
        EOF -> return 0
        Chunks nums -> do
            let nums' = sum nums
            rest <- sum4 getNum
            return $ nums' + rest
\end{lstlisting}%$

Это все хорошо, но давайте представим, что мы хотим иметь два источника данных для суммирования: значения, которые пользователь вводит в командной строке, и числа, которые мы читаем через соединение HTTP. Здесь перед нами встает задача контроля: sum4 управляет процессом вызова getNum. Это модель вытягивания данных (pull data model). В энумераторах используется модель инверсии управления, или же модель проталкивания (inversion of control/push model), назначая ответсвенным энумератор. Это позволяет делать классные вещи, наподобии потребления данных из нескольких источников. Также становится проще писать энумераторы, которые правильно работают с выделением ресурсов.

\section{Тип данных Step}

Итак, нам нужен новый тип данных, которые будут представлять состояние нашей операции суммирования. Мы позволим операции находиться в одном из трех состояний:

\begin{itemize}
\item В ожидании новых данных.
\item С уже подсчитаным результатом.
\item Для удобства, мы также введем состояние ошибки. Это не обязательно (к примеру, это состояние может быть смоделировано выбором монады вроде EitherT), но так проще.
\end{itemize}

Как вы могли догадаться, эти состояния будут соответствовать трем конструкторам типа данных Step. Состояние ошибки моделируется с помощью Error SomeException, построеном на расширяемой системе исключений Haskell. Вот уже рассчитаный конструктор:

\begin{lstlisting}
Yield b (Stream a)
\end{lstlisting}

Здесь, \lstinline'a' это вход для нашего перечисляемого, а \lstinline'b'~--- это выход. Этот конструктор позволяет одновременно произвести результат и сохранить <<остатки>> входных данных для другого перечисляемого, который может работать после нас. (Это не происходит в случае функции суммы, которая всегда потребляет все входные данные, но мы увидим и другие примеры, которые не потребляют все данные.)

Теперь вопрос заключается в том, как представлять состояние перечисляемого, которое ждет дополнительных данных. Вы можете захотеть объявить некоторый тип данных, чтобы представлять внутреннее состояние и передавать его каким-то образом. Но это не так, как оно сделано: на самом деле, мы просто используем функцию (весьма в стиле Haskell, не так ли?):

\begin{lstlisting}
Continue (Stream a -> Iteratee a m b)
\end{lstlisting}

Эврика! Мы наконец увидели тип данных Iteratee! В действительности, Iteratee очень скучный тип, который присутствует только для того, чтобы мы могли объявить крутые экземпляры (например, Monad) для наших функций. Iteratee определяется как:

\begin{lstlisting}
newtype Iteratee a m b = Iteratee (m (Step a m b))
\end{lstlisting}

А целиком тип данных Step выглядет так:

\begin{lstlisting}
data Step a m b = Error SomeException 
                | Yield b (Stream a) 
                | Continue (Stream a -> Iteratee a m b)
\end{lstlisting}

Это важно: Iteratee является всего лишь newtype-оберткой вокруг типа Step, завернутого в монаду. Просто имейте это в виду, когда будете смотреть на определения в пакете enumerator. Таким образом, мы можем представлять себе конструктор Continue как:

\begin{lstlisting}
Continue (Stream a -> m (Step a m b))
\end{lstlisting}

К этому определению гораздо легче подойти: функция берет некоторое количество входных данных и возвращает новое состояние перечисляемого. Давайте посмотрим, как будет выглядеть наша функция суммирования, использующая тип данных Step:

\begin{lstlisting}
sum5 :: Monad m => Step Int m Int -- входные данные типа Int, любая монада, результат типа Int
sum5 =
    Continue $ go 0 -- обычный подход, всегда начинайте с Continue
  where
    go :: Monad m => Int -> Stream Int -> Iteratee Int m Int
    -- Складываем новые входные данные с текущей суммой и создаем новый Continue
    go runningSum (Chunks nums) = do
        let runningSum' = runningSum + sum nums
        -- Следующая строчка *страшная*, но хорошо, что есть 
        -- вспомогательные функции, что бы сделать это яснее.
        -- Подробнее об этом ниже.
        Iteratee $ return $ Continue $ go runningSum'
    -- Произвести конечный результат
    go runningSum EOF = Iteratee $ return $ Yield runningSum EOF
\end{lstlisting}%$

\begin{remark}
Для того, чтобы запустить этот код, вы можете использовать \lstinline'run\_ \$ enumList 8 [1 .. 10] sum5'. Но здесь используется черная магия Enumerator, которую мы рассмотрим позже.
\end{remark}

Первая <<настоящая>> строка (\lstinline'Continue \$ go 0') приводит наше перечисляемое в начальное состояние. Как и во всех других функциях суммирования, мы должны явно заявить, что начинаем с нуля. Настоящая рабочая лошадка это функция \lstinline'go'. Обратите внимание, как мы передаем состояние перечисляемого в качестве первого аргумента \lstinline'go': это тоже очень распространенная подход в програмировании перечисляемого.

Мы должны обрабатывать два разных случая: когда получаем EOF, функция \lstinline'go' должна произвести значение Yield. (Она также может произвести Error, но определенно не Continue.) В этом случае, мы просто возвращаем текущую сумму и говорим, что данных не осталось. Когда же мы получаем некоторые входные данные через Chunks, мы просто складываем их и создаем новое Continue, основаное на той же функции \lstinline'go'.

Давайте теперь поработаем над тем, чтобы сделать эту функцию немного красивее с помощью встроенных вспомогательных функций. Конструкция \lstinline'Iteratee . return' достаточно обычна, чтобы оправдать вспомогательную функцию:

\begin{lstlisting}
returnI :: Monad m => Step a m b -> Iteratee a m b
returnI = Iteratee . return
\end{lstlisting}

К примеру:

\begin{lstlisting}
go runningSum EOF = Iteratee $ return $ Yield runningSum EOF
\end{lstlisting}%$

становится:

\begin{lstlisting}
go runningSum EOF = returnI $ Yield runningSum EOF
\end{lstlisting}%$

Но даже это достаточно обычно, что бы ввести еще одну вспомогательную функцию:

\begin{lstlisting}
yield :: Monad m => b -> Stream a -> Iteratee a m b
yield x chunk = returnI $ Yield x chunk
\end{lstlisting}%$

после чего наша строка становиться:

\begin{lstlisting}
go runningSum EOF = yield runningSum EOF
\end{lstlisting}

Таким же образом:

\begin{lstlisting}
Iteratee $ return $ Continue $ go runningSum'
\end{lstlisting}%$

становиться:

\begin{lstlisting}
continue $ go runningSum'
\end{lstlisting}%$

\section{Экземпляр Monad для Iteratee}

Это все очень хорошо: теперь у нас есть перечисляемое, которому могут скармливаться числа из любой монады, и он сможет их складывать. Он может даже брать входные данные из различных источников, и складывать их вместе. (Кстати, я на самом деле еще не показал вам, как скармливать ему эти числа: об этом во второй части, про энумераторы) Но давайте будем честными: sum5 является уродливой функцией. Разве нельзя написать как-нибудь попроще?

На самом деле, можно. Помните, я уже говорил, что Iteratee существуют просто чтобы облегчить определение екземпляров классов типов? Это включает в себя и екземпляр монады. Вы можете посмотреть код, чтобы увидеть, как этот экземпляр определен, а здесь мы рассмотрим, как его можно использовать:

\begin{lstlisting}
sum6 :: Monad m => Iteratee Int m Int
sum6 = do
    maybeNum <- head -- это не функция head из Prelude!
    case maybeNum of
        Nothing -> return 0
        Just i -> do
            rest <- sum6
            return $ i + rest
\end{lstlisting}%$

Функция head не из Prelude, она из модуля Data.Enumerator. Вот ее сигнатура типа:

\begin{lstlisting}
head :: Monad m => Iteratee a m (Maybe a)
\end{lstlisting}

Она означает <<дай мне следующую часть входных данных, если они есть>>. Чуть позже мы рассмотрим эту функцию более подробно.

Сравните код sum6 и sum2: они удивительно похожи. Часто можно строить более сложные перечисляемые с помощью простых перечисляемых и экземпляра Monad для Iteratee.

\section{Чередующийся ввод/вывод}

Отлично, давайте теперь рассмотрим совершенно другую задачу. Допустим, мы хотим получить на вход некоторое количество строк и вывести их по одной на экран. Одним из подходов будет использвание ленивого ввода/вывода:

\begin{lstlisting}
lazyIO :: IO ()
lazyIO = do
    s <- lines `fmap` getContents
    mapM_ putStrLn s
\end{lstlisting}

Но это решение имеет два недостатка:

\begin{itemize}
\item Оно привязано к одному источнику данных --- стандартному вводу. Это ограничение можно обойти аргументом, указывающим источник данных.
\item Но, допустим, в качестве источника данных используется некоторый ограниченный ресурс (представьте себе дескрипторы файлов на очень загруженном веб-сервере). С ленивым вводом/выводом у нас нет никаких гарантий относительно того, когда эти дескрипторы файлов будут освобождены.
\end{itemize}

Давайте рассмотрим, как написать то же самое, используя новый высокоуровневый монадический подход с использованием перечисляемого:

\begin{lstlisting}
interleaved :: MonadIO m => Iteratee String m ()
interleaved = do
    maybeLine <- head
    case maybeLine of
        Nothing -> return ()
        Just line -> do
            liftIO $ putStrLn line
            interleaved
\end{lstlisting}%$

Функция liftIO --- из пакета transformers, она просто продвигает действие в монаде IO в любое произвольное действие в MonadIO. Обратите внимание, что мы не отслеживаем состояние в этом перечисляемом: мы не заботимся о результате, только о побочных эффектах.

\section{Реализация head}

В качестве последнего примера, давайте попробуем реализовать функцию head.

\begin{lstlisting}
head' :: Monad m => Iteratee a m (Maybe a)
head' =
    continue go
  where
    go (Chunks []) = continue go
    go (Chunks (x:xs)) = yield (Just x) (Chunks xs)
    go EOF = yield Nothing EOF
\end{lstlisting}

Как и наша функция sum6, она тоже оборачивает внутреннюю функцию \lstinline'go', используя continue. Однако теперь у нас есть три варианта для функции \lstinline'go'. Первый обрабатывает случай пустых блоков \lstinline'(Chunks [])'. Цитируя документацию enumerator:

\lstinline'(Chunks [])' используется для обозначения того, что поток все еще активный, но в настоящее время нет доступных данных. Iteratee должен игнорировать пустые блоки.

Второй вариант обрабатывает случай, когда нам даны некоторые данные. В этом случае мы возвращаем первый элемент списка, и остатки. Третий пункт обрабатывает конец ввода, возвращая Nothing.

\section{Enumerator}

В то время как Iteratee является потребителем, Enumerator является производителем. На высоком уровне, Enumerator является в действительности трансформатором Iteratee, переводя Iteratee из одного состояния в другое. Давайте посмотрим, как это работает.

\section{Извлечение значений}

Мы уже написали несколько перечисляемых, но мы до сих пор не знаем, как из них извлекать значения. Для начала вспомним, что Iteratee это просто newtype-обертка вокруг Step:

\begin{lstlisting}
newtype Iteratee a m b = Iteratee { runIteratee :: m (Step a m b) }
\end{lstlisting}

Давайте развернем Iteratee, чтобы иметь дело со значением Step внутри. Также вспомним, что для типа Step есть три конструктора: Continue, Yield и Error. Мы будем обрабатывать конструктор Error, возвращая наш результат в Either. Yield уже содержит данные, которые мы ищем.

Немного сложнее с Continue: в этом случае у нас есть перечисляемое, которое ожидает больше данных. Здесь на помощь приходит конструктор EOF: это наш простой способ сказать перечисляемому закончить то, что оно делает, и продолжить работу. Если вы помните, выше я сказал, что правильно реализованое перечисляемое никогда не вернет Continue после получения EOF. Сейчас мы увидим, почему:

\begin{lstlisting}
extract :: Monad m => Iteratee a m b -> m (Either SomeException b)
extract (Iteratee mstep) = do
    step <- mstep
    case step of
        Continue k -> do
            let Iteratee mstep' = k EOF
            step' <- mstep'
            case step' of
                Continue _ -> error "Misbehaving iteratee"
                Yield b _ -> return $ Right b
                Error e -> return $ Left e
        Yield b _ -> return $ Right b
        Error e -> return $ Left e
\end{lstlisting}%$

К счастью, вам не нужно переопределять все это самостоятельно: enumerator уже содержит функции \lstinline'run' и \lstinline'run\_'. Давайте пойдем дальше и воспользуемся этим в нашей sum6 функции:

\begin{lstlisting}
main = run_ sum6 >>= print
\end{lstlisting}

Если вы запустите этот код, результатом будет 0. Это подчеркивает один важный момент: перечисляемое отвечает не только за обработку входных данных, но и за состояние обработки. В этом случае, мы не сделали ничего, чтобы изменить начальное состояние sum6, в связи с чем начальное значение не изменилось.

Для аналогии представьте перечисляемое как автомат. Когда вы вводите в него данные, вы измененяете его внутреннее состояние, но вы не видите всех этих изменений снаружи. Когда же вы закончили ввод, вы нажимаете кнопку, и он выдает результат. Если вы не вводили никаких данных, ваш результат будет в начальном состоянии.

\section{Добавление данных}

Давайте предположим, что сейчас нам действительно нужно найти сумму нескольких чисел. Например, от 1 до 10. Мы должны каким-то образом скормить их нашему перечисляемому sum6. Для того, чтобы как-то подойти к этому, нам опять нужно развернуть наш Iteratee и работать со значеним Step напрямую.

В данном случае мы точно знаем, что конструктор Step, который мы использовали --- это Continue, так что можно безопасно записать нашу функцию как:

\begin{lstlisting}
sum7 :: Monad m => Iteratee Int m Int
sum7 = Iteratee $ do
    Continue k <- runIteratee sum6
    runIteratee $ k $ Chunks [1..10]
\end{lstlisting}%$

Но в общем случае мы не будем знать, какой конструктор мы встретим, и должны как положено обрабатывать Continue, Yield и Error. Мы уже знаем, что делать с Continue: скормить ему данные. С Yield и Error, в общем случее, правильным действием будет ничего не делать, поскольку мы уже прибыли в наше конечное состояние (это или успешный Yield или Error). Таким образом, <<правильный>> способ записи функции:

\begin{lstlisting}
sum8 :: Monad m => Iteratee Int m Int
sum8 = Iteratee $ do
    step <- runIteratee sum6
    case step of
        Continue k -> runIteratee $ k $ Chunks [1..10]
        _ -> return step
\end{lstlisting}%$

\section{Синоним типа Enumerator}

В функциях sum7 и sum8 мы выполняли преобразование Iteratee. Но делали это в очень ограниченном виде: мы явно вписали использование оригинальной функции Iteratee (sum6). А могли бы сделать ее аргументом функции:

\begin{lstlisting}
sum9 :: Monad m => Iteratee Int m Int -> Iteratee Int m Int
sum9 orig = Iteratee $ do
    step <- runIteratee orig
    case step of
        Continue k -> runIteratee $ k $ Chunks [1..10]
        _ -> return step
\end{lstlisting}%$

Так как мы всегда хотим развернуть значение Iteratee, более естественно сделать аргумент типа Step, а именно:

\begin{lstlisting}
sum10 :: Monad m => Step Int m Int -> Iteratee Int m Int
sum10 (Continue k) = k $ Chunks [1..10]
sum10 step = returnI step
\end{lstlisting}%$

Эта сигнатура типа (взять Step, вернуть Iteratee) оказывается очень распространенной:

\begin{lstlisting}
type Enumerator a m b = Step a m b -> Iteratee a m b
\end{lstlisting}

Значит, сигнатура типа функции sum10 является следующей:

\begin{lstlisting}
sum10 :: Monad m => Enumerator Int m Int
\end{lstlisting}

Конечно, нам понадобиться вспомогательная функция для связи Enumerator и Iteratee:

\begin{lstlisting}
applyEnum :: Monad m => Enumerator a m b -> Iteratee a m b -> Iteratee a m b
applyEnum enum iter = Iteratee $ do
    step <- runIteratee iter
    runIteratee $ enum step
\end{lstlisting}%$

Позвольте мне повторить, на интуитивном уровне, Enumerator трансформирует Iteratee из его исходного состояния в новое состояние, скармливая ему данные. Для того, чтобы использовать эту функцию, мы можем написать:

\begin{lstlisting}
run_ (applyEnum sum10 sum6) >>= print
\end{lstlisting}

Здесь результататом будет 55, в точности, как мы ожидали. Но теперь мы видим одно из преимуществ энумераторов: мы можем использовать несколько источников данных. Допустим, у нас есть еще один энумератор:

\begin{lstlisting}
sum11 :: Monad m => Enumerator Int m Int
sum11 (Continue k) = k $ Chunks [11..20]
sum11 step = returnI step
\end{lstlisting}%$

Тогда мы можем просто применить оба энумератора:

\begin{lstlisting}
run_ (applyEnum sum11 $ applyEnum sum10 sum6) >>= print
\end{lstlisting}%$

И мы получим результат 210. (Да, (1 + 20) * 10 = 210), но не волнуйтесь, вам не нужно писать функцию applyEnum самим: enumerator предоставляет оператор \lstinline'\$\$', который делает то же самое. Его сигнатура типа немного страшнее, так как это обобщение applyEnum, но он работает так же, и даже делает код более читабельным:

\begin{lstlisting}
run_ (sum11 $$ sum10 $$ sum6) >>= print
\end{lstlisting}%$

\lstinline'\$\$' является синонимом для \lstinline'==<<', который представляет собой просто \lstinline'flip >>=='. Лично я нахожу \lstinline'\$\$' наиболее читаемым, но для вас это может быть по-другому.

\section{Некоторые встроенные энумераторы}

Конечно, писать целую функцию только для того, чтобы передать несколько чисел функции суммирования, кажется несколько утомительным. Мы могли бы легко сделать список аргументом функции:

\begin{lstlisting}
sum12 :: Monad m => [Int] -> Enumerator Int m Int
sum12 nums (Continue k) = k $ Chunks nums
sum12 _ step = returnI step
\end{lstlisting}%$

Но в этой функции нет ничего, что привязывало бы нас к типу Int, и мы могли бы легко обобщить ее до:

\begin{lstlisting}
genericSum12 :: Monad m => [a] -> Enumerator a m b
genericSum12 nums (Continue k) = k $ Chunks nums
genericSum12 _ step = returnI step
\end{lstlisting}%$

Оказывается, в пакете enumerator есть встроеная функция enumList, которая делает все это. Функция enumList также принимает аргумент типа Integer, который указывает максимальное количество элементов в блоке. Например, мы можем написать:

\begin{lstlisting}
run_ (enumList 5 [1..30] $$ sum6) >>= print
\end{lstlisting}%$

(Совершенно очевидно, что результатом будет 465.) Первый аргумент enumList никогда не должен влиять на результат, хотя он может иметь некоторое влияние на производительность.

Модуль Data.Enumerator включает в себя два других энумератора: enumEOF просто передает EOF в перечисляемое. concatEnums немного более интересный, он обьединяет несколько энумераторов воедино. Например:

\begin{lstlisting}
run_ (concatEnums
        [ enumList 1 [1..10]
        , enumList 1 [11..20]
        , enumList 1 [21..30]
        ] $$ sum6) >>= print
\end{lstlisting}%$

Здесь мы также получаем результат 465.

\section{Не чистые входные данные}

Использование энумераторов гораздо интереснее, если иметь дело не только с чистыми значениями. В первой части этой главы мы привели пример ввода чисел пользователем в командной строке:

\begin{lstlisting}
getNumber :: IO (Maybe Int)
getNumber = do
    x <- getLine
    if x == "q"
        then return Nothing
        else return $ Just $ read x

sum2 :: IO Int
sum2 = do
    maybeNum <- getNumber
    case maybeNum of
        Nothing -> return 0
        Just num -> do
            rest <- sum2
            return $ num + rest
\end{lstlisting}%$

Мы говорили об этом как о модели вытягивания данных: sum2 вытаскивал каждое значению из getNumber. Давайте посмотрим, сможем ли мы переписать getNumber так, что бы она была в роли толкателя (pusher), а не пасивного источника (pullee).

\begin{lstlisting}
getNumberEnum :: MonadIO m => Enumerator Int m b
getNumberEnum (Continue k) = do
    x <- liftIO getLine
    if x == "q"
        then continue k
        else k (Chunks [read x]) >>== getNumberEnum
        
getNumberEnum step = returnI step
\end{lstlisting}

Во-первых, обратите внимание, что мы проверяем, какой нам передали конструктор, и только в случае Continue осуществляем какие-либо действия. Если это был Continue, мы получим строку ввода от пользователя. Если получили <<q>> (наш сигнал окончания ввода), то ничего не делаем. Вы, наверное, подумали, что мы должны вернуть EOF. Но если бы мы это сделали, мы бы предотвратили передачу других данных этому перечисляемому. Вместо этого, мы просто возвращаем исходное значение Step.

Если строка была не <<q>>, мы превращаем ее в Int через read, создаем значение Stream с типом данных Chunks, и передаем его \lstinline'k'. (Если бы мы хотели все делать правильно, мы бы проверяли, на самом ли деле \lstinline'x' является целым числом и использовали бы конструктор Error; оставляю это вам в качестве упраженния.) А сейчас давайте посмотрим на сигнатуру типа:

\begin{lstlisting}
k (Chunks [read x]) :: Iteratee Int m b
\end{lstlisting}

Если бы мы просто отбросили остаток строки, наша программа прошла бы проверку соответствия типов. Однако она читала бы только одно значение из командной строки; \lstinline'==>>' getNumberEnum заставляет наш энумератор зацикливаться.

И последнее, что следует отметить о нашей функции: обратите внимание на \lstinline'b' в сигнатуре типа.

\begin{lstlisting}
getNumberEnum :: MonadIO m => Enumerator Int m b
\end{lstlisting}

Это означает, что наш Enumerator может скармливать Int любому Iteratee, принемающему Int, и не имеет значения, какой тип будет у окончательного вывода. Это обычная манера работы энумераторов, что позволяет создавать совершенно разные перечисляемые, которые работают с одними и теми же энумератором:

\begin{lstlisting}
intsToStrings :: (Show a, Monad m) => Iteratee a m String
intsToStrings = (unlines . map show) `fmap` consume
\end{lstlisting}

И после этого обе следуюющие строки работают:

\begin{lstlisting}
run_ (getNumberEnum $$ sum6) >>= print
run_ (getNumberEnum $$ intsToStrings) >>= print
\end{lstlisting}%$

\section{Enumeratee}

Заключительной частью головоломки является Enumeratee. Это сочетание Iteratee (он потребляет некоторые данные) и Enumerator (передает свои данные). Его можно рассматривать как трансформатор потока, или как конвеер, соединяющий Enumerator с Iteratee.

\section{Обобщение getNumberEnum}

Ранее мы создали функцию getNumberEnum с сигнатурой типа:

\begin{lstlisting}
getNumberEnum :: MonadIO m => Enumerator Int m b
\end{lstlisting}

Если вы подзабыли, это означает, что getNumberEnum производит поток Int'ов. В частности, наша функция getNumberEnum читает строки из стандартного ввода, преобразовывает их в Int и скармливает их в перечисляемое. Она перестет читать строки, когда встречает <<q>>. 

Но кажется, что эта функциональность может быть полезна и вне контекста Int. Например, мы можем захотеть работать с оригинальными String, или Bool, или множеством других типов. Так мы можем легко определить более обобщенную функцию, которая просто не делает преобразования String в Int:

\begin{lstlisting}
lineEnum :: MonadIO m => Enumerator String m b
lineEnum (Continue k) = do
    x <- liftIO getLine
    if x == "q"
        then continue k
        else k (Chunks [x]) >>== lineEnum
lineEnum step = returnI step
\end{lstlisting}

Круто, давайте используем это с нашей функции sumIter (я переименовал функции sum6 из двух предыдущих частей):
\begin{lstlisting}
lineEnum $$ sumIter
\end{lstlisting}%$

Но оказывается, что это не проходит проверку типов: lineEnum производит String, а sumIter хочет Int. Нам нужно как-то изменить одну из них.

\begin{lstlisting}
sumIterString :: Monad m => Iteratee String m Int
sumIterString = Iteratee $ do
    innerStep <- runIteratee sumIter
    return $ go innerStep
  where
    go :: Monad m => Step Int m Int -> Step String m Int
    go (Yield res _) = Yield res EOF
    go (Error err) = Error err
    go (Continue k) = Continue $ \strings -> Iteratee $ do
        let ints = fmap read strings :: Stream Int
        step <- runIteratee $ k ints
        return $ go step
\end{lstlisting}%$

То, что мы тут сделали --- это обернули оригинальное перечисляемое. Как обычно, нам в первую очередь необходимо развернуть конструктор Iteratee и монаду, чтобы добраться до сердца значения Step. Как только мы получим значение innerStep, мы передаем его функции go, которая просто преобразует значения в значении Stream, из String в Int.

\section{Еще большее обощение}

Конечно, было бы неплохо, если бы мы могли применить это преобразование вообще к любому перечисляемому. Для начала, давайте просто передадим внутреннее перечисляемое и отображающюю функцию в качестве параметров.

\begin{lstlisting}
mapIter :: Monad m => (aOut -> aIn) -> Iteratee aIn m b -> Iteratee aOut m b
mapIter f innerIter = Iteratee $ do
    innerStep <- runIteratee innerIter
    return $ go innerStep
  where
    go (Yield res _) = Yield res EOF
    go (Error err) = Error err
    go (Continue k) = Continue $ \strings -> Iteratee $ do
        let ints = fmap f strings
        step <- runIteratee $ k ints
        return $ go step
\end{lstlisting}%$

Это можно использовать так:

\begin{lstlisting}
run_ (lineEnum $$ mapIter read sumIter) >>= print
\end{lstlisting}%$

Здесь нет ничего особенного, это в общем-то идентично предыдущей версии. Что интересно, в пакете enumerator есть  функция map, которая делает как раз это, но у нее значительно отличается сигнатура типа:

\begin{lstlisting}
map :: Monad m => (ao -> ai) -> Enumeratee ao ai m b
\end{lstlisting}

так как:

\begin{lstlisting}
type Enumeratee aOut aIn m b = Step aIn m b -> Iteratee aOut m (Step aIn m b)
\end{lstlisting}

это еквивалентно:

\begin{lstlisting}
map :: Monad m => (aOut -> aIn) -> Step aIn m b -> Iteratee aOut m (Step aIn m b)
\end{lstlisting}

К чему все это дополнительное усложнение сигнатуры типа? Это не является необходимым для самой map, но это необходимо для целой кучи других подобных функций. Но давайте на секунду сосредоточимся на map, чтобы мы не заблудились: первый аргумент --- это та же старая отображающая функция, что была раньше. Вторым аргументом является значение Step. Это не так уж удивительно: в нашей mapIter мы взяли Iteratee с теми же параметрами, и внутренне просто развернул его в Step.

Но что происходит с возвращаемым значением? Помня о значении всех этих типов данных, это Iteratee которому будет подаваться поток aOut и который будет возвращать Step (aka, новое перечисляемое, правда?). Этот вроде как имеет интуитивный смысл: мы ввели посредника, который принимает ввод от одного источника и преобразует Step в новое состояние.

А теперь, возможно, самая сложная часть всего этого: как мы можем использовать функцию map? Оказывается, что Enumeratee достаточно близок по сигнатуре типа к Enumerator, чтобы мы могли сделать:

\begin{lstlisting}
map read $$ sumIter
\end{lstlisting}%$

Но сигнатура типа оказывается немного странной:

\begin{lstlisting}
Iteratee String m (Step Int m Int)
\end{lstlisting}

Помня, что Iteratee --- это просто завернутый Step, мы имеем здесь перечисляемое, которое принимает String и возвращает Iteratee, который, в свою очередь принимает Int и производит Int. Этот причудливый результат позволяет сделать один из наших великих трюков с перечисляемым: подключить данные из нескольких источников. Например, мы могли бы подключить несколько String к этой уродливой вещи, запустить ее, получить новое перечисляемое, которое получает Int, скармливает эти Int и получает результат Int.

(Если это все прошло мимо ваших ушей, не волнуйтесь. Я больше не буду говорить о таких вещах.)

Но зачастую, нам не нужна все эта мощь. Мы просто хотим прилепить энумератор к нашему перечисляемому и получить новое перечисляемое. В нашем случае, мы хотим присоединить map к sumIter для получения нового перечисляемого, которая принимает String и возвращает Int. Для того, чтобы это сделать, нам нужна функция подобная этой:

\begin{lstlisting}
unnest :: Monad m => Iteratee String m (Step Int m Int) -> Iteratee String m Int
unnest outer = do -- используем экземпляр Monad для Iteratee
    inner <- outer -- inner :: Step Int m Int
    go inner
  where
    go (Error e) = throwError e
    go (Yield x _) = yield x EOF
    go (Continue k) = k EOF >>== go
\end{lstlisting}

Мы можем запустить этот полнейший беспорядок следующим образом:

\begin{lstlisting}
run_ (lineEnum $$ unnest $ map read $$ sumIter) >>= print
\end{lstlisting}%$

На самом деле функция unnest доступна в Data.Enumerator, и там она называется joinI. Таким образом, в действительности мы должны писать:

\begin{lstlisting}
run_ (lineEnum $$ joinI $ map read $$ sumIter) >>= print
\end{lstlisting}%$

\section{Пропуск значений}

Давайте напишем чуть более интересное повторяемое, которое пропускает входные значения через одно.

\begin{lstlisting}
skip :: Monad m => Enumeratee a a m b
skip (Continue k) = do
    x <- head
    _ <- head -- пропускаем одно значение
    case x of
        Nothing -> return $ Continue k
        Just y -> do
            newStep <- lift $ runIteratee $ k $ Chunks [y]
            skip newStep
skip step = return step
\end{lstlisting}%$

Что интересно в этом подходе, это то, как он похож на Enumerator. Мы делаем много тех же вещей: проверяем, или значение Step это Continue; если это не так, то просто возвращаем его. Затем мы пользуемся тем, что Iteratee является экземпляром Monad, используя функцию head извлекаем два значения из потока. Если данных больше нет, мы возвращаем исходное значение Continue: как и с Enumerator, мы не возвращаем EOF, чтобы мы позже смогли скормить еще данные в перечисляемое. Если есть данные, мы передаем их в перечисляемое, получаем наше новое значение Step, и затем зацикливаемся.

Что круто в повторяемом, это то, что мы можем сцеплять все вместе:

\begin{lstlisting}
run_ (lineEnum $$ joinI $ skip $$ joinI $ map read $$ sumIter) >>= print
\end{lstlisting}%$

Здесь мы читаем строки, пропускаем каждую вторую, преобразуем String в Int и суммируем.

\section{Примеры из жизни: пакет http-enumerator}

Я начал работать на этой главой, во время работы над пакетом http-enumerator. Я думаю, что использование повторяемых дает отличное объяснение преимуществ, которые они могут предложить в реальной жизни. Существуют три различных способа разбить тело ответа:

\begin{itemize}
\item Блочное кодирование. В этом случае веб-сервер возвращает шестнадцатеричную строку, определяющую длину следующего блока, а затем этот блок. В конце концов, он отправляет 0, чтобы указать конец этого ответа.
\item Длинна содержимого. Здесь, веб-сервер отправляет перед телом ответа заголовок, указывающий полную длину тела.
\item Ничего не делать. В этом случае, тело ответа длится до конца файла.
\end{itemize}

Кроме того, тело может быть и не быть запаковано GZIP. В конечном итоге мы остаемся со следующими повторяемыми, каждое с сигнатурой типа \lstinline'Enumeratee ByteString ByteString m b': chunkedEncoding, contentLength и ungzip. Затем мы должны сделать что-то похожее на:

\begin{lstlisting}
let parseBody x =
        if ("transfer-encoding", "chunked") `elem` responseHeaders
            then joinI $ chunkedEncoding $$ x
            else case mlen of
                    Just len -> joinI $ contentLength len $$ x
                    Nothing -> x -- вообще не применяем ни одно повторяемое
let decompress x =
        if ("content-encoding", "gzip") `elem` responseHeaders
            then joinI $ ungzip $$ x
            else x
run_ $ socketEnumerator $$ parseBody $ decompress $ bodyIteratee
\end{lstlisting}%$

Мы создаем цепочку: данные с сервера поступает в функцию parseBody. В случае блочного кодирования, данные обрабатываются соответствующим образом, и затем заголовки отфильтровываются. Если мы имеем дело с длинной содержимого, то считываем только указанное количество байт. В противном случае parseBody является пустой операцией.

В любом случае, тело ответа затем скармливаеться decompress. Если тело запаковано GZIP, то ungzip распаковывает его, в противном случае decompress является пустой операцией. Наконец, разобранные и распакованые данные скармливаются в поставляемую пользователем функцию bodyIteratee. Пользователь остается в блаженном неведении о шагах, которые потребовались, чтобы доставить ему данные.

\section{Упражнения}

\begin{enumerate}
\item Написать повторяемое, которое принимает шестнадцатеричные символы (например, <<DEADBEEF>>), и записывает их в Word8. Его сигнатура типа должна быть \lstinline'Enumeratee Char Word8 m b'.
\item Написать противоположное повторяемое, например \lstinline'Enumeratee Word8 Char m b'.
\item Создать тест quickcheck, который проверяет, что эти две функции работают правильно.
\end{enumerate}

\section{Выводы}

\begin{itemize}
\item Enumeratee является конвеером, связывающим энумератор с перечисляемым.
\item Странная сигнатура типа Enumeratee скрывает множество мощных возможностей. Особенно обратите внимание, как схожа его сигнатура типа с Enumerator.
\item Вы можете слить Enumeratee в Iteratee, используя \lstinline'joinI \$ enumeratee \$\$ iteratee'.
\item Не забывайте, что вы можете использовать экземпляр Monad для Iteratee при создании собственных повторяемых.
\item Вы всегда можете объединить несколько повторяемых вместе, как это сделано в http-enumerator.
\end{itemize}
