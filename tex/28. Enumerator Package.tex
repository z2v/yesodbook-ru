Пакет Enumerator

В связи с тем, что Yesod перешел на использование пакета conduit, эта глава больше не соответствует текущему состоянию Yesod. Она приведена здесь в качестве справки для тех, кто до сих пор используют enumerator.

Enumerator это одна из новых концепций в Haskell предназначеная для решения проблем производства, изменения и потребления потоков данных. Enumerator считается немного пугающей, возможно, потому что:

* Существует несколько реализаций, все с несколько различными подходами.
* Некоторые из этих реализаций (на мой взгляд) используют сбивающюю с толку систему именования.
* Как правило, существующие руководства не нацелены непосредственно на конкретную реализацию, а больше работают над развитием интуитивного понимания, и не дают инструкции, как использовать библиотеку.

Yesod использует enumerator во многих местах: в WAI/Warp для работы с телами запроса и ответа, в Persistent для получения результатов запроса к базе данных, и в различных сторонних пакетах, таких как http-enumerator и xml-enumerator. Мы всегда используем пакет enumerator. И этот пакет является темой данной главы.

Эта глава состоит из трех основных разделов, каждый рассматривающий одно из основных понятий:

* Начнём с iteratee, который является потребителем (consumer). Ему скармливаются данные с которыми он что-то делают.
* Далее мы рассмотрим enumerator, который является производителем (producer). Он скармливает данные в iteratee.
* В конце, мы рассмотрим enumeratee. Это конвеер который получает данные от enumerator и в свою очередь передаёт их iteratee.

Вы можете быть удивлены, почему мы должны возиться с этим, ведь большинство из этих проблем решается ленивым вводом/выводом. Но основная проблема с ленивым вводом/выводом это его недетерминизм. Для получения дополнительной информации лучше обратиться к оригинальному источнику по этой теме --- Олегу Киселёву.

Iteratee

Iteratee является потребителем данных. Это центральный тип пакета enumerator, на котором основаны другие типы.

Интуитивное понимание

Предположим, что мы хотим написать функцию, которая суммирует числа в списке. Пренебрёгши неинтересными деталями, такими как требованими к памяти, вполне хорошей реализацией будет:

\begin{lstlisting}
sum1 :: [Int] -> Int
sum1 [] = 0
sum1 (x:xs) = x + sum1 xs
\end{lstlisting}

Но давайте допустим, что у нас нет списка чисел. Вместо этого, пользователь может вводить числа в командной строке, и "q" для окончания ввода. Иными словами, у нас есть такая функция:

\begin{lstlisting}
getNumber :: IO (Maybe Int)
getNumber = do
    x <- readLine
    if x == "q"
        then return Nothing
        else return $ Just $ read x
\end{lstlisting}%$

Мы можем написать новую функцию суммы так:

\begin{lstlisting}
sum2 :: IO Int
sum2 = do
    maybeNum <- getNumber
    case maybeNum of
        Nothing -> return 0
        Just num -> do
            rest <- sum2
            return $ num + rest
\end{lstlisting}%$

Довольно неудобно быть вынужденным писать две разные функции суммы только потому, что изменился наш источник данных. В идеале, мы бы хотели немного обобщить сущности. Начнем с того, что выделим сходство между этими двумя функциями: они обе возвращают значения только тогда, когда чисел больше нет. В случае sum1 мы проверяем пустой ли список, в sum2 мы проверяем на Nothing.

Тип данных Stream

Первый тип данных определённый в пакете enumerator это: 

\begin{lstlisting}
data Stream a = Chunks [a] | EOF
\end{lstlisting}

Конструктор EOF означает, что больше нет доступных данных. Конструктор Chunks просто позволяет нам обьеденять несколько частей данных вместе для повышения эффективности. Теперь мы можем переписать sum2 используя тип данных Stream:

\begin{lstlisting}
getNumber2 :: IO (Stream Int)
getNumber2 = do
    maybeNum <- getNumber -- используем оригинальную функцию getNumber
    case maybeNum of
        Nothing -> return EOF
        Just num -> return $ Chunks [num]

sum3 :: IO Int
sum3 = do
    stream <- getNumber2
    case stream of
        EOF -> return 0
        Chunks nums -> do
            let nums' = sum nums
            rest <- sum3
            return $ nums' + rest
\end{lstlisting}%$

Нельзя сказать, что этот способ гораздо лучше чем sum2, но по крайней мере он демонстрирует использование типа данных Stream. Здесь проблема в том, что мы по-прежнему явно ссылаемся на функцию getNumber2, жёстко задавая источник данных.

Одно из возможных решений --- сделать источник данных аргументом функции суммы, а именно:

\begin{lstlisting}
sum4 :: IO (Stream Int) -> IO Int
sum4 getNum = do
    stream <- getNum
    case stream of
        EOF -> return 0
        Chunks nums -> do
            let nums' = sum nums
            rest <- sum4 getNum
            return $ nums' + rest
\end{lstlisting}%$

Это все хорошо, но давайте представим, что мы хотим иметь два источника данных для суммирования: значения которые пользователь вводит в командной строке, и,  допустим, числа которые мы читаем через соединение HTTP. Здесь перед нами задача контроля: sum4 управляет процессом вызывая getNum. Это модель вытягивания данных (pull data model). В enumerators используется модель инверсии управления, или же модель продавливания (inversion of control/push model), назначая ответсвенным enumerator. Это позволяет делать классные вещи, наподобии потребления данных из нескольких источников, а также становится проще писать enumerators, которые правильно работают с выделением ресурсов.

Тип данных Step

Итак нам нужен новый тип данных, которые будут представлять состояние нашей операции суммирования. Мы позволим нашей операции находиться в одном из трех состояний:

* В ожидании новых данных.
* С уже подсчитаным результатом.
* Для удобства, мы также введём состояние ошибки. Это не обязательно (к примеру, это состояние может быть смоделировано выбором монады вроде EitherT), но так проще.

Как вы могли догадаться, эти состояния будут соответствовать трём конструкторам типа данных Step. Состояние ошибки моделируется с помощью Error SomeException, построеном на расширяемой системе исключений Haskell. Вот уже рассчитаный конструктор:

\begin{lstlisting}
Yield b (Stream a)
\end{lstlisting}

Здесь, \lstinline'a' это вход для нашего iteratee, а \lstinline'b' это выход. Этот конструктор позволяет одновременно произвести результат и сохранить "остатки" входных данных для другого iteratee, который может работать после нас. (Это не происходит в случае функции суммы, которая всегда потребляет все входные данные, но мы увидим и другие примеры, которые не потребляют все данные.)

Теперь вопрос заключается в том, как представлять состояние iteratee который ждёт дополнительных данных. Вы можете захотеть объявить некоторый тип данных, чтобы представлять внутреннее состояние и передавать его каким-то образом. Но это не так, как оно сделано: вместо этого мы просто используем функцию (весьма в стиле Haskell, не так ли?):

\begin{lstlisting}
Continue (Stream a -> Iteratee a m b)
\end{lstlisting}

Эврика! Мы наконец увидели тип данных Iteratee! На самом деле, Iteratee очень скучный тип, который присутствует только для того, чтобы мы могли объявить крутые экземпляры (например, Monad) для наших функций. Iteratee определяется как:

\begin{lstlisting}
newtype Iteratee a m b = Iteratee (m (Step a m b))
\end{lstlisting}

А целиком тип данных Step выглядет так:

\begin{lstlisting}
data Step a m b = Error SomeException 
                | Yield b (Stream a) 
                | Continue (Stream a -> Iteratee a m b)
\end{lstlisting}

Это важно: Iteratee это просто newtype обертка вокруг типа Step завёрнутого в монаду. Просто имейте это в виду, когда будете смотреть на определения в пакете enumerator. Таким образом, зная это, мы можем представлять себе конструктор Continue как:

\begin{lstlisting}
Continue (Stream a -> m (Step a m b))
\end{lstlisting}

К этому определению гораздо легче подойти: эта функция берёт некоторое количество входных данных и возвращает новое состояние iteratee. Давайте посмотрим, как будет выглядеть наша функция суммы используя тип данных Step:

\begin{lstlisting}
sum5 :: Monad m => Step Int m Int -- входные данные типа Int, любая монада, результат типа Int
sum5 =
    Continue $ go 0 -- обычный подход, всегда начинайте с Continue
  where
    go :: Monad m => Int -> Stream Int -> Iteratee Int m Int
    -- Складываем новые входные данные с текущей суммой и создаём новый Continue
    go runningSum (Chunks nums) = do
        let runningSum' = runningSum + sum nums
        -- Следующая строчка *страшная*, но хорошо, что есть 
        -- вспомогательные функции, что бы сделать это яснее.
        -- Больше про это ниже.
        Iteratee $ return $ Continue $ go runningSum'
    -- Произвести конечный результат
    go runningSum EOF = Iteratee $ return $ Yield runningSum EOF
\end{lstlisting}%$

Для того, чтобы запустить этот код, вы можете использовать \lstinline'run\_ \$ enumList 8 [1 .. 10] sum5'. Но это использует чёрную магию Enumerator которую мы рассмотрим позже.

Первая "настоящая" строка (\lstinline'Continue \$ go 0') инициализирует наш iteratee в начальное состояние. Как и во всех других функциях суммирования мы должны явно заявить, что мы начинаем с 0. Настоящая рабочая лошадка это функция \lstinline'go'. Обратите внимание, как мы передаём состояние iteratee в качестве первого аргумента \lstinline'go': это тоже очень распространенная подход в програмировании iteratee.

Мы должны обрабатывать два разных случая: когда получаем EOF, функция \lstinline'go' должна произвести значение Yield. (Она также может произвести Error, но определенно не может Continue.) В этом случае, мы просто возвращаем текущую сумму и говорим, что данных не осталось. Когда же мы получаем некоторые входные данные через Chunks, мы просто складываем их с текущей суммой и создаём новое Continue основаное на той же функции \lstinline'go'.

Давайте теперь поработаем над тем, что бы сделать эту функцию немного красивее с помощью встроенных вспомогательных функций. Конструкция \lstinline'Iteratee . return' достаточно обычна, чтобы оправдать вспомогательную функцию, а именно:

\begin{lstlisting}
returnI :: Monad m => Step a m b -> Iteratee a m b
returnI = Iteratee . return
\end{lstlisting}

Так к примеру,

\begin{lstlisting}
go runningSum EOF = Iteratee $ return $ Yield runningSum EOF
\end{lstlisting}%$

становится

\begin{lstlisting}
go runningSum EOF = returnI $ Yield runningSum EOF
\end{lstlisting}%$

Но даже это достаточно обычно, что бы захотеть вспомогательную функцию:

\begin{lstlisting}
yield :: Monad m => b -> Stream a -> Iteratee a m b
yield x chunk = returnI $ Yield x chunk
\end{lstlisting}%$

так наша строка становиться

\begin{lstlisting}
go runningSum EOF = yield runningSum EOF
\end{lstlisting}

Таким же образом,

\begin{lstlisting}
Iteratee $ return $ Continue $ go runningSum'
\end{lstlisting}%$

становиться

\begin{lstlisting}
continue $ go runningSum'
\end{lstlisting}%$

Екземпляр Monad для Iteratee

Это все очень хорошо: теперь у нас есть iteratee, которому могут скармливаться числа из любой монады, и он сможет их сложить. Он может даже брать входные данные из различных источников, и складывать их вместе. (Кстати, я на самом деле ещё не показал вам, как скармливать ему эти числа: об этом во второй части, про enumerators) Но давайте будем честными: sum5 является уродливой функцией. Разве нельзя написать как нибудь попроще?

На самом деле, можно. Помните, как я уже говорил, что Iteratee на самом деле существуют просто чтобы облегчить определение екземпляров классов типа? Это включает в себя и екземпляр монады. Вы можете посмотреть код, чтобы увидеть, как этот екземпляр определён, но здесь мы просто покажем, как это можно использовать:

\begin{lstlisting}
sum6 :: Monad m => Iteratee Int m Int
sum6 = do
    maybeNum <- head -- это не функция head из Prelude!
    case maybeNum of
        Nothing -> return 0
        Just i -> do
            rest <- sum6
            return $ i + rest
\end{lstlisting}%$

Функция head не из Prelude, она из модуля Data.Enumerator. Вот её сигнатура типа:

\begin{lstlisting}
head :: Monad m => Iteratee a m (Maybe a)
\end{lstlisting}

которая в общем означает, дай мне следующую часть входных данных, если они есть. Чуть позже мы рассмотрим эту функцию более подробно.

Сравните код sum6 и sum2: они удивительно похожи. Часто можно строить более сложные iteratee с помощью простых iteratee и экземпляра Monad для Iteratee.

Чередующийся(Вложенный) ввод/вывод

Отлично, давайте теперь рассмотрим совершенно другую задачу. Допустим мы хотим получить на вход некоторое количество строк и вывести их по одной на экран. Одним из подходов будет использвание ленивого ввода/вывода:

\begin{lstlisting}
lazyIO :: IO ()
lazyIO = do
    s <- lines `fmap` getContents
    mapM_ putStrLn s
\end{lstlisting}

Но это решение имеет два недостатка:

* Оно привязано к одному источнику данных --- стандартному вводу. Это ограничение можно обойти аргументом, указывающим источник данных.
* Но, допустим, в качестве источника данных используется некоторый ограниченный ресурс (представте себе дескрипторы файлов на очень загруженном веб-сервере). С ленивым вводом/выводом у нас нет никаких гарантий, когда эти дескрипторы файлов будут освобождены.

Давайте рассмотрим, как написать это в нашем новом высокоуровневом монадическом iteratee подходе:

\begin{lstlisting}
interleaved :: MonadIO m => Iteratee String m ()
interleaved = do
    maybeLine <- head
    case maybeLine of
        Nothing -> return ()
        Just line -> do
            liftIO $ putStrLn line
            interleaved
\end{lstlisting}%$

Функция liftIO из пакета transformers, она просто продвигает действие в монаде IO в любое произвольное действие в MonadIO. Обратите внимание, что мы не отслеживаем состояние в этом iteratee: мы не заботимся о результате, только о побочных эффектах.

Реализация head

В качестве последнего примера, давайте попробуем реализовать функцию head.

\begin{lstlisting}
head' :: Monad m => Iteratee a m (Maybe a)
head' =
    continue go
  where
    go (Chunks []) = continue go
    go (Chunks (x:xs)) = yield (Just x) (Chunks xs)
    go EOF = yield Nothing EOF
\end{lstlisting}

Как и наша функция sum6, она тоже оборачивает внутреннюю функцию \lstinline'go' используя continue. Однако, теперь у нас есть три варианта для функции \lstinline'go'. Первый обрабатывает случай пустых блоков (\lstinline'Chunks []'). Цитируя документацию enumerator:

(\lstinline'Chunks []') используется для обозначения того, что поток всё ещё активный, но в настоящее время нет доступных данных. Iteratee должен игнорировать пустые блоки.

Второй вариант обрабатывает случай, когда нам даны некоторые данные. В этом случае мы возвращаем первый элемент списка, и остатки. Третий пункт обрабатывает конец ввода, возвращая Nothing.

Enumerator

В то время как Iteratee является потребителем (consumer), Enumerator является производителем (producer). На высоком уровне, Enumerator яаляется в действительности трансформатором Iteratee, переводя Iteratee из одного состояния в другое. Давайте посмотрим, как это работает.

Извлекая значение

Мы уже написали несколько iteratee, но мы до сих пор не знаем, как из них извлекать значения. Для начала вспомним, что Iteratee это просто newtype обертка вокруг Step:

\begin{lstlisting}
newtype Iteratee a m b = Iteratee { runIteratee :: m (Step a m b) }
\end{lstlisting}

Давайте развернём Iteratee, что бы иметь дело со значением Step внутри. Также вспомним, что для типа Step есть три конструктора: Continue, Yield и Error. Мы будем обрабатывать конструктор Error, возвращая наш результат в Either. Yield уже содержит данные, которые мы ищем.

Немного сложнее с Continue: в этом случае у нас есть iteratee, который ожидает больше данных. Здесь на помощь приходит конструктор EOF: это наш простой способ сказать iteratee закончить то, что он делает, и продолжить работу. Если вы помните, выше я сказал, что правильно реализованый iteratee никогда не вернет Continue после получения EOF; сейчас мы увидим, почему:

\begin{lstlisting}
extract :: Monad m => Iteratee a m b -> m (Either SomeException b)
extract (Iteratee mstep) = do
    step <- mstep
    case step of
        Continue k -> do
            let Iteratee mstep' = k EOF
            step' <- mstep'
            case step' of
                Continue _ -> error "Misbehaving iteratee"
                Yield b _ -> return $ Right b
                Error e -> return $ Left e
        Yield b _ -> return $ Right b
        Error e -> return $ Left e
\end{lstlisting}%$

К счастью, вам не нужно переопределять это самостоятельно: enumerator уже содержит функции \lstinline'run' и \lstinline'run\_'. Давайте пойдем дальше и воспользуемся этим в нашей sum6 функции:

\begin{lstlisting}
main = run_ sum6 >>= print
\end{lstlisting}

Если вы исполните это, то результатом будет 0. Это подчеркивает один важный момент: iteratee это не только то, как обрабатывать входные данные, это ещё и состояние обработки. В этом случае, мы не сделали ничего, чтобы изменить начальное состояние sum6, так что у нас еще начальное значение 0.

Для аналогии представте iteratee как автомат. Когда вы вводите в него данные, вы измененяете его внутреннее состояние, но вы не видите всех этих изменений снаружи. Когда же вы закончили ввод, вы нажимаете кнопку, и он выдаёт результат. Если вы не вводили никаких данных, ваш результат будет в начальном состоянии.

Сложение данных

Давайте предположим, что сейчас нам действительно нужно найти сумму нескольких чисел. Например, от 1 до 10. Мы должны каким-то образом скормить их нашему sum6 iteratee. Для того, чтобы как-то подойти к этому, нам опять нужно развернуть наш Iteratee и работать со значеним Step напрямую.

В нашем случае, мы точно знаем, что конструктор Step, который мы использовали это Continue, так что можно безопасно записать нашу функцию как:

\begin{lstlisting}
sum7 :: Monad m => Iteratee Int m Int
sum7 = Iteratee $ do
    Continue k <- runIteratee sum6
    runIteratee $ k $ Chunks [1..10]
\end{lstlisting}%$

Но в общем случае, мы не будем знать какой конструктор мы встретим, и должны как положено обрабатывать Continue, Yield и Error. Мы увидели, что делать с Continue: скормить ему данные. С Yield и Error, в общем случее, правильным действием будет ничего не делать, поскольку мы уже прибыли в наше конечное состояние (это или успешный Yield или Error). Таким образом, "правильный" способ записи функции выше:

\begin{lstlisting}
sum8 :: Monad m => Iteratee Int m Int
sum8 = Iteratee $ do
    step <- runIteratee sum6
    case step of
        Continue k -> runIteratee $ k $ Chunks [1..10]
        _ -> return step
\end{lstlisting}%$

Синоним типа Enumerator

То что мы сделали в sum7 и sum8 это выполнили преобразование Iteratee. Но сделали это в очень ограниченном виде: мы явно вписали использование оригинальной функции Iteratee (sum6). Мы могли бы сделать её аргументом функции:

\begin{lstlisting}
sum9 :: Monad m => Iteratee Int m Int -> Iteratee Int m Int
sum9 orig = Iteratee $ do
    step <- runIteratee orig
    case step of
        Continue k -> runIteratee $ k $ Chunks [1..10]
        _ -> return step
\end{lstlisting}%$

Так как мы всегда просто хотим развернуть значение Iteratee, более естественно сделать аргумент типа Step, а именно:

\begin{lstlisting}
sum10 :: Monad m => Step Int m Int -> Iteratee Int m Int
sum10 (Continue k) = k $ Chunks [1..10]
sum10 step = returnI step
\end{lstlisting}%$

Эта сигнатура типа (взять Step, вернуть Iteratee) оказывается очень распространена:

\begin{lstlisting}
type Enumerator a m b = Step a m b -> Iteratee a m b
\end{lstlisting}

Значит сигнатура типа sum10 может быть выражена следующим образом:

\begin{lstlisting}
sum10 :: Monad m => Enumerator Int m Int
\end{lstlisting}

Конечно, нам понадобиться вспомогательная функция для связи Enumerator и Iteratee:

\begin{lstlisting}
applyEnum :: Monad m => Enumerator a m b -> Iteratee a m b -> Iteratee a m b
applyEnum enum iter = Iteratee $ do
    step <- runIteratee iter
    runIteratee $ enum step
\end{lstlisting}%$

Позвольте мне повторить, на интуитивном уровне, Enumerator трансформирует Iteratee из его исходного состояния в новое состояние, скармливая ему данные. Для того, чтобы использовать эту функцию, мы можем написать:

\begin{lstlisting}
run_ (applyEnum sum10 sum6) >>= print
\end{lstlisting}

Здесь результат 55, точно такой, какой мы ожидали. Но теперь мы видим одно из преимуществ enumerator: мы можем использовать несколько источников данных. Допустим, у нас есть еще один enumerator:

\begin{lstlisting}
sum11 :: Monad m => Enumerator Int m Int
sum11 (Continue k) = k $ Chunks [11..20]
sum11 step = returnI step
\end{lstlisting}%$

Тогда мы можем просто применить оба enumerator:

\begin{lstlisting}
run_ (applyEnum sum11 $ applyEnum sum10 sum6) >>= print
\end{lstlisting}%$

И мы получим результат 210. (Да, (1 + 20) * 10 = 210), но не волнуйтесь, вам не нужно писать функцию applyEnum самим: enumerator предоставляет оператор \lstinline'\$\$', который делает то же самое. Его сигнатура типа немного страшнее, так как это обобщение applyEnum, но он работает так же, и даже делает код более читабельным:

\begin{lstlisting}
run_ (sum11 $$ sum10 $$ sum6) >>= print
\end{lstlisting}%$

\lstinline'\$\$' это синоним для \lstinline'==<<', который просто \lstinline'flip >>=='. Я нахожу \lstinline'\$\$' наиболее читаемым, но для вас это может быть по другому.

Некоторые встроенные enumerator

Конечно, писать целую функцию только для того, что бы передать несколько чисел нашей функции суммирования кажется несколько утомительным. Мы могли бы легко сделать список аргументом функции:

\begin{lstlisting}
sum12 :: Monad m => [Int] -> Enumerator Int m Int
sum12 nums (Continue k) = k $ Chunks nums
sum12 _ step = returnI step
\end{lstlisting}%$

Но в нашей функции нет ничего Int специфичного и мы могли бы её легко обобщить до:

\begin{lstlisting}
genericSum12 :: Monad m => [a] -> Enumerator a m b
genericSum12 nums (Continue k) = k $ Chunks nums
genericSum12 _ step = returnI step
\end{lstlisting}%$

А в самом деле, в пакете enumerator есть встроеная функция enumList, которая это делает. Функция enumList также принимает аргумент типа Integer, который указывает максимальное количество элементов в блоке. Например, мы можем написать:

\begin{lstlisting}
run_ (enumList 5 [1..30] $$ sum6) >>= print
\end{lstlisting}%$

(Если вы считаете, то результатом будет 465.) Первый аргумент enumList никогда не должен влиять на результат, хотя он может иметь некоторое влияние на производительность.

Data.Enumerator включает в себя два других enumerators: enumEOF просто передает EOF в iteratee. concatEnums немного более интересный, он обьединяет несколько enumerator вместе. Например:

\begin{lstlisting}
run_ (concatEnums
        [ enumList 1 [1..10]
        , enumList 1 [11..20]
        , enumList 1 [21..30]
        ] $$ sum6) >>= print
\end{lstlisting}%$

Это тоже выведет 465.

Не чистый вход

Использование enumerator гораздо интереснее, если иметь дело не только с чистыми значениями. В первой части этого руководства, мы привели пример ввода чисел пользователем в командной строке:

\begin{lstlisting}
getNumber :: IO (Maybe Int)
getNumber = do
    x <- getLine
    if x == "q"
        then return Nothing
        else return $ Just $ read x

sum2 :: IO Int
sum2 = do
    maybeNum <- getNumber
    case maybeNum of
        Nothing -> return 0
        Just num -> do
            rest <- sum2
            return $ num + rest
\end{lstlisting}%$

Мы говорили об этом как о модели вытягивания данных: sum2 вытаскивал каждое значению из getNumber. Давайте посмотрим, сможем ли мы переписать getNumber так, что бы она была в роли толкателя (pusher), а не пасивного источника (pullee).

\begin{lstlisting}
getNumberEnum :: MonadIO m => Enumerator Int m b
getNumberEnum (Continue k) = do
    x <- liftIO getLine
    if x == "q"
        then continue k
        else k (Chunks [read x]) >>== getNumberEnum
getNumberEnum step = returnI step
\end{lstlisting}

Во-первых, обратите внимание, что мы проверяем какой нам передали конструктор, и только в случае Continue осуществляем какие либо действия. Если это был Continue, мы получим строку ввода от пользователя. Если получили "q" (наш сигнал окончания ввода), то ничего не делаем. Вы, наверное, подумали, что мы должны вернуть EOF. Но если бы мы это сделали, мы бы предотвратили передачу других данных этой iteratee. Вместо этого, мы просто возвращаем исходное значение Step.

Если строка была не "q", мы превращаем её в Int через read, создаём значение Stream с типом данных Chunks, и передаём его \lstinline'k'. (Если бы мы хотели, всё делать правильно, мы бы проверили, на самом ли деле \lstinline'x' это Int и использовали конструктор Error; я оставляю это в качестве упражнения для читателя.) А сейчас, давайте посмотрим на сигнатуру типа:

\begin{lstlisting}
k (Chunks [read x]) :: Iteratee Int m b
\end{lstlisting}

Если бы мы просто отбросили остаток линии, наша программа прошла бы проверку соответствия типов. Однако, она читала бы только одно значение из командной строки; \lstinline'==>>' getNumberEnum заставляет наш enumerator зацикливаться.

И последнее, что следует отметить о нашей функции: обратите внимание на \lstinline'b' в сигнатуре типа.

\begin{lstlisting}
getNumberEnum :: MonadIO m => Enumerator Int m b
\end{lstlisting}

Оно говорит, что наш Enumerator может скармливать Int любому Iteratee принемающему Int, и не имеет значения, какой тип будет у окончательного вывода. Это обычная манера работы enumerator, что позволяет создавать совершенно разные iteratee, которые работают с одними и теми же enumerator:

\begin{lstlisting}
intsToStrings :: (Show a, Monad m) => Iteratee a m String
intsToStrings = (unlines . map show) `fmap` consume
\end{lstlisting}

И после этого обе следуюющие строки работают:

\begin{lstlisting}
run_ (getNumberEnum $$ sum6) >>= print
run_ (getNumberEnum $$ intsToStrings) >>= print
\end{lstlisting}%$

Enumeratee

Заключительной частью головоломки является Enumeratee. Это сочетание Iteratee (он потребляет некоторые данные) и Enumerator (передает свои данные). Его можно рассматривать как трансформатор потока, или, как конвеер соединяющий Enumerator с Iteratee.

Обобщяя getNumberEnum

Раньше мы создали функцию getNumberEnum с сигнатурой типа:

\begin{lstlisting}
getNumberEnum :: MonadIO m => Enumerator Int m b
\end{lstlisting}

Если вы не помните, то это означает, что getNumberEnum производит поток Int. В частности, наша функция getNumberEnum читает строки из стандартного ввода, преобразовывает их в Int и скармливает их в iteratee. Она перестёт читать строки, когда встречает "q". 

Но кажется, что эта функциональность, может быть полезна и вне области Int. Например, мы можем захотеть работать с оригинальными String, или Bool, или множеством других типов. Так мы можем легко определить более обобщенную функцию, которая просто не делает преобразования String в Int:

\begin{lstlisting}
lineEnum :: MonadIO m => Enumerator String m b
lineEnum (Continue k) = do
    x <- liftIO getLine
    if x == "q"
        then continue k
        else k (Chunks [x]) >>== lineEnum
lineEnum step = returnI step
\end{lstlisting}

Круто, давайте используем это с нашей функции sumIter (я переименовал функции sum6 из двух предыдущих частей):
\begin{lstlisting}
lineEnum $$ sumIter
\end{lstlisting}%$

На самом деле, это проходит проверку типа: lineEnum производит String, а sumIter хочет Int. Нам нужно как-то изменить одну из них.

\begin{lstlisting}
sumIterString :: Monad m => Iteratee String m Int
sumIterString = Iteratee $ do
    innerStep <- runIteratee sumIter
    return $ go innerStep
  where
    go :: Monad m => Step Int m Int -> Step String m Int
    go (Yield res _) = Yield res EOF
    go (Error err) = Error err
    go (Continue k) = Continue $ \strings -> Iteratee $ do
        let ints = fmap read strings :: Stream Int
        step <- runIteratee $ k ints
        return $ go step
\end{lstlisting}%$

То что мы тут сделали, это обернули вокруг оригинального iteratee. Как обычно, нам в первую очередь необходимо развернуть конструктор Iteratee и монаду, чтобы добраться до сердца значения Step. Как только мы получим значение innerStep, мы передаем его функции go, которая просто преобразовывает значения в значении Stream, из String в Int.

Ещё общее

Конечно, было бы неплохо, если бы мы могли применить это преобразование к *любой* iteratee. Для начала, давайте просто передадим внутренний iteratee и отображающюю функции в качестве параметров.

\begin{lstlisting}
mapIter :: Monad m => (aOut -> aIn) -> Iteratee aIn m b -> Iteratee aOut m b
mapIter f innerIter = Iteratee $ do
    innerStep <- runIteratee innerIter
    return $ go innerStep
  where
    go (Yield res _) = Yield res EOF
    go (Error err) = Error err
    go (Continue k) = Continue $ \strings -> Iteratee $ do
        let ints = fmap f strings
        step <- runIteratee $ k ints
        return $ go step
\end{lstlisting}%$

Это можно вызывать так:

\begin{lstlisting}
run_ (lineEnum $$ mapIter read sumIter) >>= print
\end{lstlisting}%$

Здесь нет ничего особенного, это в общем-то идентично предыдущей версии. Что интересно, это то, что в пакете enumerator есть  функция \lstinline'map', чтобы как раз делать это, но у неё значительно отличается сигнатура типа:

\begin{lstlisting}
map :: Monad m => (ao -> ai) -> Enumeratee ao ai m b
\end{lstlisting}

так как:

\begin{lstlisting}
type Enumeratee aOut aIn m b = Step aIn m b -> Iteratee aOut m (Step aIn m b)
\end{lstlisting}

это еквивалентно:

\begin{lstlisting}
map :: Monad m => (aOut -> aIn) -> Step aIn m b -> Iteratee aOut m (Step aIn m b)
\end{lstlisting}

К чему всё это дополнительное усложнение сигнатуры типа? Это не является необходимым для самой \lstinline'map', но это необходимо для целой кучи других подобных функций. Но давайте на секунду сосредоточимся на \lstinline'map', чтобы мы не заблудились: первый аргумент это та же старая отображающая функция, что была раньше. Вторым аргументом является значение Step. Это не так уж удивительно: в нашей mapIter, мы взяли Iteratee с теми же параметрами, и внутренне просто развернул его в Step.

Но что происходит с возвращаемым значением? Помня о значении всех этих типов данных, это Iteratee которому будет подаваться поток aOut и который будет возвращать Step (aka, новый iteratee, правда?). Этот вроде как имеет интуитивный смысл: мы ввели посредника, который принимает ввод от одного источника и преобразует Step в новое состояние.

А теперь, возможно, самая сложная часть всего этого: как мы можем использовать эту функцию \lstinline'map'? Оказывается, что Enumeratee достаточно близок по сигнатуре типа к Enumerator, что мы можем просто сделать:

\begin{lstlisting}
map read $$ sumIter
\end{lstlisting}%$

Но сигнатура типа оказывается немного странной:

\begin{lstlisting}
Iteratee String m (Step Int m Int)
\end{lstlisting}

Помня, что Iteratee просто завёрнутый Step, мы имеем здесь iteratee, который принимает String и возвращает Iteratee, который, в свою очередь принимает Int и производит Int. Этот причудливый результат позволяет сделать один из наших великих трюков с iteratee: подключить данные из нескольких источников. Например, мы могли бы подключить несколько String к этой уродливой вещи, запустить её, получить новый iteratee который получает Int, скармливает эти Int и получает результат Int.

(Если это всё прошло мимо ваших ушей, не волнуйтесь. Я больше не буду говорить о таких вещах.)

Но зачастую, нам не нужна все эта мощь. Мы просто хотим прилепить наш enumeratee к нашему iteratee и получить новый iteratee. В нашем случае, мы хотим присоединить нашу \lstinline'map' к sumIter для получения нового iteratee, которая принимает String и возвращает Int. Для того, чтобы это сделать, нам нужна функция подобная этой:

\begin{lstlisting}
unnest :: Monad m => Iteratee String m (Step Int m Int) -> Iteratee String m Int
unnest outer = do -- используем экземпляр Monad для Iteratee
    inner <- outer -- inner :: Step Int m Int
    go inner
  where
    go (Error e) = throwError e
    go (Yield x _) = yield x EOF
    go (Continue k) = k EOF >>== go
\end{lstlisting}

Мы можем запустить наш полнейший беспорядок так:

\begin{lstlisting}
run_ (lineEnum $$ unnest $ map read $$ sumIter) >>= print
\end{lstlisting}%$

На самом деле функция unnest доступна в Data.Enumerator, и там она называется joinI. Таким образом, мы действительно должны писать:

\begin{lstlisting}
run_ (lineEnum $$ joinI $ map read $$ sumIter) >>= print
\end{lstlisting}%$

Пропуск значений

Давайте напишем чуть более интересный enumeratee: этот пропускает входные значения через одно.

\begin{lstlisting}
skip :: Monad m => Enumeratee a a m b
skip (Continue k) = do
    x <- head
    _ <- head -- это мы пропускаем
    case x of
        Nothing -> return $ Continue k
        Just y -> do
            newStep <- lift $ runIteratee $ k $ Chunks [y]
            skip newStep
skip step = return step
\end{lstlisting}%$

Что интересно в этом подходе, это то как он похож на Enumerator. Мы делаем много тех же вещей: проверяем, или значение Step это Continue; если это не так, то просто возвращаем его. Затем мы пользуемся тем, что Iteratee является экземпляром Monad, используя функцию head извлекаем два значения из потока. Если данных больше нет, мы возвращаем исходное значение Continue: как и с Enumerator, мы не возвращаем EOF, чтобы мы позже смогли скормить ещё данные в iteratee. Если есть данные, мы передаем их в iteratee, получаем наше новое значение Step, и затем зацикливаемся.

И то, что круто в enumeratee это то, что мы можем сцеплять всё вместе:

\begin{lstlisting}
run_ (lineEnum $$ joinI $ skip $$ joinI $ map read $$ sumIter) >>= print
\end{lstlisting}%$

Здесь мы читаем строки, пропускаем каждую вторую, преобразуем String в Int и суммируем.

Примеры из жизни: пакет http-enumerator

Я начал работать на этим руководством, во время работы над пакетом http-enumerator. Я думаю, что использование enumeratee даёт отличное объяснение преимуществ, которые они могут предложить в реальной жизни. Существуют три различных способа разбить тело ответа:

* Блочное кодирование. В этом случае веб-сервер возвращает шестнадцатеричную строку, определяющую длину следующего блока, а затем этот блок. В конце концов, он отправляет 0, чтобы указать конец этого ответа.
* Длинна содержимого. Здесь, веб-сервер отправляет перед телом ответа заголовок, указывающий полную длину тела.
* Ничего не делать. В этом случае, тело ответа длится до конца файла.

Кроме того, тело может быть и не быть запаковано GZIP. В конечном итоге мы остаёмся со следующими enumeratee, каждый с сигнатурой типа \lstinline'Enumeratee ByteString ByteString m b': chunkedEncoding, contentLength и ungzip. Затем мы должны сжелать что-то похожее на:

\begin{lstlisting}
let parseBody x =
        if ("transfer-encoding", "chunked") `elem` responseHeaders
            then joinI $ chunkedEncoding $$ x
            else case mlen of
                    Just len -> joinI $ contentLength len $$ x
                    Nothing -> x -- вообще не применяем ни один enumeratee
let decompress x =
        if ("content-encoding", "gzip") `elem` responseHeaders
            then joinI $ ungzip $$ x
            else x
run_ $ socketEnumerator $$ parseBody $ decompress $ bodyIteratee
\end{lstlisting}%$

Мы создаем цепочку: данные с сервера поступает в функцию parseBody. В случае блочного кодирования, данные обрабатываются соответствующим образом, и затем заголовки отфильтровуються. Если мы имеем дело с длинной содержимого, то считываем только указанное количество байт. А в случае, ни одного из этих вариантов, parseBody является пустой операцией (no-op).

В любом случае, тело ответа затем скармливаеться decompress. Если тело запаковано GZIP, то ungzip распаковывает его, в противном случае decompress является пустой операцией. Наконец, разобранные и распакованые данные скармливаются в поставляемую пользователем функцию bodyIteratee. Пользователь остается в блаженном неведении о шагах которые потребовались, чтобы доставить ему данные.

Упражнения

1. Написать enumeratee который принимает шестнадцатеричные символы (например, "DEADBEEF"), и записывает их в Word8. Его сигнатура типа должна быть \lstinline'Enumeratee Char Word8 m b'.
2. Написать противоположный enumeratee, например \lstinline'Enumeratee Word8 Char m b'.
3. Создать тест quickcheck, который проверяет, что эти две функции работают правильно.

Выводы

* Enumeratee является конвеером связывающим enumerator с iteratee.
* Странная сигнатура типа Enumeratee скрывает множество мощных возможностей. Особенно обратите внимание, как схожа его сигнатура типа с Enumerator.
* Вы можете слить Enumeratee в Iteratee используя \lstinline'joinI \$ enumeratee \$\$ iteratee'.
* Не забывайте, что вы можете использовать экземпляр Monad для Iteratee при создании собственных enumeratees.
* Вы всегда можете составить несколько enumeratee вместе, как например в http-enumerator.
