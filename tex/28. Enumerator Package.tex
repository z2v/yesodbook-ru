Пакет Enumerator

В связи с тем, что Yesod перешел на использование пакета conduits, эта глава больше не соответствует нынешнему Yesod. Она сохранена в качестве справки для тех, кто до сих пор используют enumerators.

Одной из развивающихся моделей в Haskell является enumerators. Они предназначены для решения проблем производства, изменения и потребления потоков данных. Enumerators считаются немного пугающиим, возможно, потому что:

* Существует несколько реализаций, все с несколько различными подходами.
* Некоторые из этих реализаций (на мой взгляд) используют сбивающюю с толку систему именования.
* Как правило, существующие руководства не нацелены непосредственно на конкретную реализацию, а больше работают на развитием интуиции, и не дают инструкции, как использовать библиотеку.

Инфраструктура Йесод использует enumerators за кулисами во многих местах: в WAI/Warp для работы с телами запроса и ответа, в Persistent для получения результатов запроса к базе данных, и в различных сторонних пакетах, таких как http-enumerator и xml-enumerator. Мы всегда используем пакет enumerators. Этот пакет является темой этой главы.

Эта глава состоит из трех основных разделов, каждый рассматривающий одно из основных понятий:

* Начнем с iteratees, которые являются потребителями (consumers). Им скармливаются данные и они что-то с ними делают.
* Далее мы рассмотрим enumerators, которые являются производителями (producers). Они скармливают данные iteratee.
* Наконец, мы рассмотрим enumeratees. Это трубы (pipes), которые получают данные от enumerators и в свою очередь передают их iteratee.

Вы можете быть удивлены, почему мы возиться с этим, когда большинство из этих проблем могут быть решены ленивым I/O. Основная проблема с ленивым I/O это его недетерминизм. Для получения дополнительной информации, то лучше пойти на оригинальный источник по этой теме: Олег.

Iteratees


Iteratee является потребителем данных. Это центральный тип пакета enumerator, на котором основаны другие типы.

Интуиция

Предположим, что мы хотим написать функцию, которая суммирует числа в списке. Пренебрёгши неинтересными деталями, такими как требованими к памяти, вполне хорошей реализацией будет:

\begin{lstlisting}
sum1 :: [Int] -> Int
sum1 [] = 0
sum1 (x:xs) = x + sum1 xs
\end{lstlisting}

Но давайте допустим, что у нас нету списка числа. Вместо этого, пользователь может вводить цифры в командной строке, и нажать "q", когда закончит. Другими словами, у нас есть такая функция:

\begin{lstlisting}
getNumber :: IO (Maybe Int)
getNumber = do
    x <- readLine
    if x == "q"
        then return Nothing
        else return $ Just $ read x
\end{lstlisting}

Мы можем написать новую функцию суммы так:

\begin{lstlisting}
sum2 :: IO Int
sum2 = do
    maybeNum <- getNumber
    case maybeNum of
        Nothing -> return 0
        Just num -> do
            rest <- sum2
            return $ num + rest
\end{lstlisting}

Это довольно неудобно быть винужденным писать две разные функции суммы только потому, что изменился наш источник данных. В идеале, мы бы хотели немного обобщить сущности. Начнем с того, что выделим сходство между этими двумя функциями: они обе возвращают значения только когда чисел больше нет. В случае sum1 мы проверяем пустой ли список, в sum2 мы проверяем на Nothing.

Тип данных Stream

Первый тип данных определеный в пакете enumerator:

\begin{lstlisting}
data Stream a = Chunks [a] | EOF
\end{lstlisting}

Конструктор EOF означает, что больше нет доступных данных. Конструктор Chunks просто позволяет нам поместить несколько частей данных вместе для повышения эффективности. Теперь мы можем переписать sum2 используя тип данных Stream:

\begin{lstlisting}
getNumber2 :: IO (Stream Int)
getNumber2 = do
    maybeNum <- getNumber -- using the original getNumber function
    case maybeNum of
        Nothing -> return EOF
        Just num -> return $ Chunks [num]

sum3 :: IO Int
sum3 = do
    stream <- getNumber2
    case stream of
        EOF -> return 0
        Chunks nums -> do
            let nums' = sum nums
            rest <- sum3
            return $ nums' + rest
\end{lstlisting}

Нельзя сказать, что это гораздо лучше, чем sum2, но по крайней мере это демонстрирует, как использовать тип данных Stream. Здесь проблема в том, что мы по-прежнему явно ссылаемся на функцию getNumber2, жёстко задавая источник данных.

Одним из возможных решений будет сделать источник данных аргументом функции суммы, а именно:

\begin{lstlisting}
sum4 :: IO (Stream Int) -> IO Int
sum4 getNum = do
    stream <- getNum
    case stream of
        EOF -> return 0
        Chunks nums -> do
            let nums' = sum nums
            rest <- sum4 getNum
            return $ nums' + rest
\end{lstlisting}

Это все хорошо, но давайте представим, что мы хотим иметь два источника данных для суммирования: значения которые пользователь вводит в командной строке, и,  допустим, числа которые мы читаем через соединение HTTP. Здесь перед нами проблема управления: sum4 управляет процессом вызывая getNum. Это модель вытягивания данных (pull data model). В enumerators используется модель инверсии управления, или же модель продавливания (inversion of control/push model), назначая ответсвенным за это enumerator. Это позволяет делать классные вещи, наподобии потребления данных из нескольких источников данных, а также становится проще писать enumerators, которые правильно работают с выделением (распределением) ресурсов.

Тип данных Step

Итак нам нужен новый тип данных, которые будут представлять состояние нашей операции суммирования. Мы позволим нашей операции находиться в одном из трех состояний:

* В ожидании новых данных.
* С уже подсчитаным результатом.
* Для удобства, мы также имеем состояние ошибки. Это не обязательно (например это состояние может быть смоделировано выбором монады вида EitherT), но это проще.

Как вы могли догадаться, эти состояния будут соответствовать трём конструкторам типа данных Step. Состояние ошибки моделируется с помощью Error SomeException, построеном на расширяемой системе исключений Haskell. Вот уже рассчитаный конструктор:

\begin{lstlisting}
Yield b (Stream a)
\end{lstlisting}

Здесь, a это вход для нашего iteratee, а b это выход. Этот конструктор позволяет одновременно произвести результат и сохранить "остатки" входных данных для другого iteratee, который может работать после нас. (Это не происходит в случае функции суммы, которая всегда потребляет все входные данные, но мы увидим и другие примеры, которые не потребляют все данные.)

Теперь вопрос заключается в том, как представлять состояние iteratee который ждёт дополнительных данных. Сперва вы можете захотеть объявить некоторый тип данных, чтобы представлять внутреннее состояние и передавать его каким-то образом. Но это не так, как оно сделано: вместо этого мы просто используем функцию (весьма в стиле Haskell, не так ли?):

\begin{lstlisting}
Continue (Stream a -> Iteratee a m b)
\end{lstlisting}

Эврика! Мы наконец увидели тип данных Iteratee! На самом деле, Iteratee очень скучный тип, который присутствует только для того, чтобы мы могли объявить крутые екземпляры (например, Monad) для наших функций. Iteratee определяется как:

\begin{lstlisting}
newtype Iteratee a m b = Iteratee (m (Step a m b))
\end{lstlisting}

А целиком тип данных Step выглядет так:

\begin{lstlisting}
data Step a m b = Error SomeException 
                | Yield b (Stream a) 
                | Continue (Stream a -> Iteratee a m b)
\end{lstlisting}

Это важно: Iteratee это просто newtype обертка вокруг Step завёрнутого в монаду. Просто имейте это в виду, когда будете смотреть на определения в пакете enumerator. Таким образом, зная это, мы можем представлять себе конструктор Continue как:

\begin{lstlisting}
Continue (Stream a -> m (Step a m b))
\end{lstlisting}

К этому определению гораздо легче подойти: эта функция берёт некоторое количество входных данных и возвращает новое состояние iteratee. Давайте посмотрим, как будет выглядеть наша функция суммы используя тип данных Step:

\begin{lstlisting}
sum5 :: Monad m => Step Int m Int -- вход Int, любая монада, выход Int
sum5 =
    Continue $ go 0 -- обычный подход, всегда начинайте с Continue
  where
    go :: Monad m => Int -> Stream Int -> Iteratee Int m Int
    -- Сложить новые входные данные с текущей суммой и создать новый Continue
    go runningSum (Chunks nums) = do
        let runningSum' = runningSum + sum nums
        -- Следующая строчка *страшная*, но хорошо, что есть 
        -- вспомогательные функции, что бы сделать это яснее.
        -- Больше про это ниже.
        Iteratee $ return $ Continue $ go runningSum'
    -- Произвести конечный результат
    go runningSum EOF = Iteratee $ return $ Yield runningSum EOF
\end{lstlisting}

Для того, чтобы запустить этот код, вы можете использовать run_ $ enumList 8 [1 .. 10] sum5. Но это использует чёрную магию Enumerator которую мы рассмотрим позже.

Первая действительная строка (Continue $ go 0) инициализирует наш iteratee в начальное состояние. Как и все другие функции суммирования мы должны явно заявить, что мы начинаем с 0. Настоящая рабочая лошадка это функция go. Обратите внимание, как мы передаём состояние iteratee в качестве первого аргумента go: это тоже очень распространенная подход в iteratees.

Мы должны обрабатывать два разных случая: когда получили EOF, функция go должна произвести значение Yield. (Она также может произвести Error, но определенно не может Continue.) В этом случае, мы просто возвращаем текущую сумму и говорим, что данных не осталось. Когда мы получаем некоторые входные данные с помощью Chunks, мы просто складываем их с текущей суммой и создаём новое Continue основаное на той же функции go.

Давайте теперь поработаем над тем, что бы сделать эту функцию немного красивее с помощью встроенных вспомогательных функций. Конструкция Iteratee . return достаточно обычна, чтобы оправдать вспомогательную функцию, а именно:

\begin{lstlisting}
returnI :: Monad m => Step a m b -> Iteratee a m b
returnI = Iteratee . return
\end{lstlisting}

Так к примеру,

\begin{lstlisting}
go runningSum EOF = Iteratee $ return $ Yield runningSum EOF
\end{lstlisting}

становится

\begin{lstlisting}
go runningSum EOF = returnI $ Yield runningSum EOF
\end{lstlisting}

Но даже это достаточно обычно, что бы захотеть вспомогательную функцию:

\begin{lstlisting}
yield :: Monad m => b -> Stream a -> Iteratee a m b
yield x chunk = returnI $ Yield x chunk
\end{lstlisting}

так наша строка становиться

\begin{lstlisting}
go runningSum EOF = yield runningSum EOF
\end{lstlisting}

Таким же образом,

\begin{lstlisting}
Iteratee $ return $ Continue $ go runningSum'
\end{lstlisting}

становиться

\begin{lstlisting}
continue $ go runningSum'
\end{lstlisting}

Екземпляр монады для Iteratee

Это все очень хорошо: теперь у нас есть iteratee, которому могут скармливаться числа из любой монады и он может их сложить. Он может даже брать входные данные из различных источников, и складывать их вместе. (Кстати, я на самом деле ещё не показал вам, как скармливать эти числа: об этом во второй части, про enumerators) Но давайте будем честными: sum5 является уродливой функцией. Разве нельзя написать как нибудь попроще?

На самом деле, можно. Помните, как я уже говорил, что Iteratee на самом деле существуют просто чтобы облегчить определение екземпляров классов типа? Это включает в себя и екземпляр монады. Вы можете посмотреть код, чтобы увидеть, как этот екземпляр определён, но здесь мы просто покажем, как это можно использовать:

\begin{lstlisting}
sum6 :: Monad m => Iteratee Int m Int
sum6 = do
    maybeNum <- head -- это не функция head из Prelude!
    case maybeNum of
        Nothing -> return 0
        Just i -> do
            rest <- sum6
            return $ i + rest
\end{lstlisting}

Эта функция head не из Prelude, она из модуля Data.Enumerator. Вот её сигнатура типа:

\begin{lstlisting}
head :: Monad m => Iteratee a m (Maybe a)
\end{lstlisting}

которая в общем означает, дай мне следующую часть входных данных, если они есть. Чуть позже мы рассмотрим эту функцию более подробно.

Сравните код sum6 и sum2: они удивительно похожи. Часто можно строить более сложные iteratees с помощью простых iteratees и экземпляра Monad для Iteratee.

Чередующийся(Вложенный) I/O

Хорошо, давайте рассмотрим совершенно другую проблему. Мы хотим, считывать строки с входных данных, и выводить их по одной на экран. Один из подходов заключается в использовании ленивого I/O:

\begin{lstlisting}
lazyIO :: IO ()
lazyIO = do
    s <- lines `fmap` getContents
    mapM_ putStrLn s
\end{lstlisting}

Но это решение имеет два недостатка:

* Оно привязано к одному источнику данных, стандартный ввод. Это ограничение можно обойти аргументом, указывающим источник данных.
* Но, допустим, в качестве источника данных используется некоторый ограниченный ресурс (представте себе дескрипторы файлов на очень загруженном веб-сервере). С ленивым I/O у нас нет никаких гарантий, когда эти дескрипторы файлов будут освобождены.

Давайте рассмотрим, как написать это в нашем новом высокоуровневом монадическом подходе iteratee:

\begin{lstlisting}
interleaved :: MonadIO m => Iteratee String m ()
interleaved = do
    maybeLine <- head
    case maybeLine of
        Nothing -> return ()
        Just line -> do
            liftIO $ putStrLn line
            interleaved
\end{lstlisting}

Функция liftIO из пакета трансформаторов, она просто продвигает действие в монаде IO в любое произвольное действие в MonadIO. Обратите внимание, что мы не отслеживаем состояние в этом iteratee: мы не заботимся о результате, только о побочных эффектах.

Реализация head

В качестве последнего примера, давайте попробуем реализовать функцию head.

\begin{lstlisting}
head' :: Monad m => Iteratee a m (Maybe a)
head' =
    continue go
  where
    go (Chunks []) = continue go
    go (Chunks (x:xs)) = yield (Just x) (Chunks xs)
    go EOF = yield Nothing EOF
\end{lstlisting}

Как и наша функция sum6, она тоже оборачивает внутреннюю функцию "go" используя continue. Однако, теперь у нас есть три условия для нашей функции go. Первый обрабатывает случай пустых блоков (Chunks []). Цитируя документацию enumerator:

(Chunks []) используется для обозначения того, что поток по-всё ещё активный, но в настоящее время нет данных. Iteratees должны игнорировать пустые блоки.

Второй вариант обрабатывает случай, когда нам даны некоторые данные. В этом случае мы возвращаем первый элемент списка, и остатки. Третий пункт обрабатывает конец ввода, возвращая Nothing.

Enumerators

В то время как Iteratee является потребителем (consumer), Enumerator является производителем (producer). На высоком уровне, Enumerator яаляется в действительности трансформатором Iteratee, переводя Iteratee из одного состояния в новое. Давайте посмотрим, как это работает.

Извлекая значение

Мы уже написали несколько iteratees, но мы до сих пор не знаем, как из них извлекать значения. Для начала, давайте вспомним, что Iteratee это просто newtype обертка вокруг Step:

\begin{lstlisting}
newtype Iteratee a m b = Iteratee { runIteratee :: m (Step a m b) }
\end{lstlisting}

Давайте развернём Iteratee, что бы иметь дело со значением Step внутри. Также вспомним, что для типа Step есть три конструктора: Continue, Yield и Error. Мы будем обрабатывать конструктор Error, возвращая наш результат в Either. Yield уже содержит данные, которые мы ищем.

Сложный случай с Continue: здесь, у нас есть iteratee, которй  ожидает больше данных. Здесь на помощь приходит конструктор EOF: это наш маленький способ сказать iteratee закончить то, что он делает, и продолжить нашу работу. Если вы помните, выше я сказал, что правильно реализованый (воспитаный) iteratee никогда не вернет Continue после получения EOF; сейчас мы увидим, почему:

\begin{lstlisting}
extract :: Monad m => Iteratee a m b -> m (Either SomeException b)
extract (Iteratee mstep) = do
    step <- mstep
    case step of
        Continue k -> do
            let Iteratee mstep' = k EOF
            step' <- mstep'
            case step' of
                Continue _ -> error "Misbehaving iteratee"
                Yield b _ -> return $ Right b
                Error e -> return $ Left e
        Yield b _ -> return $ Right b
        Error e -> return $ Left e
\end{lstlisting}

К счастью, вам не нужно переопределять это самостоятельно: enumerator содержит обе функции run и run_. Давайте пойдем дальше и воспользуемся этим в нашей sum6 функции:

\begin{lstlisting}
main = run_ sum6 >>= print
\end{lstlisting}

Если вы исполните это, то результат будет 0. Это подчеркивает один важный момент: iteratee не только то как для обрабатывать входные данные, это ещё и состояние обработки. В этом случае, мы не сделали ничего, чтобы изменить начальное состояние sum6, так что у нас еще начальное значение 0.

Чтобы дать аналогию: представте iteratee как такую машину. Когда вы вводите в неё данные, вы измененяете её внутреннее состояние, но вы не видите всех этих изменений снаружи. Когда же вы закончили ввод, вы нажимаете кнопку, и она выдаёт результат. Если вы не вводили никаких данных, ваш результат в начальном состоянии.

Добавление данных

Давайте предположим, что мы действительно хотим найти сумму некоторых чисел. Например, числа от 1 до 10. Мы должны каким-то образом скормить их нашему sum6 iteratee. Для того, чтобы как-то подойти к этому, нам опять нужно развернуть наш Iteratee и работать со значеним Step напрямую.

В нашем случае, мы точно знаем, что конструктор Step, который мы использовали это Continue, так что можно безопасно записать нашу функцию как:

\begin{lstlisting}
sum7 :: Monad m => Iteratee Int m Int
sum7 = Iteratee $ do
    Continue k <- runIteratee sum6
    runIteratee $ k $ Chunks [1..10]
\end{lstlisting}

Но в общем случае, мы не будем знать какой конструктор будет лежать в ожидании нас. Мы должны как положено обработать Continue, Yield и Error. Мы увидели, что делать с Continue: скормить ему данные. С Yield и Error, в общем правильным действием будет ничего не делать, поскольку мы уже прибыли в наш конечное состояние (или успешный Yield или Error). Таким образом, "правильный" способ записи функции выше:

\begin{lstlisting}
sum8 :: Monad m => Iteratee Int m Int
sum8 = Iteratee $ do
    step <- runIteratee sum6
    case step of
        Continue k -> runIteratee $ k $ Chunks [1..10]
        _ -> return step
\end{lstlisting}

Синоним типа Enumerator

То что мы сделали с sum7 и sum8 это выполнили преобразование Iteratee. Но мы сделали это в очень ограниченном виде: мы явно вписали использование орининальной функцию Iteratee (sum6). Мы могли бы сделать её аргументом функции:

\begin{lstlisting}
sum9 :: Monad m => Iteratee Int m Int -> Iteratee Int m Int
sum9 orig = Iteratee $ do
    step <- runIteratee orig
    case step of
        Continue k -> runIteratee $ k $ Chunks [1..10]
        _ -> return step
\end{lstlisting}

Но так как мы всегда просто хотим развернуть значение Iteratee, оказывается, что более естественно сделать аргумент типа Step, а именно:

\begin{lstlisting}
sum10 :: Monad m => Step Int m Int -> Iteratee Int m Int
sum10 (Continue k) = k $ Chunks [1..10]
sum10 step = returnI step
\end{lstlisting}

Эта сигнатура типа (взять Step, вернуть Iteratee) оказывается очень распространенна:

\begin{lstlisting}
type Enumerator a m b = Step a m b -> Iteratee a m b
\end{lstlisting}

Значит сигнатура типа sum10 может быть выражена следующим образом:

\begin{lstlisting}
sum10 :: Monad m => Enumerator Int m Int
\end{lstlisting}

Конечно, нам нужна некоторая вспомогательная функция для связи Enumerator и Iteratee:

\begin{lstlisting}
applyEnum :: Monad m => Enumerator a m b -> Iteratee a m b -> Iteratee a m b
applyEnum enum iter = Iteratee $ do
    step <- runIteratee iter
    runIteratee $ enum step
\end{lstlisting}

Позвольте мне повторить, наша интуиция здесь: Enumerator трпнсформирует Iteratee из его исходного состояния в новое состояние, скармливая ему данные. Для того, чтобы использовать эту функцию, мы можем написать:

\begin{lstlisting}
run_ (applyEnum sum10 sum6) >>= print
\end{lstlisting}

Здесь результат 55, точно тот, что мы ожидали. Но теперь мы видим одно из преимуществ enumerators: мы можем использовать несколько источников данных. Допустим, у нас есть еще один enumerator:

\begin{lstlisting}
sum11 :: Monad m => Enumerator Int m Int
sum11 (Continue k) = k $ Chunks [11..20]
sum11 step = returnI step
\end{lstlisting}

Тогда мы могли бы просто применить оба enumerators:

\begin{lstlisting}
run_ (applyEnum sum11 $ applyEnum sum10 sum6) >>= print
\end{lstlisting}

И мы получили бы результат 210. (Да, (1 + 20) * 10 = 210), но не волнуйтесь, вам не нужно писать функцию applyEnum самим: enumerator  предоставляет оператор $$, который делает то же самое. Его сигнатура типа немного страшнее, так как это обобщение applyEnum, но он работает так же, и даже делает код более читабельным:

\begin{lstlisting}
run_ (sum11 $$ sum10 $$ sum6) >>= print
\end{lstlisting}

$$ это синорим для ==<<, которая просто flip >>==. Я нахожу $$ наиболее читаемым, но для вас это может быть подругому.

Некоторые встроенные enumerators

Конечно, писать целую функцию только что бы передать несколько чисел нашей функции суммы кажется несколько утомительным. Мы могли бы легко сделать список аргументом функции:

\begin{lstlisting}
sum12 :: Monad m => [Int] -> Enumerator Int m Int
sum12 nums (Continue k) = k $ Chunks nums
sum12 _ step = returnI step
\end{lstlisting}

Но в нашей функции нет ничего Int специфичного. Мы могли бы легко её обобщить до:

\begin{lstlisting}
genericSum12 :: Monad m => [a] -> Enumerator a m b
genericSum12 nums (Continue k) = k $ Chunks nums
genericSum12 _ step = returnI step
\end{lstlisting}

И в самом деле, enumerator идёт со встроеной функцией enumList, которая это делает. enumList также принимает аргумент типа Integer, который указывает максимальное количество элементов в блоке. Например, мы можем написать:

\begin{lstlisting}
run_ (enumList 5 [1..30] $$ sum6) >>= print
\end{lstlisting}

(Это произведёт 465, если вы считаете.) Первый аргумент enumList никогда не должен влиять на результат, хотя он может иметь некоторое влияние на производительность.

Data.Enumerator включает в себя два других enumerators: enumEOF просто передает EOF в iteratee. concatEnums немного более интересный, он обьединяет несколько enumerators вместе. Например:

\begin{lstlisting}
run_ (concatEnums
        [ enumList 1 [1..10]
        , enumList 1 [11..20]
        , enumList 1 [21..30]
        ] $$ sum6) >>= print
\end{lstlisting}

Это тоже произведёт 465.

Некоторый не чистый вход

Enumerators гораздо интереснее, если они не просто имеют дело с чистыми значениями. В первой части этого руководства, мы привели пример ввода чисел пользователем в командной строке:

\begin{lstlisting}
getNumber :: IO (Maybe Int)
getNumber = do
    x <- getLine
    if x == "q"
        then return Nothing
        else return $ Just $ read x

sum2 :: IO Int
sum2 = do
    maybeNum <- getNumber
    case maybeNum of
        Nothing -> return 0
        Just num -> do
            rest <- sum2
            return $ num + rest
\end{lstlisting}

Мы говорили об этом как о модели вытягивания данных: sum2 вытаскивал каждое значению из getNumber. Давайте посмотрим, сможем ли мы переписать getNumber так, что бы она была в роли толкателя (pusher), а не пасивного источника (pullee).

\begin{lstlisting}
getNumberEnum :: MonadIO m => Enumerator Int m b
getNumberEnum (Continue k) = do
    x <- liftIO getLine
    if x == "q"
        then continue k
        else k (Chunks [read x]) >>== getNumberEnum
getNumberEnum step = returnI step
\end{lstlisting}

Во-первых, обратите внимание, что мы проверяем какой передали конструктор, и только в случае Continue осуществляем какие либо действия. Если это был Continue, мы получим строку ввода от пользователя. Если строка «q» (наше указание прекратить ввод значений), мы ничего не делаем. Вы, наверное, подумали, что мы должны передать EOF. Но если бы мы это сделали, мы бы предотвратили передачу других данных этой iteratee. Вместо этого, мы просто возвращаем исходное значение Step.

Если строка была не "q", мы превращаем её в Int через read, создаём значение Stream с типом данных Chunks, и передаём его k. (Если бы мы хотели, всё делать правильно, мы бы проверили, на самом ли деле x это Int и использовали конструктора Error; я оставляю это в качестве упражнения для читателя.) На данный момент, давайте посмотрим на сигнатуру типа:

\begin{lstlisting}
k (Chunks [read x]) :: Iteratee Int m b
\end{lstlisting}

Если мы просто отбросим остаток линии, наша программа прошла бы проверку соответствия типов. Однако, она читала бы только одно значение из командной строки; ==>> getNumberEnum заставляет наш enumerator зацикливаться.

И последнее, что следует отметить о нашей функции: обратите внимание на b в сигнатуре типа.

\begin{lstlisting}
getNumberEnum :: MonadIO m => Enumerator Int m b
\end{lstlisting}

Оно говорит, что наш Enumerator может скармливать Ints любому Iteratee принемающему Ints, и не имеет значения, какой тип будет у окончательного вывода. Это обычная манера работы enumerators. Это позволяет создавать совершенно разные iteratees, которые работают с одними и теми же enumerators:

\begin{lstlisting}
intsToStrings :: (Show a, Monad m) => Iteratee a m String
intsToStrings = (unlines . map show) `fmap` consume
\end{lstlisting}

И после этого обе следуюющие линии работают:

\begin{lstlisting}
run_ (getNumberEnum $$ sum6) >>= print
run_ (getNumberEnum $$ intsToStrings) >>= print
\end{lstlisting}

Enumeratees

The final piece in the puzzle is the Enumeratee. This is a combination of an Iteratee (it consumes some data) and an Enumerator (is passes it other data on). It can be thought of as a stream transformer, or as a pipe connecting an Enumerator to an Iteratee.

Generalizing getNumberEnum

Earlier, we created a getNumberEnum function with a type signature:

\begin{lstlisting}
getNumberEnum :: MonadIO m => Enumerator Int m b
\end{lstlisting}

If you don't remember, this means getNumberEnum produces a stream of Ints. In particular, our getNumberEnum function read lines from stdin, converted them to ints and fed them into an iteratee. It stopped reading lines when it saw a "q".

But this functionality seems like it could be useful outside the realm of Ints. We may like to deal with the original Strings, for example, or Bools, or a bunch of other things. We could easily define a more generalized function which simply doesn't do the String to Int conversion:

\begin{lstlisting}
lineEnum :: MonadIO m => Enumerator String m b
lineEnum (Continue k) = do
    x <- liftIO getLine
    if x == "q"
        then continue k
        else k (Chunks [x]) >>== lineEnum
lineEnum step = returnI step
\end{lstlisting}

Cool, let's plug this into our sumIter function (I've renamed the sum6 function from the previous two parts):

lineEnum $$ sumIter

Actually, that doesn't type check: lineEnum produces Strings, and sumIter takes Ints. We need to modify one of them somehow.

\begin{lstlisting}
sumIterString :: Monad m => Iteratee String m Int
sumIterString = Iteratee $ do
    innerStep <- runIteratee sumIter
    return $ go innerStep
  where
    go :: Monad m => Step Int m Int -> Step String m Int
    go (Yield res _) = Yield res EOF
    go (Error err) = Error err
    go (Continue k) = Continue $ \strings -> Iteratee $ do
        let ints = fmap read strings :: Stream Int
        step <- runIteratee $ k ints
        return $ go step
\end{lstlisting}

What we've done here is wrap around the original iteratee. As usual, we first need to unwrap the Iteratee constructor and the monad to get at the heart of the Step value. Once we have that innerStep value, we pass it to the go function, which simply transforms that values in the Stream value from Strings to Ints.

Even more general

Of course, it would be nice if we could apply this transformation to *any* iteratee. To start with, let's just pass the inner iteratee and the mapping function as parameters.

\begin{lstlisting}
mapIter :: Monad m => (aOut -> aIn) -> Iteratee aIn m b -> Iteratee aOut m b
mapIter f innerIter = Iteratee $ do
    innerStep <- runIteratee innerIter
    return $ go innerStep
  where
    go (Yield res _) = Yield res EOF
    go (Error err) = Error err
    go (Continue k) = Continue $ \strings -> Iteratee $ do
        let ints = fmap f strings
        step <- runIteratee $ k ints
        return $ go step
\end{lstlisting}

We could call this like:

\begin{lstlisting}
run_ (lineEnum $$ mapIter read sumIter) >>= print
\end{lstlisting}

Nothing much to see here, it's basically identical to the previous version. What's funny is that enumerator comes built in with a map function to do just this, but it has a significantly different type signature:

\begin{lstlisting}
map :: Monad m => (ao -> ai) -> Enumeratee ao ai m b
\end{lstlisting}

since:

\begin{lstlisting}
type Enumeratee aOut aIn m b = Step aIn m b -> Iteratee aOut m (Step aIn m b)
\end{lstlisting}

that's equivalent to:

\begin{lstlisting}
map :: Monad m => (aOut -> aIn) -> Step aIn m b -> Iteratee aOut m (Step aIn m b)
\end{lstlisting}

What's with all this extra complication in type signature? Well, it's not necessary for map itself, but it is necessary for a whole bunch of other similar functions. But let's focus on this map for a second so we don't get lost: the first argument is the same old mapping function we had before. The second argument is a Step value. This isn't really so surprising: in our mapIter, we took an Iteratee with the same parameters, and we internally just unwrapped it to a Step.

But what's happening with that return value? Remembering the meanings for all these datatypes, it's an Iteratee which will be fed a stream of aOuts and return a Step (aka, a new iteratee, right?). This kind of makes intuitive sense: we've introduced a middle man which accepts input from one source and transforms a Step to a newer state.

But now perhaps the trickiest part of the whole thing: how do we actually use this map function? It turns out that an Enumeratee is close enough in type signature to an Enumerator that we can just do:

\begin{lstlisting}
map read $$ sumIter
\end{lstlisting}

But the type signature on that turns out to be a little bit weird:

\begin{lstlisting}
Iteratee String m (Step Int m Int)
\end{lstlisting}

Remembering that an Iteratee is just a wrapped up Step, what we've got here is an iteratee that takes Strings and returns an Iteratee, which in turn takes Ints and produces an Int. Having this fancy result allows us to do one of our great tricks with iteratees: plug in data from multiple sources. For example, we could plug some Strings into this whole ugly thing, run it, get a new iteratee which takes Ints, feed that some Ints and get an Int result.

(If all that went over your head, don't worry. I won't be talking about that kind of stuff any more.)

But often times, we don't need all of that power. We just want to stick our enumeratee onto our iteratee and get a new iteratee. In our case, we want to attach our map onto the sumIter to produce a new iteratee that takes Strings and returns Ints. In order to do that, we need a function like this:

\begin{lstlisting}
unnest :: Monad m => Iteratee String m (Step Int m Int) -> Iteratee String m Int
unnest outer = do -- using the Monad instance of Iteratee
    inner <- outer -- inner :: Step Int m Int
    go inner
  where
    go (Error e) = throwError e
    go (Yield x _) = yield x EOF
    go (Continue k) = k EOF >>== go
\end{lstlisting}

We can then run our unholy mess with:

\begin{lstlisting}
run_ (lineEnum $$ unnest $ map read $$ sumIter) >>= print
\end{lstlisting}

And actually, the unnest function is available in Data.Enumerator, and it's called joinI. So we should really write:

\begin{lstlisting}
run_ (lineEnum $$ joinI $ map read $$ sumIter) >>= print
\end{lstlisting}

Skipping

Let's write a slightly more interesting enumeratee: this one skips every other input value.

\begin{lstlisting}
skip :: Monad m => Enumeratee a a m b
skip (Continue k) = do
    x <- head
    _ <- head -- the one we're skipping
    case x of
        Nothing -> return $ Continue k
        Just y -> do
            newStep <- lift $ runIteratee $ k $ Chunks [y]
            skip newStep
skip step = return step
\end{lstlisting}

What's interesting about the approach here is how similar it looks to an Enumerator. We're doing a lot of the same things: checking if the Step value is a Continue; if it's not, then simply return it. Then we capitalize on the Iteratee Monad instance, using the head function to pop two values out of the stream. If there's no more data, we return the original Continue value: just like with an Enumerator, we don't give an EOF so that we can feed more data into the iteratee later. If there is data, we pass it off to the iteratee, get our new step value and then loop.

And what's cool about enumeratees is we can chain these all together:

\begin{lstlisting}
run_ (lineEnum $$ joinI $ skip $$ joinI $ map read $$ sumIter) >>= print
\end{lstlisting}

Here, we read lines, skip every other input, convert the Strings to Ints and sum them.

Real life examples: http-enumerator package

I started working on these tutorials as I was working on the http-enumerator package. I think the usage of enumeratees there is a great explanation of the benefits they can offer in real life. There are three different ways the response body can be broken up:

* Chunked encoding. In this case, the web server gives a hex string specifying the length of the next chunk and then that chunk. At the end, it sends a 0 to indicate the end of that response.
* Content length. Here, the web server sends a header before any of the body is sent specifying the total length of the body.
* Nothing at all. In this case, the response body lasts until an end-of-file.

In addition, the body may or may not be GZIP compressed. We end up with the following enumeratees, each with type signature Enumeratee ByteString ByteString m b: chunkedEncoding, contentLength and ungzip. We then get to do something akin to:

\begin{lstlisting}
let parseBody x =
        if ("transfer-encoding", "chunked") `elem` responseHeaders
            then joinI $ chunkedEncoding $$ x
            else case mlen of
                    Just len -> joinI $ contentLength len $$ x
                    Nothing -> x -- no enumeratee applied at all
let decompress x =
        if ("content-encoding", "gzip") `elem` responseHeaders
            then joinI $ ungzip $$ x
            else x
run_ $ socketEnumerator $$ parseBody $ decompress $ bodyIteratee
\end{lstlisting}

We create a chain: the data from the server is fed into the parseBody function. In the case of chunked encoding, the data is processed appropriately and then headers are filtered out. If we are dealing with content length, then only the specified number of bytes are read. And in the case of neither of those, parseBody is a no-op.

Whatever the case may be, the raw response body is then fed into decompress. If the body is GZIPed, then ungzip inflates it, otherwise decompress is a no-op. Finally, the parsed and inflated data is fed into the user-supplied bodyIteratee function. The user remains blissfully unaware of any steps the data took to get to him/her.

Упражнения

1. Написать enumeratee который принимает шестнадцатеричные символы (например, "DEADBEEF"), и записывает их в Word8s. Его сигнатура типа должна быть Enumeratee Char Word8 m b.
2. Написать противоположный enumeratee, например Enumeratee Word8 Char m b.
3. Создать тест quickcheck, который проверяет, что эти две функции работают правильно.

Выводы

* Enumeratees являются конвеером связывающим enumerators с iteratees.
* Странная сигнатура типа Enumeratee скрывает множество мощных возможностей. Особенно обратите внимание, как схожа его сигнатура типа с Enumerators.
* Вы можете слить Enumeratee в Iteratee используя joinI $ enumeratee $$ iteratee.
* Не забывайте, что вы можете использовать экземпляр Monad для Iteratee при создании собственных enumeratees.
* Вы всегда можете составить несколько enumeratees вместе, как например в http-enumerator.
