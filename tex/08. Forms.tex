\chapter{Формы}

Мы уже упоминали граничное условие: когда данные приходят в приложение или покидают его,
мы должны их проверить. Вероятно, наиболее сложная проверка происходит в формах.
Программировать формы --- сложно; в идеальном мире мы хотели бы уметь:

\begin{itemize}
\item убеждаться, что данные валидны; % FIXME: valid --- действительны, годны, зачетны :)
\item преобразовать строковые данные формы в типы данных Haskell; % FIXME: marshal --- ?
\item генерировать код HTML для отображения формы;
\item генерировать Javascript, выполняющий валидацию на стороне клиента и предоставляющий
более дружелюбные виджеты, такие как,например, выбор даты;
\item строить более сложные формы, объединяя вместе более простые;
\item автоматически присваивать полям имена, для которых гарантируется уникальность.
\end{itemize}

Пакет \lstinline'yesod-form' предоставляет все эти возможности с простым декларативным
API. Он строится на виджетах Yesod, чтобы упростить дизайн форм и надлежащее применение
Javascript. И, как и остальной Yesod, использует систему типов Haskell для обеспечения
корректной работы.
% FIXME: styling (of forms) --- дизайн (форм)
% FIXME: род слова Yesod -- мужской? 

\section{Краткий обзор}

% FIXME: род i18n --- женский (интернационализация?)
% FIXME: parsed --- ???
\begin{lstlisting}
{-# LANGUAGE QuasiQuotes, TemplateHaskell, MultiParamTypeClasses,
    OverloadedStrings, TypeFamilies #-}
import Yesod
import Yesod.Form.Jquery
import Data.Time (Day)
import Data.Text (Text)
import Control.Applicative ((<$>), (<*>))

data Synopsis = Synopsis

mkYesod "Synopsis" [parseRoutes|
/ RootR GET
/person PersonR POST
|]

instance Yesod Synopsis

-- Указывает приложению использовать стандартные английские сообщения
-- Если вам нужна i18n, вы можете предоставить функцию перевода
instance RenderMessage Synopsis FormMessage where
    renderMessage _ _ = defaultFormMessage

-- И указывает, где найти библиотеки jQuery. Мы будем использовать значение
-- по умолчанию, указывающее на Google CDN
instance YesodJquery Synopsis

-- Тип данных, который мы хотим получить из формы
data Person = Person
    { personName :: Text
    , personBirthday :: Day
    , personFavoriteColor :: Maybe Text
    , personEmail :: Text
    , personWebsite :: Maybe Text
    }
  deriving Show

-- Объявление формы. Сигнатура типа несколько пугающая, но вот её обзор:
--
-- * Параметр Html используется для кодирования некоторой дополнительной
-- информации. См. обсуждение runFormGet и runFormPost ниже для 
-- дополнительного объяснения
--
-- * Как обычно, у нас есть типы под- и главного сайта
--
-- * FormResult может находиться в трех состояниях: FormMissing (нет
-- доступных данных), FormFailure (некорректные данные) и FormSuccess
--
-- * Widget "--- отображаемая форма для вставки на страницу
--
-- Обратите внимание, что шаблон сайта предоставляет удобный синоним типа
-- Form, так что наша сигнатура может быть переписана как:
-- > personForm :: Form Person
--
-- Для наших целей лучше видеть полную версию
personForm :: Html -> MForm Synopsis Synopsis (FormResult Person, Widget)
personForm = renderDivs $ Person
    <$> areq textField "Name" Nothing
    <*> areq (jqueryDayField def
        { jdsChangeYear = True -- give a year dropdown
        , jdsYearRange = "1900:-5" -- 1900 till five years ago
        }) "Birthday" Nothing
    <*> aopt textField "Favorite color" Nothing
    <*> areq emailField "Email address" Nothing
    <*> aopt urlField "Website" Nothing

-- Обработчик GET-запроса отображает форму
getRootR :: Handler RepHtml
getRootR = do
    -- Generate the form to be displayed
    (widget, enctype) <- generateFormPost personForm
    defaultLayout [whamlet|
<p>The widget generated contains only the contents of the form, not the form tag itself.
So...
<form method=post action=@{PersonR} enctype=#{enctype}>
    ^{widget}
    <p>It also doesn't include the submit button.
    <input type=submit>
|]

-- Обработчик POST-запроса обрабатывает форму. Если обработка успешно 
-- завершилась, он отображает данные переданного человека. Иначе -- снова
-- форму с сообщениями об ошибке.
postPersonR :: Handler RepHtml
postPersonR = do
    ((result, widget), enctype) <- runFormPost personForm
    case result of
        FormSuccess person -> defaultLayout [whamlet|<p>#{show person}|]
        _ -> defaultLayout [whamlet|
<p>Invalid input, let's try again.
<form method=post action=@{PersonR} enctype=#{enctype}>
    ^{widget}
    <input type=submit>
|]

main :: IO ()
main = warpDebug 3000 Synopsis
\end{lstlisting}

\section{Виды форм}

Перед тем, как рассмотреть сами типы, начнем с обзора разных видов форм. Имеются три типа
форм:

\subsection{Аппликативные}
Наиболее широко используемые (они были использованы выше в примере). Аппликативные формы
позволяют нам объединять сообщения об ошибках друг с другом, сохраняя при этом
декларативный высокоуровневый подход. Более детальную информацию об аппликативном подходе
можно почерпнуть в Haskell-вики.

\subsection{Монадические}
Более мощная альтернатива аппликативным. Гибкость достигается за счет несколько большей
многословности. Бывают полезны, если необходимо создать форму, которая не укладывается в
стандартный двухстолбцовый формат.

\subsection{Для ввода}
Используются только для ввода данных. Не генерируют никакого HTML для получения ввода
пользователя. Полезны для взаимодействия с уже существующими формами.

К тому же, существует некоторое число переменных для каждого вида форма, а также поля,
которые вам, возможно, захочется установить:
\begin{itemize}
\item Это поле обязательное или опциональное?
\item Данные должны передаваться методом GET или POST?
\item У него есть значение по-умолчанию или нет?
\end{itemize}

Основная цель заключается в том, чтобы минимизировать число определений полей и позволить
им быть полезными в как можно большем числе контекстов. В следствии этого мы добавляем
несколько слов для каждого поля. В обзоре, вы наверное заметили такие штуки как
\lstinline'areq' и лишний параметр \lstinline'Nothing'. Мы обсудим зачем они нужны в
рамках данной главы, а сейчас пока можете считать, что сделав эти поля явными, мы можем
переиспользовать одиночные поля (как, например, \lstinline'intField') несколькими
различными способами.

Замечание по поводу именования. Каждая форма имеет однобуквенный префикс (A, M или I)
который используется в нескольких местах, как например в \lstinline'MForm'. Мы также
будем использовать \lstinline'req' и \lstinline'opt' для обозначения обязательности и
опциональности соответственно. Так мы можем создавать обязательное аппликативное поле с
помощью \lstinline'areq' или оциональное поле для вода данных и помощью \lstinline'iopt'.

\section{Типы}

Модуль \lstinline'Yesod.Form.Types' определяет несколько типов.Давайте начнем с самых
простых:

\subsection{Enctype}
Тип кодировки: либо \lstinline'UrlEncoded', либо \lstinline'Multipart'. Этот тип данных
имеет инстанс для монады \lstinline'ToHtml', так что вы можете его использовать
непосредственно в \lstinline'Hamlet'.

\subsection{Env}
Отображает имя параметра в список значений.

\subsection{FileEnv}
Отображает имя параметра в соответствующий загруженный файл.

\subsection{Ints}
Как было сказано во введении, формы в yesod автоматически генерируют уникальные имена 
каждому полю. \lstinline'Ints' использоуется для хранения этой информации.

\subsection{FormResult}
Имеет три состояния: \lstinline'FormMissing' если данные не были переданы,
\lstinline'FormFailure' если произошла ошибка при разборе формы (например, отсутствует
обязательное поле, неправильное содержимое) или \lstinline'FormSuccess' когда всё прошло
гладко.

Три следующих типа данных используются для определения индивидуальных полей.

\emph{Полем называется атомарная часть информации, такая как число, строка или адрес
email. Поля, соединяясь друг с другом, образуют форму}

\subsection{Field}
Определяют два вида функциональности: как преобразовать текстовый вход от пользователя 
в значение языка Haskell и как создовать виджет, который будет показан пользователю.
Несколько атомарных полей пакетп \lstinline'yesod-form' определено в модуле
\lstinline'Yesod.Form.Fields'.

\subsection{FieldSettings}
Основная информация о том, как поле следует отображать, например отображаемое имя,
подсказка, и, возможно, захардкоженные ID и имя атрибута. (Если ничего не указано, то они
генерятся автоматически.)

FieldSettings предоставляет экземпляр IsString, так что, когда вам понадобится указать
значение типа FieldSettings, вы можете обойтись просто строковым литералом. Так мы
делали во введении.

\subsection{FieldView}
Промежуточный формат, содержащий кучу информации о том, как отображать поле. Навряд ли
это когда-либо понадобится пользователю, мы поговорим об это позже.

Наконец, мы добрались к важной части нашего рассказа: непосредственно к формам. Существует
три вида форм: \lstinline'MForm' для монадических, \lstinline'AForm' для аппликативных и
\lstinline'IForm' (определенная в \lstinline'IForm') для форм ввода
данных. \lstinline'MForm' часто является синонимом типа стека монад, который позволяет
следующие действия:
\begin{itemize}
\item Монада \lstinline'Reader' предосталяет нам параметры (\lstinline'Env' и 
\lstinline'FileEnv'), the master site argument и список языков, которые поддерживаются на
стороне пользователя. Последние два используются в \lstinline'i18n', но об это позже.

\item Монада \lstinline'Writer' заотится о \lstinline'Enctype'. Форма всегда будет в
закодированна как  \lstinline'UrlEncoded', за исключение случая, когда присутствует
параметр для загрузке файлов. Тогда у нас форма будет загодирована с помощью multipart.
\item Монада \lstinline'State' хранит \lstinline'Ints' для обеспечения возможности
сгенерировать следующее уникально имя.
\end{itemize}
Форма \lstinline'AForm' устроена сходно. Однако, есть несколько важных различий:
\begin{itemize}
\item Она генерирует список \lstinline'FieldViews'. Это позволяет нам оперировать
абстракцией отображения форм, выбирая соответствующую функцию для отрисовки страницы в
самом конце. Во введении мы использовали \lstinline'renderDivs', которая создает
много тегов \lstinline'div'. Другим варианто могла бы быть 
\lstinline'renderTable'.

\item У неё нет экземпляра \lstinline'Monad'. Задача \lstinline'Applicative' заключается
в том, чтобы позволить форме выполниться целиком, собрать как можно больше информации, и
выдать результат. Она не может работать в контексте \lstinline'Monad'.
\end{itemize}
\lstinline'IForm' ещё проще: Она возвращает либо список ошибок, либо результат.

\section{Преобразование}

"Погодите-ка," скажете вы. "Вы говорите, что во введении использовались аппликативные
формы, но я уверен в том, что сигнатуры типов были \lstinline'MForm'. Не были ли
они монадическими?" Да, верно, в конце сгенерировались монадические формы, но в
действительности они получились преобразованием из аппликативных.

Опять же, наша цель заключается в том, чтобы переиспользовать как можно больше кода и
минимизировать число функций в API. И  монадические формы являются более
выразительными, чем аппликативные. Грубо говоря, всё что может быть выражено
аппликативными формами может быть выражено и монадическими. В этом нам помогут две
основные функции: \lstinline'aformToForm' преобразует любую аппликативную форму в
монаическую, а \lstinline'formToAForm' преобразует несколько видов монадических форм в их
аппликативные варианты.

<<Минутку>>, скажете вы. <<Я не видел никаких aformToForm!>> Это тоже верно.
Преобразование произошло в функции \lstinline'renderDivs'.

\subsection{Создание аппликативных форм}
Теперь, когда (я надеюсь) мы убедились в том, что во введении мы работали с
аппликативными формами, давать поймем как они создавались. Начнем с простого примера:

\begin{lstlisting}
data Car = Car
    { carModel :: Text
    , carYear :: Int
    }
  deriving Show

carAForm :: AForm Synopsis Synopsis Car
carAForm = Car
    <$> areq textField "Model" Nothing
    <*> areq intField "Year" Nothing

carForm :: Html -> MForm Synopsis Synopsis (FormResult Car, Widget)
carForm = renderTable carAForm

getCarR :: Handler RepHtml
getCarR = do
    ((result, widget), enctype) <- runFormGet carForm
    case result of
        FormSuccess car -> defaultLayout [whamlet|<p>#{show car}|]
        _ -> defaultLayout [whamlet|
<form method=get action=@{CarR} enctype=#{enctype}>
    <table>
        ^{widget}
    <input type=submit>
|]
\end{lstlisting}
Здесь мы явно разделили аппликативные и монадические формы. В \lstinline'carAForm' мы
использовали опреаторы \lstinline'<$>' и \lstinline'<*>'. Здесь нечему удивляться, они
часто используются при аппликативном программировании. И у нас про одной строчке для
каждой записи в типа \lstinline'Car'. Вероятно вы не удивитесь тому, что мы использовали 
\lstinline'textField' для записи типа \lstinline'Text' и \lstinline'intField' для записи
типа \lstinline'Int'.

Давайте взглянем поближе на функцию \lstinline'areq'. Её (упрощенной) сигнатурой является
\lstinline'Field a -> FieldSettings -> Maybe a -> AForm a'. 
Так что первый аргумент определяет тип данных поля, как его распарсить и как отрисовать.
Следующий аргумент, \lstinline'FieldSettings', дает нам метку, подсказку, имя и  ID
поля. В этом случае мы испльзуем раннее упомянутый экземпляр \lstinline'IsString' для 
\lstinline'FieldSettings'.

А что с \lstinline'Maybe a'? Она предоставляет опциональное значение по умолчанию. 
Например, если мы хватим заполнить форму с помощью <<2007>> как годом машины по
умолчанию, мы воспользуемся \lstinline'аreq intField "Year" (Just 2007)'. Мы можем даже
сделать это выше уровнем, так как форма принимает опциональный аргумент для значений по
умолчанию.

\subsection{Формы со значениями по умолчанию}

\begin{lstlisting}
carAForm :: Maybe Car -> AForm Synopsis Synopsis Car
carAForm mcar = Car
    <$> areq textField "Model" (carModel <$> mcar)
    <*> areq intField "Year" (carYear <$> mcar)

carForm :: Html -> MForm Synopsis Synopsis (FormResult Car, Widget)
carForm = renderTable (carAForm $ Just $ Car "Forte" 2010)

getCarR :: Handler RepHtml
getCarR = do
    ((result, widget), enctype) <- runFormGet carForm
    case result of
        FormSuccess car -> defaultLayout [whamlet|<p>#{show car}|]
        _ -> defaultLayout [whamlet|
<form method=get action=@{CarR} enctype=#{enctype}>
    <table>
        ^{widget}
    <input type=submit>
|]
\end{lstlisting}

\section{Опциональные поля}
Предположим, что нам нужно опциональное поле (например цвет машины). Всё что нужно ---
это воспользоваться функцией \lstinline'aopt'.

\begin{lstlisting}
data Car = Car
    { carModel :: Text
    , carYear :: Int
    , carColor :: Maybe Text
    }
  deriving Show

carAForm :: AForm Synopsis Synopsis Car
carAForm = Car
    <$> areq textField "Model" Nothing
    <*> areq intField "Year" Nothing
    <*> aopt textField "Color" Nothing

carForm :: Html -> MForm Synopsis Synopsis (FormResult Car, Widget)
carForm = renderTable carAForm

getCarR :: Handler RepHtml
getCarR = do
    ((result, widget), enctype) <- runFormGet carForm
    case result of
        FormSuccess car -> defaultLayout [whamlet|<p>#{show car}|]
        _ -> defaultLayout [whamlet|
<form method=get action=@{CarR} enctype=#{enctype}>
    <table>
        ^{widget}
    <input type=submit>
|]
\end{lstlisting}

Как и в случае обязательных полей, последним аргументом является значение по умолчанию.
Однако, оно заверруто в тип \lstinline'Maybe' два раза. Это может показаться чрезмерным,
но это урощает написаное кода, который принимает в параметре формы опциональное значение
по умолчанию, как в следующем примере

\subsection{Опциональные поля по умолчанию}

\begin{lstlisting}
data Car = Car
    { carModel :: Text
    , carYear :: Int
    , carColor :: Maybe Text
    }
  deriving Show

carAForm :: Maybe Car -> AForm Synopsis Synopsis Car
carAForm mcar = Car
    <$> areq textField "Model" (carModel <$> mcar)
    <*> areq intField  "Year"  (carYear  <$> mcar)
    <*> aopt textField "Color" (carColor <$> mcar)

carForm :: Html -> MForm Synopsis Synopsis (FormResult Car, Widget)
carForm = renderTable $ carAForm $ Just $ Car "Forte" 2010 $ Just "gray"

getCarR :: Handler RepHtml
getCarR = do
    ((result, widget), enctype) <- runFormGet carForm
    case result of
        FormSuccess car -> defaultLayout [whamlet|<p>#{show car}|]
        _ -> defaultLayout [whamlet|
<form method=get action=@{CarR} enctype=#{enctype}>
    <table>
        ^{widget}
    <input type=submit>
|]
\end{lstlisting}

\section{Валидаций}
Как бы сделать так, чтобы наша форма принимала только машины, созданные после 1990 года?
Если вы помните, мы говорили выше, что \lstinline'Field' сам по себе содержит информацию 
о допустимых значениях. Так что, всё что нам надо это использовать новый
\lstinline'Field', верно же? Да, но это будет несколько утомительно. Вместо этого,
давайте изменим уже существующее.
\begin{lstlisting}
carAForm :: Maybe Car -> AForm Synopsis Synopsis Car
carAForm mcar = Car
    <$> areq textField    "Model" (carModel <$> mcar)
    <*> areq carYearField "Year"  (carYear  <$> mcar)
    <*> aopt textField    "Color" (carColor <$> mcar)
  where
    errorMessage :: Text
    errorMessage = "Your car is too old, get a new one!"

    carYearField = check validateYear intField

    validateYear y
        | y < 1990 = Left errorMessage
        | otherwise = Right y

carForm :: Html -> MForm Synopsis Synopsis (FormResult Car, Widget)
carForm = renderTable $ carAForm $ Just $ Car "Forte" 2010 $ Just "gray"

getCarR :: Handler RepHtml
getCarR = do
    ((result, widget), enctype) <- runFormGet carForm
    case result of
        FormSuccess car -> defaultLayout [whamlet|<p>#{show car}|]
        _ -> defaultLayout [whamlet|
<form method=get action=@{CarR} enctype=#{enctype}>
    <table>
        ^{widget}
    <input type=submit>
|]
\end{lstlisting}

Трюк кроется в функции провеки \lstinline'check'. Она принимает функцию 
(\lstinline'validateYear'), которая возвращает либо сообщение об ошибке, или новое
значение. В этом примере, мы вообще не модифицировали значение. That is usually going to
be the case. Такой вид проверки довольно распространён, так что мы можем применить
сокразение:

\begin{lstlisting}
    carYearField = checkBool (>= 1990) errorMessage intField
\end{lstlisting}

\begin{lstlisting}
carForm :: Html -> MForm Synopsis Synopsis (FormResult Car, Widget)
carForm = renderTable $ carAForm $ Just $ Car "Forte" 2010 $ Just "gray"

getCarR :: Handler RepHtml
getCarR = do
    ((result, widget), enctype) <- runFormGet carForm
    case result of
        FormSuccess car -> defaultLayout [whamlet|<p>#{show car}|]
        _ -> defaultLayout [whamlet|
<form method=get action=@{CarR} enctype=#{enctype}>
    <table>
        ^{widget}
    <input type=submit>
|]
\end{lstlisting}

Функция \lstinline'checkBool' принимает два парметра: условие, которое должно быть
выполнено и сообщение об ошибке, которое следует отобразить если оно не верно.

Вы могли заметить явное указание \lstinline'Text' в сигнатуре типа функции
\lstinline'errorMessage'. При использовании \lstinline'OverloadedStrings' это
необходимо. Чтобы поддерживать i18n, сообщения могут иметь много различных типов
данных и GHC никак не может сам определить, котороый экземпляр \lstinline'IsString' вам
нужен.

Классно, что мы можем быть уверены, что наша машина не очень стара. Но что, если мы хотим
быть уверенными в том, что указанный год не из будущего? Чтобы получить текущий год, нам
надо выполнить немного IO. Для таких случаев предназначение функция \lstinline'checkM':

\begin{lstlisting}
    carYearField = checkM inPast $ checkBool (>= 1990) errorMessage intField

    inPast y = do
        thisYear <- liftIO getCurrentYear
        return $ if y <= thisYear
            then Right y
            else Left ("You have a time machine!" :: Text)
\end{lstlisting}

\begin{lstlisting}
getCurrentYear :: IO Int
getCurrentYear = do
    now <- getCurrentTime
    let today = utctDay now
    let (year, _, _) = toGregorian today
    return $ fromInteger year

carForm :: Html -> MForm Synopsis Synopsis (FormResult Car, Widget)
carForm = renderTable $ carAForm $ Just $ Car "Forte" 2010 $ Just "gray"

getCarR :: Handler RepHtml
getCarR = do
    ((result, widget), enctype) <- runFormGet carForm
    case result of
        FormSuccess car -> defaultLayout [whamlet|<p>#{show car}|]
        _ -> defaultLayout [whamlet|
<form method=get action=@{CarR} enctype=#{enctype}>
    <table>
        ^{widget}
    <input type=submit>
|]
\end{lstlisting}

Функция \lstinline'inPast' вернет результат типа \lstinline'Either'. Однако, она
использует монаду \lstinline'Handler'. Мы использует \lstinline'liftIO getCurrentYear',
чтобы получить текущий год и затем сравнить её с кодом, указанным пользователем. Также,
обратите внимание как мы несколько валидаторов построили в цепочку.

С тех пор как валидатор \lstinline'checkM' работает в монаде \lstinline'Handler', он
можете использовать тот же код что и обычно теперь и в \lstinline'Yesod'. Это особенно
полезно при обращении к базам данных, которые будет рассмотрено в главе
\lstinline'Persistent'.
%FIXME: add link

\section{Более сложные поля}
Наше поле для ввода цвета довольно приличное, но не очень user-friendly. В
действительности на нужен выпадающий список.

\subsection{Выпадающие списки}

\begin{lstlisting}
data Car = Car
    { carModel :: Text
    , carYear :: Int
    , carColor :: Maybe Color
    }
  deriving Show

data Color = Red | Blue | Gray | Black
    deriving (Show, Eq, Enum, Bounded)

carAForm :: Maybe Car -> AForm Synopsis Synopsis Car
carAForm mcar = Car
    <$> areq textField "Model" (carModel <$> mcar)
    <*> areq carYearField "Year" (carYear <$> mcar)
    <*> aopt (selectFieldList colors) "Color" (carColor <$> mcar)
  where
    colors :: [(Text, Color)]
    colors = [("Red", Red), ("Blue", Blue), ("Gray", Gray), ("Black", Black)]
    errorMessage :: Text
    errorMessage = "Your car is too old, get a new one!"

    carYearField = checkM inPast $ checkBool (>= 1990) errorMessage intField

    inPast y = do
        thisYear <- liftIO getCurrentYear
        return $ if y <= thisYear
            then Right y
            else Left ("You have a time machine!" :: Text)

getCurrentYear :: IO Int
getCurrentYear = do
    now <- getCurrentTime
    let today = utctDay now
    let (year, _, _) = toGregorian today
    return $ fromInteger year

carForm :: Html -> MForm Synopsis Synopsis (FormResult Car, Widget)
carForm = renderTable $ carAForm $ Just $ Car "Forte" 2010 $ Just Black

getCarR :: Handler RepHtml
getCarR = do
    ((result, widget), enctype) <- runFormGet carForm
    case result of
        FormSuccess car -> defaultLayout [whamlet|<p>#{show car}|]
        _ -> defaultLayout [whamlet|
<form method=get action=@{CarR} enctype=#{enctype}>
    <table>
        ^{widget}
    <input type=submit>
|]
\end{lstlisting}

Функция \lstinline'selectFieldList' принимает список пар. Первый элемент пары --- это
текст, который отобразится пользователю в выпадающем списке, а вторым элементом
является соответствующее значение из \lstinline'Haskell'. Конечно же код выше выглядит
солидно, но мы можем получить тот же результат воспользовавшись экземплярами
\lstinline'Enum' и \lstinline'Bounded', которые GHC автоматически
выводит нам.

\subsection{Используя Enum и Bounded}

\begin{lstlisting}
data Car = Car
    { carModel :: Text
    , carYear :: Int
    , carColor :: Maybe Color
    }
  deriving Show

data Color = Red | Blue | Gray | Black
    deriving (Show, Eq, Enum, Bounded)

carAForm :: Maybe Car -> AForm Synopsis Synopsis Car
carAForm mcar = Car
    <$> areq textField "Model" (carModel <$> mcar)
    <*> areq carYearField "Year" (carYear <$> mcar)
    <*> aopt (selectFieldList colors) "Color" (carColor <$> mcar)
  where
    colors = map (pack . show &&& id) $ [minBound..maxBound]
    errorMessage :: Text
    errorMessage = "Your car is too old, get a new one!"

    carYearField = checkM inPast $ checkBool (>= 1990) errorMessage intField

    inPast y = do
        thisYear <- liftIO getCurrentYear
        return $ if y <= thisYear
            then Right y
            else Left ("You have a time machine!" :: Text)

getCurrentYear :: IO Int
getCurrentYear = do
    now <- getCurrentTime
    let today = utctDay now
    let (year, _, _) = toGregorian today
    return $ fromInteger year

carForm :: Html -> MForm Synopsis Synopsis (FormResult Car, Widget)
carForm = renderTable $ carAForm $ Just $ Car "Forte" 2010 $ Just Black

getCarR :: Handler RepHtml
getCarR = do
    ((result, widget), enctype) <- runFormGet carForm
    case result of
        FormSuccess car -> defaultLayout [whamlet|<p>#{show car}|]
        _ -> defaultLayout [whamlet|
<form method=get action=@{CarR} enctype=#{enctype}>
    <table>
        ^{widget}
    <input type=submit>
|]
\end{lstlisting}

В промежутке \lstinline'[minBound..maxBound]' предоставляет нам список всех различных
значений типа \lstinline'Color'. Мы может затем применить \lstinline'map' и 
\lstinline'&&&' (a.k.a, the fan-out operator), превращая его в список пар.

Некоторые люди предпочитаю кнопки radio buttons выпадающим спискам. К счастью, нам надо
только провести одно изменение. Вот пример.

\subsection{Radio buttons}
\begin{lstlisting}
data Car = Car
    { carModel :: Text
    , carYear :: Int
    , carColor :: Maybe Color
    }
  deriving Show

data Color = Red | Blue | Gray | Black
    deriving (Show, Eq, Enum, Bounded)

carAForm :: Maybe Car -> AForm Synopsis Synopsis Car
carAForm mcar = Car
    <$> areq textField "Model" (carModel <$> mcar)
    <*> areq carYearField "Year" (carYear <$> mcar)
    <*> aopt (radioFieldList colors) "Color" (carColor <$> mcar)
  where
    colors = map (pack . show &&& id) $ [minBound..maxBound]
    errorMessage :: Text
    errorMessage = "Your car is too old, get a new one!"

    carYearField = checkM inPast $ checkBool (>= 1990) errorMessage intField

    inPast y = do
        thisYear <- liftIO getCurrentYear
        return $ if y <= thisYear
            then Right y
            else Left ("You have a time machine!" :: Text)

getCurrentYear :: IO Int
getCurrentYear = do
    now <- getCurrentTime
    let today = utctDay now
    let (year, _, _) = toGregorian today
    return $ fromInteger year

carForm :: Html -> MForm Synopsis Synopsis (FormResult Car, Widget)
carForm = renderTable $ carAForm $ Just $ Car "Forte" 2010 $ Just Black

getCarR :: Handler RepHtml
getCarR = do
    ((result, widget), enctype) <- runFormGet carForm
    case result of
        FormSuccess car -> defaultLayout [whamlet|<p>#{show car}|]
        _ -> defaultLayout [whamlet|
<form method=get action=@{CarR} enctype=#{enctype}>
    <table>
        ^{widget}
    <input type=submit>
|]
\end{lstlisting}

\section{Выполнение форм}
А теперь воспользуемся нашими формами, чтобы получить некоторый результат. Для этого
существует несколько различных функций, каждая имеет своё назначение. Я пройдусь по ним
всем, ничиная с самых распространённых.

\subsection{runFormPost}

This will run your form against any submitted POST parameters. If this is not a POST
submission, it will return a FormMissing. Токен безопасности вставится автоматически
как скрытое поле во избежание CSRF-аттак.

\subsection{runFormGet}
То же, что и \lstinline'runFormPost' для GET-параметров. Чтобы различать обычную
загрузку страницы через GET от отправки GET формы, она включает дополнительное скрытое
поле \lstinline'_hasdata' в форме.

\subsection{runFormPostNoNonce}
То же, что и \lstinline'runFormPost', но без включения токена безопасности CSRF.

\subsection{generateFormPost}
Вместо связывания существующих POST параметров, действует так, будто их нет. Может
быть полезно когда вам нужно сгенерировать новую форму после того, как предыдущая была
отправлена, such as in a wizard.

\subsection{generateFormGet}

То же, что и \lstinline'generateFormPost', но через GET.

Возвращаемым значением первых трёх является \lstinline'((FormResult a, Widget), Enctype)'.
\lstinline'Widget' уже будет иметь ошибки валидации и предыдущие тправленные значения.
Widget will already have any validation errors and previously submitted values.

\section{i18n}
Здесь будет просто несколько ссылок к i18n. Эта тема подробнее освещена в своей
собтсвенной главе
%
но так как она напрямую связана с формами, я хочу дать краткий обзор. 
Идея по поддержке i18n в Yesod состоит в том, чтобы иметь типы данных для представляения
сообщений. Каждый сайт может иметь экземпляр \lstinline'RenderMessage' для конкретного
типа данных, который будет переводить сообщение в сообтветствии со списком языков,
доступных на клиенте. В результате это есть несколько вещей, о которых вам стоит знать:
\begin{itemize}
\item  Для каждого сайта автоматически создается экземпляр \lstinline'RenderMessage' для
типа \lstinline'Text', так что вы можете просто использовать простые строки , если не
хотите заботиться о поддержке i18n. ОДнако, вам неожиданно можгут понадобиться явные
сигнатуры типов.
\item Все сообщения в yesod-form выражаются в терминах типа \lstinline'FormMessage'.
Поэтому, для использования yesod-form вам нужен соответствующий экземпляр 
\lstinline'RenderMessage'. Наипростейший, который использует перевод на английсий по
умолчанию, будет выглядеть так:
\begin{lstlisting}
instance RenderMessage MyApp FormMessage where
    renderMessage _ _ = defaultFormMessage
\end{lstlisting}
This is provided automatically by the scaffolded site.
\end{itemize}

\section{Monadic Forms}

Often times, a simple form layout is adequate, and applicative forms excel at this
approach. Sometimes, however, you'll want to have a more customized look to your form.

\subsection{A non-standard form layout}
\begin{figure}[tbph]
  \centering
  \caption{}
  \includegraphics{08-forms-image-01.png}
\end{figure}
For these use cases, monadic forms fit the bill. They are a bit more verbose than their
applicative cousins, but this verbosity allows you to have complete control over what the
form will look like. In order to generate the form above, we could code something like
this.

\begin{lstlisting}
{-# LANGUAGE OverloadedStrings, TypeFamilies, QuasiQuotes,
             TemplateHaskell, MultiParamTypeClasses #-}

import Yesod
import Control.Applicative
import Data.Text (Text)

data MFormExample = MFormExample

mkYesod "MFormExample" [parseRoutes|
/ RootR GET
|]

instance Yesod MFormExample

instance RenderMessage MFormExample FormMessage where
    renderMessage _ _ = defaultFormMessage

data Person = Person { personName :: Text, personAge :: Int }
    deriving Show

personForm :: Html -> MForm MFormExample MFormExample (FormResult Person, Widget)
personForm extra = do
    (nameRes, nameView) <- mreq textField "this is not used" Nothing
    (ageRes, ageView) <- mreq intField "neither is this" Nothing
    let personRes = Person <$> nameRes <*> ageRes
    let widget = do
            toWidget [lucius|
##{fvId ageView} {
    width: 3em;
}
|]
            [whamlet|
#{extra}
<p>
    Hello, my name is #
    ^{fvInput nameView}
    \ and I am #
    ^{fvInput ageView}
    \ years old. #
    <input type=submit value="Introduce myself">
|]
    return (personRes, widget)

getRootR :: Handler RepHtml
getRootR = do
    ((res, widget), enctype) <- runFormGet personForm
    defaultLayout [whamlet|
<p>Result: #{show res}
<form enctype=#{enctype}>
    ^{widget}
|]

main :: IO ()
main = warpDebug 3000 MFormExample
\end{lstlisting}

Similar to the applicative areq, we use mreq for monadic forms. (And yes, there's also
mopt for optional fields.) But there's a big difference: mreq gives us back a pair of
values. Instead of hiding away the FieldView value and automatically inserting it into a
widget, we get the control to insert it as we see fit.

FieldView has a number of pieces of information. The most important is fvInput, which is
the actual form field. In this example, we also use fvId, which gives us back the HTML id
attribute of the input tag. In our example, we use that to specify the width of the field.

You might be wondering what the story is with the "this is not used" and "neither is this"
values. mreq takes a FieldSettings as its second argument. Since FieldSettings provides an
IsString instance, the strings are essentially expanded by the compiler to:

\begin{lstlisting}
fromString "this is not used" == FieldSettings
    { fsLabel = "this is not used"
    , fsTooltip = Nothing
    , fsId = Nothing
    , fsName = Nothing
    , fsClass = []
    }
\end{lstlisting}

In the case of applicative forms, the fsLabel and fsTooltip values are used when
constructing your HTML. In the case of monadic forms, Yesod does not generate any of the
"wrapper" HTML for you, and therefore these values are ignored. However, we still keep the
FieldSettings parameter to allow you to override the id and name attributes of your fields
if desired.

The other interesting bit is the extra value. GET forms include an extra field to indicate
that they have been submitted, and POST forms include a security tokens to prevent CSRF
attacks. If you don't include this extra hidden field in your form, Yesod will not accept
it.

Other than that, things are pretty straight-forward. We create our personRes value by
combining together the nameRes and ageRes values, and then return a tuple of the person
and the widget. And in the getRootR function, everything looks just like an applicative
form. In fact, you could swap out our monadic form with an applicative one and the code
would still work.

\section{Input forms}

Applicative and monadic forms handle both the generation of your HTML code and the parsing
of user input. Sometimes, you only want to do the latter, such as when there's an
already-existing form in HTML somewhere, or if you want to generate a form dynamically
using Javascript. In such a case, you'll want input forms.

These work mostly the same as applicative and monadic forms, with some differences:
\begin{itemize}
 \item You use runInputPost and runInputGet.
 \item You use ireq and iopt. These functions now only take two arguments: the field type
and the name (i.e., HTML name attribute) of the field in question.
 \item  After running a form, it returns the value. It doesn't return a widget or an
encoding type.
 \item  If there are any validation errors, the page returns an "invalid arguments" error
page.
\end{itemize}
You can use input forms to recreate the previous example. Note, however, that the input
version is less user friendly. If you make a mistake in an applicative or monadic form,
you will be brought back to the same page, with your previously entered values in the
form, and an error message explaning what you need to correct. With input forms, the user
simply gets an error message.

\begin{lstlisting}
{-# LANGUAGE OverloadedStrings, TypeFamilies, QuasiQuotes,
             TemplateHaskell, MultiParamTypeClasses #-}

import Yesod
import Control.Applicative
import Data.Text (Text)

data Input = Input

mkYesod "Input" [parseRoutes|
/ RootR GET
/input InputR GET
|]

instance Yesod Input

instance RenderMessage Input FormMessage where
    renderMessage _ _ = defaultFormMessage

data Person = Person { personName :: Text, personAge :: Int }
    deriving Show

getRootR :: Handler RepHtml
getRootR = defaultLayout [whamlet|
<form action=@{InputR}>
    <p>
        My name is #
        <input type=text name=name>
        \ and I am #
        <input type=text name=age>
        \ years old. #
        <input type=submit value="Introduce myself">
|]

getInputR :: Handler RepHtml
getInputR = do
    person <- runInputGet $ Person
                <$> ireq textField "name"
                <*> ireq intField "age"
    defaultLayout [whamlet|<p>#{show person}|]

main :: IO ()
main = warpDebug 3000 Input
\end{lstlisting}

\section{Custom fields}

The fields that come built-in with Yesod will likely cover the vast majority of your form
needs. But occassionally, you'll need something more specialized. Fortunately, you can
create new forms in Yesod yourself. The Field datatype has two records: fieldParse takes a
list of values submitted by the user and returns one of three results:
\begin{enumerate}
 \item An error message saying validation failed.
 \item The parsed value.
 \item Nothing, indicating that no data was supplied.
\end{enumerate}

That last case might sound surprising: shouldn't Yesod automatically know that no
information is supplied when the input list is empty? Well, no actually. Checkboxes, for
instance, indicate an unchecked state by sending in an empty list.

Also, what's up with the list? Shouldn't it be a Maybe? Well, that's also not the case.
With grouped checkboxes and multi-select lists, you'll have multiple widgets with the same
name. We also use this trick in our example below.

The second record is fieldView, and it renders a widget to display to the user. This
function has four arguments: the id attribute, the name attribute, the result and a Bool
indicating if the field is required.

What did I mean by result? It's actually an Either, giving either the unparsed input (when
parsing failed) or the successfully parsed value. intField is a great example of how this
works. If you type in 42, the value of result will be Right 42. But if you type in turtle,
the result will be Left "turtle". This lets you put in a value attribute on your input tag
that will give the user a consistent experience.

As a small example, we'll create a new field type that is a password confirm field. This
field has two text inputs- both with the same name attribute- and returns an error message
if the values don't match. Note that, unlike most fields, it does not provide a value
attribute on the input tags, as you don't want to send back a user-entered password in
your HTML ever.

\begin{lstlisting}
passwordConfirmField :: Field sub master Text
passwordConfirmField = Field
    { fieldParse = \rawVals ->
        case rawVals of
            [a, b]
                | a == b -> return $ Right $ Just a
                | otherwise -> return $ Left "Passwords don't match"
            [] -> return $ Right Nothing
            _ -> return $ Left "You must enter two values"
    , fieldView = \idAttr nameAttr _ eResult isReq -> [whamlet|
<input id=#{idAttr} name=#{nameAttr} type=password>
<div>Confirm:
<input id=#{idAttr}-confirm name=#{nameAttr} type=password>
|]
    }

getRootR :: Handler RepHtml
getRootR = do
    ((res, widget), enctype) <- runFormGet $ renderDivs
        $ areq passwordConfirmField "Password" Nothing
    defaultLayout [whamlet|
<p>Result: #{show res}
<form enctype=#{enctype}>
    ^{widget}
    <input type=submit value="Change password">
|]
main :: IO ()
main = warpDebug 3000 Password
\end{lstlisting}

\section{Заключение}

Формы в Yesod делятся на три вида. Аппликативные используются чаще всего, так как
предоставляют красивый интерфейс и простой для использование API. Монадические форма дают
больше возможностей, но их сложнее использовать. Формы ввода данных полезны, когда вам
надо просто принять данные пользователя, не генерируя сложных виджетов.

Из коробки Yesod предоставляет несколько видов полей для форм. Для использования
форм вам придется определиться, какую форму вы хотите и является поле опциональным или
обязательным. Итого мы имеет шесть дополнительных функций: areq, aopt, mreq, mopt, ireq,
и iopt.

Формы довольно-таки мощны. Они могут автоматически вставлять код на Javascript, чтобы
получаять более красивые элементы управляения, например, для выбора даты из библиотеки 
jQuery. Формы также поддерживают  i18n, так что вы можете расчитывать на большое
сообщество пользователей. А для более специфических надобностей, вы можете привязать
функции валидации данных для конкретных полей, или написать свои с чистого  листа.

