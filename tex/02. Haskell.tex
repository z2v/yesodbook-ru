Haskell

Чтобы использовать Yesod, вам необходимо иметь по крайней мере базовые знания языка Haskell. Помимо этого, в Yesod используются некоторые особенности Haskell, которые не описаны в большинстве руководств начального уровня. Хотя от читателя предполагается знакомство с основами Haskell, эта глава призвана заполнить возможные пробелы.

Если вы уже хорошо владеете Haskell, то вполне можете вовсе пропустить эту главу. Также, если вы предпочтете начать непосредственно с погружения в Yesod, то вы всегда сможете при необходимости вернуться к этой главе.

Если вам необходимо более полное руководство по языку Haskell, я бы порекомендовал "Real World Haskell" или "Learn You a Haskell".

Терминология

Даже у тех, кто хорошо знаком с Haskell, иногда может возникнуть путаница с терминологией. Сформулируем некоторые базовые термины, которые мы будем использовать на протяжении этой книги.

Тип данных

Это один из основных строительных блоков для строго типизированного языка, которым является Haskell. Некоторые типы данных, такие как Int, можно считать элементарными, а остальные типы строятся на их основе для создания более сложных значений. Например, вы могли бы представить человека следующим образом:

data Person = Person Text Int

Здесь Text содержит имя человека, а Int~--- его возраст. Из-за простоты этого примера мы будем обращаться к нему на протяжении всей книги.

Существует три способа, с помощью которых вы можете создать тип данных:

\begin{itemize}
  \item Определение типа, например, type GearCount = Int, просто создает синоним существующего типа. Система типов не станет препятствовать вам использовать Int везде, где требуется GearCount. Использование такого типа может сделать ваш код более самодокументирующим.
  \item Определение newtype, например, newtype Make = Make Text. В этом случае вы не можете случайно использовать Text вместо Make, компилятор не даст вам этого сделать. Обертка, создаваемая newtype, удаляется во время компиляции и не создает накладных расходов.
  \item Определение data, как в приведенном выше примере с Person. Вы можете также создавать алгебраические типы данных (АТД), такие как data Vehicle = Bycicle GearCount | Car Make Model.
\end{itemize}

Конструктор данных

В приведенных выше примерах Person, Make, Bicycle и Car~--- конструкторы данных.

Конструктор типа

В приведенных выше примерах Person, Make и Vehicle~--- конструкторы типов.

Переменные типов

Рассмотрим тип данных data Maybe a = Just a | Nothing. В этом случае a~--- переменная типа.

Инструментарий

Для разработки на Haskell вам понадобятся два основных инструмента. Во-первых, Glasgow Haskell Compiler (GHC), стандартный компилятор Haskell~--- и единственный официально поддерживаемый Yesod. Вам также понадобится Cabal, стандартное средство сборки для Haskell. Cabal используется не только для сборки локального кода~--- он также может автоматически скачивать и устанавливать зависимости из Hackage, репозитория пакетов Haskell.

Тем, кто работает в среде Windows или Mac, настоятельно рекомендуется скачать Haskell Platform. Многие дистрибутивы Linux содержат Haskell Platform в своих репозиториях. Например, в дистрибутивах, основанных на Debian, стоит начать с выполнения команды sudo apt-get install haskell-platform. Если в вашем дистрибутиве Haskell Platform недоступна, вы можете установить ее вручную, следуя инструкциям на официальном сайте.

Еще один важный инструмент, который вам нужно будет обновить,~--- это alex. Haskell Platform включает версию 2, но используемой Yesod программе минимизации JavaScript, hjsmin, требуется версия 3. Не забудьте выполнить cabal install alex после установки Haskell Platform, иначе получите сообщения об ошибках в отношении пакета language-javascript.

Некоторым нравится жить на острие прогресса и устанавливать последнюю версию GHC до того, как она станет доступна в Haskell Platform. Мы стараемся поддерживать совместимость Yesod со всеми современными версиями GHC, но официально мы поддерживаем только Haskell Platform. Если вы все-таки решили пойти по пути ручной установки GHC, то:

\begin{itemize}
  \item Вам нужно будет установить некоторые дополнительные инструменты, в частности, alex и happy.
  \item Убедитесь, что установлены все требуемые C-библиотеки. В дистрибутивах, основанных на Debian, это можно сделать, выполнив команду sudo apt-get install libedit-dev libbsd-dev lbgmp3-dev zlib1g-dev freeglut3-dev.
\end{itemize}

Независимо от способа установки инструментов вам нужно добавить путь к каталогу bin Cabal в переменную окружения PATH. В Mac и Linux это будет \$HOME/.cabal/bin, а в Windows~--- \%APPDATA\%\cabal\bin.

У Cabal есть множество доступных опций, но для начала ознакомьтесь с двумя:

\begin{itemize}
  \item cabal updata скачивает актуальный список пакетов с hackage.
  \item cabal install yesod-platform устанавливает Yesod и его зависимости.
\end{itemize}

Многие члены сообщества предпочитают выполнять изолированную сборку пакетов Haskell, что предотвращает порчу существующих пакетов вследствие установки Yesod или порчу Yesod из-за установки каких-то пакетов в будущем. В этой книге я не буду углубляться в детали того, как это делается, но два наиболее часто используемых для этих целей инструмента~--- это cabal-dev и virthualenv.

Указания компилятору

По умолчанию GHC работает с режиме, очень близком к Haskell98. Но с ним поставляется большое число языковых расширений, предоставляющих более мощные классы типов, изменения в синтаксисе и прочее. Есть несколько путей заставить GHC включить эти расширения. В большинстве фрагментов кода, приведенных в этой книге, вы увидите указания компилятору, которые выглядят следующим образом:

{-# LANGUAGE MyLanguageExtension #-}

Эти указания должны всегда размещаться в самом начале исходного файла. Помимо этого, есть еще два распространенных способа:
\begin{itemize}
\item передать GHC аргумент командной строки -XMyLanguageExtension;
\item добавить блок расширений в файл cabal.
\end{itemize}

Лично я никогда не использую подход с аргументами командной строки. Это личное предпочтение, но я предпочитаю, когда мои настройки явным образом указаны в файле. В общем случае также рекомендуется избегать помещения расширений в файл cabal. Впрочем, в Yesod scaffolded site мы специально применяем этот подход, чтобы избежать необходимости указывать одни и те же указания компилятору в каждом исходном файле.

В конечном счете мы будем использовать в этой книге совсем немного языковых расширений (scaffolding uses 11). Мы не будем рассматривать значение каждого из них. За этим, пожалуйста, обращайтесь к документации GHC.

Перегруженные строки

Каков тип "hello"? Обычно это String, определенный как type String = [Char]. К сожалению, у этого подхода есть ряд ограничений:
\begin{itemize}
\item Это очень неэффективная реализация хранения текстовых данных. Мы должны выделить память под каждую cons-ячейку, плюс сам символ занимает целое машинное слово.
\item Иногда у нас есть данные, похожие на строку, но не являющиеся текстом, такие как ByteString и HTML.
\end{itemize}

% monomorphic type
Для обхода этих ограничений в GHC есть языковое расширение, называемое OverloadedStrings. Когда оно включено, строковые литералы будут иметь не мономорфный тип String, а тип IsString a => a, где IsString определен следующим образом:

class IsString a where
    fromString :: String -> a

% a much more efficient packed String type
Существуют экземпляры IsString для ряда типов в Haskell, таких как Text (намного более эффективный тип для хранения упакованных строк), ByteString и HTML. Практически каждый пример в этой книге предполагает, что это языковое расширение включено.

% GHC's type checked
К сожалению, у этого расширения есть один недостаток: иногда оно может сбить с толку проверку типов GHC. Представьте, что у нас есть следующее:

{-# LANGUAGE OverloadedStrings, TypeSynonymInstances, FlexibleInstances #-}

import Data.Text (Text)

class DoSomething a where
    something :: a -> IO ()

instance DoSomething String where
    something _ = putStrLn "String"

instance DoSomething Text where
    something _ = putStrLn "Text"

myFunc :: IO ()
myFunc = something "hello"

Что эта программа напечатает~--- "String" или "Text"? Неясно. Поэтому вам придется предоставить явную аннотацию типа, чтобы указать, должен ли литерал "hello" трактоваться как String или как Text.

Семейства типов

% associated type
Главная идея семейства типов~--- устанавливать некоторую ассоциацию между двумя различными типами. Предположим, мы хотим написать функцию, которая безопасным образом будет получать первый элемент списка. Но мы не хотим, чтобы она работала только на списках. Мы бы хотели, чтобы она трактовала ByteString как список из Word8. Чтобы этого добиться, нам нужно ввести некоторый ассоциированный тип, чтобы определить, каково содержимое определенного типа.

\begin{verbatim}
{-# LANGUAGE TypeFamilies, OverloadedStrings #-}

import Data.Word (Word8)
import qualified Data.ByteString as S
import Data.ByteString.Char8 () -- get an orphan IsString instance

class SafeHead a where
    type Content a
    safeHead :: a -> Maybe (Content a)

instance SafeHead [a] where
    type Content [a] = a
    safeHead [] = Nothing
    safeHead (x:_) = Just x

instance SafeHead S.ByteString where
    type Content S.ByteString = Word8
    safeHead bs
        | S.null bs = Nothing
        | otherwise = Just $ S.head bs

main :: IO ()
main = do
    print $ safeHead ("" :: String)
    print $ safeHead ("hello" :: String)

    print $ safeHead ("" :: S.ByteString)
    print $ safeHead ("hello" :: S.ByteString)
\end{verbatim}

Новый синтаксис позволяет нам разместить тип внутри определения класса и экземпляра. Вместо этого мы также можем использова data, что создаст новый тип данных вместо ссылки на уже существующий.

Есть и другие пути использования ассоциированных типов вне контекста класса типа. Однако в Yesod все наши ассоциированные типы являются, фактически, частью класса типа. За более подробной информацией о семействах типов обращайтесь на wiki-страницу Haskell.

% надо ли переводить?
Template Haskell

Template Haskell (TH)~--- это способ генерации кода. Мы используем его в ряде мест в Yesod для уменьшения объема bolerplate и для того, чтобы быть уверенными в корректности сгенерированного кода. Template Haskell~--- это, в сущности, Haskell, который генерирует абстрактное синтаксическое дерево (АСД) Haskell.

На самом деле TH еще более мощный, так как он позволяет фактически выполнять интроспекцию кода. Однако эти возможности мы в Yesod не используем.

Написание кода на TH может быть непростым делом, и, к сожалению, типовой безопасности при этом не слишком много. Можно легко написать на TH генерацию кода, который не скомпилируется. Это проблема только для разработчиков Yesod, но не для его пользователей. В ходе разработки мы используем большой набор модульных тестов, чтобы убедиться в корректности сгенерированного кода. Как пользователю, все что вам нужно делать~--- это вызывать эти уже существующие функции. Например, чтобы включить внешний шаблон Hamlet, вы можете написать:

\begin{verbatim}
$(hamletFile "myfile.hamlet")
\end{verbatim}

% meta
(Hamlet обсуждается в главе о Shakespeare.) Символ доллара, за которым следует открывающая скобка, сообщает GHC, что то, что следует далее, является функцией Template Haskell. Код внутри скобок затем запускается компилятором и генерирует АСД Haskell, которое затем компилируется. И да, при этом можно даже использовать метапрограммирование.

% IO actions
Приятная особенность~--- код TH может выполнять произвольные IO actions, и, следовательно, мы можем разместить входные данные во внешних файлах, которые будет разбираться во время компиляции. Один из примеров использования заключается в получении шаблонов HTML, CSS и JavaScript, проверяемых во время компиляции.

Если ваш код Template Haskell используется для генерации объявлений и располагается на верхнем уровне наших файлов, то мы можем избавиться от знаков доллара и скобок. Другими словами

\begin{verbatim}
{-# LANGUAGE TemplateHaskell #-}

-- Обычное определение функции, ничего особенного
myFunction = ...

-- Включить код TH
$(myThCode)

-- Или, эквивалентно
myThCode
\end{verbatim}

Может быть полезным посмотреть, какой код генерирует для вас Template Haskell. Для этого вам нужно использовать опцию GHC -ddump-splices.

Есть еще много других особенностей Template Haskell, которые здесь не рассматриваются. Более подробную информацию ищите на wiki-странице Haskell.

QuasiQuotes

QuasiQuotes (QQ) это небольшое расширение Template Haskell, которое позволяет нам включать произвольные данные в файлы с исходным кодом на Haskell. Например, выше упоминалась функция hamletFile Template Haskell, которая считывает содержимое шаблона из внешнего файла. У нас также есть quasi-quoter, называемый hamlet, который считывает содержимое, хранящееся непосредственно в исходном коде:

\begin{verbatim}
{-# LANGUAGE QuasiQuotes #-}

[hamlet|<p>This is quasi-quoted Hamlet.|]
\end{verbatim}

Синтаксис выделяется квадратными скобками и pipes. Имя quasi-quoter пишется между открывающей скобкой и первым символом pipe, а содержимое приводится между символами pipe.

На протяжении книги мы во многих случаях будем предпочитать внешним файлам QQ-подход, поскольку такой код проще копировать. Однако в реальных приложениях внешние файлы являются предпочтительными во всех случаях, кроме совсем коротких данных, так как это дает нам хорошее разделение кода на Haskell и кода с иным синтаксисом.

Выводы

Вам не нужно быть экспертом в Haskell, чтобы использовать Yesod, достаточно базового знакомства. Надеюсь, эта глава дала вам достаточно информации, чтобы чувствовать себя более комфортно в оставшейся части книги.