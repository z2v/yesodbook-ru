\section{Haskell}

Чтобы использовать Yesod, вам необходимо знать по крайней мере основы языка Haskell. Кроме того, в Yesod используются некоторые особенности Haskell, которые не описаны в большинстве руководств начального уровня. Хотя от читателя предполагается базовое владение Haskell, эта глава призвана заполнить возможные пробелы.

Если вы уже хорошо владеете Haskell, можете не стесняться и вовсе пропустить эту главу. Также, если вы предпочитаете начать непосредственно с погружения в Yesod, то вы всегда сможете потом вернуться к этой главе.

Если вам необходимо более полное руководство по языку Haskell, я бы порекомендовал <<Real World Haskell>> или <<Learn You a Haskell>>.

\subsection{Терминология}

Даже у тех, кто хорошо знаком с языком Haskell, иногда может возникать путаница с терминологией. Сформулируем некоторые базовые термины, которые мы будем использовать на протяжении всей книги.

\subsubsection{Тип данных}

Это один из основных строительных блоков для строго типизированного языка, которым является Haskell. Некоторые типы данных, такие как \lstinline'Int', можно считать элементарными, а остальные типы строятся на их основе для создания более сложных значений. Например, вы могли бы представить человека следующим образом:

\begin{lstlisting}
data Person = Person Text Int
\end{lstlisting}

Здесь \lstinline'Text' содержит имя человека, а \lstinline'Int' "--- его возраст. Из-за простоты этого примера мы будем обращаться к нему на протяжении всей книги.

Существует три способа, с помощью которых вы можете создать тип данных:

\begin{itemize}
  \item Определение типа, например, \lstinline'type GearCount = Int', просто создает синоним существующего типа. Система типов не станет препятствовать вам использовать \lstinline'Int' везде, где требуется \lstinline'GearCount'. Использование такого типа может сделать ваш код более самодокументирующим.
  \item Определение \lstinline'newtype', например, \lstinline'newtype Make = Make Text'. В этом случае вы не можете случайно использовать \lstinline'Text' вместо \lstinline'Make', компилятор не даст вам этого сделать. Обертка, создаваемая \lstinline'newtype', удаляется во время компиляции и не создает накладных расходов.
  \item Определение \lstinline'data', как в приведенном выше примере с \lstinline'Person'. Вы можете также создавать алгебраические типы данных (АТД), такие как \lstinline'data Vehicle = Bycicle GearCount | Car Make Model'.
\end{itemize}

\subsubsection{Конструктор данных}

В приведенных выше примерах \lstinline'Person', \lstinline'Make', Bicycle и Car "--- конструкторы данных.

\subsubsection{Конструктор типа}

В приведенных выше примерах \lstinline'Person', \lstinline'Make' и \lstinline'Vehicle' "--- конструкторы типов.

\subsubsection{Переменные типов}

Рассмотрим тип данных \lstinline'data Maybe a = Just a | Nothing'. В этом случае \lstinline'a' "--- переменная типа.

\subsection{Инструментарий}

Для разработки на Haskell вам понадобятся два основных инструмента. Во-первых, Glasgow Haskell Compiler (GHC), стандартный компилятор Haskell "--- и единственный официально поддерживаемый Yesod. Вам также понадобится Cabal, стандартное средство сборки для Haskell. Cabal используется не только для сборки локального кода "--- он также может автоматически скачивать и устанавливать зависимости из Hackage, репозитория пакетов Haskell.

Тем, кто работает в среде Windows или Mac, настоятельно рекомендуется скачать Haskell Platform. Многие дистрибутивы Linux содержат Haskell Platform в своих репозиториях. Например, в дистрибутивах, основанных на Debian, стоит начать с выполнения команды \lstinline'apt-get install haskell-platform'. Если в вашем дистрибутиве Haskell Platform недоступна, вы можете установить ее вручную, следуя инструкциям на официальном сайте.

Еще один важный инструмент, который вам нужно будет обновить, "--- это alex. Haskell Platform включает версию 2, но используемой Yesod программе минимизации JavaScript, hjsmin, требуется версия 3. Не забудьте выполнить \lstinline'cabal install alex' после установки Haskell Platform, иначе получите сообщения об ошибках в отношении пакета language-javascript.

Некоторым нравится жить на острие прогресса и устанавливать последнюю версию GHC до того, как она станет доступна в Haskell Platform. Мы стараемся поддерживать совместимость Yesod со всеми современными версиями GHC, но официально мы поддерживаем только Haskell Platform. Если вы все-таки решили пойти по пути ручной установки GHC, то:

\begin{itemize}
  \item Вам нужно будет установить некоторые дополнительные инструменты, в частности, alex и happy.
  \item Убедитесь, что установлены все требуемые C-библиотеки. В дистрибутивах, основанных на Debian, это можно сделать, выполнив команду \lstinline'sudo apt-get install libedit-dev libbsd-dev lbgmp3-dev zlib1g-dev freeglut3-dev'.
\end{itemize}

Независимо от способа установки инструментов вам нужно добавить путь к каталогу bin Cabal в переменную окружения PATH. В Mac и Linux это будет \$HOME/.cabal/bin, а в Windows~--- \%APPDATA\%\textbackslash{}cabal\textbackslash{}bin.

У Cabal есть множество доступных опций, но для начала ознакомьтесь с двумя:

\begin{itemize}
  \item \lstinline'cabal updata' скачивает актуальный список пакетов с hackage.
  \item \lstinline'cabal install yesod-platform' устанавливает Yesod и его зависимости.
\end{itemize}

Многие члены сообщества предпочитают выполнять изолированную сборку пакетов Haskell, что предотвращает порчу существующих пакетов вследствие установки Yesod или порчу Yesod из-за установки каких-то пакетов в будущем. В этой книге я не буду углубляться в детали того, как это делается, но два наиболее часто используемых для этих целей инструмента "--- это cabal-dev и virthualenv.

\subsection{Указания компилятору}

По умолчанию GHC работает с режиме, очень близком к Haskell98. Но с ним также поставляется большое число языковых расширений, предоставляющих более мощные классы типов, изменения в синтаксисе и прочее. Есть несколько способов заставить GHC включить эти расширения. В большинстве фрагментов кода, приведенных в этой книге, вы увидите указания компилятору, которые выглядят следующим образом:

\begin{lstlisting}
{-# LANGUAGE MyLanguageExtension #-}
\end{lstlisting}

Эти указания должны всегда находиться в самом начале исходного файла. Помимо этого, есть еще два распространенных способа:
\begin{itemize}
\item передать GHC аргумент командной строки \lstinline'-XMyLanguageExtension';
\item добавить блок расширений в файл cabal.
\end{itemize}

Лично я никогда не использую подход с аргументами командной строки. Это личное предпочтение, но мне нравится, когда мои настройки явным образом указаны в файле. В общем случае также рекомендуется избегать помещения расширений в файл cabal. Впрочем, в сгенерированном Yesod начальном каркасе сайта мы специально применяем этот подход, чтобы избежать необходимости указывать одни и те же указания компилятору в каждом исходном файле.

В конечном счете мы будем использовать в этой книге немало языковых расширений (начальный каркас сайта использует 11). Мы не будем рассматривать значение каждого из них. За этим, пожалуйста, обращайтесь к документации по GHC.

\subsection{Перегруженные строки}

Какой тип имеет литерал <<hello>>? Обычно это \lstinline'String', определенный как \lstinline'type String = [Char]'. К сожалению, у этого подхода есть ряд ограничений:
\begin{itemize}
% DOUBT: cons cell
\item Это очень неэффективный способ хранения текстовых данных. Мы должны выделить память под каждую cons-ячейку, плюс каждый символ занимает целое машинное слово.
\item Иногда у нас есть данные, похожие на строку, но не являющиеся текстом, такие как \lstinline'ByteString' и \lstinline'HTML'.
\end{itemize}

Для преодоления этих ограничений в GHC есть языковое расширение, называемое \lstinline'OverloadedStrings'. Когда оно включено, строковые литералы будут иметь не мономорфный тип \lstinline'String', а тип \lstinline'IsString a => a', где \lstinline'IsString' определен следующим образом:

\begin{lstlisting}
class IsString a where
    fromString :: String -> a
\end{lstlisting}

% DOUBT: a much more efficient packed String type
Существуют экземпляры \lstinline'IsString' для ряда типов Haskell, таких как \lstinline'Text' (намного более эффективный тип для упакованного хранения строк), \lstinline'ByteString' и \lstinline'HTML'. Практически каждый пример в этой книге предполагает, что это языковое расширение включено.

% DOUBT: GHC's type checker
К сожалению, у этого расширения есть один недостаток: иногда оно может сбить с толку проверку типов GHC. Представьте, что у нас есть следующий код:

\begin{lstlisting}
{-# LANGUAGE OverloadedStrings, TypeSynonymInstances, FlexibleInstances #-}

import Data.Text (Text)

class DoSomething a where
    something :: a -> IO ()

instance DoSomething String where
    something _ = putStrLn "String"

instance DoSomething Text where
    something _ = putStrLn "Text"

myFunc :: IO ()
myFunc = something "hello"
\end{lstlisting}

Что эта программа напечатает "--- <<String>> или <<Text>>? Неясно. Поэтому вам придется предоставить явную аннотацию типа, чтобы указать, должен ли литерал <<hello>> трактоваться как \lstinline'String' или как \lstinline'Text'.

\subsection{Семейства типов}

% DOUBT: associated type
% DOUBT: есть сомнения в правильности перевода
% Оригинал:
% The basic idea of a type family is to state some association between two different types. Suppose we want to write a function that will safely take the first element of a list. But we don't want it to work just on lists; we'd like it to treat a ByteString like a list of Word8s. To do so, we need to introduce some associated type to specify what the contents of a certain type are.
Основная идея семейства типов "--- устанавливать некоторую ассоциацию между двумя различными типами. Предположим, мы хотим написать функцию, которая безопасным образом получает первый элемент списка. Но мы не хотим, чтобы она работала только на списках; нам бы хотелось, чтобы она трактовала \lstinline'ByteString' как список, состоящий из элементов типа \lstinline'Word8'. Чтобы этого добиться, нам нужно ввести некоторый ассоциированный тип, чтобы указать, каково содержимое определенного типа.

\begin{lstlisting}
{-# LANGUAGE TypeFamilies, OverloadedStrings #-}

import Data.Word (Word8)
import qualified Data.ByteString as S
import Data.ByteString.Char8 () -- get an orphan IsString instance

class SafeHead a where
    type Content a
    safeHead :: a -> Maybe (Content a)

instance SafeHead [a] where
    type Content [a] = a
    safeHead [] = Nothing
    safeHead (x:_) = Just x

instance SafeHead S.ByteString where
    type Content S.ByteString = Word8
    safeHead bs
        | S.null bs = Nothing
        | otherwise = Just $ S.head bs

main :: IO ()
main = do
    print $ safeHead ("" :: String)
    print $ safeHead ("hello" :: String)

    print $ safeHead ("" :: S.ByteString)
    print $ safeHead ("hello" :: S.ByteString)
\end{lstlisting}

Новый синтаксис заключается в возможности поместить тип внутри класса и экземпляра. Вместо этого мы также можем использова \lstinline'data', что создаст новый тип данных вместо ссылки на уже существующий.

Есть и другие пути использования ассоциированных типов вне контекста класса типов. Однако в Yesod все наши ассоциированные типы являются, фактически, частью класса типов. Более подробную информацию о семействах типов можно найти на соответствующей странице Haskell wiki.

% DOUBT: надо ли переводить?
\subsection{Template Haskell}

% DOUBT: boilerplate = вспомогательный код?
Template Haskell (TH) "--- это способ генерации кода. Мы используем его в ряде мест в Yesod для уменьшения объема вспомогательного кода и для того, чтобы быть уверенными в корректности сгенерированного кода. Template Haskell "--- это, в сущности, Haskell, который генерирует абстрактное синтаксическое дерево (АСД) Haskell.

На самом деле возможности TH этим не ограничиваются, так как он позволяет фактически выполнять интроспекцию кода. Однако эти возможности мы в Yesod не используем.

Написание кода на TH может быть непростым делом, и, к сожалению, типовой безопасности при этом не слишком много. Несложно написать на TH программу, генерирующую код, который не скомпилируется. Это является проблемой только для разработчиков Yesod, но не для его пользователей. В ходе разработки мы используем большой набор модульных тестов, чтобы убедиться в корректности сгенерированного кода. Как пользователю все что вам нужно делать "--- вызывать эти уже существующие функции. Например, чтобы включить внешний шаблон Hamlet, вы можете написать:

\begin{lstlisting}
$(hamletFile "myfile.hamlet")
\end{lstlisting}

% DOUBT: And yes, it's even possible to go meta with this.
(Hamlet обсуждается в главе о Shakespeare.) Символ доллара, за которым следует открывающая скобка, сообщает GHC, что то, что следует далее, является функцией Template Haskell. Код внутри скобок затем запускается компилятором и генерирует АСД программы на Haskell, которое затем компилируется. И да, при этом можно даже использовать метапрограммирование.

Приятная особенность "--- код на TH может выполнять произвольные действия ввода-вывода, и, следовательно, мы можем разместить входные данные во внешних файлах, которые будет разбираться во время компиляции. Один из примеров использования заключается в получении шаблонов HTML, CSS и JavaScript, проверяемых во время компиляции.

Если ваш код на Template Haskell используется для генерации объявлений и располагается на верхнем уровне наших файлов, то мы можем избавиться от знаков доллара и скобок. Иными словами,

\begin{lstlisting}
{-# LANGUAGE TemplateHaskell #-}

-- Обычное определение функции, ничего особенного
myFunction = ...

-- Включить код на TH
$(myThCode)

-- Или, то же самое
myThCode
\end{lstlisting}

Может быть полезно посмотреть, какой код генерирует для вас Template Haskell. Для этого вам нужно использовать опцию GHC \lstinline'-ddump-splices'.

Есть еще много других особенностей Template Haskell, которые здесь не рассматриваются. Более подробную информацию можете посмотреть в Haskell wiki.

\subsubsection{QuasiQuotes}

% DOUBT: quasi-quoter
QuasiQuotes (QQ) это небольшое расширение Template Haskell, которое позволяет нам включать произвольные данные в файлы с исходным кодом на Haskell. Например, выше упоминалась функция Template Haskell \lstinline'hamletFile', которая считывает содержимое шаблона из внешнего файла. У нас также есть quasi-quoter, называемый hamlet, который считывает содержимое, хранящееся непосредственно в исходном коде:

\begin{lstlisting}
{-# LANGUAGE QuasiQuotes #-}

[hamlet|<p>This is quasi-quoted Hamlet.|]
\end{lstlisting}

% DOUBT: pipes = символ <<|>>?
Синтаксис выделяется квадратными скобками и символами <<|>>. Имя quasi-quoter пишется между открывающей скобкой и первым символом <<|>>, а содержимое приводится между символами <<|>>.

На протяжении книги мы во многих случаях будем предпочитать внешним файлам QQ-подход, поскольку такой код проще копировать. Однако в реальных приложениях внешние файлы являются предпочтительными во всех случаях, кроме совсем коротких данных, так как это дает нам хорошее разделение кода на Haskell и кода с иным синтаксисом.

\subsection{Выводы}

Вам не нужно быть экспертом в Haskell, чтобы использовать Yesod, достаточно базового знакомства. Надеюсь, эта глава дала вам достаточно информации, чтобы чувствовать себя более комфортно при изучении оставшейся части книги.
