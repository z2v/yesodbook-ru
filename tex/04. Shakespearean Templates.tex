\chapter{Shakespeare шаблоны}\label{chap:shakespeare}
%FIXME: Shakespearean Templates -> Shakespeare шаблоны

Yesod использует Shakespeare семейство шаблонных языков как стандартный 
подход к созданию HTML, CSS и Javascript. Это семейство языков имеет похожий 
синтаксис и общепринятые принципы: 

\begin{itemize}
%FIXME: as well as overarching princeples -> и общепринятые принципы
\item Как можно меньшее вмешательство в язык, на которых шаблонные языки 
основываются, но в то же время использование преимуществ этого языка.
%FIXME: тавтология
\item Гарантии корректности контента обеспечиваются компилятором.
%XXX:compile-time guarantees on well-formed content -> Гарантии корректности контента обеспечиваются компилятором.
\item Предоставляемая статической типизацией безопасность, которая также 
предотвращает \texttt{XSS} (cross-site scripting) атаки.
\item Автоматическая проверка валидности URL-ов, где это возможно, с помощью 
типобезопасных URL-ов.
%FIXME:type-safe URLs -> типобезопасных URL-ов
\end{itemize}

По сути, ничего не связывает Yesod с этими языками, другими словами, и языки, 
и Yesod можно использовать по-отдельности. Данная глава будет рассматривать 
эти шаблонные языки сами по себе, в то время как оставшаяся часть книги 
будет их использовать для разработки приложений для Yesod.
%FIXME: to enhance Yesod application development -> для разработки приложений на Yesod

\section{Краткий обзор}
%FIXME: Synopsis -> Краткий обзор

Всего в игре 4 основных языка: Hamlet - это шаблонный язык HTML, 
Julius - для Javascript, Cassius и Lucius - оба для CSS. Hamlet и Cassius - 
%FIXME: Hamlet and Cassius are both whitespace sensitive formats -> два языка, чувствительные к форматированию
два языка, чувствительные к форматированию, использующие отступы для 
%XXX: use indentation to denote nesting -> использовать отступы для обозначения вложенных блоков
обозначения вложенных блоков. Lucius же, являясь подмножеством CSS, использует
%XXX: Lucius is a superset of CSS -> Lucius является подмножеством CSS
фигурные скобки для обозначения вложенных блоков. 
Julius - это простой однопроходный язык, который служит для 
%FIXME: simple passthrough language -> простой однопроходный язык
генерирования Javascript; единственная добавочная функциональность - это 
интерполяция переменных.
%FIXME: variable interpolation -> интерполяция переменных

\subsection{Hamlet (HTML)}

\begin{lstlisting}
$doctype 5
<html>
    <head>
        <title>#{pageTitle} - My Site
        <link rel=stylesheet href=@{Stylesheet}>
    <body>
        <h1 .page-title>#{pageTitle}
        <p>Here is a list of your friends:
        $if null friends
            <p>Sorry, I lied, you don't have any friends.
        $else
            <ul>
                $forall Friend name age <- friends
                    <li>#{name} (#{age} years old)
        <footer>^{copyright}
\end{lstlisting}

\subsection{Cassius (CSS)}

\begin{lstlisting}
#myid
    color: #{red}
    font-size: #{bodyFontSize}
foo bar baz
    background-image: url(@{MyBackgroundR})
\end{lstlisting}

\subsection{Lucius (CSS)}

\begin{lstlisting}
section.blog {
    padding: 1em;
    border: 1px solid #000;
    h1 {
        color: #{headingColor};
    }
}
\end{lstlisting}

\subsection{Julius (Javascript)}

\begin{lstlisting}
$(function(){
    $("section.#{sectionClass}").hide();
    $("#mybutton").click(function(){document.location = "@{SomeRouteR}";});
    ^{addBling}
});
\end{lstlisting}
%FIXME: что-то с форматированием lstlisting в vim (мешает $)

\section{Types}

Прежде чем мы перейдем к синтаксису давайте взглянем на различные используемые 
типы данных. Мы уже обсуждали~\ref{chap:introduction} во вступлении, что типы 
помогают нам защищаться от \texttt{XSS} атак. К примеру, скажем, 
у нас есть HTML шаблон, который должен отображать чьë-то имя. Он может выглядеть
как-то так:

\begin{lstlisting}
<p>Hello, my name is #{name}
\end{lstlisting}


\lstinline!#{...}! - это способ интерполяции переменных в Shakespeare.

Что должно произойти с имененем, и какого оно должно быть типа данных?
Самое простое решение - использовать \texttt{Text} переменную, и вставлять 
еë значение в код.  
%FIXME: naive approach - самое простое решение
%FIXME: use Text value and insert it verbatim  - использовать Text переменную и вставлять ее значение в код
Но это вызовет проблемы для случая, когда
\lstinline!name="<script src='http://nefarious.com/evil.js'></script>"!.
Что хотелось бы получить в данном случае - это имя с закодированными символами, 
так что 
%FIXME: entity-encode - кодировать символы
\lstinline!<! становится \lstinline!&lt;!.

Таким же на наивным решением было бы просто кодировать каждый кусок 
вставляемого текста. Что получится, если у вас есть заранее сгенерированный 
другим процессом HTML? Например, на сайте Yesod, все Haskell-куски кода 
пропущены через раскрашивающую функцию, которая оборачивает каждое слово
в соответствующий \texttt{span}-тэг. Если мы закодируем все символы такого 
текста, все куски раскрашенного кода станут просто нечитабельными.

Вместо этого мы имеем специальный тип данных - Html. Для того, чтобы сгенерировать
Html значение, у нас есть две возможности в API: \lstinline!ToHtml! класс типов
предоставляет способ конвертировать String и Text значения в Html через 
\lstinline!toHtml! функцию, которая автоматически конвертирует все символы.
Этот подход подходит для решения проблемы с \texttt{name}, описанный выше. Для
примеров с кусками кода мы бы использовали \lstinline!preEscaped! 
семейство функций.
%FIXME: как-то криво звучит последнее предложение - по сути, повторение мысли
%FIXME: предыдущего. Может его как-то союзом соединить каким-нибудь?

Когда вы используете интерполяцию переменной в Hamlet (HTML Shakespeare язык), 
она автоматически применяет \lstinline!toHtml! функцию на значение 
этой переменной. Т.е. если вы интерполируете String, все ее символы 
будут закодированы. Но если вы возьмете переменную типа Html, ее значение
будет появляться неизменëнным. В примере с кусками кода, мы могли бы 
интерполировать как-нибудь так: \lstinline!#{preEscapedText myHaskellHtml}!.

Тип Html, как и все описанные выше функции, объявлены в пакете 
\texttt{blaze-html}. Это позволяет Hamlet взаимодействовать со всеми 
остальными \texttt{blaze-html} пакетами, а также предоставляет Hamlet 
более общее решение для создания \texttt{blaze-html} значений. 
Еще одним преимуществом пакета \texttt{blaze-html} является 
его высокая производительность.
%XXX: пакетами -> подпакетами?
%XXX: какой-то кривой перевод

Аналогично, у нас есть \lstinline!Css!/\lstinline!ToCss! и 
\lstinline!Javascript!/\lstinline!ToJavascript!. Это дает возможность во время
компиляции проводить некоторую проверку работоспособности программы: что мы 
случайно не добавили какой-то HTML код в CSS.

Еще одно достоинство, уже со стороны CSS, - это вспомогательные типы данных для 
цветов и единиц измерений. Например: 

\begin{lstlisting}
.red { color: #{colorRed} }
\end{lstlisting}

Подробности ищите в докуменации по Haddock.

\section{Типобезопасные URL}
Наверное, самая уникальная особенность Yesod - это типобезопасные URL, и 
возможность удобного их использования предоставлена напрямую Shakespeare.
%XXX: системой Shakespeare?
Использование типобезопасных URL почти идентично интерполяции переменных,
мы просто используем символ "собаки" (\verb'@') вместо "решетки" (\verb'#').
Мы чуть позже остановимся подробнее на синтаксисе, сперва, давайте прольем свет
на семантику.
%FIXME: let's clarify the intuition -> давайте прольем свет на семантику

Предположим, у нас есть приложение с двумя маршрутами 
\texttt{http://example.com/profile/home} - это домашняя страница, и 
\texttt{http://example.com/display/time} - показывает текущее время.
И, скажем, мы хотим сделать ссылку с домашней страницы на страницу со временем.
Я вижу три различных способа конструирования URL:
\begin{enumerate}
  \item Как относительную ссылку: \texttt{../display/time}
  \item Как абсолютную ссылку без домена: \texttt{/display/time}
  \item Как абсолютную ссылку с доменом: \texttt{http://example.com/display/time}
\end{enumerate}

Каждый из этих способов имеет недостатки: первый перестанет работать, если 
любой из URL изменится. К тому же, он подходит не для всех случаев: 
\texttt{RSS} и \texttt{Atom}, к примеру, требуют абсолютный URL. Второй способ
более защищен от изменений URL, чем первый, но все еще неприменим для RSS и Atom.
И, хотя, третий способ хорошо работает для всех случаев, вам придется каждый раз
обновлять все URL, когда поменяется ваш домен. Вы думаете, это происходит не так
часто? Просто подождите, пока вы переместитесь с сервера разработки на пробный
сервер, а потом и на рабочий сервер.
%FIXME: staging server -> пробный сервер
%FIXME: production server -> рабочий сервер

Но что более важно, есть еще одна очень большая проблема во всех этих подходах:
если вы изменяете ваши маршруты, ваш компилятор не предупредит вас о сломанных
ссылках. Не говоря об опечатках, которые также могут причинить большой ущерб.

Цель введения типобезопасных URL - это позволить компилятору проверять за 
нами как можно больше вещей. Чтобы способствовать этому, нашим первым шагом 
должен быть уход от обычного текста, который компилятор не умеет понимать, 
к каким-то хорошо определенным типы данных. Для нашего простого приложения,
давайте будем моделировать наши маршруты следующим типом:
%FIXME: plain text -> обычный текст
%FIXME: well defined datatypes -> хорошо определенные типы данных

\begin{lstlisting}
data MyRoute = Home | Time
\end{lstlisting}

Вместо того, чтобы добавлять в наш шаблон ссылку вида /display/time, мы можем
использовать конструктор Time. Но в итоге HTML - это текст, а не типы данных,
так что мы должны иметь какой-то способ конвертировать эти значения в текст.
Мы называем это - рендерингом URL в строку, один из которых:

\begin{lstlisting}
renderMyRoute :: MyRoute -> Text
renderMyRoute Home = "http://example.com/profile/home"
renderMyRoute Time = "http://example.com/display/time"
\end{lstlisting}

Функции рендеринга URL обычно чуть более сложные, чем описанный выше пример.
Они должны уметь работать с параметрами строки запросов (query string parameters),
с аргументами конструкторов и более правильно управляться с доменными именами.
На практике, вам не придется беспокоиться об этом, т.к. Yesod автоматически 
создает вам функции рендеринга. Единственная вещь, которую стоит здесь отметить,
 - это то, что сигнатура типа, на самом деле, чуть более усложняется для 
работы с параметрами строки запросов.
%FIXME: records within constructors -> аргументы конструкторов 

\begin{lstlisting}
type Query = [(Text, Text)]                                                     
type Render url = url -> Query -> Text                                          
renderMyRoute :: Render MyRoute                                                 
renderMyRoute Home _ = ...                                                      
renderMyRoute Time _ = ...   
\end{lstlisting}

Что ж, хорошо, у нас есть теперь наша функция рендеринга в строку, и у нас есть
типобезопасные URL, встроенные в шаблоны. Как все это работает вместе?
Вместо генерации Html (или Css или Javascript) значений напрямую, 
Shakespeare шаблоны фактически создают функции, которые, используя данную
функцию рендеринга, создает сам HTML. Чтобы лучше понять данную концепцию,
давайте взглянем на то, как Hamlet обработает следующий шаблон:
%FIXME: under the surface -> на самом деле

\begin{lstlisting}
<a href=@{Time}>The time                                                        
\end{lstlisting}
                                                                                
Эта строчка будет представлена примерно таким Haskell кодом 

\begin{lstlisting}
\render -> mconcat ["<a href='", render Time, "'>The time</a>"]     
\end{lstlisting}

\section{Синтаксис}
Все Shakespeare языки используют один и тот же интерполяционный синтаксис, 
и все они могут использовать типобезопасные URL. Они отличаются в синтаксисе,
специфичном для их целевых языков (HTML, CSS, Javascript).
%FIXME: interpolation syntax -> интерполяционный синтаксис

\subsection{Синтаксис языка Hamlet}
Hamlet - это самый сложный из языков семейства. Он предоставляет не только 
синтаксис для генеации HTML, но также и базовые структуры для контроля: 
условия, циклы, maybes.
%FIXME: maybes -> maybes

\subsection{Тэги}
Очевидно, тэги играют важную роль в любом шаблонном языке HTML. В Hamlet
мы пытаемся оставаться как можно ближе к текущему синтаксису HTML, чтобы
сделать язык более удобным. Однако, вместо использования закрывающих тэгов
для обозначения вложенности, мы используем отступы. Например, следующий код
в HTML:
%FIXME: tag -> тэг

\begin{lstlisting}
<body>                                                                          
<p>Some paragraph.</p>                                                          
<ul>                                                                            
<li>Item 1</li>                                                                 
<li>Item 2</li>                                                                 
</ul>                                                                           
</body>   
\end{lstlisting}

будет выглядеть следующим образом:
\begin{lstlisting}
<body>                                                                          
    <p>Some paragraph.                                                          
    <ul>                                                                        
        <li>Item 1                                                              
        <li>Item 2    
\end{lstlisting}

В целом, мы считаем, что этот способ более прост в использования, нежели чем 
оригинальный HTML, как только вы привыкнете к нему. Единственная сложная часть
 - это работа с пробелами до и после тэгов. К примеру, скажем, вы хотите
создать следующий HTML:

\begin{lstlisting}
<p>Paragraph <i>italic</i> end.</p>
\end{lstlisting}

Мы хотим быть уверенными, что пробелы останутся после слова "Paragraph" и
до слова "end". Чтобы добиться этого мы используем два простых escape-символа:
%FIXME: escape character -> escape-символ

\begin{lstlisting}
<p>                                                                             
    Paragraph #                                                                 
    <i>italic                                                                   
    \ end.         
\end{lstlisting}

Правила дли использования escape-пробелов очень простые:
\begin{enumerate}
\item Если первый непробельный символ в строке - это обратная косая черта, 
он игнорируется
\item Если последний символ в строке - это решетка, он игнорируется
\end{enumerate}

И еще одна важная особенность. Hamlet не экранирует своë содержимое.
Это сделано намеренно, чтобы позволять копировать уже существующий HTML-код.
То есть пример выше может быть записан как:
%FIXME: escape entities within its content -> экранировать своеë содержимое
\begin{lstlisting}
<p>Paragraph <i>italic</i> end.
\end{lstlisting}

Заметим, что Hamlet автоматически закроет первый тэг, в то время как внутренний
тэг "i" останется как есть. Вы вольны использовать любой из предложенных
подходов, они равноценны. Будьте, однако, осторожны, Hamlet закрывает только
подобные встроенные тэги; нормальные тэги не будут закрыты.
%FIXME: вообще не понял последнее предложение!

\section{Интерполяция}
Всë, что мы имели до текущего момента - это приятный, упрощенный HTML, но он
не предоставляет никакой возможности взаимодействовать с нашим кодом на Haskell.
Как мы будем встраивать в него переменные? Очень просто: с помощью интерполяции:

\begin{lstlisting}
<head>
    <title>#{title}
\end{lstlisting}

Символ решетки \verb'#', за которым следуют фигурные скобки - определяет интерполяцию
переменной. В примере выше будет использована переменная \lstinline!title! из той
области видимости, где был использован шаблон. Мне хочется подчеркнуть еще раз:
Hamlet имеет доступ к переменным той области видимости, из которой был вызван.
При этом не нужно особым образом указывать список использованных в шаблоне переменных.

Вы также можете применять функции внутри интерполяции. Вы можете использовать
строковые и численные литералы в интерполяции. Вы можете использовать 
квалификационные имена модулей (\lstinline!import qualified ... as ...!). Внутри
интерполяции можно использовать как скобки, так и знак доллара \texttt{\$}
для группировки выражений. И еще, в самом конце, функция \lstinline!toHtml!
применится к результату вычисления, что значит, что все экземпляры класса 
\lstinline!ToHtml! могут быть сынтерполированы. Возьмите, к примеру, следующий код.
%FIXME qualified -> квалифицированное имя

\begin{lstlisting}
-- Пока что игнорируйте QuasiQuotes и функцию shamlet, мы все это объясним позже
{-# LANGUAGE QuasiQuotes #-}

import Text.Hamlet (shamlet)
import Text.Blaze.Html.Renderer.String (renderHtml)
import Data.Char (toLower)
import Data.List (sort)

data Person = Person
    { name :: String
    , age  :: Int
    }

main :: IO ()
main = putStrLn $ renderHtml [shamlet|
<p>Hello, my name is #{name person} and I am #{show $ age person}.
<p>
    Let's do some funny stuff with my name: #
    <b>#{sort $ map toLower (name person)}
<p>Oh, and in 5 years I'll be #{show ((+) 5 (age person))} years old.
|]
  where
    person = Person "Michael" 26
\end{lstlisting}

Что же с нашими расхваленными типобезопасными URL? Они почти что идентичны
интерполяции переменных по всем показателям, за исключением того, что они
начинаются с символа \texttt{@}. Кроме того, существует также встраивание с помощью
знака вставки \verb'^', которое позволяет вам вставить другой шаблон того же типа.
Код ниже демонстрирует обе описанные концепции.

\begin{lstlisting}
{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE OverloadedStrings #-}

import Text.Hamlet (HtmlUrl, hamlet)
import Text.Blaze.Html.Renderer.String (renderHtml)
import Data.Text (Text)

data MyRoute = Home

render :: MyRoute -> [(Text, Text)] -> Text
render Home _ = "/home"

footer :: HtmlUrl MyRoute
footer = [hamlet|
<footer>
    Return to #
    <a href=@{Home}>Homepage
    .
|]

main :: IO ()
main = putStrLn $ renderHtml $ [hamlet|
<body>
    <p>This is my page.
    ^{footer}
|] render
\end{lstlisting}

\section{Атрибуты}
В последнем примере, мы добавили \texttt{href} атрибут в \texttt{a} тэг. Давайте
уточним синтаксис:

\begin{itemize}
\item Вы можете иметь интерполяции внутри значения атрибута. 
\item Знак равенства и значения атрибута - опциональны, точно так же, как в HTML.
Так что \lstinline!<input type=checkbox checked>! - абсолютно валидный код
\item Есть два удобных атрибута: для \lstinline!id!, вы можете использовать знак 
решетк, а для класса - точку. Например, \lstinline!<p #paragraphid .class1 .class2>!.
\item Кавычки вокруг значения атрибута опциональны, но они обязательны, если вы
хотите использовать пробел в составе этого значения.
\item Вы можете использовать атрибут опционально с помощью использования двоеточия.
Чтобы сделать checkbox активированным только если переменная \lstinline!isChecked!
установлена в \lstinline!True!, вы можете написать
\lstinline!<input type=checkbox :isChecked:checked>!.
Чтобы сделать параграф опционально красным, вы можете использовать
\lstinline!<p :isRed:style="color:red">!.
\end{itemize}

% FIXME: checkbox -> checkbox



%TODO: for WORD in HTML, CSS, Javascript, Yesod, Hamlet, Julius, Casius, Lucius, Shakespeare, Haskell:
%TODO:       WORD -> \texttt{WORD}
%TODO: for WORD in Html, String, Text:
%TODO:       WORD -> \lstinline!WORD!
%TODO: ë

