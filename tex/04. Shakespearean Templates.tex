\chapter{Шекспировские шаблоны}\label{chap:shakespeare}

Yesod использует Шекспировское семейство шаблонных языков как стандартный 
подход к созданию HTML, CSS и Javascript. Это семейство языков имеет похожий 
синтаксис и общепринятые принципы: 

\begin{itemize}
%FIXME: as well as overarching princeples -> и общепринятые принципы
\item Как можно меньшее вмешательство в язык, на которых шаблонные языки 
основываются, но в то же время использование преимуществ этого языка.
%FIXME: тавтология
\item Гарантии корректности контента обеспечиваются компилятором.
%XXX:compile-time guarantees on well-formed content -> Гарантии корректности контента обеспечиваются компилятором.
\item Предоставляемая статической типизацией безопасность, которая также 
предотвращает \texttt{XSS} (cross-site scripting) атаки.
\item Автоматическая проверка валидности URL-ов, где это возможно, с помощью 
типобезопасных URL-ов.
%FIXME:type-safe URLs -> типобезопасных URL-ов
\end{itemize}

По сути, ничего не связывает Yesod с этими языками, другими словами, и языки, 
и Yesod можно использовать по-отдельности. Данная глава будет рассматривать 
эти шаблонные языки сами по себе, в то время как оставшаяся часть книги 
будет их использовать для разработки приложений для Yesod.
%FIXME: to enhance Yesod application development -> для разработки приложений на Yesod

\section{Краткий обзор}
%FIXME: Synopsis -> Краткий обзор

Всего в игре 4 основных языка: Hamlet - это шаблонный язык HTML, 
Julius - для Javascript, Cassius и Lucius - оба для CSS. Hamlet и Cassius - 
%FIXME: Hamlet and Cassius are both whitespace sensitive formats -> два языка, чувствительные к форматированию
два языка, чувствительные к форматированию, использующие отступы для 
%XXX: use indentation to denote nesting -> использовать отступы для обозначения вложенных блоков
обозначения вложенных блоков. Lucius же, являясь подмножеством CSS, использует
%XXX: Lucius is a superset of CSS -> Lucius является подмножеством CSS
фигурные скобки для обозначения вложенных блоков. 
Julius - это простой однопроходный язык, который служит для 
%FIXME: simple passthrough language -> простой однопроходный язык
генерирования Javascript; единственная добавочная функциональность - это 
интерполяция переменных.
%FIXME: variable interpolation -> интерполяция переменных

\subsection{Hamlet (HTML)}

\begin{lstlisting}
$doctype 5
<html>
    <head>
        <title>#{pageTitle} - My Site
        <link rel=stylesheet href=@{Stylesheet}>
    <body>
        <h1 .page-title>#{pageTitle}
        <p>Here is a list of your friends:
        $if null friends
            <p>Sorry, I lied, you don't have any friends.
        $else
            <ul>
                $forall Friend name age <- friends
                    <li>#{name} (#{age} years old)
        <footer>^{copyright}
\end{lstlisting}

\subsection{Cassius (CSS)}

\begin{lstlisting}
#myid
    color: #{red}
    font-size: #{bodyFontSize}
foo bar baz
    background-image: url(@{MyBackgroundR})
\end{lstlisting}

\subsection{Lucius (CSS)}

\begin{lstlisting}
section.blog {
    padding: 1em;
    border: 1px solid #000;
    h1 {
        color: #{headingColor};
    }
}
\end{lstlisting}

\subsection{Julius (Javascript)}

\begin{lstlisting}
$(function(){
    $("section.#{sectionClass}").hide();
    $("#mybutton").click(function(){document.location = "@{SomeRouteR}";});
    ^{addBling}
});
\end{lstlisting}
%FIXME: что-то с форматированием lstlisting в vim (мешает $)

\section{Types}

Прежде чем мы перейдем к синтаксису давайте взглянем на различные используемые 
типы данных. Мы уже обсуждали~\ref{chap:introduction} во вступлении, что типы 
помогают нам защищаться от \texttt{XSS} атак. К примеру, скажем, 
у нас есть HTML шаблон, который должен отображать чьë-то имя. Он может выглядеть
как-то так:

\begin{lstlisting}
<p>Hello, my name is #{name}
\end{lstlisting}


\lstinline!#{...}! - это способ интерполяции переменных в Шекспировских шаблонах.

Что должно произойти с имененем, и какого оно должно быть типа данных?
Наивное решение - это использовать \texttt{Text} переменную, и вставлять 
еë значение в код.  
%FIXME: use Text value and insert it verbatim  - использовать Text переменную и вставлять ее значение в код
Но это вызовет проблемы для случая, когда
\lstinline!name="<script src='http://nefarious.com/evil.js'></script>"!.
Что хотелось бы получить в данном случае - это имя с закодированными символами, 
так что 
%FIXME: entity-encode - кодировать символы
\lstinline!<! становится \lstinline!&lt;!.

Таким же на наивным решением было бы просто кодировать каждый кусок 
вставляемого текста. Что получится, если у вас есть заранее сгенерированный 
другим процессом HTML? Например, на сайте Yesod, все Haskell-куски кода 
пропущены через раскрашивающую функцию, которая оборачивает каждое слово
в соответствующий \texttt{span}-тэг. Если мы закодируем все символы такого 
текста, все куски раскрашенного кода станут просто нечитабельными.

Вместо этого мы имеем специальный тип данных - Html. Для того, чтобы сгенерировать
Html значение, у нас есть две возможности в API: \lstinline!ToHtml! класс типов
предоставляет способ конвертировать String и Text значения в Html через 
\lstinline!toHtml! функцию, которая автоматически конвертирует все символы.
Этот подход подходит для решения проблемы с \texttt{name}, описанный выше. Для
примеров с кусками кода мы бы использовали \lstinline!preEscaped! 
семейство функций.
%FIXME: как-то криво звучит последнее предложение - по сути, повторение мысли
%FIXME: предыдущего. Может его как-то союзом соединить каким-нибудь?

Когда вы используете интерполяцию переменной в Hamlet (HTML Шекспировский язык), 
она автоматически применяет \lstinline!toHtml! функцию на значение 
этой переменной. Т.е. если вы интерполируете String, все ее символы 
будут закодированы. Но если вы возьмете переменную типа Html, ее значение
будет появляться неизменëнным. В примере с кусками кода, мы могли бы 
интерполировать как-нибудь так: \lstinline!#{preEscapedText myHaskellHtml}!.

Тип Html, как и все описанные выше функции, объявлены в пакете 
\texttt{blaze-html}. Это позволяет Hamlet взаимодействовать со всеми 
остальными \texttt{blaze-html} пакетами, а также предоставляет Hamlet 
более общее решение для создания \texttt{blaze-html} значений. 
Еще одним преимуществом пакета \texttt{blaze-html} является 
его высокая производительность.
%XXX: пакетами -> подпакетами?
%XXX: какой-то кривой перевод

Аналогично, у нас есть \lstinline!Css!/\lstinline!ToCss! и 
\lstinline!Javascript!/\lstinline!ToJavascript!. Это дает возможность во время
компиляции проводить некоторую проверку работоспособности программы: что мы 
случайно не добавили какой-то HTML код в CSS.

Еще одно достоинство, уже со стороны CSS, - это вспомогательные типы данных для 
цветов и единиц измерений. Например: 

\begin{lstlisting}
.red { color: #{colorRed} }
\end{lstlisting}

Подробности ищите в докуменации по Haddock.

\section{Типобезопасные URL}
Наверное, самая уникальная особенность Yesod - это типобезопасные URL, и 
возможность удобного их использования предоставлена напрямую системой 
Шекспировских шаблонов.
Использование типобезопасных URL почти идентично интерполяции переменных,
мы просто используем символ "собаки" (\textt{@}) вместо "решетки" (\textt{#}).
Мы чуть позже остановимся подробнее на синтаксисе, сперва, давайте прольем свет
на семантику.
%FIXME: let's clarify the intuition -> давайте прольем свет на семантику

Предположим, у нас есть приложение с двумя маршрутами 
\textt{http://example.com/profile/home} - это домашняя страница, и 
\textt{http://example.com/display/time} - показывает текущее время.
И, скажем, мы хотим сделать ссылку с домашней страницы на страницу со временем.
Я вижу три различных способа конструирования URL:
\begin{enumerate}
  \item Как относительную ссылку: \textt{../display/time}
  \item Как абсолютную ссылку без домена: \textt{/display/time}
  \item Как абсолютную ссылку с доменом: \textt{http://example.com/display/time}
\end{enumerate}

Каждый из этих способов имеет недостатки: первый перестанет работать, если 
любой из URL изменится. К тому же, он подходит не для всех случаев: 
\textt{RSS} и \textt{Atom}, к примеру, требуют абсолютный URL. Второй способ
более защищен от изменений URL, чем первый, но все еще неприменим для RSS и Atom.
И, хотя, третий способ хорошо работает для всех случаев, вам придется каждый раз
обновлять все URL, когда поменяется ваш домен. Вы думаете, это происходит не так
часто? Просто подождите, пока вы переместитесь с сервера разработки на пробный
сервер, а потом и на рабочий сервер.
%FIXME: staging server -> пробный сервер
%FIXME: production server -> рабочий сервер

Но что более важно, есть еще одна очень большая проблема во всех этих подходах:
если вы изменяете ваши маршруты, ваш компилятор не предупредит вас о сломанных
ссылках. Не говоря об опечатках, которые также могут причинить большой ущерб.

Цель введения типобезопасных URL - это позволить компилятору проверять за 
нами как можно больше вещей. Чтобы способствовать этому, нашим первым шагом 
должен быть уход от обычного текста, который компилятор не умеет понимать, 
к каким-то хорошо определенным типы данных. Для нашего простого приложения,
давайте будем моделировать наши маршруты следующим типом:
%FIXME: plain text -> обычный текст
%FIXME: well defined datatypes -> хорошо определенные типы данных

\begin{lstlisting}
data MyRoute = Home | Time
\end{lstlisting}

Вместо того, чтобы добавлять в наш шаблон ссылку вида /display/time, мы можем
использовать конструктор Time. Но в итоге HTML - это текст, а не типы данных,
так что мы должны иметь какой-то способ конвертировать эти значения в текст.
Мы называем это - рендерингом URL в строку, один из которых:

\begin{lstlisting}
renderMyRoute :: MyRoute -> Text
renderMyRoute Home = "http://example.com/profile/home"
renderMyRoute Time = "http://example.com/display/time"
\end{lstlisting}

Функции рендеринга URL обычно чуть более сложные, чем описанный выше пример.
Они должны уметь работать с параметрами строки запросов (query string parameters),
с аргументами конструкторов и более правильно управляться с доменными именами.
На практике, вам не придется беспокоиться об этом, т.к. Yesod автоматически 
создает вам функции рендеринга. Единственная вещь, которую стоит здесь отметить,
 - это то, что сигнатура типа, на самом деле, чуть более усложняется для 
работы с параметрами строки запросов.
%FIXME: records within constructors -> аргументы конструкторов 

\begin{lstlisting}
type Query = [(Text, Text)]                                                     
type Render url = url -> Query -> Text                                          
renderMyRoute :: Render MyRoute                                                 
renderMyRoute Home _ = ...                                                      
renderMyRoute Time _ = ...   
\end{lstlisting}

Что ж, хорошо, у нас есть теперь наша функция рендеринга в строку, и у нас есть
типобезопасные URL, встроенные в шаблоны. Как все это работает вместе?
Вместо генерации Html (или Css или Javascript) значений напрямую, 
Шекспировские шаблоны фактически создают функции, которые, используя данную
функцию рендеринга, создает сам HTML. Чтобы лучше понять данную концепцию,
давайте взглянем на то, как Hamlet обработает следующий шаблон:
%FIXME: under the surface -> на самом деле

\begin{lstlisting}
<a href=@{Time}>The time                                                        
\end{lstlisting}
                                                                                
Эта строчка будет представлена примерно таким Haskell кодом 

\begin{lstlisting}
\render -> mconcat ["<a href='", render Time, "'>The time</a>"]     
\end{lstlisting}

\section{Синтаксис}
Все Шекспировские языки используют один и тот же интерполяционный синтаксис, 
и все они могут использовать типобезопасные URL. Они отличаются в синтаксисе,
специфичном для их целевых языков (HTML, CSS, Javascript).
%FIXME: interpolation syntax -> интерполяционный синтаксис

\section{Синтаксис языка Hamlet}
Hamlet - это самый сложный из языков семейства. Он предоставляет не только 
синтаксис для генеации HTML, но также и базовые структуры для контроля: 
условия, циклы, maybes.
%FIXME: maybes -> maybes

\subsection{Тэги}
Очевидно, тэги играют важную роль в любом шаблонном языке HTML. В Hamlet
мы пытаемся оставаться как можно ближе к текущему синтаксису HTML, чтобы
сделать язык более удобным. Однако, вместо использования закрывающих тэгов
для обозначения вложенности, мы используем отступы. Например, следующий код
в HTML:
%FIXME: tag -> тэг

\begin{lstlisting}
<body>                                                                          
<p>Some paragraph.</p>                                                          
<ul>                                                                            
<li>Item 1</li>                                                                 
<li>Item 2</li>                                                                 
</ul>                                                                           
</body>   
\end{lstlisting}

будет выглядеть следующим образом:
\begin{lstlisting}
<body>                                                                          
    <p>Some paragraph.                                                          
    <ul>                                                                        
        <li>Item 1                                                              
        <li>Item 2    
\end{lstlisting}

В целом, мы считаем, что этот способ более прост в использования, нежели чем 
оригинальный HTML, как только вы привыкнете к нему. Единственная сложная часть
 - это работа с пробелами до и после тэгов. К примеру, скажем, вы хотите
создать следующий HTML:

\begin{lstlisting}
<p>Paragraph <i>italic</i> end.</p>
\end{lstlisting}

Мы хотим быть уверенными, что пробелы останутся после слова "Paragraph" и
до слова "end". Чтобы добиться этого мы используем два простых escape-символа:
%FIXME: escape character -> escape-символ

\begin{lstlisting}
<p>                                                                             
    Paragraph #                                                                 
    <i>italic                                                                   
    \ end.         
\end{lstlisting}

Правила дли использования escape-пробелов очень простые:
\begin{enumerate}
\item Если первый непробельный символ в строке - это обратная косая черта, 
он игнорируется
\item Если последний символ в строке - это решетка, он игнорируется
\end{enumerate}

И еще одна важная особенность. Hamlet не экранирует своë содержимое.
Это сделано намеренно, чтобы позволять копировать уже существующий HTML-код.
То есть пример выше может быть записан как:
%FIXME: escape entities within its content -> экранировать своеë содержимое
\begin{lstlisting}
<p>Paragraph <i>italic</i> end.
\end{lstlisting}

Заметим, что Hamlet автоматически закроет первый тэг, в то время как внутренний
тэг "i" останется как есть. Вы вольны использовать любой из предложенных
подходов, они равноценны. Будьте, однако, осторожны, Hamlet закрывает только
подобные встроенные тэги; нормальные тэги не будут закрыты.
%FIXME: вообще не понял последнее предложение!

\subsection{Интерполяция}
Всë, что мы имели до текущего момента - это приятный, упрощенный HTML, но он
не предоставляет никакой возможности взаимодействовать с нашим кодом на Haskell.
Как мы будем встраивать в него переменные? Очень просто: с помощью интерполяции:

\begin{lstlisting}
<head>
    <title>#{title}
\end{lstlisting}

Символ решетки '#', за которым следуют фигурные скобки - определяет интерполяцию
переменной. В примере выше будет использована переменная \lstinline!title! из той
области видимости, где был использован шаблон. Мне хочется подчеркнуть еще раз:
Hamlet имеет доступ к переменным той области видимости, из которой был вызван.
При этом не нужно особым образом указывать список использованных в шаблоне переменных.

Вы также можете применять функции внутри интерполяции. Вы можете использовать
строковые и численные литералы в интерполяции. Вы можете использовать 
квалификационные имена модулей (\lstinline!import qualified ... as ...!). Внутри
интерполяции можно использовать как скобки, так и знак доллара \texttt{\$}
для группировки выражений. И еще, в самом конце, функция \lstinline!toHtml!
применится к результату вычисления, что значит, что все экземпляры класса 
\lstinline!ToHtml! могут быть сынтерполированы. Возьмите, к примеру, следующий код.
%FIXME qualified -> квалифицированное имя

\begin{lstlisting}
-- Пока что игнорируйте QuasiQuotes и функцию shamlet, мы все это объясним позже
{-# LANGUAGE QuasiQuotes #-}

import Text.Hamlet (shamlet)
import Text.Blaze.Html.Renderer.String (renderHtml)
import Data.Char (toLower)
import Data.List (sort)

data Person = Person
    { name :: String
    , age  :: Int
    }

main :: IO ()
main = putStrLn $ renderHtml [shamlet|
<p>Hello, my name is #{name person} and I am #{show $ age person}.
<p>
    Let's do some funny stuff with my name: #
    <b>#{sort $ map toLower (name person)}
<p>Oh, and in 5 years I'll be #{show ((+) 5 (age person))} years old.
|]
  where
    person = Person "Michael" 26
\end{lstlisting}

Что же с нашими расхваленными типобезопасными URL? Они почти что идентичны
интерполяции переменных по всем показателям, за исключением того, что они
начинаются с символа \texttt{@}. Кроме того, существует также встраивание с помощью
знака вставки \texttt{^}, которое позволяет вам вставить другой шаблон того же типа.
Код ниже демонстрирует обе описанные концепции.

\begin{lstlisting}
{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE OverloadedStrings #-}

import Text.Hamlet (HtmlUrl, hamlet)
import Text.Blaze.Html.Renderer.String (renderHtml)
import Data.Text (Text)

data MyRoute = Home

render :: MyRoute -> [(Text, Text)] -> Text
render Home _ = "/home"

footer :: HtmlUrl MyRoute
footer = [hamlet|
<footer>
    Return to #
    <a href=@{Home}>Homepage
    .
|]

main :: IO ()
main = putStrLn $ renderHtml $ [hamlet|
<body>
    <p>This is my page.
    ^{footer}
|] render
\end{lstlisting}

\subsection{Атрибуты}
В последнем примере, мы добавили \texttt{href} атрибут в тэг \texttt{a}. Давайте
уточним синтаксис:

\begin{itemize}
\item Вы можете иметь интерполяции внутри значения атрибута. 
\item Знак равенства и значения атрибута - опциональны, точно так же, как в HTML.
Так что \lstinline!<input type=checkbox checked>! - абсолютно валидный код
\item Есть два удобных атрибута: для \lstinline!id!, вы можете использовать знак 
решетка \texttt{#}, а для класса - точку \texttt{.}. Например, \lstinline!<p #paragraphid .class1 .class2>!.
\item Кавычки вокруг значения атрибута опциональны, но они обязательны, если вы
хотите использовать пробел в составе этого значения.
\item Вы можете использовать атрибут опционально с помощью использования двоеточия.
Чтобы сделать checkbox активированным только если переменная \lstinline!isChecked!
установлена в \lstinline!True!, вы можете написать
% FIXME: checkbox -> checkbox
\lstinline!<input type=checkbox :isChecked:checked>!.
Чтобы сделать параграф опционально красным, вы можете использовать
\lstinline!<p :isRed:style="color:red">!.
\end{itemize}


\subsection{Условные выражения}

В конечном счëте вы захотите добавить некоторую логику на вашу страницу. Цель
языка Hamlet - это сделать эту логику как можно более минималистичной, возлагая
всю сложную работу на Haskell. Например, логические выражения - очень просты...
Настолько просты, что это базовый набор \texttt{if}, \texttt{elsif} и 
\texttt{else}.

\begin{lstlisting}
$if isAdmin
    <p>Welcome to the admin section.
$elseif isLoggedIn
    <p>You are not the administrator.
$else
    <p>I don't know who you are. Please log in so I can decide if you get access.
\end{lstlisting}

Все те же самые правила обычной интерполяции применяются и к содержимому 
условных выражений.
%FIXME apply to the content of the conditionals -> применяются и к содержимому условных выражений

\subsection{Maybe}

Подобным же образом, мы имеем специальную конструкцию, чтобы работать 
со значениями Maybe. Технически, это можно делать с помощью \texttt{if}, 
\texttt{isJust} и \texttt{fromJust}, но наш подход более удобный и позволяет
избегать частично вычислимых функций.
%FIXME partial functions -> частично вычислимая функция

\begin{lstlisting}
$maybe name <- maybeName
    <p>Your name is #{name}
$nothing
    <p>I don't know your name.
\end{lstlisting}

Помимо простых идентификаторов вы можете использовать слева от стрелки некоторые другие, 
более сложные значения, например, конструкторы и кортежи.

\begin{lstlisting}
$maybe Person firstName lastName <- maybePerson
    <p>Your name is #{firstName} #{lastName}
\end{lstlisting}

Выражение справа от стрелки подчиняется тем же правилам интерполяции, 
позволяет использовать переменные, вызывать функции и т.д.

\subsection{Forall}

А что с пробеганием по элементам списка? Мы покрываем и этот шаблон:

\begin{lstlisting}
$if null people
    <p>No people.
$else
    <ul>
        $forall person <- people
            <li>#{person}
\end{lstlisting}


\subsection{Case}

Сопоставление шаблонов - одна из сильных сторон Haskell. Алгебраические типы данных
позволяют вам удобно моделировать любые типы данных из реального мира, а 
case-выражения позволяют вам безопасно их сопоставлять, возлагая на компилятор
обязанность предупреждать, если вы пропустили одно из значений.
Hamlet предоставляет вам эти же самые преимущества.

\begin{lstlisting}
$case foo
    $of Left bar
        <p>It was left: #{bar}
    $of Right baz
        <p>It was right: #{baz}
\end{lstlisting}

\subsection{With}

Мы заканчиваем обзор выражений языка, рассматривая \texttt{with}. Это, по сути,
просто удобный способ объявления синонима для длинного выражения

\begin{lstlisting}
$with foo <- some very (long ugly) expression that $ should only $ happen once
    <p>But I'm going to use #{foo} multiple times. #{foo}
\end{lstlisting}

\subsection{Doctype}
Последняя ложка синтаксического сахара: выражение \texttt{doctype}. Мы
поддерживаем несколько разных версий \texttt{doctype}, хотя мы рекомендуем
lstinline!\$doctype 5! для современных интернет-приложений, который генерирует
\lstinline!<!DOCTYPE html>!

\begin{lstlisting}
$doctype 5
<html>
    <head>
        <title>Hamlet is Awesome
    <body>
        <p>All done.
\end{lstlisting}

Мы все еще поддерживаем и старый синтаксис: три восклицательных знака \texttt{!!!}.
Вы все еще можете увидеть его в коде. Мы планируем и дальше поддерживать этот
синтаксис, но в целом, находим \lstinline!\$doctype! подход более легким для чтения.

\section{Синтаксис языка Cassius}
Cassius - это оригинальный шаблонный язык CSS. Он использует простые правила
с пробелами для разделения блоков, делая фигурные скобки и точки с запятой 
необязательными. Он поддерживает интерполяцию переменных и URL, но не поддерживает
встраивание. Его синтаксис очень простой:

\begin{lstlisting}
#banner
    border: 1px solid #{bannerColor}
    background-image: url(@{BannerImageR})
\end{lstlisting}

\section{Синтаксис языка Lucius}
В то время, как Cassius использует модифицированный, чувствительный к пробелам 
синтаксис для CSS, подход Lucius полностью оригинальный. Вы можете взять любой CSS
файл и он будет валидным Lucius файлом. Однако, есть некоторые дополнения:

\begin{itemize}
\item Как в Cassius, мы позволяем интерполяцию как переменных, так и URL.
\item Возможность вложенных CSS блоков.
\item Вы можете определять переменные в ваших шаблонах.
\end{itemize}

Что касается второго пункта: скажем, вы хотите иметь специфичный стиль для 
какого-то тэга в вашей статье. В плоском CSS вы должны были бы написать

\begin{lstlisting}
article code { background-color: grey; }
article p { text-indent: 2em; }
article a { text-decoration: none; }
\end{lstlisting}

В этом случае получилось не так уж и много выражений, но необходимость печатать
\texttt{article} каждый раз - слегка надоедает. А представьте, что таких выражений, 
скажем, около десятка - согласитесь, раздражает.
Lucius пожможет в этом случае:

\begin{lstlisting}
article {
    code { background-color: grey; }
    p { text-indent: 2em; }
    a { text-decoration: none; }
}
\end{lstlisting}

Само наличие переменныx в Lucius позволяет вам избегать повторов. Простым примером
будет определить общий используемый цвет как переменную:

\begin{lstlisting}
@textcolor: #ccc; /* just because we hate our users */
body { color: #{textcolor} }
a:link, a:visited { color: #{textcolor} }
\end{lstlisting}

В остальном, Lucius идентичен CSS.

\section{Синтаксис языка Julius}

Julius - наиболее простой среди всех обсуждаемых здесь языков. На самом деле, 
многие могут сказать, что это на самом деле всего лишь Javascript. Julius
Позволяет использовать три формы интерполяции, которые мы уже упоминали.
И, наоборот, не применяет никаких преобразований к вашему контенту.
%FIXME: and otherwise applies no transformations to your content -> И, наоборот, не применяет никаких преобразований к вашему контенту.

Если вы используете Julius c ??? Yesod сайтом, вы возможно заметили, что ваш
Javascript автоматически компактизован. Это не следствие использования Julius, это
результат использования пакета hjsmin в Yesod, который служит для компактизации
выдачи Julius.
%FIXME: scaffolded Yesod site -> ???
%FIXME: minified -> компактизован

\section{Как заставить Шекспировские шаблоны работать}

Конечно, в какой-то момент у вас появится этот вопрос: "Как же мне заставить это
все работать?". Существует три разных способа вызывать Шекспировские языки 
из вашего Haskell кода:

\subsection{Квази-цитирование}
Квази-цитирование (quasiquotes) позволяют вам встроить произвольное содержимое в ваш Haskell код, и
конвертировать это содержимое в Haskell во время компиляции.
%FIXME: стоит ли оставлять английский вариант?

\subsection {Внешние файлы}
В этом случае, код шаблонов находится в отдельных файлов, на который мы ссылаемся
с помощью шаблонов Haskell.

\subsection {Режим перезагрузки}
Оба использованных выше подхода требуют полной перекомпиляции для того, чтобы увидеть
какие-то изменения. В режиме перезагрузки ваши шаблоны хранятся в отдельных файлах,
и ссылаются из шаблонов Haskell. Но при этом, в рантайме, эти внешние файлы 
каждый раз пересканируются на лету
%FIXME: runtime -> в рантайме

Режим перезагрузки нельзя использовать для Hamlet, только для Cassius, Lucius и Julius.
В Hamlet слишком много сложной логики, которая полагается напрямую на Haskell
компилятор, что препятствует использованию этот режима для Hamlet.
%FIXME: runtime -> в рантайме

Первые два подхода следует использовать в реальных условиях на серверах.
%FIXME: in production -> в реальных условиях на серверах
Они оба встраивают целиком шаблоны в финальный исполняемый файл, упрощая 
развертывание кода и увеличивая производительность.
%FIXME deployment -> развертывание кода
Достоинство квази-цитирования - это простота: все остается в одном файле.
Для коротких шаблонов, это может быть очень удобно. Однако, в целом, мы рекомендуем
использовать внешние файлы для шаблонов, поскольку:

\begin{itemize}
\item Это следование традиции разделения логики и представления данных
\item Вы можете легко переключиться между внешними файлами и отладочным режимом
работы с помощью простых макро-определений \texttt{CPP}, в том смысле, что вы
можете совмещать быструю и удобную разработку и все еще получать высокую
производительность на боевых серверах.
%FIXME: deployment -> боевые сервера
\end{itemize}

Так как это специальные функции Квази-цитиования и шаблонного Haskell, вы 
должны удостовериться, что вы используете соответствующие расширения языка
и корректный синтаксис. Вы можете посмотреть простейшие примеры каждого подхода
на следующих примерах

%TODO: название в примеры??
%TODO: Квази-цитирование
\begin{lstlisting}
{-# LANGUAGE OverloadedStrings #-} -- we're using Text below
{-# LANGUAGE QuasiQuotes #-}

import Text.Hamlet (HtmlUrl, hamlet)
import Data.Text (Text)
import Text.Blaze.Html.Renderer.String (renderHtml)

data MyRoute = Home | Time | Stylesheet

render :: MyRoute -> [(Text, Text)] -> Text
render Home _ = "/home"
render Time _ = "/time"
render Stylesheet _ = "/style.css"

template :: Text -> HtmlUrl MyRoute
template title = [hamlet|
$doctype 5
<html>
    <head>
        <title>#{title}
        <link rel=stylesheet href=@{Stylesheet}>
    <body>
        <h1>#{title}
|]

main :: IO ()
main = putStrLn $ renderHtml $ template "My Title" render
\end{lstlisting}

%TODO: Внешние файлы
\begin{lstlisting}

{-# LANGUAGE OverloadedStrings #-} -- we're using Text below
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE CPP #-} -- to control production versus debug

import Text.Lucius (CssUrl, luciusFile, luciusFileDebug, renderCss)
import Data.Text (Text)
import qualified Data.Text.Lazy.IO as TLIO

data MyRoute = Home | Time | Stylesheet

render :: MyRoute -> [(Text, Text)] -> Text
render Home _ = "/home"
render Time _ = "/time"
render Stylesheet _ = "/style.css"

template :: CssUrl MyRoute
#if PRODUCTION
template = $(luciusFile "template.lucius")
#else
template = $(luciusFileDebug "template.lucius")
#endif

main :: IO ()
main = TLIO.putStrLn $ renderCss $ template render
-- @template.lucius
foo { bar: baz }
\end{lstlisting}

Способ именования функций очень консистентная.
%TODO: таблица
Language	Quasiquoter	External file	Reload
Hamlet	hamlet	hamletFile	N/A
Cassius	cassius	cassiusFile	cassiusFileReload
Lucius	lucius	luciusFile	luciusFileReload
Julius	julius	juliusFile	juliusFileReload

\section{Добавление функциональности в типы Hamlet}
%FIXME: alternate -> добавление функциональности
До сих пор мы видели только как генерировать HtmlUrl значение из Hamlet, что 
является HTML со встроенными типо-безопасными URL. Есть еще три других значения, 
которые мы можем генерировать, используя Hamlet: простой HTML, HTML с URL и 
интернациональными текстами, и виджеты.
%FIXME: internationalized messages -> интернациональными текстами
%FIXME: plain HTML -> простой HTML
Последние будут отдельно описаны в главе "Виджеты"~\ref{chap:introduction}.

Чтобы сгенерировать простой HTML без встроенных URL, мы используем 
"Упрощенный Hamlet" с некоторыми изменениями:

\begin{itemize}
\item Мы используем другой набор функций, которые начинаются с дополнительного 
префикса "s". Так что квази-цитирование - это \texttt{shamlet} и функция 
использования внешнего файла - это \texttt{shamletFile}. Вопрос, как следует произносить
названия этих функций, все еще находится в обсуждении.
\item Не позволяется использовать интерполяцию URL. Если попытаться это сделать, 
мы получим ошибку во время компиляции.
\item Встраивание (интерполяция-вставка) более не позволяет использовать произвольные
HtmlUrl значения. Правило здесь таково, что встраиваемое значение должно иметь
точно такой же тип, что и сам шаблон, что в данном случае - Html. Это означает,
что для \texttt{shamlet}, встраивание может быть полностью заменено интерполяцией
переменных (с использованием решетки \texttt{#}).
\end{itemize}

Работа с интернационализацией (i18n) в Hamlet проводится чуть более сложно.
Hamlet поддерживает i18n с помощью специального типа данных для сообщений - решение
концептуально и по реализации похоже на типобезопасные URL. Для примера, скажем, 
мы хотим написать программу, которая приветствует нас и говорит, как много яблок 
%FIXME: motivating example -> пример ??
мы съели. Мы могли бы представить эти сообщения в виде типа данных

\begin{lstlisting}
data Msg = Hello | Apples Int
\end{lstlisting}

Далее, мы бы хотели иметь возможность представлять это в каком-то более удобном
для чтения формате, поэтому мы определяем некоторую функцию для представления данных:
\begin{lstlisting}
renderEnglish :: Msg -> Text
renderEnglish Hello = "Hello"
renderEnglish (Apples 0) = "You did not buy any apples."
renderEnglish (Apples 1) = "You bought 1 apple."
renderEnglish (Apples i) = T.concat ["You bought ", T.pack $ show i, " apples."]
\end{lstlisting}

Теперь мы хотим интерполировать эти значения типа Msg напрямую в шаблоне.
Для этого мы используем интерполяцию с подчеркиванием.
%FIXME: underscore interpolation -> интерполяция с подчеркиванием

\begin{lstlisting}
$doctype 5
<html>
    <head>
        <title>i18n
    <body>
        <h1>_{Hello}
        <p>_{Apples count}
\end{lstlisting}

Этому вида шаблона теперь требуется некоторый способ представить эти данные в HTML.
Для этого, как и для типобезопасных URL, мы определяем специальную функцию.
%FIXME render function -> функция для представления данных 
Для удобства, определим синонимичный тип
%FIXME type synonym -> синонимичный тип

\begin{lstlisting}
type Render url = url -> [(Text, Text)] -> Text
type Translate msg = msg -> Html
type HtmlUrlI18n msg url = Translate msg -> Render url -> Html
\end{lstlisting}

В данной точке, вы можете передать \lstinline!renderEnglish!, 
\lstinline!renderSpanish! или \lstinline!renderKlingon! в данных шаблон. И он
сгенерирует хорошо переведенный контент (качество которого, конечно, зависит от
ваших переводчиков). Программа целиком будет выглядеть так:
\begin{lstlisting}
{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE OverloadedStrings #-}

import Data.Text (Text)
import qualified Data.Text as T
import Text.Hamlet (HtmlUrlI18n, ihamlet)
import Text.Blaze.Html (toHtml)
import Text.Blaze.Html.Renderer.String (renderHtml)

data MyRoute = Home | Time | Stylesheet

renderUrl :: MyRoute -> [(Text, Text)] -> Text
renderUrl Home _ = "/home"
renderUrl Time _ = "/time"
renderUrl Stylesheet _ = "/style.css"

data Msg = Hello | Apples Int

renderEnglish :: Msg -> Text
renderEnglish Hello = "Hello"
renderEnglish (Apples 0) = "You did not buy any apples."
renderEnglish (Apples 1) = "You bought 1 apple."
renderEnglish (Apples i) = T.concat ["You bought ", T.pack $ show i, " apples."]

template :: Int -> HtmlUrlI18n Msg MyRoute
template count = [ihamlet|
$doctype 5
<html>
    <head>
        <title>i18n
    <body>
        <h1>_{Hello}
        <p>_{Apples count}
|]

main :: IO ()
main = putStrLn $ renderHtml
     $ (template 5) (toHtml . renderEnglish) renderUrl
\end{lstlisting}

\section{Другие Шекспировские возможности}

%FIXME: Other Shakespare -> Другие Шекспировские возможности
В дополнение к языкам-помощникам для HTML, CSS и Javascript, есть также и более
общий пакет утилит. \lstinline!shakespare-text! предоставляет простой способ 
создания интерполированных строк, который очень нравится людям, привыкшим к 
скриптовым языкам вроде Ruby или Python. Конечно, утилиты этого пакета можно
использовать не только для Yesod.

\begin{lstlisting}
{-# LANGUAGE QuasiQuotes, OverloadedStrings #-}

import Text.Shakespeare.Text
import qualified Data.Text.Lazy.IO as TLIO
import Data.Text (Text)
import Control.Monad (forM_)

data Item = Item
    { itemName :: Text
    , itemQty :: Int
    }

items :: [Item]
items =
    [ Item "apples" 5
    , Item "bananas" 10
    ]

main :: IO ()
main = forM_ items $ \item -> TLIO.putStrLn
    [lt|You have #{show $ itemQty item} #{itemName item}.|]
\end{lstlisting}

Несколько быстрых подсказок по этому простому примеру:
\begin{itemize}
\item Мы используем три разных текстовых типа данных в примере 
(\lstinline!String!, строгий и ленивый \lstinline!Text!). Они замечательно
работают вместе.
\item Мы используем оператор квазицитирования \lstinline!lt!, который генерирует
ленивую версию текста. Также есть его строгий аналог \lstinline!st!.
\item Есть и более длинные имена для этих операторов 
(\lstinline!ltext! и \lstinline!stext!).
\end{itemize}

\section{Общие рекомендации}

Ниже приводятся общие рекомендации комьюнити Yesod по использованию
Шекспировского семейства языков.

\begin{itemize}
\item Для сайтов используйте внешние файлы. Для библиотек это вполне 
нормально - использовать квази-квотирование, при условии, что оно не слишком большое.
\item Патрик Брисбин (Patrick Brisbin) сделал правила раскраски для Vim, 
которые сильно помогают при разработке.
\item Вам следует почти всегда начинать тэги Hamlet на новых строках вместо того,
чтобы писать их после существующих тэгов. Единственное исключение этому правилу - это
использование \lstinline!<i>! и \lstinline!<b>! тэгов в большом блоке текста.
\end{itemize}

%TODO: for WORD in HTML, CSS, Javascript, Yesod, Hamlet, Julius, Cassius, Lucius, Haskell, Maybe:
%TODO:       WORD -> \texttt{WORD}
%TODO: for WORD in Html, String, Text:
%TODO:       WORD -> \lstinline!WORD!
%TODO: ë

