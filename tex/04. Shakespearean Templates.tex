\chapter{Shakespeare шаблоны}\label{ch:shakespeare}
%FIXME: Shakespearean Templates -> Shakespeare шаблоны

Yesod использует Shakespeare семейство шаблонных языков как стандартный 
подход к созданию HTML, CSS и Javascript. Это семейство языков имеет похожий 
синтаксис и общепринятые принципы: 

\begin{itemize}
%FIXME: as well as overarching princeples -> и общепринятые принципы
\item Как можно меньшее вмешательство в язык, на которых шаблонные языки 
основываются, но в то же время использование преимуществ этого языка.
%FIXME: тавтология
\item Гарантии корректности контента обеспечиваются компилятором.
%XXX:compile-time guarantees on well-formed content -> Гарантии корректности контента обеспечиваются компилятором.
\item Предоставляемая статической типизацией безопасность, которая также 
предотвращает \texttt{XSS} (cross-site scripting) атаки.
\item Автоматическая проверка валидности URL-ов, где это возможно, с помощью 
типобезопасных URL-ов.
%FIXME:type-safe URLs -> типобезопасных URL-ов
\end{itemize}

По сути, ничего не связывает Yesod с этими языками, другими словами, и языки, 
и Yesod можно использовать по-отдельности. Данная глава будет рассматривать 
эти шаблонные языки сами по себе, в то время как оставшаяся часть книги 
будет их использовать для разработки приложений для Yesod.
%FIXME: to enhance Yesod application development -> для разработки приложений на Yesod

\section{Краткий обзор}
%FIXME: Synopsis -> Краткий обзор

Всего в игре 4 основных языка: Hamlet - это шаблонный язык HTML, 
Julius - для Javascript, Cassius и Lucius - оба для CSS. Hamlet и Cassius - 
%FIXME: Hamlet and Cassius are both whitespace sensitive formats -> два языка, чувствительные к форматированию
два языка, чувствительные к форматированию, использующие отступы для 
%XXX: use indentation to denote nesting -> использовать отступы для обозначения вложенных блоков
обозначения вложенных блоков. Lucius же, являясь подмножеством CSS, использует
%XXX: Lucius is a superset of CSS -> Lucius является подмножеством CSS
фигурные скобки для обозначения вложенных блоков. 
Julius - это простой однопроходный язык, который служит для 
%FIXME: simple passthrough language -> простой однопроходный язык
генерирования Javascript; единственная добавочная функциональность - это 
интерполяция переменных.
%XXX: variable interpolation -> интерполяция переменных

\subsection{Hamlet (HTML)}

\begin{lstlisting}
$doctype 5
<html>
    <head>
        <title>#{pageTitle} - My Site
        <link rel=stylesheet href=@{Stylesheet}>
    <body>
        <h1 .page-title>#{pageTitle}
        <p>Here is a list of your friends:
        $if null friends
            <p>Sorry, I lied, you don't have any friends.
        $else
            <ul>
                $forall Friend name age <- friends
                    <li>#{name} (#{age} years old)
        <footer>^{copyright}
\end{lstlisting}

\subsection{Cassius (CSS)}

\begin{lstlisting}
#myid
    color: #{red}
    font-size: #{bodyFontSize}
foo bar baz
    background-image: url(@{MyBackgroundR})
\end{lstlisting}

\subsection{Lucius (CSS)}

\begin{lstlisting}
section.blog {
    padding: 1em;
    border: 1px solid #000;
    h1 {
        color: #{headingColor};
    }
}
\end{lstlisting}

\subsection{Julius (Javascript)}

\begin{lstlisting}
$(function(){
    $("section.#{sectionClass}").hide();
    $("#mybutton").click(function(){document.location = "@{SomeRouteR}";});
    ^{addBling}
});
\end{lstlisting}
%FIXME: что-то с форматированием lstlisting в vim (мешает $)

\section{Types}

Прежде чем мы перейдем к синтаксису давайте взглянем на различные используемые 
типы данных. Мы уже обсуждали~\ref{ch:introduction} во вступлении, что типы 
помогают нам защищаться от \texttt{XSS} атак. К примеру, скажем, 
у нас есть HTML шаблон, который должен отображать чьë-то имя. Он может выглядеть
как-то так:

\begin{lstlisting}
<p>Hello, my name is #{name}
\end{lstlisting}


\lstinline!#{...}! - это способ интерполяции переменных в Shakespeare.

Что должно произойти с имененем, и какого оно должно быть типа данных?
Самое простое решение - использовать \texttt{Text} переменную, и вставлять 
еë значение в код.  
%FIXME: naive approach - самое простое решение
%FIXME: use Text value and insert it verbatim  - использовать Text переменную и вставлять ее значение в код
Но это вызовет проблемы для случая, когда
\lstinline!name="<script src='http://nefarious.com/evil.js'></script>"!.
Что хотелось бы получить в данном случае - это имя с закодированными символами, 
так что 
%FIXME: entity-encode - кодировать символы
\lstinline!<! становится \lstinline!&lt;!.

Таким же на наивным решением было бы просто кодировать каждый кусок 
вставляемого текста. Что получится, если у вас есть заранее сгенерированный 
другим процессом HTML? Например, на сайте Yesod, все Haskell-куски кода 
пропущены через раскрашивающую функцию, которая оборачивает каждое слово
в соответствующий \texttt{span}-тэг. Если мы закодируем все символы такого 
текста, все куски раскрашенного кода станут просто нечитабельными.

Вместо этого мы имеем специальный тип данных - Html. Для того, чтобы сгенерировать
Html значение, у нас есть две возможности в API: \lstinline!ToHtml! класс типов
предоставляет способ конвертировать String и Text значения в Html через 
\lstinline!toHtml! функцию, которая автоматически конвертирует все символы.
Этот подход подходит для решения проблемы с \texttt{name}, описанный выше. Для
примеров с кусками кода мы бы использовали \lstinline!preEscaped! 
семейство функций.
%FIXME: как-то криво звучит последнее предложение - по сути, повторение мысли
%FIXME: предыдущего. Может его как-то союзом соединить каким-нибудь?

Когда вы используете интерполяцию переменной в Hamlet (HTML Shakespeare язык), 
она автоматически применяет \lstinline!toHtml! функцию на значение 
этой переменной. Т.е. если вы интерполируете String, все ее символы 
будут закодированы. Но если вы предоставите переменную типа Html, ее значение
будет появляться неизменëнным. В примере с кусками кода, мы могли бы 
интерполировать текст вида \lstinline!#{preEscapedText myHaskellHtml}!.


%TODO: for WORD in HTML, CSS, Javascript, Yesod, Hamlet, Julius, Casius, Lucius, Shakespeare, Haskell:
%TODO:       WORD -> \texttt{WORD}
%TODO: for WORD in Html, String, Text:
%TODO:       WORD -> \lstinline!WORD!
%TODO: ë

