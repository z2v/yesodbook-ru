\chapter{Шекспировские шаблоны}\label{chap:shakespeare}

\texttt{Yesod} использует Шекспировское семейство шаблонных языков как стандартный 
подход к созданию \texttt{HTML}, \texttt{CSS} и \texttt{Javascript}. Это семейство языков имеет похожий 
синтаксис и общие принципы: 

\begin{itemize}
\item Как можно меньшее вмешательство в языки, на базе которых создаются
Шекспировские шаблоны, но в то же время использование преимуществ этих языков.
\item Гарантии корректности контента обеспечиваются компилятором.
\item Безопасность статической типизации, которая также 
предотвращает \texttt{XSS} (cross-site scripting) атаки.
\item Автоматическая проверка валидности URL-ов, где это возможно, с помощью 
типобезопасных URL-ов.
\end{itemize}

По сути, ничего не связывает \texttt{Yesod} с этими языками. Или, другими словами, и языки, 
и \texttt{Yesod} можно использовать по-отдельности. Данная глава будет рассматривать 
эти шаблонные языки сами по себе, в то время как оставшаяся часть книги 
будет их использовать для разработки приложений для \texttt{Yesod}.

\section{Краткий обзор}

Всего в игре 4 основных языка: \texttt{Hamlet} - это шаблонный язык \texttt{HTML}, 
\texttt{Julius} - для \texttt{Javascript}, \texttt{Cassius} и \texttt{Lucius} - оба для \texttt{CSS}. \texttt{Hamlet} и \texttt{Cassius} - 
два языка, чувствительные к форматированию, использующие отступы для 
обозначения вложенных блоков. \texttt{Lucius} же, являясь расширением \texttt{CSS}, использует
фигурные скобки для обозначения вложенных блоков. 
\texttt{Julius} - это простой однопроходный язык, который служит для 
генерирования \texttt{Javascript}; единственная добавленная функциональность - это 
интерполяция переменных.

\subsection{\texttt{Hamlet} (\texttt{HTML})}

\begin{lstlisting}
$doctype 5
<html>
    <head>
        <title>#{pageTitle} - My Site
        <link rel=stylesheet href=@{Stylesheet}>
    <body>
        <h1 .page-title>#{pageTitle}
        <p>Вот список ваших друзей:
        $if null friends
            <p>Прошу прощения, я соврал, у вас нет друзей.
        $else
            <ul>
                $forall Friend name age <- friends
                    <li>#{name} (#{age} лет)
        <footer>^{copyright}
\end{lstlisting}

\subsection{\texttt{Cassius} (\texttt{CSS})}

\begin{lstlisting}
#myid
    color: #{red}
    font-size: #{bodyFontSize}
foo bar baz
    background-image: url(@{MyBackgroundR})
\end{lstlisting}

\subsection{\texttt{Lucius} (\texttt{CSS})}

\begin{lstlisting}
section.blog {
    padding: 1em;
    border: 1px solid #000;
    h1 {
        color: #{headingColor};
    }
}
\end{lstlisting}

\subsection{\texttt{Julius} (\texttt{Javascript})}

\begin{lstlisting}
$(function(){
    $("section.#{sectionClass}").hide();
    $("#mybutton").click(function(){document.location = "@{SomeRouteR}";});
    ^{addBling}
});
\end{lstlisting}
%FIXME: что-то с форматированием lstlisting в vim (мешает $)

\section{Types}

Прежде чем мы перейдем к синтаксису давайте взглянем на различные используемые 
типы данных. Мы уже обсуждали~\ref{chap:introduction} во вступлении, что типы 
помогают нам защищаться от \texttt{XSS} атак. К примеру, скажем, 
у нас есть \texttt{HTML} шаблон, который должен отображать чьë-то имя. Он может выглядеть
как-то так:

\begin{lstlisting}
<p>Привет, меня зовут #{name}
\end{lstlisting}


\lstinline!#{...}! - это способ интерполяции переменных в Шекспировских шаблонах.

Что должно произойти с имененем, и какого оно должно быть типа данных?
Наивное решение - это использовать \lstinline!Text! переменную, и вставлять 
явно еë значение в код.  
Но это вызовет проблемы для случая, когда
\lstinline!name="<script src='http://nefarious.com/evil.js'></script>"!.
Что хотелось бы получить в данном случае - это имя с закодированными символами, 
так что 
\lstinline!<! становится \lstinline!&lt;!.

Таким же наивным решением было бы просто кодировать каждый кусок 
вставляемого текста. Что получится, если у вас есть заранее сгенерированный 
другим процессом \texttt{HTML}? Например, на сайте \texttt{Yesod}, все \texttt{Haskell}-куски кода 
пропущены через раскрашивающую функцию, которая оборачивает каждое слово
в соответствующий \texttt{span}-тэг. Если мы закодируем все символы такого 
текста, все куски раскрашенного кода станут просто нечитабельными.

Вместо этого мы имеем специальный тип данных - \lstinline!Html!. Для того, чтобы сгенерировать
\lstinline!Html! значение, у нас есть две возможности в API: \lstinline!ToHtml! класс типов
предоставляет способ конвертировать \lstinline!String! и \lstinline!Text! значения в \lstinline!Html! через 
\lstinline!toHtml! функцию, которая автоматически конвертирует все символы.
Этот подход подходит для решения проблемы с \texttt{name}, описанный выше. Для
примеров с кусками кода мы бы использовали \lstinline!preEscaped! 
семейство функций.

Когда вы используете интерполяцию переменной в \texttt{Hamlet} (\texttt{HTML} Шекспировский язык), 
она автоматически применяет \lstinline!toHtml! функцию на значение 
этой переменной. Т.е. если вы интерполируете \lstinline!String!, все ее символы 
будут закодированы. Но если вы возьмете переменную типа \lstinline!Html!, ее значение
будет появляться неизменëнным. В примере с кусками кода, мы могли бы 
интерполировать как-нибудь так: \lstinline!#{preEscapedText myHaskellHtml}!.

Тип данных \lstinline!Html!, как и все описанные выше функции, объявлены в пакете 
\texttt{blaze-html}. Это позволяет \texttt{Hamlet} взаимодействовать со всеми 
остальными \texttt{blaze-html} пакетами, а также предоставляет 
более общее решение для создания \texttt{blaze-html} значений. 
Еще одним преимуществом пакета \texttt{blaze-html} является 
его высокая производительность.

Аналогично, у нас есть \lstinline!Css!/\lstinline!ToCss! и 
\lstinline!Javascript!/\lstinline!ToJavascript!. Это дает возможность во время
компиляции проводить некоторую проверку работоспособности программы: что мы 
случайно не добавили какой-то \texttt{HTML} код в \texttt{CSS}.

Еще одно достоинство, уже со стороны \texttt{CSS}, - это вспомогательные типы данных для 
цветов и единиц измерений. Например: 

\begin{lstlisting}
.red { color: #{colorRed} }
\end{lstlisting}

Подробности ищите в докуменации по Haddock.

\section{Типобезопасные URL}
Наверное, самая уникальная особенность \texttt{Yesod} - это типобезопасные URL, и 
возможность удобного их использования предоставлена напрямую системой 
Шекспировских шаблонов.
Использование типобезопасных URL почти идентично интерполяции переменных,
мы просто используем символ "собаки" (\verb'@') вместо "решетки" (\verb'#').
Мы чуть позже остановимся подробнее на синтаксисе, сперва, давайте создадим
общее понимание концепции.

Предположим, у нас есть приложение с двумя маршрутами 
\texttt{http://example.com/profile/home} - это домашняя страница, и 
\texttt{http://example.com/display/time} - показывает текущее время.
И, скажем, мы хотим сделать ссылку с домашней страницы на страницу со временем.
Я вижу три различных способа конструирования URL:
\begin{enumerate}
  \item Как относительную ссылку: \texttt{../display/time}
  \item Как абсолютную ссылку без домена: \texttt{/display/time}
  \item Как абсолютную ссылку с доменом: \texttt{http://example.com/display/time}
\end{enumerate}

Каждый из этих способов имеет недостатки: первый перестанет работать, если 
любой из URL изменится. К тому же, он подходит не для всех случаев: 
\texttt{RSS} и \texttt{Atom}, к примеру, требуют абсолютный URL. Второй способ
более защищен от изменений URL, чем первый, но все еще неприменим для \texttt{RSS} и \texttt{Atom}.
И, хотя, третий способ хорошо работает для всех случаев, вам придется каждый раз
обновлять все URL, когда поменяется ваш домен. Вы думаете, это происходит не так
часто? Просто подождите, пока вы переместитесь с сервера разработки на пробный
сервер, а потом и на "боевой" сервер.

Но что более важно, есть ещë одна очень большая проблема во всех этих подходах:
если вы изменяете ваши маршруты, компилятор не предупредит вас о сломанных
ссылках. Не говоря уже об опечатках, которые также могут причинить большой ущерб.

Цель введения типобезопасных URL - это позволить компилятору проверять за 
нами как можно больше вещей. Чтобы сделать этому, нашим первым шагом 
должен быть уход от обычного текста, который компилятор не умеет понимать, 
к каким-то хорошо определенным типам данных. Для нашего простого приложения,
давайте будем моделировать наши маршруты следующим типом данных:

\begin{lstlisting}
data MyRoute = Home | Time
\end{lstlisting}

Вместо того, чтобы добавлять в наш шаблон ссылку вида /display/time, мы можем
использовать конструктор Time. Но в итоге \texttt{HTML} - это текст, а не типы данных,
так что мы должны иметь какой-то способ конвертировать эти значения в текст.
Мы называем это - функцией рендеринга URL в строку, одна из которых:

\begin{lstlisting}
renderMyRoute :: MyRoute -> Text
renderMyRoute Home = "http://example.com/profile/home"
renderMyRoute Time = "http://example.com/display/time"
\end{lstlisting}

\begin{remark}
Функции рендеринга URL обычно чуть более сложные, чем описанный выше пример.
Они должны уметь работать с параметрами строки запросов (query string parameters),
с аргументами конструкторов и более правильно управляться с доменными именами.
На практике, вам не придется беспокоиться об этом, т.к. \texttt{Yesod} автоматически 
создает вам функции рендеринга. Единственная вещь, которую стоит здесь отметить,
 - это то, что сигнатура типа, на самом деле, чуть усложняется для 
работы с параметрами строки запросов.

\begin{lstlisting}
type Query = [(Text, Text)]                                                     
type Render url = url -> Query -> Text                                          
renderMyRoute :: Render MyRoute                                                 
renderMyRoute Home _ = ...                                                      
renderMyRoute Time _ = ...   
\end{lstlisting}
\end{remark}

Что ж, хорошо, у нас теперь есть наша функция рендеринга в строку, и у нас есть
типобезопасные URL, встроенные в шаблоны. Как всë это работает вместе?
Вместо генерации \lstinline!Html! (или \lstinline!Css! или \lstinline!Javascript!) значений напрямую, 
Шекспировские шаблоны фактически создают функции, которые, используя данную
функцию рендеринга, создает сам \texttt{HTML}. Чтобы лучше понять данную концепцию,
давайте взглянем на то, как \texttt{Hamlet} обработает следующий шаблон:

\begin{lstlisting}
<a href=@{Time}>The time                                                        
\end{lstlisting}
                                                                                
Эта строчка будет представлена примерно таким \texttt{Haskell} кодом 

\begin{lstlisting}
\render -> mconcat ["<a href='", render Time, "'>The time</a>"]     
\end{lstlisting}

\section{Синтаксис}
Все Шекспировские языки используют один и тот же интерполяционный синтаксис, 
и все они могут использовать типобезопасные URL. Они отличаются синтаксисом,
специфичном для их целевых языков (\texttt{HTML}, \texttt{CSS}, \texttt{Javascript}).

\section{Синтаксис языка \texttt{Hamlet}}
\texttt{Hamlet} - это самый сложный из языков семейства. Он предоставляет не только 
синтаксис для генеации \texttt{HTML}, но также и базовые структуры для контроля: 
условия, циклы, maybes.
%FIXME: maybes -> maybes

\subsection{Тэги}
Очевидно, тэги играют важную роль в любом шаблонном языке \texttt{HTML}. В \texttt{Hamlet}
мы пытаемся оставаться как можно ближе к текущему синтаксису \texttt{HTML}, чтобы
сделать язык более удобным. Однако, вместо использования закрывающих тэгов
для обозначения вложенности, мы используем отступы. Например, следующий код
в \texttt{HTML}:

\begin{lstlisting}
<body>                                                                          
<p>Какой-то абзац.</p>                                                          
<ul>                                                                            
<li>Пункт 1</li>                                                                 
<li>Пункт 2</li>                                                                 
</ul>                                                                           
</body>   
\end{lstlisting}

будет выглядеть следующим образом:
\begin{lstlisting}
<body>                                                                          
    <p>Какой-то абзац.
    <ul>                                                                        
        <li>Пункт 1                                                              
        <li>Пункт 2    
\end{lstlisting}

В целом, мы считаем, что этот способ более прост в использования, чем 
оригинальный \texttt{HTML}, как только вы привыкнете к нему. Единственная сложная часть
 - это работа с пробелами до и после тэгов. К примеру, скажем, вы хотите
создать следующий \texttt{HTML}:

\begin{lstlisting}
<p>Абзац <i>курсив</i> конец.</p>
\end{lstlisting}

Мы хотим быть уверенными, что пробелы останутся после слова "Paragraph" и
до слова "end". Чтобы добиться этого мы используем два простых escape-символа:
%FIXME: escape -> escape

\begin{lstlisting}
<p>                                                                             
    Абзац #
    <i>курсив                                                    
    \ конец.         
\end{lstlisting}

Правила дли использования escape-пробелов очень простые:
\begin{enumerate}
\item Если первый непробельный символ в строке - это обратная косая черта, 
он игнорируется
\item Если последний символ в строке - это решетка, он игнорируется
\end{enumerate}

И ещë одна важная особенность. \texttt{Hamlet} не экранирует содержимое своего контента.
Это сделано намеренно, чтобы позволять копировать уже существующий \texttt{HTML}-код.
То есть пример выше может быть записан как:
\begin{lstlisting}
<p>Абзац <i>курсив</i> конец.
\end{lstlisting}

Заметим, что \texttt{Hamlet} автоматически закроет первый тэг, в то время как внутренний
тэг "i" останется как есть. Вы вольны использовать любой из предложенных
подходов, они равноценны. Будьте, однако, осторожны, \texttt{Hamlet} закрывает только
подобные встроенные тэги; нормальные тэги не будут закрыты.
%FIXME: вообще не понял последнее предложение!

\subsection{Интерполяция}
Всë, что мы видели до текущего момента - это приятный, упрощенный \texttt{HTML}, но он
не предоставляет никакой возможности взаимодействовать с нашим кодом на \texttt{Haskell}.
Как мы будем встраивать в него переменные? Очень просто: с помощью интерполяции:

\begin{lstlisting}
<head>
    <title>#{title}
\end{lstlisting}

Символ решетки \verb'#', за которым следуют фигурные скобки - определяет интерполяцию
переменной. В примере выше будет использована переменная \lstinline!title! из той
области видимости, где был использован шаблон. Мне хочется подчеркнуть ещë раз:
\texttt{Hamlet} имеет доступ к переменным той области видимости, из которой был вызван.
При этом не нужно особым образом указывать список использованных в шаблоне переменных.

Вы также можете применять функции внутри интерполяции. Вы можете использовать
строковые и численные литералы в интерполяции. Вы можете использовать 
квалификационные имена модулей (\lstinline!import qualified ... as ...!). Внутри
%FIXME qualified -> квалифицированное имя
интерполяции можно использовать как скобки, так и знак доллара \texttt{\$}
для группировки выражений. И ещë, в самом конце, функция \lstinline!toHtml!
применится к результату вычисления, что значит, что все экземпляры класса 
\lstinline!ToHtml! могут быть сынтерполированы. Возьмите, к примеру, следующий код.

\begin{lstlisting}
-- Пока что игнорируйте QuasiQuotes и функцию shamlet, мы всë это объясним позже
{-# LANGUAGE QuasiQuotes #-}

import Text.Hamlet (shamlet)
import Text.Blaze.Html.Renderer.String (renderHtml)
import Data.Char (toLower)
import Data.List (sort)

data Person = Person
    { name :: String
    , age  :: Int
    }

main :: IO ()
main = putStrLn $ renderHtml [shamlet|
<p>Привет, меня зовут #{name person} и мне #{show $ age person}.
<p>
    Давайте сделаем с моим именем разные смешные штуки: #
    <b>#{sort $ map toLower (name person)}
<p>Ох, а через 5 лет мне будет #{show ((+) 5 (age person))}.
|]
  where
    person = Person "Michael" 26
\end{lstlisting}

Что же с нашими расхваленными типобезопасными URL? Они почти что идентичны
интерполяции переменных по всем показателям, за исключением того, что они
начинаются с символа \texttt{@}. Кроме того, существует также встраивание с помощью
знака вставки \verb'^', которое позволяет вам вставить другой шаблон того же типа.
Код ниже демонстрирует обе описанные концепции.

\begin{lstlisting}
{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE OverloadedStrings #-}

import Text.Hamlet (HtmlUrl, hamlet)
import Text.Blaze.Html.Renderer.String (renderHtml)
import Data.Text (Text)

data MyRoute = Home

render :: MyRoute -> [(Text, Text)] -> Text
render Home _ = "/home"

footer :: HtmlUrl MyRoute
footer = [hamlet|
<footer>
    Назад на #
    <a href=@{Home}>Домашнюю страницу
    .
|]

main :: IO ()
main = putStrLn $ renderHtml $ [hamlet|
<body>
    <p>Это моя страница.
    ^{footer}
|] render
\end{lstlisting}

\subsection{Атрибуты}
В последнем примере, мы добавили \texttt{href} атрибут в тэг \texttt{a}. Давайте
уточним синтаксис:

\begin{itemize}
\item Вы можете иметь интерполяции внутри значения атрибута. 
\item Знак равенства и значения атрибута - опциональны, точно так же, как в \texttt{HTML}.
Так что \lstinline!<input type=checkbox checked>! - абсолютно валидный код.
\item Есть два удобных атрибута: для \lstinline!id!, вы можете использовать знак 
решетка \texttt{\#}, а для класса - точку \texttt{.}. Например, \lstinline!<p #paragraphid .class1 .class2>!.
\item Кавычки вокруг значения атрибута опциональны, но они обязательны, если вы
хотите использовать пробел в составе этого значения.
\item Вы можете использовать атрибут опционально с помощью использования двоеточия.
Чтобы сделать checkbox активированным только если переменная \lstinline!isChecked!
установлена в \lstinline!True!, вы можете написать
% FIXME: checkbox -> checkbox
\lstinline!<input type=checkbox :isChecked:checked>!.
Чтобы сделать параграф опционально красным, вы можете использовать
\lstinline!<p :isRed:style="color:red">!.
\end{itemize}


\subsection{Условные выражения}

В конечном счëте вы захотите добавить некоторую логику на вашу страницу. Цель
языка \texttt{Hamlet} - это сделать эту логику как можно более минималистичной, возлагая
всю сложную работу на \texttt{Haskell}. Например, логические выражения - очень просты...
Настолько просты, что это базовый набор \texttt{if}, \texttt{elsif} и 
\texttt{else}.

\begin{lstlisting}
$if isAdmin
    <p>Добро пожаловать в админскую секцию.
$elseif isLoggedIn
    <p>Вы не администратор.
$else
    <p>Я не знаю, кто Вы. Пожалуйста, войдите в систему, чтобы я мог понять, есть ли у вас доступ.
\end{lstlisting}

Все те же самые правила обычной интерполяции применяются и к содержимому 
условных выражений.

\subsection{\lstinline!Maybe!}

Подобным же образом, мы имеем специальную конструкцию, чтобы работать 
со значениями \lstinline!Maybe!. Технически, это можно делать с помощью \texttt{if}, 
\texttt{isJust} и \texttt{fromJust}, но наш подход более удобный и позволяет
избегать частично вычислимых функций.
%FIXME partial functions -> частично вычислимая функция

\begin{lstlisting}
$maybe name <- maybeName
    <p>Ваc зовут #{name}
$nothing
    <p>Я не знаю Вашего имени.
\end{lstlisting}

Помимо простых идентификаторов вы можете использовать слева от стрелки некоторые другие, 
более сложные значения, например, конструкторы и кортежи.

\begin{lstlisting}
$maybe Person firstName lastName <- maybePerson
    <p>Ваше имя - #{firstName} #{lastName}
\end{lstlisting}

Выражение справа от стрелки подчиняется тем же правилам интерполяции, 
позволяет использовать переменные, вызывать функции и т.д.

\subsection{Forall}

А что с пробеганием по элементам списка? Мы покрываем и этот шаблон:

\begin{lstlisting}
$if null people
    <p>Нет людей.
$else
    <ul>
        $forall person <- people
            <li>#{person}
\end{lstlisting}


\subsection{Case}

Сопоставление шаблонов - одна из сильных сторон \texttt{Haskell}. Алгебраические типы данных
позволяют вам удобно моделировать любые типы данных из реального мира, а 
case-выражения позволяют вам безопасно их сопоставлять, возлагая на компилятор
обязанность предупреждать, если вы пропустили одно из значений.
\texttt{Hamlet} предоставляет вам те же самые преимущества.

\begin{lstlisting}
$case foo
    $of Left bar
        <p>Он был слева: #{bar}
    $of Right baz
        <p>Он был справа: #{baz}
\end{lstlisting}

\subsection{With}

Мы заканчиваем обзор выражений языка, рассматривая \texttt{with}. Это, по сути,
просто удобный способ объявления синонима для длинного выражения. К примеру, 
в данном примере мы определяем один раз переменную с помощью \texttt{with}, а затем
используем ее дважды.

\begin{lstlisting}
$with foo <- some very (long ugly) expression that $ should only $ happen once
    <p>Я использую эту переменную #{foo} несколько раз. #{foo}
\end{lstlisting}

\subsection{Doctype}
Последняя ложка синтаксического сахара: выражение \texttt{doctype}. Мы
поддерживаем несколько разных версий \texttt{doctype}, хотя мы рекомендуем
\lstinline!$doctype 5! для современных интернет-приложений, который генерирует
\lstinline'<!DOCTYPE html>'

\begin{lstlisting}
$doctype 5
<html>
    <head>
        <title>Hamlet просто чудесен
    <body>
        <p>Все готово.
\end{lstlisting}

Мы всë ещë поддерживаем и старый синтаксис: три восклицательных знака \texttt{!!!}.
Вы всë ещë можете увидеть его в коде. Мы планируем и дальше поддерживать этот
синтаксис, но в целом, находим \lstinline!$doctype! подход более легким для чтения.

\section{Синтаксис языка \texttt{Cassius}}
\texttt{Cassius} - это оригинальный шаблонный язык \texttt{CSS}. Он использует простые правила
с пробелами для разделения блоков, делая фигурные скобки и точки с запятой 
необязательными. Он поддерживает интерполяцию переменных и URL, но не поддерживает
встраивание. Его синтаксис очень простой:

\begin{lstlisting}
#banner
    border: 1px solid #{bannerColor}
    background-image: url(@{BannerImageR})
\end{lstlisting}

\section{Синтаксис языка \texttt{Lucius}}
В то время, как \texttt{Cassius} использует модифицированный, чувствительный к пробелам 
синтаксис для \texttt{CSS}, подход \texttt{Lucius} полностью оригинальный. Вы можете взять любой \texttt{CSS}
файл и он будет валидным \texttt{Lucius} файлом. Однако, есть некоторые дополнения:

\begin{itemize}
\item Как в \texttt{Cassius}, мы позволяем интерполяцию как переменных, так и URL.
\item Возможность вложенных \texttt{CSS} блоков.
\item Вы можете определять переменные в ваших шаблонах.
\end{itemize}

Что касается второго пункта: скажем, вы хотите иметь специфичный стиль для 
какого-то тэга в вашей статье. В плоском \texttt{CSS} вы должны были бы написать

\begin{lstlisting}
article code { background-color: grey; }
article p { text-indent: 2em; }
article a { text-decoration: none; }
\end{lstlisting}

В этом случае получилось не так уж и много клозов, но необходимость печатать
\texttt{article} каждый раз - слегка надоедает. А представьте, что таких выражений, 
скажем, около десятка - согласитесь, раздражает.
\texttt{Lucius} пожможет в этом случае:

\begin{lstlisting}
article {
    code { background-color: grey; }
    p { text-indent: 2em; }
    a { text-decoration: none; }
}
\end{lstlisting}

Само наличие переменныx в \texttt{Lucius} позволяет вам избегать повторов. Простым примером
будет определить общий используемый цвет как переменную:

\begin{lstlisting}
@textcolor: #ccc; /* просто потому, что мы ненавидим наших пользователей */
body { color: #{textcolor} }
a:link, a:visited { color: #{textcolor} }
\end{lstlisting}

В остальном, \texttt{Lucius} идентичен \texttt{CSS}.

\section{Синтаксис языка \texttt{Julius}}

\texttt{Julius} - наиболее простой среди всех обсуждаемых здесь языков. На самом деле, 
многие могут сказать, что это на самом деле всего лишь \texttt{Javascript}. \texttt{Julius}
позволяет использовать три формы интерполяции, которые мы уже упоминали.
Либо, вообще не применяет никаких преобразований к вашему контенту.

Если вы используете \texttt{Julius} cо сгенерированным каркасом сайта \texttt{Yesod}, вы возможно заметили, что ваш
\texttt{Javascript} автоматически минифицирован. Это не следствие использования \texttt{Julius}, это
результат использования пакета \lstinline!hjsmin! в \texttt{Yesod}, который служит для компактизации
выдачи \texttt{Julius}.

\section{Как заставить Шекспировские шаблоны работать}

Конечно, в какой-то момент у вас появится этот вопрос: "Как же мне заставить это
всë работать?". Существует три разных способа вызывать Шекспировские языки 
из вашего \texttt{Haskell} кода:

\subsection{Квази-цитирование}
Квази-цитирование (quasiquotes) позволяют вам встроить произвольное содержимое в ваш \texttt{Haskell} код, и
конвертировать это содержимое в \texttt{Haskell} во время компиляции.

\subsection {Внешние файлы}
В этом случае, код шаблонов находится в отдельных файлов, на который мы ссылаемся
с помощью шаблонов \texttt{Haskell}.

\subsection {Режим перезагрузки}
Оба использованных выше подхода требуют полной перекомпиляции для того, чтобы увидеть
какие-то изменения. В режиме перезагрузки ваши шаблоны хранятся в отдельных файлах,
и ссылаются из шаблонов \texttt{Haskell}. Но при этом, в рантайме, эти внешние файлы 
каждый раз пересканируются на лету

Режим перезагрузки нельзя использовать для \texttt{Hamlet}, только для \texttt{Cassius}, \texttt{Lucius} и \texttt{Julius}.
В \texttt{Hamlet} слишком много сложной логики, которая полагается напрямую на \texttt{Haskell}
компилятор, что не позволяет использовать этот режим для \texttt{Hamlet}.
%FIXME: runtime -> в рантайме

Первые два подхода следует использовать в "боевых" условиях на серверах.
Они оба встраивают целиком шаблоны в финальный исполняемый файл, упрощая 
развертывание кода и увеличивая производительность.
Достоинство квази-цитирования - это простота: всë остается в одном файле.
Для коротких шаблонов, это может быть очень удобно. Однако, в целом, мы рекомендуем
использовать внешние файлы для шаблонов, поскольку:

\begin{itemize}
\item Это следование традиции разделения логики и представления данных.
\item Вы можете легко переключиться между внешними файлами и отладочным режимом
работы с помощью простых макро-определений \texttt{CPP}, в том смысле, что вы
можете совмещать быструю и удобную разработку и всë ещë получать высокую
производительность на "боевых" серверах.
\end{itemize}

Так как это специальные функции Квази-цитиования и шаблонного \texttt{Haskell}, вы 
должны удостовериться, что вы используете соответствующие расширения языка
и корректный синтаксис. Вы можете посмотреть простейшие примеры каждого подхода
на следующих примерах

%TODO: название в примеры??
Квазицитиование
\begin{lstlisting}
{-# LANGUAGE OverloadedStrings #-} -- мы используем Text чуть ниже
{-# LANGUAGE QuasiQuotes #-}

import Text.Hamlet (HtmlUrl, hamlet)
import Data.Text (Text)
import Text.Blaze.Html.Renderer.String (renderHtml)

data MyRoute = Home | Time | Stylesheet

render :: MyRoute -> [(Text, Text)] -> Text
render Home _ = "/home"
render Time _ = "/time"
render Stylesheet _ = "/style.css"

template :: Text -> HtmlUrl MyRoute
template title = [hamlet|
$doctype 5
<html>
    <head>
        <title>#{title}
        <link rel=stylesheet href=@{Stylesheet}>
    <body>
        <h1>#{title}
|]

main :: IO ()
main = putStrLn $ renderHtml $ template "Мой заголовок" render
\end{lstlisting}

%TODO: название в примеры??
Внешние файлы
\begin{lstlisting}

{-# LANGUAGE OverloadedStrings #-} -- мы используем Text чуть ниже
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE CPP #-} -- чтобы контролировать "боевой" режим против отладочного

import Text.Lucius (CssUrl, luciusFile, luciusFileDebug, renderCss)
import Data.Text (Text)
import qualified Data.Text.Lazy.IO as TLIO

data MyRoute = Home | Time | Stylesheet

render :: MyRoute -> [(Text, Text)] -> Text
render Home _ = "/home"
render Time _ = "/time"
render Stylesheet _ = "/style.css"

template :: CssUrl MyRoute
#if PRODUCTION
template = $(luciusFile "template.lucius")
#else
template = $(luciusFileDebug "template.lucius")
#endif

main :: IO ()
main = TLIO.putStrLn $ renderCss $ template render
-- @template.lucius
foo { bar: baz }
\end{lstlisting}

Способ именования функций очень консистентная.
%TODO: проверить, что таблица нормально отображается
\begin{tabular}{l l l l}
Language & Quasiquoter & External file & Reload \\
\texttt{Hamlet}   & hamlet      & hamletFile    & N/A    \\
\texttt{Cassius}  & cassius     & cassiusFile   & cassiusFileReload \\
\texttt{Lucius}   & lucius      & luciusFile    & luciusFileReload \\
\texttt{Julius}   & julius      & juliusFile    & juliusFileReload \\
\end{tabular}

\section{Добавление функциональности в типы \texttt{Hamlet}}
%FIXME: alternate -> добавление функциональности
До сих пор мы видели только как генерировать HtmlUrl значение из \texttt{Hamlet}, что 
является \texttt{HTML} со встроенными типо-безопасными URL. Используя \texttt{Hamlet}, 
мы можем генерировать еще три других результата: простой \texttt{HTML}, \texttt{HTML} с URL и 
интернациональными текстами, и виджеты.
Последние будут отдельно описаны в главе "Виджеты"~\ref{chap:widgets}.

Чтобы сгенерировать простой \texttt{HTML} без встроенных URL, мы используем 
"Упрощенный \texttt{Hamlet}" с некоторыми изменениями:

\begin{itemize}
\item Мы используем другой набор функций, которые начинаются с дополнительного 
префикса "s". Так что квази-цитирование - это \texttt{shamlet} и функция 
использования внешнего файла - это \texttt{shamletFile}. Вопрос о том, как следует произносить
названия этих функций, всë ещë находится в обсуждении.
\item Не позволяется использовать интерполяцию URL. Если попытаться это сделать, 
мы получим ошибку во время компиляции.
\item Встраивание (интерполяция-вставка) более не позволяет использовать произвольные
HtmlUrl значения. Правило здесь таково, что встраиваемое значение должно иметь
точно такой же тип, что и сам шаблон, что в данном случае - \lstinline!Html!. Это означает,
что для \texttt{shamlet}, встраивание может быть полностью заменено интерполяцией
переменных (с использованием решетки \texttt{\#}).
\end{itemize}

Работа с интернационализацией (i18n) в \texttt{Hamlet} происходит чуть более сложно.
\texttt{Hamlet} поддерживает i18n с помощью специального типа данных для сообщений - решение
концептуально и по реализации похоже на типобезопасные URL. Для примера, скажем, 
мы хотим написать программу, которая приветствует нас и говорит, как много яблок 
мы съели. Мы могли бы представить эти сообщения в виде типа данных

\begin{lstlisting}
data Msg = Hello | Apples Int
\end{lstlisting}

Далее, мы бы хотели иметь возможность представлять это в каком-то более удобном
для чтения формате, поэтому мы определяем некоторую функцию рендеринга:
\begin{lstlisting}
renderEnglish :: Msg -> Text
renderEnglish Hello = "Привет"
renderEnglish (Apples 0) = "Вы не купили яблок."
renderEnglish (Apples 1) = "Вы купили одно яблоко."
renderEnglish (Apples i) = T.concat ["Вы купили ", T.pack $ show i, " яблок."]
\end{lstlisting}

Теперь мы хотим интерполировать эти значения типа Msg напрямую в шаблоне.
Для этого мы используем интерполяцию с подчеркиванием.

\begin{lstlisting}
$doctype 5
<html>
    <head>
        <title>i18n
    <body>
        <h1>_{Hello}
        <p>_{Apples count}
\end{lstlisting}

Этот шаблон, теперь надо как-то представить в \texttt{HTML}.  Для этого, как и для типобезопасных URL, 
мы определяем специальную функцию рендеринга в строку.
Для удобства, определим синоним типа:

\begin{lstlisting}
type Render url = url -> [(Text, Text)] -> Text
type Translate msg = msg -> Html
type HtmlUrlI18n msg url = Translate msg -> Render url -> Html
\end{lstlisting}

В данной точке, вы можете передать \lstinline!renderEnglish!, 
\lstinline!renderSpanish! или \lstinline!renderKlingon! в этот шаблон. И он
сгенерирует хорошо переведенный контент (качество которого, конечно, зависит от
ваших переводчиков). Программа целиком будет выглядеть так:
\begin{lstlisting}
{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE OverloadedStrings #-}

import Data.Text (Text)
import qualified Data.Text as T
import Text.Hamlet (HtmlUrlI18n, ihamlet)
import Text.Blaze.Html (toHtml)
import Text.Blaze.Html.Renderer.String (renderHtml)

data MyRoute = Home | Time | Stylesheet

renderUrl :: MyRoute -> [(Text, Text)] -> Text
renderUrl Home _ = "/home"
renderUrl Time _ = "/time"
renderUrl Stylesheet _ = "/style.css"

data Msg = Hello | Apples Int

renderEnglish :: Msg -> Text
renderEnglish Hello = "Привет"
renderEnglish (Apples 0) = "Вы не купили яблок."
renderEnglish (Apples 1) = "Вы купили одно яблоко."
renderEnglish (Apples i) = T.concat ["Вы купили ", T.pack $ show i, " яблок."]

template :: Int -> HtmlUrlI18n Msg MyRoute
template count = [ihamlet|
$doctype 5
<html>
    <head>
        <title>i18n
    <body>
        <h1>_{Hello}
        <p>_{Apples count}
|]

main :: IO ()
main = putStrLn $ renderHtml
     $ (template 5) (toHtml . renderEnglish) renderUrl
\end{lstlisting}

\section{Другие Шекспировские возможности}

В дополнение к языкам-помощникам для \texttt{HTML}, \texttt{CSS} и \texttt{Javascript}, есть также и более
общий пакет утилит. \lstinline!shakespare-text! предоставляет простой способ 
создания интерполированных строк, который очень нравится тем, кто привык к 
скриптовым языкам вроде Ruby или Python. Конечно, утилиты этого пакета можно
использовать не только для \texttt{Yesod}.

\begin{lstlisting}
{-# LANGUAGE QuasiQuotes, OverloadedStrings #-}

import Text.Shakespeare.Text
import qualified Data.Text.Lazy.IO as TLIO
import Data.Text (Text)
import Control.Monad (forM_)

data Item = Item
    { itemName :: Text
    , itemQty :: Int
    }

items :: [Item]
items =
    [ Item "яблоки" 5
    , Item "бананы" 10
    ]

main :: IO ()
main = forM_ items $ \item -> TLIO.putStrLn
    [lt|У вас есть #{show $ itemQty item} #{itemName item}.|]
\end{lstlisting}

Несколько быстрых подсказок по этому простому примеру:
\begin{itemize}
\item Мы используем три разных текстовых типа данных в примере 
(\lstinline!String!, строгий и ленивый \lstinline!Text!). Они замечательно
работают вместе.
\item Мы используем оператор квазицитирования \lstinline!lt!, который генерирует
ленивую версию текста. Также есть его строгий аналог \lstinline!st!.
\item Есть и более длинные имена для этих операторов 
(\lstinline!ltext! и \lstinline!stext!).
\end{itemize}

\section{Общие рекомендации}

Ниже приводятся общие рекомендации комьюнити \texttt{Yesod} по использованию
Шекспировского семейства языков.

\begin{itemize}
\item Для сайтов используйте внешние файлы. Для библиотек это вполне 
нормально - использовать квази-квотирование, при условии, что оно не слишком большое.
\item Патрик Брисбин (Patrick Brisbin) сделал правила раскраски для Vim, 
которые сильно помогают при разработке.
\item Вам следует почти всегда начинать тэги \texttt{Hamlet} на новых строках вместо того,
чтобы писать их после существующих тэгов. Единственное исключение этому правилу - это
использование \lstinline!<i>! и \lstinline!<b>! тэгов в большом блоке текста.
\end{itemize}
