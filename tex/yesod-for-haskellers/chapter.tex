\chapter{Yesod для программистов на Haskell}

Большая часть книги построена на предоставлении практической информации о том,
как выполнить распространённые задачи без глубокого погружения в детали, что
происходит <<под капотом>>. Хотя книга предполагает знание Haskell, она не
следует типичному стилю множества введений в библиотеки Haskell. Многие опытные
программисты на Haskell отвергаются таким сокрытием деталей реализации. Цель
этой главы~--- исправить эти недостатки.

В этой главе мы начнём с предельно минимального веб-приложения и постепенно
перейдём к более сложным примерам, объясняя компоненты и их типы в процессе
перехода.

\section{Встречаем Warp}

Давайте начнём с предельно простого приложения, какое мы можем придумать:
\begin{lstlisting}
{-# LANGUAGE OverloadedStrings #-}
import           Network.HTTP.Types       (status200)
import           Network.Wai              (Application, responseLBS)
import           Network.Wai.Handler.Warp (run)

main :: IO ()
main = run 3000 app

app :: Application
app _req = return $ responseLBS
    status200
    [("Content-Type", "text/plain")]
    "Hello Warp!"
\end{lstlisting}

Минутку, но здесь отсутствует Yesod! Не волнуйтесь, дойдём и до него. Напомню,
что мы начинаем построение снизу вверх, а в Yesod в самом низу находится WAI
(Web Application Interface, интерфейс веб-приложения). WAI находится между
\textbf{веб-обработчиком}, например, веб-сервером или функция для
тестирования, и \textbf{веб-приложением}. В нашем случае, обработчик~--- это
Warp, высокопроизводительный веб-сервер, а наше приложение~--- это
функция~\lstinline'app'.

Что за таинственный тип~\lstinline'Application'? Это просто синоним типа для
\begin{lstlisting}
type Application = Request -> IO Response
\end{lstlisting}
Значение типа \lstinline'Request' содержит информацию о запрошенном пути,
параметры строки запроса, заголовки запроса, тело запроса и IP адрес клиента.
Мы можем использовать её для выполнения простой диспетчеризации:
\begin{lstlisting}
{-# LANGUAGE OverloadedStrings #-}
import           Network.HTTP.Types       (status200)
import           Network.Wai              (Application, pathInfo, responseLBS)
import           Network.Wai.Handler.Warp (run)

main :: IO ()
main = run 3000 app

app :: Application
app req =
    case pathInfo req of
        ["foo", "bar"] -> return $ responseLBS
            status200
            [("Content-Type", "text/plain")]
            "You requested /foo/bar"
        _ -> return $ responseLBS
            status200
            [("Content-Type", "text/plain")]
            "You requested something else"
\end{lstlisting}

WAI требует, чтобы путь был разбит на отдельные фрагменты (блоки между прямыми
косыми чертами) и преобразован в текст. Это упрощает сравнение с шаблонами
(pattern matching). Если вам нужно исходное немодифицированное значение
типа~\lstinline'ByteString', вы можете воспользоваться
функцией~\lstinline'rawPathInfo'. За более подробной информацией о доступных
полях обращайтесь к документации WAI.

Мы рассмотрели запрос, что насчёт ответов? Мы уже видели
функцию~\lstinline'responseLBS', представляющую собой удобный способ создания
ответа из ленивой~\lstinline'ByteString'. Эта функция принимает три аргумента:
код ответа, список заголовков ответа (пары ключ/значение) и само тело ответа.
Но \lstinline'responseLBS'~--- это просто удобная обёртка. Внутри WAI
использует тип данных~\lstinline'Builder' из пакета~\texttt{blaze-builder} для
представления сырых байтов. Давайте копнём ещё на уровень глубже в этом
направлении и используем \lstinline'Builder' напрямую:
\begin{lstlisting}
{-# LANGUAGE OverloadedStrings #-}
import           Blaze.ByteString.Builder (Builder, fromByteString)
import           Network.HTTP.Types       (status200)
import           Network.Wai              (Application, responseBuilder)
import           Network.Wai.Handler.Warp (run)

main :: IO ()
main = run 3000 app

app :: Application
app _req = return $ responseBuilder
    status200
    [("Content-Type", "text/plain")]
    (fromByteString "Hello from blaze-builder!" :: Builder)
\end{lstlisting}

Это открывает некоторые замечательные возможности для эффективного построения
тел ответов, так как \lstinline'Builder' позволяет использовать операции
добавления с производительностью O(1). Также мы получаем возможность
использовать преимущества пакета~\texttt{blaze-html}, базирующегося на
\texttt{blaze-builder}. Давайте сделаем наше первое HTML приложение.
\begin{lstlisting}
{-# LANGUAGE OverloadedStrings #-}
import           Network.HTTP.Types            (status200)
import           Network.Wai                   (Application, responseBuilder)
import           Network.Wai.Handler.Warp      (run)
import           Text.Blaze.Html.Renderer.Utf8 (renderHtmlBuilder)
import           Text.Blaze.Html5              (Html, docTypeHtml)
import qualified Text.Blaze.Html5              as H

main :: IO ()
main = run 3000 app

app :: Application
app _req = return $ responseBuilder
    status200
    [("Content-Type", "text/html")] -- yay!
    (renderHtmlBuilder myPage)

myPage :: Html
myPage = docTypeHtml $ do
    H.head $ do
        H.title "Hello from blaze-html and Warp"
    H.body $ do
        H.h1 "Hello from blaze-html and Warp"
\end{lstlisting}

Но использование чистого значения типа~\lstinline'Buidler' накладывает одно
ограничение: мы должны создать тело ответа целиком до того, как возвращать
значение типа~\lstinline'Response'. С ленивым выполнением это не так плохо, как
можно подумать, так как не всё тело целиком будет находиться в памяти
единовременно. Однако, если нам потребуется выполнить какие-либо операции
ввода/вывода для генерации тела запроса (например, чтение данных из базы), у
нас возникнут проблемы.

Для решения этой проблемы WAI использует кондуит для представления потокового
тела ответа. Это также позволяет явно контролировать сброс потока путём
оборачивания значения в тип данных~\lstinline'Flush'. Давайте посмотрим, как
это работает.

\begin{lstlisting}
{-# LANGUAGE OverloadedStrings #-}
import           Blaze.ByteString.Builder           (Builder, fromByteString)
import           Blaze.ByteString.Builder.Char.Utf8 (fromShow)
import           Control.Concurrent                 (threadDelay)
import           Control.Monad                      (forM_)
import           Control.Monad.Trans.Class          (lift)
import           Data.Conduit                       (Flush (Chunk, Flush),
                                                     Source, yield)
import           Data.Monoid                        ((<>))
import           Network.HTTP.Types                 (status200)
import           Network.Wai                        (Application,
                                                     responseSource)
import           Network.Wai.Handler.Warp           (run)

main :: IO ()
main = run 3000 app

app :: Application
app _req = return $ responseSource
    status200
    [("Content-Type", "text/plain")]
    mySrc

mySrc :: Source IO (Flush Builder)
mySrc = do
    yield $ Chunk $ fromByteString "Starting streaming response.\n"
    yield $ Chunk $ fromByteString "Performing some I/O.\n"
    yield Flush
    -- pretend we're performing some I/O
    lift $ threadDelay 1000000
    yield $ Chunk $ fromByteString "I/O performed, here are some results.\n"
    forM_ [1..50 :: Int] $ \i -> do
        yield $ Chunk $ fromByteString "Got the value: " <>
                        fromShow i <>
                        fromByteString "\n"
\end{lstlisting}

Ещё одно частое требование при использовании потокового ответа~--- безопасное
размещение дефицитных ресурсов, например, файлов. Под \textbf{безопасностью} я
понимаю гарантию, что ресурс будет освобождён даже в случае возникновения
исключения. В таких ситуациях вы можете использовать
функцию~\lstinline'responseSourceBracket':
\begin{lstlisting}
{-# LANGUAGE OverloadedStrings #-}
import           Blaze.ByteString.Builder (fromByteString)
import           Data.Conduit             (Flush (Chunk), ($=))
import           Data.Conduit.Binary      (sourceHandle)
import qualified Data.Conduit.List        as CL
import           Network.HTTP.Types       (status200)
import           Network.Wai              (Application, responseSourceBracket)
import           Network.Wai.Handler.Warp (run)
import           System.IO                (IOMode (ReadMode), hClose, openFile)

main :: IO ()
main = run 3000 app

app :: Application
app _req = responseSourceBracket
    (openFile "index.html" ReadMode)
    hClose
    $ \handle -> return
        ( status200
        , [("Content-Type", "text/html")]
        , sourceHandle handle $= CL.map (Chunk . fromByteString)
        )
\end{lstlisting}

Однако, в случае обслуживания файлов, более эффективно использовать
функцию~\lstinline'responseFile', которая может использовать системный
вызов~\lstinline'sendfile' для избежания ненужных копий буфера:
\begin{lstlisting}
{-# LANGUAGE OverloadedStrings #-}
import           Network.HTTP.Types       (status200)
import           Network.Wai              (Application, responseFile)
import           Network.Wai.Handler.Warp (run)

main :: IO ()
main = run 3000 app

app :: Application
app _req = return $ responseFile
    status200
    [("Content-Type", "text/html")]
    "index.html"
    Nothing -- means "serve whole file"
            -- you can also serve specific ranges in the file
\end{lstlisting}

У WAI есть ещё много аспектов, здесь нерассмотренных. Одна из важных тем~---
это компоненты промежуточного уровня (middleware), которую мы рассмотрим ближе
к концу главы. Мы ещё вообще не заглядывали в тело запроса. Но для цели
понимания Yesod, к этому моменту рассмотрено достаточно.

\section{Что насчёт Yesod?}
Среди всех наших забот о WAI и Warp мы до сих пор не встречали Yesod! Так как к
этому моменту мы узнали всё о WAI, первым нашим вопросом должен быть: как Yesod
взаимодействует с WAI. Ответ: используя одну одну очень важную функцию:
\begin{lstlisting}
toWaiApp :: YesodDispatch site => site -> IO Application
\end{lstlisting}

\begin{remark}
    Есть ещё более простая функция в Yesod, которая
    называется~\lstinline'toWaiAppPlain'. Отличие в том, что
    \lstinline'toWaiAppPlain' не устанавливает дополнительных компонент
    промежуточного слоя, тогда как \lstinline'toWaiApp' добавляет часто
    используемые компоненты такие, как протоколирование, GZIP сжатие и
    обработчик запросов~HEAD.
\end{remark}

Эта функция принимает некоторое значение сайта, которое должно быть
экземпляром класса типов~\lstinline'YesodDispatch', и создаёт значение
типа~\lstinline'Application'. Эта функция живёт в монаде~\lstinline'IO', так
как ей, скорее всего, придётся выполнять действия наподобие выделения
разделяемого буфера для протокола. Гораздо более интересный вопрос, что собою
представляет значение~\lstinline'site'.

Yesod вводит концепцию \textbf{основного типа данных}. Этот тип данных является
ядром каждого приложения и используется для трёх важных вещей:
\begin{itemize}
    \item Он может хранить значения, которые инициализируются и разделяются
        повсеместно в вашем приложении, например, менеджер соединений HTTP, пул
        соединений с базой данных, загруженные из файла настройки или некоторое
        изменяемое состояние, например, счётчик или кеш.

    \item Экземпляры класса типов предоставляют ещё больше информации о вашем
        приложении. Класс типов~\lstinline'Yesod' имеет различные настройки,
        например, какой шаблон по умолчанию для вашего приложения использовать
        или максимальный размер тела запроса. Класс
        типов~\lstinline'YesodDispatch' указывает, как входящие запросы должны
        диспетчеризоваться в функции-обработчики. И есть ещё целый набор
        классов типов, обычно используемых в вспомогательных библиотеках Yesod,
        например, \lstinline'RenderMessage' для поддержки интернационализации
        или \lstinline'YesodJquery' для разделяемого размещения Javascript
        библиотеки jQuery.

    \item Связанные типы (т.е., семейства типов) используются для создания
        соответствующего \textbf{типа данных путей} для каждого приложения. Это
        простой алгебраический тип данных, который представляет все разрешённые
        пути в вашем приложении. Используя этот промежуточный тип данных вместо
        непосредственной работы со строками, приложение Yesod получает
        преимущество: можно использовать компилятор для предотвращения создания
        некорректных ссылок. Это свойство известно, как \textbf{типобезопасные
            URL}.
\end{itemize}

Продолжим в духе главы и для нашего первого приложения Yesod выберем трудный
путь создания~--- написание всего вручную. Потом постепенно будем добавлять
удобные вспомогательные функции поверх написанного.

\begin{lstlisting}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TypeFamilies      #-}
import           Network.HTTP.Types            (status200)
import           Network.Wai                   (responseBuilder)
import           Network.Wai.Handler.Warp      (run)
import           Text.Blaze.Html.Renderer.Utf8 (renderHtmlBuilder)
import qualified Text.Blaze.Html5              as H
import           Yesod.Core                    (Html, RenderRoute (..), Yesod,
                                                YesodDispatch (..), toWaiApp)
import           Yesod.Core.Types              (YesodRunnerEnv (..))

-- | Our foundatation datatype.
data App = App
    { welcomeMessage :: !Html
    }

instance Yesod App

instance RenderRoute App where
    data Route App = HomeR -- just one accepted URL
        deriving (Show, Read, Eq, Ord)

    renderRoute HomeR = ( [] -- empty path info, means "/"
                        , [] -- empty query string
                        )

instance YesodDispatch App where
    yesodDispatch (YesodRunnerEnv _logger site _sessionBackend) _req =
        return $ responseBuilder
            status200
            [("Content-Type", "text/html")]
            (renderHtmlBuilder $ welcomeMessage site)

main :: IO ()
main = do
    -- We could get this message from a file instead if we wanted.
    let welcome = H.p "Welcome to Yesod!"
    waiApp <- toWaiApp App
        { welcomeMessage = welcome
        }
    run 3000 waiApp
\end{lstlisting}

Итак, мы добавили здесь несколько новых блоков, с них и начнём. Первое, что мы
сделали,~--- создали новый тип данных~\lstinline'App'. Имя часто используется
для основного типа данных в приложениях, но, естественно, можете использовать
любое по своему желанию. Мы добавили в этот тип
поле~\lstinline'welcomeMessage', которое будет хранить содержимое нашей
домашней страницы.

Затем мы объявили экземпляр для класса типов~\lstinline'Yesod'. В нашем примере
мы просто используем значения по умолчанию для всех методов. Более интересен
экземпляр класса типов~\lstinline'RenderRoute'. Это сердце наших типобезопасных
URL. Мы создаём связанный тип данных для \lstinline'App', в котором перечислены
все маршруты, принимаемые нашим приложением. В данном случае, такой маршрут
один: домашняя страница, которую мы назвали~\lstinline'HomeR'. Это ещё одно
соглашение Yesod~--- добавлять \lstinline'R' в конец имени всех конструкторов
маршрутов.

Также мы должны создать метод~\lstinline'renderRoute', который преобразовывает
значение типобезопасного маршрута в кортеж, включающий список участков маршрута
и список параметров строки запроса. Ниже мы рассмотрим более интересные
примеры, пока же для нашей домашней страницы оба списка пусты.

Класс \lstinline'YesodDispatch' определяет, как ведёт себя наше приложение. У
него один метод~\lstinline'yesodDispatch', имеющий тип:
\begin{lstlisting}
yesodDispatch :: YesodRunnerEnv site -> Application
\end{lstlisting}

Класс \lstinline'YesodRunnerEnv' предоставляет три значения: \lstinline'Logger'
для вывода протокольных сообщений, непосредственно основной тип данных и бэкенд
для сессий, используемый для хранения и получения информации об активной сессии
пользователя. В настоящих приложениях Yesod, как вы вскоре увидите, вам не
потребуется взаимодействовать с этими значениями напрямую, но это полезно~---
понимать, что находится под поверхностью.

Возвращаемый тип функции~\lstinline'yesodDispatch'~--- значение
типа~\lstinline'Application' из WAI. Но, как мы видели выше,
\lstinline'Application'~--- это просто функцию, принимающая \lstinline'Request'
и возвращающая~\lstinline'IO Response'. Поэтому наша реализация
\lstinline'yesodDispatch' позволяет использовать всё, что мы выше узнали о WAI.
Обратите внимание, как мы обращались к \lstinline'welcomeMessage' из нашего
основного типа данных.

Наконец, у нас есть функцию~\lstinline'main'. Значение~\lstinline'App' очень
легко создать и, как вы можете видеть, столько же легко можно выполнить
какие-либо операции ввода/вывода для размещения приветственного сообщения. Мы
используем \lstinline'toWaiApp' для получения приложения WAI, а затем передаём
наше приложение в Warp, как и раньше.

Примите поздравления, вы только что видели ваше первое приложение Yesod! (По
крайней мере, это было первое приложение Yesod в этой главе.)

\section{Трансформатор монад HandlerT}
Хотя наш пример технически использовал Yesod, он был невероятно скучным. Нет
сомнений, что Yesod не сделал ничего нового на нашем пути к WAI. Но это только
потому, что ещё не начали использовать преимущества, предлагаемые Yesod.
Давайте исправим это, и начнём мы с трансформатора монад~\lstinline'HandlerT'.

Часто при обработке запроса вам хочется сделать ещё некоторые вещи, например:
\begin{itemize}
    \item Вернуть некий HTML.
    \item Перенаправить пользователя на другой URL.
    \item Вернуть ошибку 404 для отсутствующего ресурса.
    \item Выполнить протоколирование.
\end{itemize}

Для встраивания всей этой функциональности Yesod предоставляет трансформатор
монад~\lstinline'HandlerT'. Подавляющая часть кода, который вы будете писать,
используя Yesod, будет жить в этом трансформаторе, поэтому вам следует с ним
познакомиться. Давайте начнём с замены нашего предыдущего
экземпляра~\lstinline'YesodDispatch' на экземпляр, использующий
преимущества~\lstinline'HandlerT':
\begin{lstlisting}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TypeFamilies      #-}
import           Network.Wai              (pathInfo)
import           Network.Wai.Handler.Warp (run)
import qualified Text.Blaze.Html5         as H
import           Yesod.Core               (HandlerT, Html, RenderRoute (..),
                                           Yesod, YesodDispatch (..), getYesod,
                                           notFound, toWaiApp, yesodRunner)

-- | Our foundatation datatype.
data App = App
    { welcomeMessage :: !Html
    }

instance Yesod App

instance RenderRoute App where
    data Route App = HomeR -- just one accepted URL
        deriving (Show, Read, Eq, Ord)

    renderRoute HomeR = ( [] -- empty path info, means "/"
                        , [] -- empty query string
                        )

getHomeR :: HandlerT App IO Html
getHomeR = do
    site <- getYesod
    return $ welcomeMessage site

instance YesodDispatch App where
    yesodDispatch yesodRunnerEnv req =
        let maybeRoute =
                case pathInfo req of
                    [] -> Just HomeR
                    _  -> Nothing
            handler =
                case maybeRoute of
                    Nothing -> notFound
                    Just HomeR -> getHomeR
         in yesodRunner handler yesodRunnerEnv maybeRoute req

main :: IO ()
main = do
    -- We could get this message from a file instead if we wanted.
    let welcome = H.p "Welcome to Yesod!"
    waiApp <- toWaiApp App
        { welcomeMessage = welcome
        }
    run 3000 waiApp
\end{lstlisting}

\lstinline'getHomeR'~--- наша первая функция-обработчик. (Имя следует ещё
одному общепринятому соглашению мира Yesod: метод HTTP в нижнем регистре, за
которым следует имя конструктора маршрута.) Обратите внимание на сигнатуру
типа: \lstinline'HandlerT App IO HTML'. Этот стек монад так часто встречается,
что большая часть приложений определяет для него синоним типа:
\lstinline'type Handler = HandlerT App IO'. Функция возвращает некоторое
значение типа~\lstinline'Html'. Вас, возможно, интересует, завязан ли Yesod
жёстко на работу только со значениями типа~\lstinline'Html'. Мы обсудим эту
деталь чуть ниже.

Тело нашей функции коротко. Мы используем функцию~\lstinline'getYesod', чтобы
получить основной тип данных, а затем возвращаем значение
поля~\lstinline'welcomeMessage'. Мы сделаем обработчики поинтереснее в процессе
дальнейшего обсуждения.

Реализация функции~\lstinline'yesodDispatch' теперь существенно отличается.
Ключевой момент~--- использование функции~\lstinline'yesodRunner',
представляющей собою низкоуровневую функции для преобразования стеков
\lstinline'HandlerT' в значение~\lstinline'Application' WAI. Давайте посмотрим
на её сигнатуру типа:
\begin{lstlisting}
yesodRunner :: (ToTypedContent res, Yesod site)
            => HandlerT site IO res
            -> YesodRunnerEnv site
            -> Maybe (Route site)
            -> Application
\end{lstlisting}

Мы уже знакомы с \lstinline'YesodRunnerEnv' по предыдущему примеру. Как можно
видеть из вызова \lstinline'yesodRunner' выше, мы передаём это значение без
изменений. Вызывает интерес значение~\lstinline'Maybe (Route site)', которое
даёт нам более глубокое понимание того, как работают типо-безопасные URL. До
этого мы видели только отображающую (rendering) сторону. Но не менее важна
\emph{разбирающая (parsing)} сторона: преобразование запрошенного пути в
значение маршрута. В нашем примере этот код состоит из нескольких строк, и
мы сохраняем результат в значении~\lstinline'maybeRoute'.

\begin{remark}
    Наша текущая функция разбора действительно мала, но в приложениях побольше
    она может быть гораздо сложнее, например, обрабатывая динамические
    параметры. В этот момент поддержание корректного соответствия между
    разбирающей и отображающей функции становится нетривиальной задачей. Ниже
    мы рассмотрим, как Yesod решает эту проблему.
\end{remark}

Вернёмся к параметрам функции~\lstinline'yesodRunner': мы уже рассмотрели
\lstinline'Maybe (Route site)' и~\lstinline'YesodRunnerEnv site'. Для получения
нашего значения~\lstinline'HandlerT site IO res' мы используем сопоставление с
образцом значения~\lstinline'maybeRoute'. Если оно равно~\lstinline'Just HomeR',
мы используем~\lstinline'getHomeR'. В противном случае, мы используем
функцию~\lstinline'notFound'~--- это встроенная функция, которая возвращает
ответ <<404 Not Found>>, используя шаблон сайта по умолчанию. Этот шаблон может
быть переопределён в классе типов~\lstinline'Yesod'. Изначально, это просто
скучная HTML страница.

Всё это имеет смысл, за исключением одной проблемы: что это за класс
типов~\lstinline'ToTypedContent', и какое отношение он имеет в нашему ответу
типа~\lstinline'Html'? Начнём с ответа на вопрос, сформулированный выше: Yesod
\textbf{никак} жёстко не фиксирует (hard-code) привязку к значением
типа~\lstinline'Html'. Функция обработчик может вернуть любое значение, которое
имеет экземпляр класса типов~\lstinline'ToTypedContent'. Этот класс типов
(к рассмотрению которого мы сейчас приступим) предоставляет тип (mime-type) и
представление (representation) данных, подходящие для WAI.
Функция~\lstinline'yesodRunner' затем преобразует их в ответ WAI, устанавливая
заголовок ответа \texttt{Content-Type} равным указанному типу, задавая код ответа
равным <<<200 OK>> и отправляя тело ответа.

\subsection{(To)Content, (To)TypedContent}
