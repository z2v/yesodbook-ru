\chapter{Маршрутизация URL и обработчики}\label{ch:routing}
Если мы посмотрим на Yesod как на веб-фреймворк, реализующий схему
Модель-Вид-Контроллер, маршрутизация URL и обработчики запросов
формируют часть <<Контроллер>>. Для сравнения, опишем два других
подхода к маршрутизации, используемых в других средах веб разработки:
\begin{itemize}
\item Диспетчеризация обработчиков, основанная на имени файла. Так,
  например, работают PHP и ASP.

\item Используется централизованная функция, которая обрабатывает
  маршруты, опираясь на регулярные выражения. Django и Rails
  следуют такому подходу.
\end{itemize}

Yesod ближе, в принципе, к последней технике. Однако, имеются
значительные отличия. Вместо использования регулярных выражений, Yesod
сопоставляет участки маршрута. А вместо однонаправленного отображения
маршрут-обработчик, Yesod использует промежуточный тип данных
(называемый маршрутный тип данных, или типобезопасный URL) и создаёт
функции для двухстороннего преобразования.

Ручная реализация этой более продвинутой системы утомительна и
подвержена ошибкам. Поэтому, Yesod определяет предметно-ориентированный
язык (Domain Specific Language (DSL)) для описания маршрутов и
предоставляет функции Template Haskell для преобразования этого DSL в
код на Haskell. В этой главе будет объяснён синтаксис объявлений
маршрута, дано некоторое представление, какой код генерируется для
вас, и описано взаимодействие между маршрутизацией и функциями
обработки запросов.

\section{Синтаксис записи маршрута}
Вместо того, чтобы пытаться втиснуть объявления маршрутов в
существующий синтаксис, подход Yesod~--- использовать упрощённый
синтаксис, разработанный специально для маршрутов. Преимущество такого
подхода~--- код не только проще писать, но он становится достаточно
простым для не имеющих опыта работы с Yesod, чтобы прочитать и понять
схему сайта вашего приложения.

Простой пример синтаксиса:
\begin{verbatim}
/             RootR     GET
/blog         BlogR     GET POST
/blog/#BlogId BlogPostR GET POST

/static       StaticR   Static getStatic
\end{verbatim}

В следующих нескольких разделах будет подробно описано, что происходит
при объявлении маршрута.

\subsection{Участки пути URL}
Одно из первых действий, совершаемых Yesod при получении запроса,~---
разбиение запрошенного пути на участки.  Участки разделяются символами
косой черты (/). Например:
\begin{lstlisting}
toPieces "/" = []
toPieces "/foo/bar/baz/" = ["foo", "bar", "baz", ""]
\end{lstlisting}

Вы можете заметить, что некоторые забавные вещи происходят с
завершающим символом косой черты, или с двойным символом косой черты
("/foo//bar//"), или ещё с чем-то. Yesod рассчитывает на получение
канонических адресов URL; если кто-то запросит URL с завершающим
символом косой черты, или с двойным символом косой черты, они
автоматически переадресуются на каноническую версия адреса. Это
гарантирует, что у вас одному URL соответствует один ресурс, и может
помочь с вашими поисковыми рейтингами.

Для вас это означает, что вам нет необходимости беспокоиться о точной
структуре ваших адресов URL: вы можете спокойно думать об участках
маршрута, а Yesod автоматически выполнит вставку символов косой черты
и экранирование проблемных символов.

Если, кстати, вы захотите более тонкой настройки того, как маршруты
разбиваются на участки и собираются обратно, вам следует посмотреть
методы \lstinline!cleanPath! и \lstinline!joinPath! в главе~\ref{ch:yesod-typeclass}
о классе типов \lstinline!Yesod!.

\subsubsection{Типы участков}
Когда вы объявляет ваши маршруты, у вас в распоряжении имеются три
типа участков:
\begin{description}
\item[Статический] \hfill \\
Это простая строка, которая должна в точности совпадать в URL.

\item[Динамический одинарный] \hfill \\
Это один участок (т.е. между двумя символами косой черты), но может
быть предоставленным пользователем значением. Это основой способ
получения дополнительного пользовательского ввода при запросе
страницы. Эти участки начинаются с символа решётки (\#), за которым
следует тип данных. Тип данных должен быть экземпляром
\lstinline!PathPiece!.

\item [Динамический множественный] \hfill \\
Аналогичен предыдущему, но может получать множество участков URL. Это
всегда должен быть последний участок в шаблоне ресурса. Задаётся
символом звёздочки (*), за которым следует тип данных, который должен
быть экземпляром \lstinline!PathMultiPiece!. Множественные участки не
столь распространены, как предыдущие два типа, хотя они очень важны
для реализации таких возможностей, как статические деревья,
представляющих файловую структуру или вики с произвольными иерархиями.
\marginpar{file structure - Может, имеется в виду структура файловой системы?}
\end{description}

Давайте посмотрим на некоторые стандартные типы шаблонов ресурса,
которые вы возможно захотите написать. Начиная с простого, корень
приложения будет просто \lstinline!/!. Также, вы возможно захотите
поместить свои часто задаваемые вопросы (FAQ) по адресу
\lstinline!/page/faq!.

Теперь давайте представим, что вы собираетесь сделать сайт для
вычисления чисел Фибоначчи. Вы можете сделать свои URL наподобие
\lstinline!/fib/#Int!. Но тут есть следующая небольшая проблема: мы не
хотим разрешать, чтобы отрицательные числа или ноль передавались в
наше приложение. К счастью, система типов может защитить нас:
\begin{lstlisting}
newtype Natural = Natural Int
    deriving (Show, Read, Eq, Num, Ord)
instance PathPiece Natural where
    toPathPiece (Natural i) = T.pack $ show i
    fromPathPiece s =
        case reads $ T.unpack s of
            (i, ""):_
                | i < 1 -> Nothing
                | otherwise -> Just $ Natural i
            [] -> Nothing
mkYesod "Fibs" [parseRoutes|
/fibs/#Natural FibsR GET
|]
instance Yesod Fibs
fibs = 1 : 1 : zipWith (+) fibs (tail fibs)
getFibsR :: Natural -> GHandler Fibs Fibs RepPlain
getFibsR (Natural i) = return $ RepPlain $ toContent $ show $ fibs !! (i - 1)
main = warpDebug 3000 Fibs
\end{lstlisting}

В строке 1 мы определяем для \lstinline!Int! изоморфный тип, который
защитит нас от некорректного ввода. Мы можем увидеть, что
\lstinline!PathPiece!~--- это класс типов с двумя
методами. \lstinline!toPathPiece! просто конвертирует в
\lstinline!Text! и ничего больше. \lstinline!fromPathPiece!
\emph{пытается} преобразовать \lstinline!Text! в наш тип данных,
возвращая \lstinline!Nothing!, если преобразование
невозможно. Используя этот тип данных, мы можем быть уверены, что
нашей функции обработчику будут передаваться только натуральные числа,
позволяя нам в очередной раз использовать систему типов для борьбы с
краевыми случаями.

\fbox{\begin{minipage}[!h]{.9\linewidth}
В реальном приложении, мы бы ещё захотели удостовериться, что никогда
случайно не создадим некорректное значение \lstinline!Natural! внутри
нашего приложения. Для этого, мы могли бы использовать подход
наподобие умных конструкторов
(\href{http://www.haskell.org/haskellwiki/Smart\_constructors}
{\texttt{smart constructors}}
\footnote{http://www.haskell.org/haskellwiki/Smart\_constructors}).
Для целей примера, мы оставили код простым.
\end{minipage}}

Определение \lstinline!PathMultiPiece! столь же простое. Допустим,
что мы хотим сделать вики с иерархией не меньше, чем два уровня;
тогда мы могли бы определить тип данных так:
\begin{lstlisting}
data Page = Page Text Text [Text] -- 2 или больше
instance PathMultiPiece Page where
    toPathMultiPiece (Page x y z) = x : y : z
    fromPathMultiPiece (x:y:z) = Just $ Page x y z
    fromPathMultiPiece _ = Nothing
main = return ()
\end{lstlisting}

\subsection{Наименование ресурса}
Каждый шаблон ресурса имеет имя, связанное с ним. Это имя становится
конструктором типа данных для типобезопасного URL, связанного с вашим
приложением. Поэтому оно должно начинаться с прописной буквы. По
соглашению, эти наименования ресурсов все заканчиваются прописной
буквой <<R>>. Это не обязательное требование, просто общепринятая
практика.

Точное определение нашего конструктора зависит от шаблона ресурса, к
которому оно относится. Все типы данных, которые включены в одинарные
и множественные динамические участки шаблона, становятся аргументами
типа данных. Это даёт нам соотношение 1-к-1 между нашим типом для
типобезопасных URL и корректными URL для нашего приложения.

%FIXME: если раскомментировать fbox, пропадёт текст аж до следующего раздела
%\fbox{
\begin{minipage}[!h]{.9\linewidth}
Это не означает непременно, что каждое значение типа представляет
рабочую страницу, это означает, что значение типа является потенциально
корректным URL. Например, значение \lstinline!PersonR "Michael"! может
не разрешиться в корректную страницу, если в базе данных нет записи для
\lstinline!"Michael"!.
\end{minipage}
%}

Давайте теперь обратимся к реальным примерам. Если бы у вас были такие
шаблоны ресурсов: \lstinline!/person/#Text! с именем
\lstinline!PersonR!; \lstinline!/year/#Int! с именем
\lstinline!YearR! и \lstinline!/page/faq! с именем \lstinline!FaqR!,
то ваш тип данных для маршрутов выглядел бы приблизительно так:
\begin{lstlisting}
data MyRoute = PersonR Text
             | YearR Int
             | FaqR
\end{lstlisting}

Если пользователь запросит относительный URL \lstinline!/year/2009!,
Yesod преобразует его в значение \lstinline!YearR 2009!.
\lstinline!/person/Michael! станет \lstinline!PersonR "Michael"!
и \lstinline!/page/faq! станет \lstinline!FaqR!. С другой
стороны, \lstinline!/year/two-thousand-nine!,
\lstinline!/person/michael/snoyman! и \lstinline!/page/FAQ! привели бы
к получению 404 ошибок даже без обращения к вашему коду.

\section{Спецификация обработчика}
Последний кусочек головоломки объявления ваших ресурсов~--- описание
того, как они будут обработаны. В Yesod есть три варианта:
\begin{itemize}
\item у заданного маршрута единственный обработчик для всех методов запроса;
\item у заданного маршрута для каждого метода отдельный
  обработчик. Для неуказанных методов будет генерироваться ответ с
  кодом 405 <<Метод не поддерживается>> (405 Method Not
  Allowed);\marginpar{в оригинале - 405 Bad Method}
\item вы хотите перейти на подсайт.
\end{itemize}

В первых двух случаях спецификация обработчика очень проста. Для
единственного обработчика это будет просто строка с шаблоном ресурса и
наименованием ресурса, например \lstinline!/page/faq FaqR!. В этом
случае, имя функции обработчика должно быть \lstinline!handleFaqR!.

Для отдельных обработчиков для каждого метода спецификация аналогична,
только добавляется список доступных методов запросов. Методы запросов
должны быть записаны прописными буквами. Например,
\lstinline!/person/#String PersonR GET POST DELETE!.
В данном случае, вам потребуется определить три функции обработки:
\lstinline!getPersonR!, \lstinline!postPersonR! и \lstinline!deletePersonR!.

Подсайты~--- очень полезная, но сложная, тема в Yesod. Мы рассмотрим
создание подсайтов позже, но использовать их не очень сложно. Самый
часто используемый подсайт~--- это статический подсайт, который
обслуживает статические файлы для вашего приложения. Для того, что
отдавать статические файлы из \lstinline!/static!, вам нужно описать
ресурс вида:
\begin{verbatim}
/static StaticR Static getStatic
\end{verbatim}

В этой строке, \lstinline!/static! просто говорит о том, откуда в вашей
структуре URL отдавать статические файлы. Нет никакой магии в слове
static (статический), вы легко можете заменить его на
\lstinline!/my/non-dynamic/files!.

Следующее слово, \lstinline!StaticR!, задаёт наименование
ресурса. Следующие два слова указывают на то, что мы используем
подсайт. \lstinline!Static!~--- это имя типа-основания подсайта, а
\lstinline!getStatic!~--- функция, которая получает значение типа
\lstinline!Static! из значения типа-основания вашего основного сайта.

Давайте здесь не будем вдаваться в детали о подсайтах. Мы рассмотрим
подробнее статический подсайт в главе о каркасе
сайта.\marginpar{вставить ссылку на главу}

\section{Диспетчеризация}
Как только вы определили свои маршруты, Yesod позаботится обо всех
надоедливых деталях диспетчеризации URL для вас. Вам нужно только
удостовериться, что вы предоставили соответствующие функции
обработки. Для маршрутов на подсайты, вам не требуется писать
какие-либо функции обработки, но для двух других типов обработчиков
это сделать необходимо. Выше мы уже упомянули правило именования
(\lstinline!MyHandlerR GET! становится \lstinline!getMyHandlerR!,
\lstinline!MyOtherHandlerR! становится \lstinline!handleMyOtherHandlerR!).
Теперь нам нужно определиться с сигнатурой типа.

\subsection{Возвращаемый тип}
Давай посмотрим на простую функцию обработки:
\begin{lstlisting}
mkYesod "Simple" [parseRoutes|
/ HomeR GET
|]

getHomeR :: Handler RepHtml
getHomeR = defaultLayout [whamlet|<h1>This is simple
|]
instance Yesod Simple
main = warpDebug 3000 Simple
\end{lstlisting}

Посмотрите на сигнатуру типа для \lstinline!getHomeR!. Первый
компонент~--- это \lstinline!Handler!. \lstinline!Handler!~--- это
специальная монада, в которой живут все функции обработки. Она
предоставляет доступ к информации из запроса, позволяет вам
осуществлять переадресацию, и ещё много других вещей, которые мы
вскоре рассмотрим.

Затем идёт \lstinline!RepHtml!. Когда мы будем рассматривать
представления, мы исследуем подробнее вопрос <<почему так>>; сейчас
нас просто интересует вопрос <<как сделать>>.

Как вы могли бы предположить, \lstinline!RepHtml!~--- это тип данных
для ответов в формате HTML. И также вы можете предположить, что веб
сайтам приходится возвращать ответы не только в HTML. CSS, Javascript,
изображения, XML являются необходимыми для веб сайта. Поэтому
возвращаемый тип функции обработки может быть любым экземпляром
\lstinline!HasReps!.

\lstinline!HasReps!~--- это мощная концепция, которая позволяет Yesod
автоматически выбирать правильное представление ваших данных,
основываясь на запросе клиента. Пока мы сосредоточимся на простых
экземплярах, наподобие \lstinline!RepHtml!, которые предоставляют
только один формат представления.

\subsection{Аргументы}
Не все маршруты столь же просты, как \lstinline!HomeR!, который мы
определили чуть выше. Возьмём для примера наш маршрут
\lstinline!PersonR! из предыдущих разделов. Имя человека необходимо
передавать в функцию обработки. Переход очень прост и, надеюсь,
интуитивно понятен. Пример:
\begin{lstlisting}
mkYesod "Args" [parseRoutes|
/person/#Text PersonR GET
/year/#Integer/month/#Text/day/#Int DateR
/wiki/*Texts WikiR GET
|]

getPersonR :: Text -> Handler RepHtml
getPersonR name = defaultLayout [whamlet|<h1>Hello #{name}!|]

handleDateR :: Integer -> Text -> Int -> Handler RepPlain -- text/plain
handleDateR year month day =
    return $ RepPlain $ toContent $
        T.concat [month, " ", T.pack $ show day, ", ", T.pack $ show year]

getWikiR :: [Text] -> Handler RepPlain
getWikiR = return . RepPlain . toContent . T.unwords

instance Yesod Args
main = warpDebug 3000 Args
\end{lstlisting}

Аргументы имеют типы динамических участков каждого маршрута, в порядке
указания. Также обратите внимание, как мы можем использовать и
\lstinline!RepHtml!, и \lstinline!RepPlain!.

\section{Монада Handler}
Подавляющая часть кода, который вы пишете в Yesod, находится внутри
монады~\lstinline!Handler!. Если вы подходите к этому с точки зрения
шаблона Модель--Вид--Контроллер (MVC, Model--View--Controller), ваш код
\lstinline!Handler!~--- это Контроллер. Перечислим несколько важных
моментов о \lstinline!Handler!, которые следует знать:
\begin{itemize}
\item Это экземпляр \lstinline!MonadIO!, поэтому вы можете
  использовать любое действие \lstinline!IO! в ваших обработчиках с
  помощью \lstinline!liftIO!. Кстати, \lstinline!liftIO! экспортируется
  модулем \lstinline!Yesod! для вашего удобства.
\item Как и \lstinline!Widget!, \lstinline!Handler!~--- это
  псевдопреобразователь монад (fake--monad--transformer). Он обёртывает
  монаду~\lstinline!ResourceT IO!. Мы подробно обсуждаем это в
  приложении\marginpar{вставить ссылку на conduits appendix}, а
  сейчас мы только скажем, что это позволяет вам безопасно выделять
  ресурсы.
\item Под <<псевдо>>, я имею в виду, что вы не можете использовать
  стандартную функцию \lstinline!lift!, предоставляемую пакетом
  \href{http://hackage.haskell.org/package/transformers}
       {\texttt{transformers}}
  \footnote{http://hackage.haskell.org/package/transformers}, вы
  должны использовать замещающую функцию из \lstinline!Yesod! (как и в
  случае с виджетами).
\item \lstinline!Handler!~--- это просто синоним типа для
  \lstinline!GHandler!. \lstinline!GHandler! позволяет вам точно
  указать, какой дочерний и материнский сайты вы используете. Синоним
  \lstinline!Handler! сообщает, что дочерний и материнский сайты~---
  это тип вашего приложения (или <<имеют тип вашего приложения>>????
  FIXME)\marginpar{says that the sub and master sites are your
    application's type}.
\item \lstinline!Handler! обеспечивает большой объём функциональности,
  такой как:
\begin{itemize}
\item Предоставление информации о запросе;
\item Хранение списка дополнительных полей заголовка ответа, которые
  вы добавили;
\item Изменения пользовательской сессии;
\item Сокращённая обработка запросов для переадресации, отправки
  статических файлов или сообщения об ошибках.
\end{itemize}
\end{itemize}

В оставшейся части главы будет дано короткое введение в некоторые
самые распространённые функции, находящиеся в монаде
\lstinline!Handler!. Я специально не описываю функции для работы с
сессиями; они будут рассмотрены в отдельной главе \marginpar{вставить
  ссылку на главу о сессиях}.

\subsection{Информация о приложении}
Есть набор функций, которые возвращают информацию о вашем приложении в
целом и не дают никакой информации об отдельных запросах. Некоторые из
них:
\begin{description}
\item[getYesod] \hfill \\
Возвращает значение основы (foundation value) вашего приложения. Если вы
храните значения настроек в вашем основании (foundation), вам, видимо,
придётся в итоге часто использовать эту функцию.

\item[getYesodSub] \hfill \\
Возвращает значение основы (foundation value) для дочернего сайта. Если вы
не работаете в дочернем сайте, будет возвращать тоже значение, что и
\lstinline!getYesod!.

\item[getUrlRender] \hfill \\
Возвращает функцию рендеринга URL, которая преобразует типобезопасный
URL в \lstinline!Text!. По большей части~--- как и в случае с
\lstinline!Hamlet!~--- Yesod вызывает эту функцию для вас, но иногда
вам может потребоваться вызвать эту функцию напрямую.

\item[getUrlRenderParams]  \hfill \\
Вариант \lstinline!getUrlRenderer!, которые преобразует и
типобезопасный URL, и список параметров из строки запроса. Это функция
выполняет требуемое кодирование символов (percent-encoding).
\end{description}

\subsection{Информация о запросе}

The most common information you will want to get about the current
request is the requested path, the query string parameters and POSTed
form data. The first of those is dealt with in the routing, as
described above. The other two are best dealt with using the forms
module.

That said, you will sometimes need to get the data in a more raw
format. For this purpose, Yesod exposes the Request datatype along
with the getRequest function to retrieve it. This gives you access to
the full list of GET parameters, cookies, and preferred
languages. There are some convenient functions to make these lookups
easier, such as lookupGetParam, lookupCookie and languages. For raw
access to the POST parameters, you should use runRequest.

If you need even more raw data, like request headers, you can use
waiRequest to access the Web Application Interface (WAI) request
value. See the WAI appendix for more details.

\subsection{Неполная обработка запроса}
%FIXME: Вариант перевода: `Обработка запроса по короткой схеме`

The following functions immediately end execution of a handler
function and return a result to the user.

redirect

Sends a redirect response to the user (a 303 response). If you want to
use a different response code (e.g., a permanent 301 redirect), you
can use redirectWith.

\fbox{\begin{minipage}[!h]{.9\linewidth}
Yesod uses a 303 response for HTTP/1.1 clients, and a 302 response for
HTTP/1.0 clients. You can read up on this sordid saga in the HTTP
spec.
\end{minipage}}

notFound

Return a 404 response. This can be useful if a user requests a
database value that doesn't exist.

permissionDenied

Return a 403 response with a specific error message.

invalidArgs

A 400 response with a list of invalid arguments.

sendFile

Sends a file from the filesystem with a specified content type. This
is the preferred way to send static files, since the underlying WAI
handler may be able to optimize this to a sendfile system call. Using
readFile for sending static files should not be necessary.

sendResponse

Send a normal HasReps response with a 200 status code. This is really
just a convenience for when you need to break out of some deeply
nested code with an immediate response.

sendWaiResponse

When you need to get low-level and send out a raw WAI response. This
can be especially useful for creating streaming responses or a
technique like server-sent events.

\subsection{Заголовки ответа}

setCookie

Set a cookie on the client. Instead of taking an expiration date, this
function takes a cookie duration in minutes. Remember, you won't see
this cookie using lookupCookie until the following request.

deleteCookie

Tells the client to remove a cookie. Once again, lookupCookie will not
reflect this change until the next request.

setHeader

Set an arbitrary response header.

setLanguage

Set the preferred user language, which will show up in the result of
the languages function.

cacheSeconds

Set a Cache-Control header to indicate how many seconds this response
can be cached. This can be particularly useful if you are using
varnish on your server.

neverExpires

Set the Expires header to the year 2037. You can use this with content
which should never expire, such as when the request path has a hash
value associated with it.

alreadyExpired

Sets the Expires header to the past.

expiresAt

Sets the Expires header to the specified date/time.

\section{Выводы}

Routing and dispatch is arguably the core of Yesod: it is from here
that our type-safe URLs are defined, and the majority of our code is
written within the Handler monad. This chapter covered some of the
most important and central concepts of Yesod, so it is important that
you properly digest it.

This chapter also hinted at a number of more complex Yesod topics that
we will be covering later. But you should be able to write some very
sophisticated web applications with just the knowledge you have
learned up until here.'
