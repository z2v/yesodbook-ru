\chapter{Маршрутизация URL и обработчики}\label{ch:routing}
Если мы посмотрим на Yesod как на веб-фреймворк, реализующий схему
Модель-Вид-Контроллер, маршрутизация URL и обработчики запросов
формируют часть <<Контроллер>>. Для сравнения, опишем два других
подхода к маршрутизации, используемых в других средах веб разработки:
\begin{itemize}
\item Диспетчеризация обработчиков, основанная на имени файла. Так,
  например, работают PHP и ASP.

\item Используется централизованная функция, которая обрабатывает
  маршруты, опираясь на регулярные выражения. Django и Rails
  следуют такому подходу.
\end{itemize}

Yesod ближе, в принципе, к последней технике. Однако, имеются
значительные отличия. Вместо использования регулярных выражений, Yesod
сопоставляет участки маршрута. А вместо однонаправленного отображения
маршрут-обработчик, Yesod использует промежуточный тип данных
(называемый маршрутный тип данных, или типобезопасный URL) и создаёт
функции для двухстороннего преобразования.

Ручная реализация этой более продвинутой системы утомительна и
подвержена ошибкам. Поэтому, Yesod определяет предметно-ориентированный
язык (Domain Specific Language (DSL)) для описания маршрутов и
предоставляет функции Template Haskell для преобразования этого DSL в
код на Haskell. В этой главе будет объяснён синтаксис объявлений
маршрута, дано некоторое представление, какой код генерируется для
вас, и описано взаимодействие между маршрутизацией и функциями
обработки запросов.

\section{Синтаксис записи маршрута}
Вместо того, чтобы пытаться втиснуть объявления маршрутов в
существующий синтаксис, подход Yesod~--- использовать упрощённый
синтаксис, разработанный специально для маршрутов. Преимущество такого
подхода~--- код не только проще писать, но он становится достаточно
простым для не имеющих опыта работы с Yesod, чтобы прочитать и понять
схему сайта вашего приложения.

Простой пример синтаксиса:
\begin{verbatim}
/             RootR     GET
/blog         BlogR     GET POST
/blog/#BlogId BlogPostR GET POST

/static       StaticR   Static getStatic
\end{verbatim}

В следующих нескольких разделах будет подробно описано, что происходит
при объявлении маршрута.

\subsection{Участки пути URL}
Одно из первых действий, совершаемых Yesod при получении запроса,~---
разбиение запрошенного пути на участки.  Участки разделяются символами
косой черты (/). Например:
\begin{lstlisting}
toPieces "/" = []
toPieces "/foo/bar/baz/" = ["foo", "bar", "baz", ""]
\end{lstlisting}

Вы можете заметить, что некоторые забавные вещи происходят с
завершающим символом косой черты, или с двойным символом косой черты
("/foo//bar//"), или ещё с чем-то. Yesod рассчитывает на получение
канонических адресов URL; если кто-то запросит URL с завершающим
символом косой черты, или с двойным символом косой черты, они
автоматически переадресуются на каноническую версия адреса. Это
гарантирует, что у вас одному URL соответствует один ресурс, и может
помочь с вашими поисковыми рейтингами.

Для вас это означает, что вам нет необходимости беспокоиться о точной
структуре ваших адресов URL: вы можете спокойно думать об участках
маршрута, а Yesod автоматически выполнит вставку символов косой черты
и экранирование проблемных символов.

Если, кстати, вы захотите более тонкой настройки того, как маршруты
разбиваются на участки и собираются обратно, вам следует посмотреть
методы \lstinline!cleanPath! и \lstinline!joinPath! в главе~\ref{ch:yesod-typeclass}
о классе типов \lstinline!Yesod!.

\subsubsection{Типы участков}
Когда вы объявляет ваши маршруты, у вас в распоряжении имеются три
типа участков:

Статический

Это простая строка, которая должно в точности совпадать в URL.

Динамический одинарный

Это один участок (т.е. между двумя символами косой черты), но может
быть предоставленным пользователем значением. Это основой способ
получения дополнительного пользовательского ввода при запросе
страницы. Эти участки начинаются с символа решётки (\#), за которым
следует тип данных. Тип данных должен быть экземпляром
\lstinline!PathPiece!.

Динамический множественный

Аналогичен предыдущему, но может получать множество участков URL. Это
всегда должен быть последний участок в шаблоне ресурса. Задаётся
символом звёздочки (*), за которым следует тип данных, который должен
быть экземпляром \lstinline!PathMultiPiece!. Множественные участки не
столь распространены, как предыдущие два типа, хотя они очень важны
для реализации таких возможностей, как статические деревья,
представляющих файловую структуру или вики с произвольными иерархиями.
\marginpar{file structure - Может, имеется в виду структура файловой системы?}

Давайте посмотрим на некоторые стандартные типы шаблонов ресурса,
которые вы возможно захотите написать. Начиная с простого, корень
приложения будет просто \lstinline!/!. Также, вы возможно захотите
поместить свои часто задаваемые вопросы (FAQ) по адресу
\lstinline!/page/faq!.

Теперь давайте представим, что вы собираетесь сделать сайт для
вычисления чисел Фибоначчи. Вы можете сделать свои URL наподобие
\lstinline!/fib/#Int!. Но тут есть следующая небольшая проблема: мы не
хотим разрешать, чтобы отрицательные числа или ноль передавались в
наше приложение. К счастью, система типов может защитить нас:
\begin{lstlisting}
newtype Natural = Natural Int
    deriving (Show, Read, Eq, Num, Ord)
instance PathPiece Natural where
    toPathPiece (Natural i) = T.pack $ show i
    fromPathPiece s =
        case reads $ T.unpack s of
            (i, ""):_
                | i < 1 -> Nothing
                | otherwise -> Just $ Natural i
            [] -> Nothing
mkYesod "Fibs" [parseRoutes|
/fibs/#Natural FibsR GET
|]
instance Yesod Fibs
fibs = 1 : 1 : zipWith (+) fibs (tail fibs)
getFibsR :: Natural -> GHandler Fibs Fibs RepPlain
getFibsR (Natural i) = return $ RepPlain $ toContent $ show $ fibs !! (i - 1)
main = warpDebug 3000 Fibs
\end{lstlisting}

В строке 1 мы определяем для \lstinline!Int! изоморфный тип, который
защитит нас от некорректного ввода. Мы можем увидеть, что
\lstinline!PathPiece!~--- это класс типов с двумя
методами. \lstinline!toPathPiece! просто конвертирует в
\lstinline!Text! и ничего больше. \lstinline!fromPathPiece!
\emph{пытается} преобразовать \lstinline!Text! в наш тип данных,
возвращая \lstinline!Nothing!, если преобразование
невозможно. Используя этот тип данных, мы можем быть уверены, что
нашей функции обработчику будут передаваться только натуральные числа,
позволяя нам в очередной раз использовать систему типов для борьбы с
краевыми случаями.

\fbox{\begin{minipage}[!h]{.9\linewidth}
В реальном приложении, мы бы ещё захотели удостовериться, что никогда
случайно не создадим некорректное значение \lstinline!Natural! внутри
нашего приложения. Для этого, мы могли бы использовать подход
наподобие умных конструкторов
(\href{http://www.haskell.org/haskellwiki/Smart\_constructors}
{\texttt{smart constructors}}
\footnote{http://www.haskell.org/haskellwiki/Smart\_constructors}).
Для целей примера, мы оставили код простым.
\end{minipage}}

Определение \lstinline!PathMultiPiece! столь же простое. Допустим,
что мы хотим сделать вики с иерархией не меньше, чем два уровня;
тогда мы могли бы определить тип данных так:
\begin{lstlisting}
data Page = Page Text Text [Text] -- 2 или больше
instance PathMultiPiece Page where
    toPathMultiPiece (Page x y z) = x : y : z
    fromPathMultiPiece (x:y:z) = Just $ Page x y z
    fromPathMultiPiece _ = Nothing
main = return ()
\end{lstlisting}

\subsection{Наименование ресурса}
Каждый шаблон ресурса имеет имя, связанное с ним. Это имя становится
конструктором типа данных для типобезопасного URL, связанного с вашим
приложением. Поэтому оно должно начинаться с прописной буквы. По
соглашению, эти наименования ресурсов все заканчиваются прописной
буквой <<R>>. Это не обязательное требование, просто общепринятая
практика.

Точное определение нашего конструктора зависит от шаблона ресурса, к
которому оно относится. Все типы данных, которые включены в одинарные
и множественные динамические участки шаблона, становятся аргументами
типа данных. Это даёт нам соотношение 1-к-1 между нашим типом для
типобезопасных URL и корректными URL для нашего приложения.

%FIXME: если раскомментировать fbox, пропадёт текст аж до следующего раздела
%\fbox{
\begin{minipage}[!h]{.9\linewidth}
Это не означает непременно, что каждое значение типа представляет
рабочую страницу, это означает, что значение типа является потенциально
корректным URL. Например, значение \lstinline!PersonR "Michael"! может
не разрешиться в корректную страницу, если в базе данных нет записи для
\lstinline!"Michael"!.
\end{minipage}
%}

Давайте теперь обратимся к реальным примерам. Если бы у вас были такие
шаблоны ресурсов: \lstinline!/person/#Text! с именем
\lstinline!PersonR!; \lstinline!/year/#Int! с именем
\lstinline!YearR! и \lstinline!/page/faq! с именем \lstinline!FaqR!,
то ваш тип данных для маршрутов выглядел бы приблизительно так:
\begin{lstlisting}
data MyRoute = PersonR Text
             | YearR Int
             | FaqR
\end{lstlisting}

Если пользователь запросит относительный URL \lstinline!/year/2009!,
Yesod преобразует его в значение \lstinline!YearR 2009!.
\lstinline!/person/Michael! станет \lstinline!PersonR "Michael"!
и \lstinline!/page/faq! станет \lstinline!FaqR!. С другой
стороны, \lstinline!/year/two-thousand-nine!,
\lstinline!/person/michael/snoyman! и \lstinline!/page/FAQ! привели бы
к получению 404 ошибок даже без обращения к вашему коду.

\section{Спецификация обработчика}
Последний кусочек головоломки объявления ваших ресурсов~--- описание
того, как они будут обработаны. В Yesod есть три варианта:
\begin{itemize}
\item у заданного маршрута единственный обработчик для всех методов запроса;
\item у заданного маршрута для каждого метода отдельный
  обработчик. Для неуказанных методов будет генерироваться ответ с
  кодом 405 <<Метод не поддерживается>> (405 Method Not
  Allowed);\marginpar{в оригинале - 405 Bad Method}
\item вы хотите перейти на подсайт.
\end{itemize}

В первых двух случаях спецификация обработчика очень проста. Для
единственного обработчика это будет просто строка с шаблоном ресурса и
наименованием ресурса, например \lstinline!/page/faq FaqR!. В этом
случае, имя функции обработчика должно быть \lstinline!handleFaqR!.

Для отдельных обработчиков для каждого метода спецификация аналогична,
только добавляется список доступных методов запросов. Методы запросов
должны быть записаны прописными буквами. Например,
\lstinline!/person/#String PersonR GET POST DELETE!.
В данном случае, вам потребуется определить три функции-обработчика:
\lstinline!getPersonR!, \lstinline!postPersonR! и \lstinline!deletePersonR!.

Подсайты~--- очень полезная, но сложная, тема в Yesod. Мы рассмотрим
создание подсайтов позже, но использовать их не очень сложно. Самый
часто используемый подсайт~--- это статический подсайт, который
обслуживает статические файлы для вашего приложения. Для того, что
отдавать статические файлы из \lstinline!/static!, вам нужно описать
ресурс вида:
\begin{verbatim}
/static StaticR Static getStatic
\end{verbatim}

В этой строке, \lstinline!/static! просто говорит о том, откуда в вашей
структуре URL отдавать статические файлы. Нет никакой магии в слове
static (статический), вы легко можете заменить его на
\lstinline!/my/non-dynamic/files!.

Следующее слово, \lstinline!StaticR!, задаёт наименование
ресурса. Следующие два слова указывают на то, что мы используем
подсайт. \lstinline!Static!~--- это имя типа-основания подсайта, а
\lstinline!getStatic!~--- функция, которая получает значение типа
\lstinline!Static! из значения типа-основания вашего основного сайта.

Давайте здесь не будем вдаваться в детали о подсайтах. Мы рассмотрим
подробнее статический подсайт в главе о каркасе
сайта.\marginpar{вставить ссылку на главу}

%FIXME: уточнить перевод для dispatch
\section{Отправка}
Once you have specified your routes, Yesod will take care of all the
pesky details of URL dispatch for you. You just need to make sure to
provide the appropriate handler functions. For subsite routes, you do
not need to write any handler functions, but you do for the other
two. We mentioned the naming rules above (MyHandlerR GET becomes
getMyHandlerR, MyOtherHandlerR becomes handleMyOtherHandlerR). Now we
need the type signature.

\subsection{Возвращаемый тип}

Let's look at a simple handler function:

\begin{lstlisting}
mkYesod "Simple" [parseRoutes|
/ HomeR GET
|]

getHomeR :: Handler RepHtml
getHomeR = defaultLayout [whamlet|<h1>This is simple
|]
instance Yesod Simple
main = warpDebug 3000 Simple
\end{lstlisting}

Look at the type signature of getHomeR. The first component is
Handler. Handler is a special monad that all handler functions live
in. It provides access to request information, let's you send
redirects, and lots of other stuff we'll get to soon.

Next we have RepHtml. When we discuss representations we will explore
the why of things more; for now, we are just interested in the how.

As you might guess, RepHtml is a datatype for HTML responses. And as
you also may guess, web sites need to return responses besides
HTML. CSS, Javascript, images, XML are all necessities of a
website. Therefore, the return value of a handler function can be any
instance of HasReps.

HasReps is a powerful concept that allows Yesod to automatically
choose the correct representation of your data based on the client
request. For now, we will focus just on simple instances such as
RepHtml, which only provide one representation.

\subsection{Аргументы}

Not every route is as simple as the HomeR we just defined. Take for
instance our PersonR route from earlier. The name of the person needs
to be passed to the handler function. This translation is very
straight-forward, and hopefully intuitive. For example:

\begin{lstlisting}
mkYesod "Args" [parseRoutes|
/person/#Text PersonR GET
/year/#Integer/month/#Text/day/#Int DateR
/wiki/*Texts WikiR GET
|]

getPersonR :: Text -> Handler RepHtml
getPersonR name = defaultLayout [whamlet|<h1>Hello #{name}!|]

handleDateR :: Integer -> Text -> Int -> Handler RepPlain -- text/plain
handleDateR year month day =
    return $ RepPlain $ toContent $
        T.concat [month, " ", T.pack $ show day, ", ", T.pack $ show year]

getWikiR :: [Text] -> Handler RepPlain
getWikiR = return . RepPlain . toContent . T.unwords
instance Yesod Args
main = warpDebug 3000 Args
\end{lstlisting}

The arguments have the types of the dynamic pieces for each route, in
the order specified. Also, notice how we are able to use both RepHtml
and RepPlain.

\section{Монада Handler}

The vast majority of code you write in Yesod sits in the Handler
monad. If you are approaching this from an MVC (Model-View-Controller)
background, your Handler code is the Controller. Some important points
to know about Handler:

* It is an instance of MonadIO, so you can run any IO action in your
handlers with liftIO. By the way, liftIO is exported by the Yesod
module for your convenience.
* Like Widget, Handler is a fake-monad-transformer. It wraps around a
ResourceT IO monad. We discuss this type at length in the conduits
appendix, but for now, we'll just say it let's you safely allocate
resources.
* By "fake", I mean you can't use the standard lift function provided
by the transformers package, you must use the Yesod-supplied one (just
like with widgets).
* Handler is just a type synonym around GHandler. GHandler let's you
specify exactly which subsite and master site you're using. The
Handler synonym says that the sub and master sites are your
application's type.
* Handler provides a lot of different functionality, such as:
** Providing request information.
** Keeping a list of the extra response headers you've added.
** Allowing you to modify the user's session.
** Short-circuiting responses, for redirecting, sending static files,
** or reporting errors.

The remainder of this chapter will give a brief introduction to some
of the most common functions living in the Handler monad. I am
specifically not covering any of the session functions; that will be
addressed in the sessions chapter.

\subsection{Информация о приложении}

There are a number of functions that return information about your
application as a whole, and give no information about individual
requests. Some of these are:

getYesod

Returns your applicaton foundation value. If you store configuration
values in your foundation, you will probably end up using this
function a lot.

getYesodSub

Get the subsite foundation value. Unless you are working in a subsite,
this will return the same value as getYesod.

getUrlRender

Returns the URL rendering function, which converts a type-safe URL
into a Text. Most of the time- like with Hamlet- Yesod calls this
function for you, but you may occassionally need to call it directly.

getUrlRenderParams

A variant of getUrlRender that converts both a type-safe URL and a
list of query-string parameters. This function handles all
percent-encoding necessary.

\subsection{Информация о запросе}

The most common information you will want to get about the current
request is the requested path, the query string parameters and POSTed
form data. The first of those is dealt with in the routing, as
described above. The other two are best dealt with using the forms
module.

That said, you will sometimes need to get the data in a more raw
format. For this purpose, Yesod exposes the Request datatype along
with the getRequest function to retrieve it. This gives you access to
the full list of GET parameters, cookies, and preferred
languages. There are some convenient functions to make these lookups
easier, such as lookupGetParam, lookupCookie and languages. For raw
access to the POST parameters, you should use runRequest.

If you need even more raw data, like request headers, you can use
waiRequest to access the Web Application Interface (WAI) request
value. See the WAI appendix for more details.

\subsection{Неполная обработка запроса}
%FIXME: Вариант перевода: `Обработка запроса по короткой схеме`

The following functions immediately end execution of a handler
function and return a result to the user.

redirect

Sends a redirect response to the user (a 303 response). If you want to
use a different response code (e.g., a permanent 301 redirect), you
can use redirectWith.

\fbox{\begin{minipage}[!h]{.9\linewidth}
Yesod uses a 303 response for HTTP/1.1 clients, and a 302 response for
HTTP/1.0 clients. You can read up on this sordid saga in the HTTP
spec.
\end{minipage}}

notFound

Return a 404 response. This can be useful if a user requests a
database value that doesn't exist.

permissionDenied

Return a 403 response with a specific error message.

invalidArgs

A 400 response with a list of invalid arguments.

sendFile

Sends a file from the filesystem with a specified content type. This
is the preferred way to send static files, since the underlying WAI
handler may be able to optimize this to a sendfile system call. Using
readFile for sending static files should not be necessary.

sendResponse

Send a normal HasReps response with a 200 status code. This is really
just a convenience for when you need to break out of some deeply
nested code with an immediate response.

sendWaiResponse

When you need to get low-level and send out a raw WAI response. This
can be especially useful for creating streaming responses or a
technique like server-sent events.

\subsection{Заголовки ответа}

setCookie

Set a cookie on the client. Instead of taking an expiration date, this
function takes a cookie duration in minutes. Remember, you won't see
this cookie using lookupCookie until the following request.

deleteCookie

Tells the client to remove a cookie. Once again, lookupCookie will not
reflect this change until the next request.

setHeader

Set an arbitrary response header.

setLanguage

Set the preferred user language, which will show up in the result of
the languages function.

cacheSeconds

Set a Cache-Control header to indicate how many seconds this response
can be cached. This can be particularly useful if you are using
varnish on your server.

neverExpires

Set the Expires header to the year 2037. You can use this with content
which should never expire, such as when the request path has a hash
value associated with it.

alreadyExpired

Sets the Expires header to the past.

expiresAt

Sets the Expires header to the specified date/time.

\section{Выводы}

Routing and dispatch is arguably the core of Yesod: it is from here
that our type-safe URLs are defined, and the majority of our code is
written within the Handler monad. This chapter covered some of the
most important and central concepts of Yesod, so it is important that
you properly digest it.

This chapter also hinted at a number of more complex Yesod topics that
we will be covering later. But you should be able to write some very
sophisticated web applications with just the knowledge you have
learned up until here.'
