\chapter{Маршрутизация URL и обработчики}\label{chap:routing}

Если мы посмотрим на Yesod как на веб-фреймворк, реализующий схему
Модель--Вид--Контроллер, то маршрутизация URL и обработчики запросов составляют в ней
<<Контроллер>>. Для сравнения, опишем два других подхода к маршрутизации, используемых в
других средах веб-разработки:
\begin{itemize}
\item Используется диспетчеризация обработчиков, основанная на имени файла. Так, например,
  работают PHP и ASP.
\item Используется централизованная функция, которая обрабатывает маршруты, опираясь на
  регулярные выражения. Такому подходу следуют Django и Rails.
\end{itemize}

Yesod в основном следует второму подходу, однако имеются и значительные отличия. Вместо
использования регулярных выражений Yesod сопоставляет компоненты маршрута. Вместо
однонаправленного отображения маршрут--обработчик Yesod использует промежуточный тип
данных (называемый тип данных маршрута, или типобезопасный URL) и создаёт функции для
двустороннего преобразования.

Ручная реализация этой более изощренной системы утомительна и подвержена ошибкам. Поэтому
Yesod определяет предметно-ориентированный язык (Domain Specific Language, DSL) для
описания маршрутов и предоставляет функции Template Haskell для преобразования кода на
этом языке в код на Haskell. В настоящей главе разъясняется синтаксис объявлений маршрута,
даётся некоторое представление о том, какой код генерируется за вас, и описывается
взаимодействие между маршрутизацией и функциями обработки запросов.

\section{Синтаксис записи маршрута}

Вместо того, чтобы пытаться втиснуть объявления маршрутов в рамки существующего
синтаксиса, Yesod использует упрощённый синтаксис, разработанный специально для
маршрутов. Преимущество такого подхода~--- код получается не только проще в написании, но
и достаточно простым для того, чтобы люди, не имеющие опыта работы с Yesod, могли
его прочитать и понять схему сайта вашего приложения.

Простой пример синтаксиса:
\begin{lstlisting}
/             RootR     GET
/blog         BlogR     GET POST
/blog/#BlogId BlogPostR GET POST

/static       StaticR   Static getStatic
\end{lstlisting}

В следующих нескольких разделах будет подробно описано, что происходит при объявлении
маршрута.

\subsection{Компоненты пути URL}

Одно из первых действий, совершаемых Yesod при получении запроса,~---
разбиение запрошенного пути на компоненты. Компоненты разделяются символами
косой черты (/). Например:
\begin{lstlisting}
toPieces "/" = []
toPieces "/foo/bar/baz/" = ["foo", "bar", "baz", ""]
\end{lstlisting}

Вы можете заметить, что некоторые забавные вещи происходят с
завершающим символом косой черты, или с двойным символом косой черты
(<</foo//bar//>>), или ещё с некоторыми другими комбинациями.
Yesod рассчитывает на получение канонических адресов URL; если кто-то
запросит URL с завершающим символом косой черты или с двойным символом
косой черты, он будет автоматически переадресован на каноническую версию адреса.
Это гарантирует, что у вас одному URL соответствует один ресурс, и может
помочь с рейтингами в поисковых системах.

Это означает, что вам нет необходимости беспокоиться о точной
структуре ваших URL: вы можете спокойно думать о компонентах
маршрута, а Yesod автоматически выполнит вставку символов косой черты
и экранирование проблемных символов.

Если, кстати, вы захотите более тонко настраивать, как маршруты
разбиваются на компоненты и собираются обратно, вам стоит взглянуть на
методы \lstinline!cleanPath! и \lstinline!joinPath! в главе~\ref{chap:yesod-typeclass}
о классе типов \lstinline!Yesod!.

\subsubsection{Типы участков}
Когда вы объявляет ваши маршруты, у вас в распоряжении имеются три
типа участков:
\begin{description}
\item[Статический] \hfill \\
Это простая строка, которая должна в точности совпадать в URL.

\item[Динамический одинарный] \hfill \\
Это один участок (т.е. между двумя символами косой черты), но может
быть предоставленным пользователем значением. Это основой способ
получения дополнительного пользовательского ввода при запросе
страницы. Эти участки начинаются с символа решётки (\#), за которым
следует тип данных. Тип данных должен быть экземпляром
\lstinline!PathPiece!.

\item [Динамический множественный] \hfill \\
Аналогичен предыдущему, но может получать множество участков URL. Это
всегда должен быть последний участок в шаблоне ресурса. Задаётся
символом звёздочки (*), за которым следует тип данных, который должен
быть экземпляром \lstinline!PathMultiPiece!. Множественные участки не
столь распространены, как предыдущие два типа, хотя они очень важны
для реализации таких возможностей, как статические деревья,
представляющие файловую структуру или вики с произвольными иерархиями.
\marginpar{FIXME: перевод для file structure}
\end{description}

Давайте посмотрим на некоторые стандартные типы шаблонов ресурса,
которые вы, возможно, захотите написать. Начнём с простого: корень
приложения будет просто \lstinline!/!. Также, вы, вероятно, захотите
поместить свои часто задаваемые вопросы (FAQ) по адресу
\lstinline!/page/faq!.

Теперь давайте представим, что вы собираетесь сделать сайт для
вычисления чисел Фибоначчи. Вы можете сделать свои URL наподобие
\lstinline!/fib/#Int!. Но тут присутствует следующая небольшая проблема: мы не
хотим разрешать, чтобы отрицательные числа или ноль передавались в
наше приложение. К счастью, система типов может защитить нас:
\begin{lstlisting}
newtype Natural = Natural Int
instance PathPiece Natural where
    toPathPiece (Natural i) = T.pack $ show i
    fromPathPiece s =
        case reads $ T.unpack s of
            (i, ""):_
                | i < 1 -> Nothing
                | otherwise -> Just $ Natural i
            [] -> Nothing
\end{lstlisting}%$

В строке 1 мы определяем для \lstinline!Int! изоморфный тип, который
защитит нас от некорректного ввода. Мы можем увидеть, что
\lstinline!PathPiece!~--- это класс типов с двумя
методами. \lstinline!toPathPiece! просто конвертирует в
\lstinline!Text! и ничего больше. \lstinline!fromPathPiece!
\emph{пытается} преобразовать \lstinline!Text! в наш тип данных,
возвращая \lstinline!Nothing!, если преобразование
невозможно. Используя этот тип данных, мы можем быть уверены, что
нашей функции обработчику будут передаваться только натуральные числа,
позволяя нам в очередной раз использовать систему типов для борьбы с
граничными случаями.

\begin{remark}
В реальном приложении мы бы ещё захотели удостовериться, что никогда
случайно не создадим некорректное значение \lstinline!Natural! внутри
нашего приложения. Для этого мы могли бы использовать подход
наподобие умных конструкторов
(\href{http://www.haskell.org/haskellwiki/Smart\_constructors}{smart constructors}\footnotemark).
Для примера мы оставили код простым.
\end{remark}

\footnotetext{\href{http://www.haskell.org/haskellwiki/Smart\_constructors}{\texttt{http://www.haskell.org/haskellwiki/Smart\_constructors}}}


Определение \lstinline!PathMultiPiece! столь же простое. Допустим,
что мы хотим сделать вики с иерархией не менее, чем два уровня;
тогда мы могли бы определить тип данных как:
\begin{lstlisting}
data Page = Page Text Text [Text] -- 2 или больше
instance PathMultiPiece Page where
    toPathMultiPiece (Page x y z) = x : y : z
    fromPathMultiPiece (x:y:z) = Just $ Page x y z
    fromPathMultiPiece _ = Nothing
\end{lstlisting}%$

\subsection{Наименование ресурса}
Каждый шаблон ресурса имеет имя, связанное с ним. Это имя становится
конструктором типа данных для типобезопасного URL, связанного с вашим
приложением. Поэтому оно должно начинаться с прописной буквы. По
соглашению, эти наименования ресурсов все заканчиваются прописной
буквой <<R>>. Это не обязательное требование, просто общепринятая
практика.

Точное определение нашего конструктора зависит от шаблона ресурса, к
которому оно относится. Все типы данных, которые включены в одинарные
и множественные участки шаблона, становятся аргументами
типа данных. Это даёт нам соотношение <<один к одному>> между нашим типом для
типобезопасных URL и корректными URL для нашего приложения.

\begin{remark}
Это не обязательно означает, что каждое значение типа представляет
работающую страницу, лишь означает, что значение типа является потенциально
корректным URL. Например, значение \lstinline!PersonR "Michael"! может
не разрешиться в корректную страницу, если в базе данных нет записи для
\lstinline!"Michael"!.
\end{remark}

Давайте теперь обратимся к реальным примерам. Если бы у вас были такие
шаблоны ресурсов: \lstinline!/person/#Text! с именем
\lstinline!PersonR!; \lstinline!/year/#Int! с именем
\lstinline!YearR! и \lstinline!/page/faq! с именем \lstinline!FaqR!,
то ваш тип данных для маршрутов выглядел бы приблизительно так:
\begin{lstlisting}
data MyRoute = PersonR Text
             | YearR Int
             | FaqR
\end{lstlisting}

Если пользователь запросит относительный URL \lstinline!/year/2009!,
Yesod преобразует его в значение \lstinline!YearR 2009!.
\lstinline!/person/Michael! станет \lstinline!PersonR "Michael"!
и \lstinline!/page/faq! станет \lstinline!FaqR!. С другой
стороны, \lstinline!/year/two-thousand-nine!,
\lstinline!/person/michael/snoyman! и \lstinline!/page/FAQ! привели бы
к получению 404 ошибок даже без обращения к вашему коду.

\section{Спецификация обработчика}
Последний кусочек головоломки объявления ваших ресурсов~--- описание
того, как они будут обработаны. В Yesod есть три варианта:
\begin{itemize}
\item у заданного маршрута единственный обработчик для всех методов запроса;
\item у заданного маршрута для каждого метода отдельный
  обработчик. Для неуказанных методов будет генерироваться ответ с
  кодом 405 <<Метод не поддерживается>> (405 Method Not
  Allowed);
\item вы хотите передать управление на дочерний сайт.
\end{itemize}

В первых двух случаях спецификация обработчика очень проста. Для
единственного обработчика это будет просто строка с шаблоном ресурса и
наименованием ресурса, например \lstinline!/page/faq FaqR!. В таком
случае, имя функции обработчика должно быть \lstinline!handleFaqR!.

Для отдельных обработчиков для каждого метода спецификация аналогична,
только добавляется список доступных методов запросов. Методы запросов
должны быть записаны прописными буквами. Например,
\lstinline!/person/#String PersonR GET POST DELETE!.
В данном случае, вам потребуется определить три функции обработки:
\lstinline!getPersonR!, \lstinline!postPersonR! и \lstinline!deletePersonR!.

Дочерние сайты~--- очень полезная, но сложная тема в Yesod. Мы рассмотрим
создание дочерних сайтов позже, в главе~<<\nameref{chap:subsite}>>,
но использовать их не очень сложно. Самый
часто используемый дочерний сайт~--- статический сайт, который
обслуживает статические файлы для вашего приложения. Для того, чтобы
отдавать статические файлы из \lstinline!/static!, вам нужно описать
ресурс вида:
\begin{verbatim}
/static StaticR Static getStatic
\end{verbatim}

В этой строке, \lstinline!/static! просто говорит о том, откуда в вашей
структуре URL отдавать статические файлы. Нет никакой магии в слове
static (статический), вы легко можете заменить его на
\lstinline!/my/non-dynamic/files!.

Следующее слово, \lstinline!StaticR!, задаёт наименование
ресурса. Следующие два слова указывают на то, что мы используем
дочернего сайт. \lstinline!Static!~--- это имя типа--основания дочернего сайта, а
\lstinline!getStatic!~--- функция, которая получает значение типа
\lstinline!Static! из значения типа-основания вашего основного сайта.

Давайте здесь не будем вдаваться в детали о дочерних сайтах. Мы рассмотрим
подробнее статический сайт в главе~\ref{chap:scaffolding} о каркасе сайта.

\section{Диспетчеризация}
Как только вы определили свои маршруты, Yesod позаботится обо всех
надоедливых деталях диспетчеризации URL для вас. Вам нужно только
удостовериться, что вы предоставили соответствующие функции
обработки. Для маршрутов на дочерние сайты, вам не требуется писать
какие--либо функции обработки, но для двух других типов обработчиков
это сделать необходимо. Выше мы уже упомянули правило именования:
(\lstinline!MyHandlerR GET! становится \lstinline!getMyHandlerR!,
\lstinline!MyOtherHandlerR! становится \lstinline!handleMyOtherHandlerR!).
Теперь нам нужно определиться с сигнатурой типа.

\subsection{Возвращаемый тип}
Давай посмотрим на простую функцию обработки:
\begin{lstlisting}
mkYesod "Simple" [parseRoutes|
/ HomeR GET
|]

getHomeR :: Handler RepHtml
getHomeR = defaultLayout [whamlet|<h1>This is simple
|]
\end{lstlisting}

Посмотрите на сигнатуру типа для \lstinline!getHomeR!. Первый
компонент~--- это \lstinline!Handler!. \lstinline!Handler!~--- это
специальная монада, в которой живут все функции обработки. Она
предоставляет доступ к информации о запросе, позволяет вам
осуществлять переадресацию, и ещё много других вещей, которые мы
рассмотрим \hyperref[sec:handler-monad]{вскоре}.

Затем идёт \lstinline!RepHtml!. Когда мы будем рассматривать
представления в главе~<<\nameref{chap:restful-content}>>,
мы исследуем подробнее вопрос \emph{<<почему так>>}; сейчас
нас просто интересует вопрос \emph{<<как сделать>>}.

Как вы могли бы предположить, \lstinline!RepHtml!~--- это тип данных
для ответов в формате HTML. И также вы можете предположить, что веб-сайтам
приходится возвращать ответы не только в HTML. CSS, Javascript,
изображения, XML являются необходимыми для веб-сайта. Поэтому
возвращаемый тип функции обработки может быть любым экземпляром
\lstinline!HasReps!.

\lstinline!HasReps!~--- это мощная концепция, которая позволяет Yesod
автоматически выбирать правильное представление ваших данных,
основываясь на запросе клиента. Пока мы сосредоточимся на простых
экземплярах, наподобие \lstinline!RepHtml!, которые предоставляют
только один формат представления.

\subsection{Аргументы}
Не все маршруты столь же просты, как \lstinline!HomeR!, который мы
определили чуть выше. Возьмём для примера наш маршрут
\lstinline!PersonR! из предыдущих разделов. Имя человека необходимо
передавать в функцию обработки. Переход очень прост и, надеюсь,
интуитивно понятен. Пример:
\begin{lstlisting}
mkYesod "Args" [parseRoutes|
/person/#Text PersonR GET
/year/#Integer/month/#Text/day/#Int DateR
/wiki/*Texts WikiR GET
|]

getPersonR :: Text -> Handler RepHtml
getPersonR name = defaultLayout [whamlet|<h1>Hello #{name}!|]

handleDateR :: Integer -> Text -> Int -> Handler RepPlain -- text/plain
handleDateR year month day =
    return $ RepPlain $ toContent $
        T.concat [month, " ", T.pack $ show day, ", ", T.pack $ show year]

getWikiR :: [Text] -> Handler RepPlain
getWikiR = return . RepPlain . toContent . T.unwords
\end{lstlisting}%$

Аргументы имеют типы динамических компонент каждого маршрута, в порядке
указания. Также обратите внимание, как мы смогли использовать и
\lstinline!RepHtml!, и \lstinline!RepPlain!.

\section{Монада Handler}\label{sec:handler-monad}
Подавляющая часть кода, который вы пишете в Yesod, находится внутри
монады~\lstinline!Handler!. Если вы подходите к этому с точки зрения
шаблона Модель--Вид--Контроллер (MVC, Model--View--Controller), ваш код
\lstinline!Handler!~--- это Контроллер. Перечислим несколько важных
моментов о \lstinline!Handler!, которые следует знать:
\begin{itemize}
\item Это экземпляр \lstinline!MonadIO!, поэтому вы можете
  использовать любое действие \lstinline!IO! в ваших обработчиках с
  помощью \lstinline!liftIO!. Кстати, \lstinline!liftIO! экспортируется
  модулем \lstinline!Yesod! для вашего удобства.
\item Как и \lstinline!Widget!, \lstinline!Handler!~--- это псевдотрансформатор
    монад (fake-monad-transformer). Он обёртывает монаду~\lstinline!ResourceT IO!.
    Мы подробно обсудим это в~\hyperref[chap:conduit]{приложении о conduit}, а
    сейчас мы только скажем, что это позволяет вам безопасно выделять ресурсы.
\item Под <<псевдо>>, я имею в виду, что вы не можете использовать
  стандартную функцию \lstinline!lift!, предоставляемую пакетом
  \footnotehref{http://hackage.haskell.org/package/transformers}{transformers},
  вы должны использовать замещающую функцию из \lstinline!Yesod! (как и в
  случае с виджетами).
\item \lstinline!Handler!~--- это просто синоним типа для
  \lstinline!GHandler!. \lstinline!GHandler! позволяет вам точно
  указать, какой дочерний и материнский сайты вы используете. Синоним
  \lstinline!Handler! сообщает, что дочерний и материнский сайты
  принадлежат типу вашего приложения.
\item \lstinline!Handler! обеспечивает большое число возможностей, среди которых:
\begin{itemize}
\item предоставление информации о запросе;
\item хранение списка дополнительных полей заголовка ответа, которые
  вы добавили;
\item изменения пользовательской сессии;
\item сокращённая обработка запросов для переадресации, отправки
  статических файлов или сообщения об ошибках.
\end{itemize}
\end{itemize}

В оставшейся части главы будет дано короткое введение в некоторые
самые распространённые функции, находящиеся в монаде
\lstinline!Handler!. Я специально не описываю функции для работы с
сессиями; они будут рассмотрены в отдельной~\hyperref[chap:sessions]{главе}.

\subsection{Информация о приложении}
Есть набор функций, которые возвращают информацию о вашем приложении в
целом и не дают никакой информации об отдельных запросах. Среди них:
\begin{description}
\item[getYesod] \hfill \\
Возвращает значение основы (foundation value) вашего приложения. Если вы
храните значения настроек в вашем основании (foundation), вам, видимо,
придётся в итоге часто использовать эту функцию.

\item[getYesodSub] \hfill \\
Возвращает значение основы (foundation value) для дочернего сайта. Если вы
не работаете в дочернем сайте, будет возвращать тоже значение, что и
\lstinline!getYesod!.

\item[getUrlRender] \hfill \\
Возвращает функцию рендеринга URL, которая преобразует типобезопасный
URL в \lstinline!Text!. По большей части~--- как при использовани
\lstinline!Hamlet!~--- Yesod сам вызывает эту функцию за вас, но иногда
вам может потребоваться вызвать эту функцию напрямую.

\item[getUrlRenderParams]  \hfill \\
Вариант \lstinline!getUrlRender!, которые преобразует и
типобезопасный URL, и список параметров из строки запроса. Это функция
выполняет требуемое кодирование символов (percent-encoding).
\end{description}

\subsection{Информация о запросе}
Информация, которую вы чаще всего захотите получить о текущем
запросе,~--- это запрошенный маршрут, параметы из строки запроса и
данные форм, отправленные на сервер (методом POST). С первым пунктом имеет
дело маршрутизация, как описано выше. С оставшимися двумя лучше всего
работать, используя модуль работы с~\hyperref[chap:forms]{формами}.

Вместе с тем вам иногда требуется получить данные в необработанном
виде. Для этой цели, Yesod экспортирует тип данных~\lstinline!Request!
вместе с функцией~\lstinline!getRequest! для его получения. Он даёт
вам доступ к полному набору параметров GET запроса, к куки и списку
предпочитаемых языков. Есть несколько удобных функций для упрощения
поиска, такие как \lstinline!lookupGetParam!, \lstinline!lookupCookie!
и \lstinline!languages!. Для прямого доступа к данным POST запроса,
вам следует использовать \lstinline!runRequest!.

Если вам требуются ещё более сырые данные, такие как заголовки
запросов, вы можете использовать \lstinline!waiRequest! для доступа к
значению запроса Интерфейса Веб-приложения (Web Application Interface,
WAI). За деталями обратитесь к \hyperref[chap:web_application_interface]{приложению о WAI}.

\subsection{Сокращённая обработка запроса}
Описанные ниже функции немедленно прекращают выполнение обработчика и
возвращают результат пользователю.
\begin{description}
\item[redirect] \hfill \\
Отправляет пользователю ответ на переадресацию (ответ 303). Если вы
хотите использовать другой код ответа (например, 301 <<Постоянная
переадресация>>), вы можете использовать \lstinline!redirectWith!.

\begin{remark}
Yesod использует ответ 303 для клиентов по протоколу HTTP/1.1, и ответ
302 для клиентов по протоколу HTTP/1.0. Вы можете почитать об этой
ужасной истории в спецификации протокола HTTP.
\end{remark}

\item[notFound] \hfill \\
Возвращает ответ 404. Это может быть полезно, если пользователь
запросил из базы данных отсутствующее значение.

\item[permissionDenied] \hfill \\
Возвращает ответ 403 с указанным сообщением об ошибке.

\item[invalidArgs] \hfill \\
Ответ 400 со списком некорректных аргументов.

\item[sendFile] \hfill \\
Отправляет файл из файловой системы с указанным типом контента. Это
предпочтительный путь для отправки статических файлов, так как лежащий
в основе обработчик WAI может оказаться в состоянии оптимизировать
отправку до системного вызова sendfile. Использование
\lstinline!readFile! для отправки статических файлов не является
обязательным.

\item[sendResponse] \hfill \\
Отправить обычный \lstinline!HasReps! ответ с кодом 200. На самом
деле, определён для удобства, чтобы вы могли прервать глубоко
вложенный код немедленным ответом.

\item[sendWaiResponse] \hfill \\
Иногда вам нужно спуститься на нижний уровень и отправить сырой ответ
WAI. Это особенно может быть полезным для создания потоковых ответов
или техник на подобие событий, посылаемых сервером.
\end{description}

\subsection{Заголовки ответа}
\begin{description}
\item[setCookie] \hfill \\
Установить куки клиенту. Вместо того, чтобы принимать дату истечения
срока жизни, эта функция принимает продолжительность жизни куки в
минутах. Помните, вы не сможете увидеть это куки, используя
\lstinline!lookupCookie!, до \emph{следующего} запроса.

\item[deleteCookie] \hfill \\
Указывает клиенту удалить куки. Опять же, \lstinline!lookupCookie! не
увидит изменений до следующего запроса.

\item[setHeader] \hfill \\
Устанавливает указанное поле заголовка запроса.

\item[setLanguage] \hfill \\
Устанавливает предпочитаемый пользователем язык, который будет
показываться в ответе функции~\lstinline!languages!.

\item[cacheSeconds] \hfill \\
Устанавливает значение поля Cache-Control заголовка для указания
времени в секундах, на которое ответ может быть кэширован. Это может
быть в частности полезно, если вы используете
\footnotehref{http://www.varnish-cache.org/}{varnish} на своём сервере.

\item[neverExpires] \hfill \\
Устанавливает поле Expires заголовка равным 2037-ому году. Вы
можете использовать это для контента, время жизни которого
неограничено, например, когда маршрут запроса имеет связанное с ним
значение хэша (hash value).

\item[alreadyExpired] \hfill \\
Устанавливает полю Expires заголовка значение в прошлом.

\item[expiresAt] \hfill \\
Устанавливает полю Expires заголовка заданное значение даты/времени.
\end{description}

\section{Выводы}
Маршрутизация и диспетчеризация~--- это, вероятно, ядро Yesod: здесь
определяются наши типобезопасные URL, и большая часть нашего кода
пишется внутри монады~\lstinline!Handler!. В этой главе описаны
некоторые самые важные и центральные концепции Yesod, поэтому важно,
чтобы вы как следует усвоили её.

Также в главе намечено несколько более сложных тем Yesod, которые
будут охвачены далее. Но вы уже должны быть в состоянии реализовать
отдельные очень сложные веб-приложения, использую только те знания,
которые вы уже получили.
