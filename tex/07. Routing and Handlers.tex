\chapter{Маршрутизация URL и обработчики}\label{ch:routing}
Если мы посмотрим на Yesod как на веб-фреймворк, реализующий схему
Модель--Вид--Контроллер, маршрутизация URL и обработчики запросов
формируют часть <<Контроллер>>. Для сравнения, опишем два других
подхода к маршрутизации, используемых в других средах веб разработки:
\begin{itemize}
\item Диспетчеризация обработчиков, основанная на имени файла. Так,
  например, работают PHP и ASP.

\item Используется централизованная функция, которая обрабатывает
  маршруты, опираясь на регулярные выражения. Django и Rails
  следуют такому подходу.
\end{itemize}

Yesod ближе, в принципе, к последней технике. Однако, имеются
значительные отличия. Вместо использования регулярных выражений, Yesod
сопоставляет участки маршрута. А вместо однонаправленного отображения
маршрут--обработчик, Yesod использует промежуточный тип данных
(называемый маршрутный тип данных, или типобезопасный URL) и создаёт
функции для двухстороннего преобразования.

Ручная реализация этой более продвинутой системы утомительна и
подвержена ошибкам. Поэтому, Yesod определяет предметно-ориентированный
язык (Domain Specific Language (DSL)) для описания маршрутов и
предоставляет функции Template Haskell для преобразования этого DSL в
код на Haskell. В этой главе будет объяснён синтаксис объявлений
маршрута, дано некоторое представление, какой код генерируется для
вас, и описано взаимодействие между маршрутизацией и функциями
обработки запросов.

\section{Синтаксис записи маршрута}
Вместо того, чтобы пытаться втиснуть объявления маршрутов в
существующий синтаксис, подход Yesod~--- использовать упрощённый
синтаксис, разработанный специально для маршрутов. Преимущество такого
подхода~--- код не только проще писать, но он становится достаточно
простым для не имеющих опыта работы с Yesod, чтобы прочитать и понять
схему сайта вашего приложения.

Простой пример синтаксиса:
\begin{verbatim}
/             RootR     GET
/blog         BlogR     GET POST
/blog/#BlogId BlogPostR GET POST

/static       StaticR   Static getStatic
\end{verbatim}

В следующих нескольких разделах будет подробно описано, что происходит
при объявлении маршрута.

\subsection{Участки пути URL}
Одно из первых действий, совершаемых Yesod при получении запроса,~---
разбиение запрошенного пути на участки.  Участки разделяются символами
косой черты (/). Например:
\begin{lstlisting}
toPieces "/" = []
toPieces "/foo/bar/baz/" = ["foo", "bar", "baz", ""]
\end{lstlisting}

Вы можете заметить, что некоторые забавные вещи происходят с
завершающим символом косой черты, или с двойным символом косой черты
("/foo//bar//"), или ещё с чем-то. Yesod рассчитывает на получение
канонических адресов URL; если кто-то запросит URL с завершающим
символом косой черты, или с двойным символом косой черты, они
автоматически переадресуются на каноническую версия адреса. Это
гарантирует, что у вас одному URL соответствует один ресурс, и может
помочь с вашими поисковыми рейтингами.

Для вас это означает, что вам нет необходимости беспокоиться о точной
структуре ваших адресов URL: вы можете спокойно думать об участках
маршрута, а Yesod автоматически выполнит вставку символов косой черты
и экранирование проблемных символов.

Если, кстати, вы захотите более тонкой настройки того, как маршруты
разбиваются на участки и собираются обратно, вам следует посмотреть
методы \lstinline!cleanPath! и \lstinline!joinPath! в главе~\ref{ch:yesod-typeclass}
о классе типов \lstinline!Yesod!.

\subsubsection{Типы участков}
Когда вы объявляет ваши маршруты, у вас в распоряжении имеются три
типа участков:
\begin{description}
\item[Статический] \hfill \\
Это простая строка, которая должна в точности совпадать в URL.

\item[Динамический одинарный] \hfill \\
Это один участок (т.е. между двумя символами косой черты), но может
быть предоставленным пользователем значением. Это основой способ
получения дополнительного пользовательского ввода при запросе
страницы. Эти участки начинаются с символа решётки (\#), за которым
следует тип данных. Тип данных должен быть экземпляром
\lstinline!PathPiece!.

\item [Динамический множественный] \hfill \\
Аналогичен предыдущему, но может получать множество участков URL. Это
всегда должен быть последний участок в шаблоне ресурса. Задаётся
символом звёздочки (*), за которым следует тип данных, который должен
быть экземпляром \lstinline!PathMultiPiece!. Множественные участки не
столь распространены, как предыдущие два типа, хотя они очень важны
для реализации таких возможностей, как статические деревья,
представляющих файловую структуру или вики с произвольными иерархиями.
\marginpar{file structure - Может, имеется в виду структура файловой системы?}
\end{description}

Давайте посмотрим на некоторые стандартные типы шаблонов ресурса,
которые вы возможно захотите написать. Начиная с простого, корень
приложения будет просто \lstinline!/!. Также, вы возможно захотите
поместить свои часто задаваемые вопросы (FAQ) по адресу
\lstinline!/page/faq!.

Теперь давайте представим, что вы собираетесь сделать сайт для
вычисления чисел Фибоначчи. Вы можете сделать свои URL наподобие
\lstinline!/fib/#Int!. Но тут есть следующая небольшая проблема: мы не
хотим разрешать, чтобы отрицательные числа или ноль передавались в
наше приложение. К счастью, система типов может защитить нас:
\begin{lstlisting}
newtype Natural = Natural Int
    deriving (Show, Read, Eq, Num, Ord)
instance PathPiece Natural where
    toPathPiece (Natural i) = T.pack $ show i
    fromPathPiece s =
        case reads $ T.unpack s of
            (i, ""):_
                | i < 1 -> Nothing
                | otherwise -> Just $ Natural i
            [] -> Nothing
mkYesod "Fibs" [parseRoutes|
/fibs/#Natural FibsR GET
|]
instance Yesod Fibs
fibs = 1 : 1 : zipWith (+) fibs (tail fibs)
getFibsR :: Natural -> GHandler Fibs Fibs RepPlain
getFibsR (Natural i) = return $ RepPlain $ toContent $ show $ fibs !! (i - 1)
main = warpDebug 3000 Fibs
\end{lstlisting}%$

В строке 1 мы определяем для \lstinline!Int! изоморфный тип, который
защитит нас от некорректного ввода. Мы можем увидеть, что
\lstinline!PathPiece!~--- это класс типов с двумя
методами. \lstinline!toPathPiece! просто конвертирует в
\lstinline!Text! и ничего больше. \lstinline!fromPathPiece!
\emph{пытается} преобразовать \lstinline!Text! в наш тип данных,
возвращая \lstinline!Nothing!, если преобразование
невозможно. Используя этот тип данных, мы можем быть уверены, что
нашей функции обработчику будут передаваться только натуральные числа,
позволяя нам в очередной раз использовать систему типов для борьбы с
краевыми случаями.

\fbox{\begin{minipage}[!h]{.9\linewidth}
В реальном приложении, мы бы ещё захотели удостовериться, что никогда
случайно не создадим некорректное значение \lstinline!Natural! внутри
нашего приложения. Для этого, мы могли бы использовать подход
наподобие умных конструкторов
(\href{http://www.haskell.org/haskellwiki/Smart\_constructors}
{\texttt{smart constructors}}
\footnote{http://www.haskell.org/haskellwiki/Smart\_constructors}).
Для целей примера, мы оставили код простым.
\end{minipage}}

Определение \lstinline!PathMultiPiece! столь же простое. Допустим,
что мы хотим сделать вики с иерархией не меньше, чем два уровня;
тогда мы могли бы определить тип данных так:
\begin{lstlisting}
data Page = Page Text Text [Text] -- 2 или больше
instance PathMultiPiece Page where
    toPathMultiPiece (Page x y z) = x : y : z
    fromPathMultiPiece (x:y:z) = Just $ Page x y z
    fromPathMultiPiece _ = Nothing
main = return ()
\end{lstlisting}%$

\subsection{Наименование ресурса}
Каждый шаблон ресурса имеет имя, связанное с ним. Это имя становится
конструктором типа данных для типобезопасного URL, связанного с вашим
приложением. Поэтому оно должно начинаться с прописной буквы. По
соглашению, эти наименования ресурсов все заканчиваются прописной
буквой <<R>>. Это не обязательное требование, просто общепринятая
практика.

Точное определение нашего конструктора зависит от шаблона ресурса, к
которому оно относится. Все типы данных, которые включены в одинарные
и множественные динамические участки шаблона, становятся аргументами
типа данных. Это даёт нам соотношение 1-к-1 между нашим типом для
типобезопасных URL и корректными URL для нашего приложения.

%FIXME: если раскомментировать fbox, пропадёт текст аж до следующего раздела
%\fbox{
\begin{minipage}[!h]{.9\linewidth}
Это не означает непременно, что каждое значение типа представляет
рабочую страницу, это означает, что значение типа является потенциально
корректным URL. Например, значение \lstinline!PersonR "Michael"! может
не разрешиться в корректную страницу, если в базе данных нет записи для
\lstinline!"Michael"!.
\end{minipage}
%}

Давайте теперь обратимся к реальным примерам. Если бы у вас были такие
шаблоны ресурсов: \lstinline!/person/#Text! с именем
\lstinline!PersonR!; \lstinline!/year/#Int! с именем
\lstinline!YearR! и \lstinline!/page/faq! с именем \lstinline!FaqR!,
то ваш тип данных для маршрутов выглядел бы приблизительно так:
\begin{lstlisting}
data MyRoute = PersonR Text
             | YearR Int
             | FaqR
\end{lstlisting}

Если пользователь запросит относительный URL \lstinline!/year/2009!,
Yesod преобразует его в значение \lstinline!YearR 2009!.
\lstinline!/person/Michael! станет \lstinline!PersonR "Michael"!
и \lstinline!/page/faq! станет \lstinline!FaqR!. С другой
стороны, \lstinline!/year/two-thousand-nine!,
\lstinline!/person/michael/snoyman! и \lstinline!/page/FAQ! привели бы
к получению 404 ошибок даже без обращения к вашему коду.

\section{Спецификация обработчика}
Последний кусочек головоломки объявления ваших ресурсов~--- описание
того, как они будут обработаны. В Yesod есть три варианта:
\begin{itemize}
\item у заданного маршрута единственный обработчик для всех методов запроса;
\item у заданного маршрута для каждого метода отдельный
  обработчик. Для неуказанных методов будет генерироваться ответ с
  кодом 405 <<Метод не поддерживается>> (405 Method Not
  Allowed);\marginpar{в оригинале - 405 Bad Method}
\item вы хотите перейти на подсайт.
\end{itemize}

В первых двух случаях спецификация обработчика очень проста. Для
единственного обработчика это будет просто строка с шаблоном ресурса и
наименованием ресурса, например \lstinline!/page/faq FaqR!. В этом
случае, имя функции обработчика должно быть \lstinline!handleFaqR!.

Для отдельных обработчиков для каждого метода спецификация аналогична,
только добавляется список доступных методов запросов. Методы запросов
должны быть записаны прописными буквами. Например,
\lstinline!/person/#String PersonR GET POST DELETE!.
В данном случае, вам потребуется определить три функции обработки:
\lstinline!getPersonR!, \lstinline!postPersonR! и \lstinline!deletePersonR!.

Подсайты~--- очень полезная, но сложная, тема в Yesod. Мы рассмотрим
создание подсайтов позже, но использовать их не очень сложно. Самый
часто используемый подсайт~--- это статический подсайт, который
обслуживает статические файлы для вашего приложения. Для того, что
отдавать статические файлы из \lstinline!/static!, вам нужно описать
ресурс вида:
\begin{verbatim}
/static StaticR Static getStatic
\end{verbatim}

В этой строке, \lstinline!/static! просто говорит о том, откуда в вашей
структуре URL отдавать статические файлы. Нет никакой магии в слове
static (статический), вы легко можете заменить его на
\lstinline!/my/non-dynamic/files!.

Следующее слово, \lstinline!StaticR!, задаёт наименование
ресурса. Следующие два слова указывают на то, что мы используем
подсайт. \lstinline!Static!~--- это имя типа-основания подсайта, а
\lstinline!getStatic!~--- функция, которая получает значение типа
\lstinline!Static! из значения типа-основания вашего основного сайта.

Давайте здесь не будем вдаваться в детали о подсайтах. Мы рассмотрим
подробнее статический подсайт в главе о каркасе
сайта.\marginpar{вставить ссылку на главу}

\section{Диспетчеризация}
Как только вы определили свои маршруты, Yesod позаботится обо всех
надоедливых деталях диспетчеризации URL для вас. Вам нужно только
удостовериться, что вы предоставили соответствующие функции
обработки. Для маршрутов на подсайты, вам не требуется писать
какие-либо функции обработки, но для двух других типов обработчиков
это сделать необходимо. Выше мы уже упомянули правило именования
(\lstinline!MyHandlerR GET! становится \lstinline!getMyHandlerR!,
\lstinline!MyOtherHandlerR! становится \lstinline!handleMyOtherHandlerR!).
Теперь нам нужно определиться с сигнатурой типа.

\subsection{Возвращаемый тип}
Давай посмотрим на простую функцию обработки:
\begin{lstlisting}
mkYesod "Simple" [parseRoutes|
/ HomeR GET
|]

getHomeR :: Handler RepHtml
getHomeR = defaultLayout [whamlet|<h1>This is simple
|]
instance Yesod Simple
main = warpDebug 3000 Simple
\end{lstlisting}

Посмотрите на сигнатуру типа для \lstinline!getHomeR!. Первый
компонент~--- это \lstinline!Handler!. \lstinline!Handler!~--- это
специальная монада, в которой живут все функции обработки. Она
предоставляет доступ к информации из запроса, позволяет вам
осуществлять переадресацию, и ещё много других вещей, которые мы
вскоре рассмотрим.

Затем идёт \lstinline!RepHtml!. Когда мы будем рассматривать
представления, мы исследуем подробнее вопрос <<почему так>>; сейчас
нас просто интересует вопрос <<как сделать>>.

Как вы могли бы предположить, \lstinline!RepHtml!~--- это тип данных
для ответов в формате HTML. И также вы можете предположить, что веб
сайтам приходится возвращать ответы не только в HTML. CSS, Javascript,
изображения, XML являются необходимыми для веб сайта. Поэтому
возвращаемый тип функции обработки может быть любым экземпляром
\lstinline!HasReps!.

\lstinline!HasReps!~--- это мощная концепция, которая позволяет Yesod
автоматически выбирать правильное представление ваших данных,
основываясь на запросе клиента. Пока мы сосредоточимся на простых
экземплярах, наподобие \lstinline!RepHtml!, которые предоставляют
только один формат представления.

\subsection{Аргументы}
Не все маршруты столь же просты, как \lstinline!HomeR!, который мы
определили чуть выше. Возьмём для примера наш маршрут
\lstinline!PersonR! из предыдущих разделов. Имя человека необходимо
передавать в функцию обработки. Переход очень прост и, надеюсь,
интуитивно понятен. Пример:
\begin{lstlisting}
mkYesod "Args" [parseRoutes|
/person/#Text PersonR GET
/year/#Integer/month/#Text/day/#Int DateR
/wiki/*Texts WikiR GET
|]

getPersonR :: Text -> Handler RepHtml
getPersonR name = defaultLayout [whamlet|<h1>Hello #{name}!|]

handleDateR :: Integer -> Text -> Int -> Handler RepPlain -- text/plain
handleDateR year month day =
    return $ RepPlain $ toContent $
        T.concat [month, " ", T.pack $ show day, ", ", T.pack $ show year]

getWikiR :: [Text] -> Handler RepPlain
getWikiR = return . RepPlain . toContent . T.unwords

instance Yesod Args
main = warpDebug 3000 Args
\end{lstlisting}%$

Аргументы имеют типы динамических участков каждого маршрута, в порядке
указания. Также обратите внимание, как мы можем использовать и
\lstinline!RepHtml!, и \lstinline!RepPlain!.

\section{Монада Handler}
Подавляющая часть кода, который вы пишете в Yesod, находится внутри
монады~\lstinline!Handler!. Если вы подходите к этому с точки зрения
шаблона Модель--Вид--Контроллер (MVC, Model--View--Controller), ваш код
\lstinline!Handler!~--- это Контроллер. Перечислим несколько важных
моментов о \lstinline!Handler!, которые следует знать:
\begin{itemize}
\item Это экземпляр \lstinline!MonadIO!, поэтому вы можете
  использовать любое действие \lstinline!IO! в ваших обработчиках с
  помощью \lstinline!liftIO!. Кстати, \lstinline!liftIO! экспортируется
  модулем \lstinline!Yesod! для вашего удобства.
\item Как и \lstinline!Widget!, \lstinline!Handler!~--- это
  псевдопреобразователь монад (fake--monad--transformer). Он обёртывает
  монаду~\lstinline!ResourceT IO!. Мы подробно обсуждаем это в
  приложении\marginpar{вставить ссылку на conduits appendix}, а
  сейчас мы только скажем, что это позволяет вам безопасно выделять
  ресурсы.
\item Под <<псевдо>>, я имею в виду, что вы не можете использовать
  стандартную функцию \lstinline!lift!, предоставляемую пакетом
  \href{http://hackage.haskell.org/package/transformers}
       {\texttt{transformers}}
  \footnote{http://hackage.haskell.org/package/transformers}, вы
  должны использовать замещающую функцию из \lstinline!Yesod! (как и в
  случае с виджетами).
\item \lstinline!Handler!~--- это просто синоним типа для
  \lstinline!GHandler!. \lstinline!GHandler! позволяет вам точно
  указать, какой дочерний и материнский сайты вы используете. Синоним
  \lstinline!Handler! сообщает, что дочерний и материнский сайты~---
  это тип вашего приложения (или <<имеют тип вашего приложения>>????
  FIXME)\marginpar{says that the sub and master sites are your
    application's type}.
\item \lstinline!Handler! обеспечивает большой объём функциональности,
  такой как:
\begin{itemize}
\item Предоставление информации о запросе;
\item Хранение списка дополнительных полей заголовка ответа, которые
  вы добавили;
\item Изменения пользовательской сессии;
\item Сокращённая обработка запросов для переадресации, отправки
  статических файлов или сообщения об ошибках.
\end{itemize}
\end{itemize}

В оставшейся части главы будет дано короткое введение в некоторые
самые распространённые функции, находящиеся в монаде
\lstinline!Handler!. Я специально не описываю функции для работы с
сессиями; они будут рассмотрены в отдельной главе \marginpar{вставить
  ссылку на главу о сессиях}.

\subsection{Информация о приложении}
Есть набор функций, которые возвращают информацию о вашем приложении в
целом и не дают никакой информации об отдельных запросах. Некоторые из
них:
\begin{description}
\item[getYesod] \hfill \\
Возвращает значение основы (foundation value) вашего приложения. Если вы
храните значения настроек в вашем основании (foundation), вам, видимо,
придётся в итоге часто использовать эту функцию.

\item[getYesodSub] \hfill \\
Возвращает значение основы (foundation value) для дочернего сайта. Если вы
не работаете в дочернем сайте, будет возвращать тоже значение, что и
\lstinline!getYesod!.

\item[getUrlRender] \hfill \\
Возвращает функцию рендеринга URL, которая преобразует типобезопасный
URL в \lstinline!Text!. По большей части~--- как и в случае с
\lstinline!Hamlet!~--- Yesod вызывает эту функцию для вас, но иногда
вам может потребоваться вызвать эту функцию напрямую.

\item[getUrlRenderParams]  \hfill \\
Вариант \lstinline!getUrlRender!, которые преобразует и
типобезопасный URL, и список параметров из строки запроса. Это функция
выполняет требуемое кодирование символов (percent-encoding).
\end{description}

\subsection{Информация о запросе}
Информация, которую вы чаще всего захотите получить о текущем
запросе,~--- это запрошенный маршрут, параметы из строки запроса и
данные форм, отправленные на сервер (методом POST). С первым пунктом имеет
дело маршрутизация, как описано выше. С оставшимися двумя лучше всего
dealt with, используя модуль для форм.

% FIXME: не придумал перевод для 'that said'
That said (?), вам иногда требуется получить данные в необработанном
виде. Для этой цели, Yesod экспортирует тип данных~\lstinline!Request!
вместе с функцией~\lstinline!getRequest! для его получения. Он даёт
вам доступ к полному набору параметров GET запроса, к куки и списку
предпочитаемых языков. Есть несколько удобных функций для упрощения
поиска, такие как \lstinline!lookupGetParam!, \lstinline!lookupCookie!
и \lstinline!languages!. Для прямого доступа к данным POST запроса,
вам следует использовать \lstinline!runRequest!.

Если вам требуются ещё более сырые данные, такие как заголовки
запросов, вы можете использовать \lstinline!waiRequest! для доступа к
значению запроса Интерфейса Веб Приложения (Web Application Interface,
WAI). За деталями обратитесь к приложению о WAI.\marginpar{вставить
  ссылку на WAI appendix}

\subsection{Сокращённая обработка запроса}
Описанные ниже функции немедленно прекращают выполнение обработчика и
возвращают результат пользователю.
\begin{description}
\item[redirect] \hfill \\
Отправляет пользователю ответ на переадресацию (ответ 303). Если вы
хотите использовать другой код ответа (например, 301 постоянная
переадресация), вы можете использовать \lstinline!redirectWith!.
\fbox{\begin{minipage}[!h]{.9\linewidth}
Yesod использует ответ 303 для клиентов по протоколу HTTP/1.1, и ответ
302 для клиентов по протоколу HTTP/1.0. Вы можете почитать эту
ужасную историю (sordid saga) в спецификации протокола HTTP.
\end{minipage}}

\item[notFound] \hfill \\
Возвращает ответ 404. Это может быть полезно, если пользователь
запросил из базы данных отсутствующее значение.

\item[permissionDenied] \hfill \\
Возвращает ответ 403 с указанным сообщением об ошибке.

\item[invalidArgs] \hfill \\
Ответ 400 со списком некорректных аргументов.

\item[sendFile] \hfill \\
Отправляет файл из файловой системы с указанным типом контента. Это
предпочтительный путь для отправки статических файлов, так как лежащий
в основе обработчик WAI может оказаться в состоянии оптимизировать
отправку до системного вызова sendfile. Использование
\lstinline!readFile! (видимо, всё-таки \lstinline!sendFile!~---
прим. перев.) для отправки статических файлов не является
обязательным.

\item[sendResponse] \hfill \\
Отправить обычный \lstinline!HasReps! ответ с кодом 200. На самом
деле, определён для удобства, чтобы вы могли прервать глубоко
вложенный код немедленным ответом.

\item[sendWaiResponse] \hfill \\
Иногда вам нужно спуститься на нижний уровень и отправить сырой ответ
WAI. Это особенном может быть полезным для создания потоковых ответов
или техник на подобие событий, посылаемых сервером.
\end{description}

\subsection{Заголовки ответа}
\begin{description}
\item[setCookie] \hfill \\
Установить куки клиенту. Вместо того, чтобы принимать дату истечения
срока жизни, эта функция принимает продолжительность жизни куки в
минутах. Помните, вы не сможете увидеть это куки, используя
\lstinline!lookupCookie!, до следующего запроса.

\item[deleteCookie] \hfill \\
Указывает клиенту удалить куки. Опять же, \lstinline!lookupCookie! не
увидит изменений до следующего запроса.

\item[setHeader] \hfill \\
Устанавливает указанное поле заголовка запроса.

\item[setLanguage] \hfill \\
Устанавливает предпочитаемый пользователем язык, который будет
показываться в ответе функции~\lstinline!languages!.

\item[cacheSeconds] \hfill \\
Устанавливает значение поля Cache-Control заголовка для указания
времени в секундах, на которое ответ может быть кэширован. Это может
быть в частности полезно, если вы используете
\footnotehref{http://www.varnish-cache.org/}{varnish} на своём сервере.

\item[neverExpires] \hfill \\
Устанавливает поле Expires заголовка равным 2037-ому году. Вы
можете использовать это для контента, время жизни которого
неограниченно, например, когда маршрут запроса имеет связанное с ним
значение хэша (hash value).

\item[alreadyExpired] \hfill \\
Устанавливает полю Expires заголовка значение в прошлом.

\item[expiresAt] \hfill \\
Устанавливает полю Expires заголовка заданное значение даты/времени.
\end{description}

\section{Выводы}
Маршрутизация и диспетчеризация~--- это, вероятно, ядро Yesod: здесь
определяются наши типобезопасные URL, и большая часть нашего кода
пишется внутри монады~\lstinline!Handler!. В этой главе описаны
некоторые самые важные и центральные концепции Yesod, поэтому важно,
чтобы вы как следует усвоили её.

Также в главе намечено несколько более сложных тем Yesod, которые
будут охвачены далее. Но вы уже должны быть в состоянии реализовать
отдельные очень сложные веб приложения, использую только те знания,
которые вы уже получили.
